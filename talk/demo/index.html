---
layout: slides
title: "Slide Demo"
description: "Demo of the interactive slide presentation system"
---

<!-- ==================== Slide 1: Title ==================== -->
<section class="slide slide-center" id="title" data-title="Title">
    <h1>Interactive Slide Demo</h1>
    <p class="subtitle">Testing the presentation infrastructure</p>
    <p class="author">Press arrow keys to navigate</p>
</section>

<!-- ==================== Slide 2: Navigation Help ==================== -->
<section class="slide" id="navigation" data-title="Navigation">
    <h2>How to Navigate</h2>
    <ul>
        <li><strong>Arrow keys</strong> or <strong>Space</strong> &mdash; Next/Previous slide</li>
        <li><strong>G</strong> &mdash; Open jump menu (go to any slide)</li>
        <li><strong>F</strong> &mdash; Toggle fullscreen</li>
        <li><strong>Home/End</strong> &mdash; First/Last slide</li>
        <li><strong>Swipe</strong> &mdash; Works on touch devices</li>
    </ul>
    <p style="margin-top: 2rem; color: var(--slide-muted);">
        You can also click the navigation buttons at the bottom.
    </p>
</section>

<!-- ==================== Slide 3: Typography ==================== -->
<section class="slide" id="typography" data-title="Typography">
    <h2>Typography Examples</h2>
    <h3>This is a Heading 3</h3>
    <p>Regular paragraph text uses Franklin Gothic Book. It's designed for readability in presentations.</p>
    <p>You can use <strong>bold text</strong>, <em>italic text</em>, and <a href="#">links styled in UVA orange</a>.</p>
    <p class="subtitle">Serif italics use the Unna font for an elegant touch.</p>
</section>

<!-- ==================== Slide 4: Two Columns ==================== -->
<section class="slide" id="columns" data-title="Two Columns">
    <h2>Two-Column Layout</h2>
    <div class="slide-columns">
        <div>
            <h3>Left Column</h3>
            <p>Content can be split into two columns for side-by-side comparisons or image-text layouts.</p>
            <ul>
                <li>First point</li>
                <li>Second point</li>
                <li>Third point</li>
            </ul>
        </div>
        <div>
            <h3>Right Column</h3>
            <p>Each column automatically takes half the available width.</p>
            <p>On mobile devices, columns stack vertically for better readability.</p>
        </div>
    </div>
</section>

<!-- ==================== Slide 5: Fragments ==================== -->
<section class="slide" id="fragments" data-title="Fragments">
    <h2>Step-by-Step Reveals</h2>
    <p>Press arrow or click to reveal each item:</p>
    <ul>
        <li class="fragment fade-up">First point appears</li>
        <li class="fragment fade-up">Second point follows</li>
        <li class="fragment fade-up">Third point last</li>
    </ul>
    <p class="fragment fade-up" style="margin-top: 2rem; color: var(--slide-accent);">
        <strong>Fragment classes:</strong> <code>fade-up</code>, <code>fade-down</code>, <code>fade-left</code>, <code>fade-right</code>, <code>zoom-in</code>
    </p>
</section>

<!-- ==================== Slide 6: Math ==================== -->
<section class="slide slide-center" id="math" data-title="Math">
    <h2>Math Rendering with KaTeX</h2>
    <p>Inline math: \( e^{i\pi} + 1 = 0 \)</p>
    <p style="font-size: 2rem; margin-top: 2rem;">
        $$ \int_{-\infty}^{\infty} e^{-x^2} dx = \sqrt{\pi} $$
    </p>
    <p style="margin-top: 2rem; color: var(--slide-muted);">
        Math is rendered automatically using KaTeX.
    </p>
</section>

<!-- ==================== Slide 6: Code ==================== -->
<section class="slide" id="code" data-title="Code">
    <h2>Code Blocks</h2>
    <pre><code>class SlideEngine {
    constructor(options) {
        this.slides = [];
        this.current = 0;
    }

    next() {
        if (this.current < this.slides.length - 1) {
            this.goTo(this.current + 1);
        }
    }
}</code></pre>
    <p style="margin-top: 1rem;">Code blocks use a monospace font with proper syntax highlighting support.</p>
</section>

<!-- ==================== Slide 7: Simulation Placeholder ==================== -->
<section class="slide slide-simulation" id="simulation" data-title="Simulation">
    <h2>Interactive Simulations (Step System)</h2>
    <p style="margin-bottom: 1rem; color: var(--slide-muted);">Press → to start Sim 1, then → again for Sim 2</p>
    <div style="display: flex; gap: 2rem; justify-content: center; flex-wrap: wrap;">
        <div style="text-align: center;">
            <div style="font-weight: bold; margin-bottom: 0.5rem;">Simulation 1 (Step 1)</div>
            <div style="position: relative; display: inline-block;">
                <canvas id="demo-canvas" width="280" height="200" style="border: 2px solid var(--slide-navy); border-radius: 8px;"></canvas>
                <button id="sim-toggle" style="position: absolute; top: 8px; right: 8px; background: var(--slide-accent); color: white; border: none; border-radius: 4px; padding: 4px 10px; font-size: 0.8rem; cursor: pointer;">▶</button>
            </div>
        </div>
        <div style="text-align: center;">
            <div style="font-weight: bold; margin-bottom: 0.5rem;">Simulation 2 (Step 2)</div>
            <div style="position: relative; display: inline-block;">
                <canvas id="demo-canvas-2" width="280" height="200" style="border: 2px solid var(--slide-navy); border-radius: 8px;"></canvas>
                <button id="sim-toggle-2" style="position: absolute; top: 8px; right: 8px; background: var(--slide-accent); color: white; border: none; border-radius: 4px; padding: 4px 10px; font-size: 0.8rem; cursor: pointer;">▶</button>
            </div>
        </div>
    </div>
</section>

<!-- ==================== Slide 8: Multi-Phase Simulation ==================== -->
<section class="slide slide-simulation" id="multiphase" data-title="Multi-Phase">
    <h2>Multi-Phase Simulation (onStep API)</h2>
    <p style="margin-bottom: 0.5rem; color: var(--slide-muted);">
        Press → to advance through phases: <strong>Init → Sample → Transform</strong>
    </p>
    <div style="text-align: center;">
        <div style="position: relative; display: inline-block;">
            <canvas id="multiphase-canvas" width="400" height="300" style="border: 2px solid var(--slide-navy); border-radius: 8px;"></canvas>
            <div id="phase-indicator" style="position: absolute; top: 8px; left: 8px; background: var(--slide-navy); color: white; padding: 4px 12px; border-radius: 4px; font-size: 0.9rem;">
                Phase 0: Initial
            </div>
        </div>
    </div>
    <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--slide-muted);">
        Uses <code>onStep(step)</code> to receive arbitrary commands on each arrow press.
    </p>
</section>

<!-- ==================== Slide 9: Hash Links ==================== -->
<section class="slide" id="links" data-title="Hash Links">
    <h2>Direct Links to Slides</h2>
    <p>Each slide has a unique URL hash for direct linking:</p>
    <ul>
        <li><code>#title</code> &mdash; Title slide</li>
        <li><code>#navigation</code> &mdash; Navigation help</li>
        <li><code>#simulation</code> &mdash; Interactive demo</li>
    </ul>
    <p style="margin-top: 1.5rem;">Share links like <code>/talk/demo/#math</code> to jump directly to a specific slide.</p>
</section>

<!-- ==================== Slide 10: Summary ==================== -->
<section class="slide slide-center" id="summary" data-title="Summary">
    <h2>Summary</h2>
    <ul style="text-align: left; display: inline-block;">
        <li>Keyboard &amp; touch navigation</li>
        <li>Jump menu for quick access (G)</li>
        <li>UVA-branded styling</li>
        <li>Math rendering (KaTeX)</li>
        <li>Simulation step system</li>
        <li>Multi-phase simulations (onStep)</li>
        <li>Responsive design</li>
    </ul>
    <p style="margin-top: 2rem;">
        <strong>Press G</strong> to try the jump menu!
    </p>
</section>

<!-- Demo simulations using SlideSimulation helper -->
<script>
document.addEventListener('DOMContentLoaded', function() {

// Simulation 1: Bouncing particles (Step 1)
window.sim1 = SlideSimulation.create({
    canvasId: 'demo-canvas',
    slideId: 'simulation',
    step: 1,
    particles: [],
    onStart() { document.getElementById('sim-toggle').textContent = '⏸'; },
    onPause() { document.getElementById('sim-toggle').textContent = '▶'; },

    init(ctx, canvas) {
        this.particles = [];
        for (let i = 0; i < 20; i++) {
            this.particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3,
                radius: Math.random() * 6 + 3,
                color: ['#e57200', '#232D4B'][Math.floor(Math.random() * 2)]
            });
        }
    },

    update(dt) {
        const canvas = this.canvas;
        this.particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            if (p.x < p.radius || p.x > canvas.width - p.radius) p.vx *= -1;
            if (p.y < p.radius || p.y > canvas.height - p.radius) p.vy *= -1;
            p.x = Math.max(p.radius, Math.min(canvas.width - p.radius, p.x));
            p.y = Math.max(p.radius, Math.min(canvas.height - p.radius, p.y));
        });
    },

    draw(ctx, canvas) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        this.particles.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
        });
    }
});

// Simulation 2: Spinning shapes (Step 2)
window.sim2 = SlideSimulation.create({
    canvasId: 'demo-canvas-2',
    slideId: 'simulation',
    step: 2,
    angle: 0,
    shapes: [],
    onStart() { document.getElementById('sim-toggle-2').textContent = '⏸'; },
    onPause() { document.getElementById('sim-toggle-2').textContent = '▶'; },

    init(ctx, canvas) {
        this.angle = 0;
        this.shapes = [];
        for (let i = 0; i < 5; i++) {
            this.shapes.push({
                x: 40 + i * 50,
                y: canvas.height / 2,
                size: 15 + i * 3,
                speed: 0.02 + i * 0.01,
                color: ['#e57200', '#232D4B', '#6c757d', '#e57200', '#232D4B'][i]
            });
        }
    },

    update(dt) {
        this.angle += 0.03;
    },

    draw(ctx, canvas) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        this.shapes.forEach((s, i) => {
            ctx.save();
            ctx.translate(s.x, s.y);
            ctx.rotate(this.angle * s.speed * 50);
            ctx.beginPath();
            const sides = 3 + i;
            for (let j = 0; j <= sides; j++) {
                const a = (j / sides) * Math.PI * 2 - Math.PI / 2;
                const px = Math.cos(a) * s.size;
                const py = Math.sin(a) * s.size;
                if (j === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.fillStyle = s.color;
            ctx.fill();
            ctx.restore();
        });
    }
});

// Button handlers
document.getElementById('sim-toggle').addEventListener('click', () => window.sim1 && window.sim1.toggle());
document.getElementById('sim-toggle-2').addEventListener('click', () => window.sim2 && window.sim2.toggle());

// Multi-phase simulation demo (uses onStep API)
window.multiPhaseSim = SlideSimulation.create({
    canvasId: 'multiphase-canvas',
    slideId: 'multiphase',
    steps: 3,  // 3 arrow presses on this slide

    // State
    phase: 0,
    points: [],
    transformProgress: 0,

    init(ctx, canvas) {
        this.phase = 0;
        this.points = [];
        this.transformProgress = 0;
        // Generate grid of points
        for (let x = 50; x < canvas.width - 30; x += 40) {
            for (let y = 50; y < canvas.height - 30; y += 40) {
                this.points.push({
                    x: x, y: y,
                    origX: x, origY: y,
                    targetX: x, targetY: y,
                    vx: 0, vy: 0,
                    color: '#232D4B'
                });
            }
        }
        this.updatePhaseIndicator();
    },

    onStep(step) {
        this.phase = step;
        if (step === 1) {
            // Phase 1: Start "sampling" - add random motion
            this.points.forEach(p => {
                p.vx = (Math.random() - 0.5) * 4;
                p.vy = (Math.random() - 0.5) * 4;
                p.color = '#e57200';
            });
            this.start();
        } else if (step === 2) {
            // Phase 2: Stop sampling, freeze positions
            this.pause();
            this.points.forEach(p => {
                p.vx = 0;
                p.vy = 0;
                p.color = '#6c757d';
            });
            this.draw(this.ctx, this.canvas);
        } else if (step === 3) {
            // Phase 3: Transform - animate to circular pattern
            this.transformProgress = 0;
            const cx = this.canvas.width / 2;
            const cy = this.canvas.height / 2;
            this.points.forEach((p, i) => {
                const angle = (i / this.points.length) * Math.PI * 2;
                const radius = 80 + (i % 3) * 30;
                p.targetX = cx + Math.cos(angle) * radius;
                p.targetY = cy + Math.sin(angle) * radius;
                p.color = '#232D4B';
            });
            this.start();
        }
        this.updatePhaseIndicator();
    },

    onStepBack(step) {
        this.phase = step;
        if (step === 0) {
            // Back to initial state
            this.pause();
            this.points.forEach(p => {
                p.x = p.origX;
                p.y = p.origY;
                p.vx = 0;
                p.vy = 0;
                p.color = '#232D4B';
            });
            this.draw(this.ctx, this.canvas);
        } else if (step === 1) {
            // Back to sampling
            this.points.forEach(p => {
                p.vx = (Math.random() - 0.5) * 4;
                p.vy = (Math.random() - 0.5) * 4;
                p.color = '#e57200';
            });
            this.start();
        } else if (step === 2) {
            // Back to frozen
            this.pause();
            this.points.forEach(p => {
                p.vx = 0;
                p.vy = 0;
                p.color = '#6c757d';
            });
            this.draw(this.ctx, this.canvas);
        }
        this.updatePhaseIndicator();
    },

    updatePhaseIndicator() {
        const indicator = document.getElementById('phase-indicator');
        if (!indicator) return;
        const labels = ['Phase 0: Initial', 'Phase 1: Sampling', 'Phase 2: Frozen', 'Phase 3: Transformed'];
        indicator.textContent = labels[this.phase] || 'Unknown';
    },

    update(dt) {
        if (this.phase === 1) {
            // Sampling mode: random bounce
            this.points.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                if (p.x < 20 || p.x > this.canvas.width - 20) p.vx *= -1;
                if (p.y < 20 || p.y > this.canvas.height - 20) p.vy *= -1;
            });
        } else if (this.phase === 3) {
            // Transform mode: animate to targets
            this.transformProgress += dt * 2;
            const t = Math.min(1, this.transformProgress);
            this.points.forEach(p => {
                p.x = p.x + (p.targetX - p.x) * 0.05;
                p.y = p.y + (p.targetY - p.y) * 0.05;
            });
            if (t >= 1) this.pause();
        }
    },

    draw(ctx, canvas) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        this.points.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
        });
    }
});

}); // end DOMContentLoaded
</script>
