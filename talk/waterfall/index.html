---
layout: slides
title: "Random Lozenge Waterfall"
description: "Interactive talk on random lozenge tilings and their limit shapes"
---

<!-- ==================== Slide 1: Title ==================== -->
<section class="slide slide-center" id="title" data-title="Title" style="display: flex; flex-direction: column;">
    <h1 style="font-size: clamp(2.5rem, 3.5vw, 4rem); line-height: 1.2;">Random Lozenge Waterfall</h1>

    <p class="author" style="margin-top: 1vh; font-size: clamp(1.5rem, 2.5vw, 2.2rem);">Leonid Petrov</p>
    <p style="font-size: clamp(1.2rem, 2vw, 1.8rem); color: var(--slide-muted);">University of Virginia</p>

    <div style="flex: 1; display: flex; align-items: center; justify-content: center; min-height: 0;">
        <canvas id="title-canvas" width="1600" height="1200" style="cursor: pointer; height: 55vh; width: auto;"></canvas>
    </div>

    <!-- Funding acknowledgment logos -->
    <div style="position: absolute; bottom: 2vh; left: 2vw; display: flex; align-items: center; gap: 2vw;">
        <img src="images/nsf-logo.png" alt="NSF" style="height: 7.5vh;">
        <img src="images/simons-logo.svg" alt="Simons Foundation" style="height: 3vh;">
    </div>
</section>

<!-- Load simulation dependencies (colorschemes.js already loaded by slides layout) -->
<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>
<script src="/js/2025-06-08-q-vol-3d.js"></script>

<!-- Dynamic WASM loader: use threaded version if SharedArrayBuffer is available -->
<script>
window.VISUAL_THREADED = typeof SharedArrayBuffer !== 'undefined';
window.VISUAL_WEBGPU = !!navigator.gpu;

// Load WASM module dynamically (no document.write)
function loadScript(src) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

const wasmSrc = '/talk/visual/sim/visual-lozenge' + (window.VISUAL_THREADED ? '-threaded' : '') + '.js';
loadScript(wasmSrc).then(() => {
    // Load WebGPU lozenge engine for GPU CFTP
    loadScript('/js/webgpu-lozenge-engine.js').catch(e => console.log('WebGPU engine not available'));
    window.dispatchEvent(new Event('wasm-loaded'));
});
</script>

<script>
window.addEventListener('wasm-loaded', async function() {
    // Wait for LozengeModule factory to be available
    if (typeof LozengeModule === 'undefined') {
        console.error('LozengeModule not loaded');
        return;
    }

    // Create isolated WASM instance for Title slide
    const wasm = await LozengeModule();

    // Triangular lattice constants (for equilateral triangles)
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) {
        return { x: n, y: slope * n + j * deltaC };
    }

    // WASM interface (using our isolated instance)
    const initFromTrianglesWasm = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const performGlauberStepsWasm = wasm.cwrap('performGlauberSteps', 'number', ['number']);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeStringWasm = wasm.cwrap('freeString', null, ['number']);
    const setUseRandomSweepsWasm = wasm.cwrap('setUseRandomSweeps', null, ['number']);

    // Color palette (UVA)
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    // Simulation state
    let activeTriangles = new Map();
    let dimers = [];
    let isValid = false;

    // Load Rotunda preset
    try {
        const response = await fetch('/letters/Rotunda.json');
        if (response.ok) {
            const data = await response.json();
            if (data.triangles) {
                for (const t of data.triangles) {
                    const type = t.type || t.t;
                    activeTriangles.set(`${t.n},${t.j},${type}`, { n: t.n, j: t.j, type });
                }

                // Initialize WASM region
                const arr = [];
                for (const [key, tri] of activeTriangles) {
                    arr.push(tri.n, tri.j, tri.type);
                }

                if (arr.length > 0) {
                    const dataPtr = wasm._malloc(arr.length * 4);
                    for (let i = 0; i < arr.length; i++) {
                        wasm.setValue(dataPtr + i * 4, arr[i], 'i32');
                    }

                    const ptr = initFromTrianglesWasm(dataPtr, arr.length);
                    const jsonStr = wasm.UTF8ToString(ptr);
                    freeStringWasm(ptr);
                    wasm._free(dataPtr);

                    const result = JSON.parse(jsonStr);
                    isValid = result.status === 'valid';

                    if (isValid) {
                        setUseRandomSweepsWasm(1);
                        // Export initial dimers so we can show lozenges on load
                        const dPtr = exportDimersWasm();
                        const jsonStr = wasm.UTF8ToString(dPtr);
                        freeStringWasm(dPtr);
                        const result = JSON.parse(jsonStr);
                        const dimerArr = Array.isArray(result) ? result : (result.dimers || []);
                        dimers.push(...dimerArr);
                    }
                }
            }
        }
    } catch (e) {
        // Failed to load preset
    }

    // High-DPI canvas for crisp rendering (2x resolution for 1920x1080 projector)
    const canvas = document.getElementById('title-canvas');
    const ctx = canvas.getContext('2d');
    const displayWidth = 800, displayHeight = 600;  // 55vh at 1080p ≈ 600px
    const dpr = 2; // 2x for retina/crisp rendering

    // Simulation state
    let isRunning = false;
    let animationId = null;

    // Pre-calculate transform (bounds don't change)
    let scale, centerX, centerY;
    function calcTransform() {
        if (!activeTriangles || activeTriangles.size === 0) return;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const [, tri] of activeTriangles) {
            let verts;
            if (tri.type === 1) {
                verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
            } else {
                verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j), getVertex(tri.n + 1, tri.j - 1)];
            }
            for (const v of verts) {
                minX = Math.min(minX, v.x);
                maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y);
                maxY = Math.max(maxY, v.y);
            }
        }
        const regionWidth = maxX - minX;
        const regionHeight = maxY - minY;
        scale = Math.min(displayWidth / regionWidth, displayHeight / regionHeight) * 0.85;
        centerX = displayWidth / 2 - ((minX + maxX) / 2) * scale;
        centerY = displayHeight / 2 + ((minY + maxY) / 2) * scale;
    }
    calcTransform();

    function draw() {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        if (!activeTriangles || activeTriangles.size === 0) return;

        // Draw lozenges
        if (Array.isArray(dimers) && dimers.length > 0) {
            for (const d of dimers) {
                const bn = d.bn, bj = d.bj, t = d.t;
                let verts;
                if (t === 0) {
                    verts = [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                } else if (t === 1) {
                    verts = [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
                } else {
                    verts = [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                }

                ctx.beginPath();
                ctx.moveTo(centerX + verts[0].x * scale, centerY - verts[0].y * scale);
                for (let i = 1; i < 4; i++) {
                    ctx.lineTo(centerX + verts[i].x * scale, centerY - verts[i].y * scale);
                }
                ctx.closePath();
                ctx.fillStyle = colors[t];
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
        } else {
            // Draw triangles (shape outline)
            for (const [, tri] of activeTriangles) {
                const n = tri.n, j = tri.j, type = tri.type;
                let verts;
                if (type === 1) {
                    verts = [getVertex(n, j), getVertex(n, j - 1), getVertex(n + 1, j - 1)];
                } else {
                    verts = [getVertex(n, j), getVertex(n + 1, j), getVertex(n + 1, j - 1)];
                }

                ctx.beginPath();
                ctx.moveTo(centerX + verts[0].x * scale, centerY - verts[0].y * scale);
                for (let i = 1; i < 3; i++) {
                    ctx.lineTo(centerX + verts[i].x * scale, centerY - verts[i].y * scale);
                }
                ctx.closePath();
                ctx.fillStyle = type === 1 ? '#232D4B' : '#F9DCBF';
                ctx.fill();
            }
        }
    }

    function animate() {
        if (!isValid || !isRunning) return;

        // Run Glauber steps
        const ptr = performGlauberStepsWasm(10000);
        freeStringWasm(ptr);

        // Refresh dimers
        const dPtr = exportDimersWasm();
        const jsonStr = wasm.UTF8ToString(dPtr);
        freeStringWasm(dPtr);
        const result = JSON.parse(jsonStr);
        dimers = Array.isArray(result) ? result : (result.dimers || []);

        draw();
        animationId = requestAnimationFrame(animate);
    }

    function startSim() {
        if (!isRunning) {
            isRunning = true;
            animate();
        }
    }

    function pauseSim() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    // Click to toggle
    canvas.addEventListener('click', () => {
        if (isRunning) pauseSim();
        else startSim();
    });

    // Initial draw
    draw();

    // Register with slide engine for step control
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('title', {
                start: startSim,
                pause: pauseSim
            }, 1);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
});
</script>

<!-- ==================== PART 0: How Nature Creates Shape ==================== -->

<section class="slide slide-top" id="nature-builds" data-title="How Nature Makes Shape">
    <h2 class="slide-title" style="margin-top: 2vh;">How Nature Makes Shape?</h2>

    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: clamp(1rem, 3vw, 4rem); margin-top: 4vh; align-items: start;">
        <!-- Left column: Basalt columns image -->
        <div>
            <p style="text-align: left; margin-bottom: 2vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Basalt columns from cooling lava</p>
            <figure style="margin: 0;">
                <img src="images/basalt-columns-boyabat-cc-by-sa-3.jpg" alt="Basalt columns in Boyabat, Turkey" style="width: 100%; height: 60vh; object-fit: cover; border-radius: 8px;">
                <figcaption><strong style="color: var(--slide-navy);">Boyabat, Turkey</strong> · Lagrima, CC BY-SA 3.0</figcaption>
            </figure>
        </div>

        <!-- Right column: Crystal growth simulation -->
        <div>
            <p style="text-align: left; margin-bottom: 2vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Random surface model (mathematical crystal)</p>
            <div style="position: relative; display: inline-block; width: 100%;">
                <canvas id="crystal-growth-canvas" style="width: 100%; height: 60vh; border-radius: 8px;"></canvas>
                <button id="crystal-play-btn" style="position: absolute; bottom: 1vh; right: 1vh; width: 4vh; height: 4vh; border-radius: 50%; border: none; background: rgba(35, 45, 75, 0.8); color: white; font-size: clamp(0.9rem, 1.5vw, 1.2rem); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: opacity 0.3s;">▶</button>
            </div>
        </div>
    </div>

    <p id="nature-builds-question" style="font-size: clamp(1.5rem, 2.8vw, 2.2rem); margin-top: 3vh; text-align: center; font-style: italic; color: var(--slide-navy); opacity: 0; transition: opacity 0.3s;">How does a mathematical model create basalt columns?</p>
</section>

<script>
// 3D q-Racah lozenge tiling simulation using WASM
(function initCrystalSim() {
    if (!window.slideEngine) {
        setTimeout(initCrystalSim, 50);
        return;
    }

    const canvas = document.getElementById('crystal-growth-canvas');
    if (!canvas) return;

    // ===== WASM INTERFACE =====
    let wasmReady = false;
    const wasmInterface = {
        ready: false,
        N_param: 30,
        T_param: 60,
        S_param: 0,
        S_target: 30,  // Stop midway (half of T)
        // Imaginary q-Racah parameters
        imaginary_q: 0.8,  // q parameter (0 < q < 1)
        kappa_i: 3.0,      // κ/i parameter
        paths: [],

        initialize() {
            if (typeof Module === 'undefined' || typeof Module.cwrap !== 'function') {
                console.error('WASM Module not ready');
                return false;
            }
            this.initializeTiling = Module.cwrap('initializeTiling', 'number', ['number', 'number', 'number', 'number', 'number'], {async: true});
            this.performSOperator = Module.cwrap('performSOperator', 'number', [], {async: true});
            this.exportPaths = Module.cwrap('exportPaths', 'number', [], {async: true});
            this.setImaginaryQ = Module.cwrap('setImaginaryQ', null, ['number']);
            this.freeString = Module.cwrap('freeString', null, ['number']);
            this.ready = true;
            return true;
        },

        async initTiling() {
            if (!this.ready) return;
            try {
                this.S_param = 0;
                // mode 7 = IMAGINARY_Q_RACAH
                // Pass -kappasq as the q parameter (negative encodes kappa^2)
                const kappasq = this.kappa_i * this.kappa_i;
                this.setImaginaryQ(this.imaginary_q);  // Set the actual q parameter
                const ptr = await this.initializeTiling(this.N_param, this.T_param, 0, 7, -kappasq);
                if (ptr) {
                    const jsonStr = Module.UTF8ToString(ptr);
                    this.freeString(ptr);
                    const result = JSON.parse(jsonStr);
                    this.S_param = result.s || 0;
                }
                await this.refreshPaths();
            } catch (e) { console.error('Init failed:', e); }
        },

        async stepForward() {
            if (!this.ready || this.S_param >= this.T_param) return false;
            try {
                const ptr = await this.performSOperator();
                if (ptr) {
                    const jsonStr = Module.UTF8ToString(ptr);
                    this.freeString(ptr);
                    const result = JSON.parse(jsonStr);
                    this.S_param = result.s;
                    await this.refreshPaths();
                    return true;
                }
            } catch (e) { console.error('Step failed:', e); }
            return false;
        },

        async refreshPaths() {
            try {
                const ptr = await this.exportPaths();
                if (ptr) {
                    const jsonStr = Module.UTF8ToString(ptr);
                    this.freeString(ptr);
                    const result = JSON.parse(jsonStr);
                    this.paths = result.paths;  // Extract paths array from result object
                    console.log('Paths refreshed, count:', this.paths?.length, 'first path length:', this.paths?.[0]?.length);
                }
            } catch (e) { console.error('Export paths failed:', e); }
        },

        async growToTarget() {
            // Grow tiling to target size (midway) by calling S-operator repeatedly
            while (this.S_param < this.S_target) {
                const stepped = await this.stepForward();
                if (!stepped) break;
            }
        }
    };

    // Wait for WASM module to be ready
    let wasmInitAttempts = 0;
    function tryInitWasm() {
        wasmInitAttempts++;
        if (typeof Module !== 'undefined' && typeof Module.cwrap === 'function') {
            const success = wasmInterface.initialize();
            if (success) {
                wasmReady = true;
                console.log('WASM initialized for crystal sim after', wasmInitAttempts, 'attempts');
            }
        } else {
            if (wasmInitAttempts < 100) {
                setTimeout(tryInitWasm, 100);
            } else {
                console.error('Failed to initialize WASM after 100 attempts');
                console.log('Module:', typeof Module, 'cwrap:', typeof Module?.cwrap);
            }
        }
    }
    tryInitWasm();

    // White metallic colors for dark background
    const colors = {
        gray1: '#FFFFFF',  // White (up rhombi)
        gray2: '#FFFFFF',  // White (down rhombi)
        gray3: '#FFFFFF',  // White (horizontal rhombi)
        border: '#444466'
    };

    // ===== THREE.JS RENDERING (LAZY LOADED) =====
    let scene = null;
    let renderer = null;
    let camera = null;
    let controls = null;
    let meshGroup = null;
    let aspect = 1;
    let renderLoopId = null;

    function initThreeJS() {
        if (renderer) return;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);  // Dark background

        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        aspect = canvas.clientWidth / canvas.clientHeight || 1;
        camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 5000);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.rotateSpeed = 0.8;
        controls.panSpeed = 0.8;
        controls.zoomSpeed = 1.2;
        controls.minDistance = 10;
        controls.maxDistance = 500;

        // Lighting (metallic style from visual talk)
        scene.add(new THREE.AmbientLight(0xffffff, 0.35));
        const hemi = new THREE.HemisphereLight(0x6666aa, 0x222244, 0.25);
        hemi.position.set(0, 20, 0);
        scene.add(hemi);
        const directional = new THREE.DirectionalLight(0xffffff, 1.2);
        directional.position.set(15, 20, 5);
        scene.add(directional);
        const fill = new THREE.DirectionalLight(0xffffff, 0.3);
        fill.position.set(-10, 5, -5);
        scene.add(fill);

        meshGroup = new THREE.Group();
        scene.add(meshGroup);

        // Camera position - close zoom for metallic look
        camera.position.set(29.7, -8.5, 3.9);
        camera.up.set(0, 0, 1);
        controls.target.set(17.3, 15.9, 5.8);
        controls.update();

        // Render loop for smooth damping
        function renderLoop() {
            if (!renderer || !camera || !controls) return;
            controls.update();
            renderer.render(scene, camera);
            renderLoopId = requestAnimationFrame(renderLoop);
        }
        renderLoop();


        resize();
    }

    function disposeThreeJS() {
        if (!renderer) return;

        if (renderLoopId) { cancelAnimationFrame(renderLoopId); renderLoopId = null; }
        if (animationId) { clearTimeout(animationId); animationId = null; }
        if (cameraAnimationId) { cancelAnimationFrame(cameraAnimationId); cameraAnimationId = null; }
        isRunning = false;
        isCameraAnimating = false;

        if (meshGroup) {
            while (meshGroup.children.length > 0) {
                const child = meshGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                meshGroup.remove(child);
            }
        }

        renderer.dispose();
        renderer = null;
        scene = null;
        camera = null;
        controls = null;
        meshGroup = null;
    }

    function resize() {
        if (!renderer || !camera) return;
        const w = canvas.clientWidth, h = canvas.clientHeight;
        if (w === 0 || h === 0) return;
        renderer.setSize(w, h, false);
        aspect = w / h;
        camera.aspect = aspect;
        camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);

    let isRunning = false;
    let animationId = null;

    // Convert WASM paths to 3D geometry (adapted from /lozenge/)
    function pathsTo3D(paths, N, T, S) {
        if (!meshGroup) return;

        // Store parameters for horizontal lozenge calculations
        currentN = N;
        currentT = T;
        currentS = S;

        // Clear existing geometry
        while (meshGroup.children.length > 0) {
            const child = meshGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
            meshGroup.remove(child);
        }

        if (!paths || paths.length === 0) return;

        // Convert paths to triplet format
        const pathTriplets = [];
        for (let i = 0; i < paths.length; i++) {
            const pathCopy = paths[i].slice().reverse();
            const firstElement = pathCopy[0];
            const adjustedPath = pathCopy.map(x => firstElement - x);

            const triplets = [];
            let x = 0, y = 0;
            const z = paths.length - i;

            triplets.push([x, y, z]);

            for (let j = 1; j < adjustedPath.length; j++) {
                const prev = adjustedPath[j-1];
                const curr = adjustedPath[j];

                if (curr === prev + 1) {
                    x++;
                } else if (curr === prev) {
                    y++;
                }
                triplets.push([x, y, z]);
            }
            pathTriplets.push(triplets);
        }

        // Create geometry
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const normals = [];
        const vertexColors = [];
        const indices = [];

        function addSquareFace(v1, v2, v3, v4, color) {
            const baseIndex = vertices.length / 3;

            // Add vertices (swap X and Y for correct orientation)
            vertices.push(v1[1], v1[0], v1[2]);
            vertices.push(v2[1], v2[0], v2[2]);
            vertices.push(v3[1], v3[0], v3[2]);
            vertices.push(v4[1], v4[0], v4[2]);

            // Calculate normal
            const edge1 = [v2[1] - v1[1], v2[0] - v1[0], v2[2] - v1[2]];
            const edge2 = [v3[1] - v1[1], v3[0] - v1[0], v3[2] - v1[2]];
            const normal = [
                edge1[1] * edge2[2] - edge1[2] * edge2[1],
                edge1[2] * edge2[0] - edge1[0] * edge2[2],
                edge1[0] * edge2[1] - edge1[1] * edge2[0]
            ];
            const len = Math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2);
            if (len > 0) {
                normal[0] /= len;
                normal[1] /= len;
                normal[2] /= len;
            }

            for (let i = 0; i < 4; i++) {
                normals.push(normal[0], normal[1], normal[2]);
            }

            const c = new THREE.Color(color);
            for (let i = 0; i < 4; i++) {
                vertexColors.push(c.r, c.g, c.b);
            }

            indices.push(
                baseIndex, baseIndex + 1, baseIndex + 2,
                baseIndex, baseIndex + 2, baseIndex + 3
            );
        }

        // Create strips between consecutive paths (vertical lozenges)
        for (let pathIdx = 1; pathIdx < pathTriplets.length; pathIdx++) {
            const topPath = pathTriplets[pathIdx];
            const bottomPath = topPath.map(point => [point[0], point[1], point[2] - 1]);

            for (let i = 0; i < topPath.length - 1; i++) {
                const topP1 = topPath[i];
                const topP2 = topPath[i + 1];
                const bottomP1 = bottomPath[i];
                const bottomP2 = bottomPath[i + 1];

                // Determine color based on segment direction
                let color;
                if (topP2[0] > topP1[0] && topP2[1] === topP1[1]) {
                    color = colors.gray2;  // UVA Blue
                } else if (topP2[0] === topP1[0] && topP2[1] > topP1[1]) {
                    color = colors.gray1;  // UVA Orange
                } else {
                    color = colors.gray3;
                }

                addSquareFace(topP1, topP2, bottomP2, bottomP1, color);
            }
        }

        // Place horizontal lozenges at all height levels
        placeAllHorizontalLozenges(pathTriplets, addSquareFace);

        // Set geometry attributes
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
        geometry.setIndex(indices);

        // Create metallic material (like visual talk - dark bg style)
        const material = new THREE.MeshStandardMaterial({
            vertexColors: true,
            side: THREE.DoubleSide,
            flatShading: true,
            roughness: 0.3,
            metalness: 0.35,
            color: 0xddeeff  // Subtle blue tint
        });

        const mesh = new THREE.Mesh(geometry, material);
        meshGroup.add(mesh);

        // Add edges (subtle for dark background)
        const edgesGeometry = new THREE.EdgesGeometry(geometry, 10);
        const edgesMaterial = new THREE.LineBasicMaterial({
            color: 0x444466,
            linewidth: 1,
            opacity: 0.6,
            transparent: true
        });
        const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
        meshGroup.add(edges);
    }

    // Store current parameters for horizontal lozenge calculation
    let currentN = 0, currentT = 0, currentS = 0;

    function extractLastFromIncreasing(list) {
        const result = [];
        let i = 0;
        while (i < list.length) {
            let j = i;
            while (j + 1 < list.length && list[j] < list[j + 1]) {
                j++;
            }
            result.push(list[j]);
            i = j + 1;
        }
        return result;
    }

    function calculateQFunction(path) {
        // q[z] := Last /@ Split[Table[If[p[z][[i]][[1]] == p[z][[i]][[2]], p[z][[i]][[2]], p[z][[i]][[1]]], {i, 1, 11}], #1 < #2 &]
        const table = [];
        for (let i = 0; i < path.length; i++) {
            const [x, y, z] = path[i];
            if (x === y) {
                table.push(y);
            } else {
                table.push(x);
            }
        }
        return extractLastFromIncreasing(table);
    }

    function calculateHorizontalLozengeMatrix(upperPath, lowerPath, S, T) {
        // Matrix dimensions: (S+1) rows (a=0 to S) × (T-S+1) columns (b=0 to T-S)
        const matrix = Array(S + 1).fill().map(() => Array(T - S + 1).fill(0));

        const upperQ = calculateQFunction(upperPath);
        const lowerQ = calculateQFunction(lowerPath);

        // Apply: If[q[z][[b + 1]] > a >= q[z + 1][[b + 1]], 1, 0]
        for (let a = 0; a <= S; a++) {
            for (let b = 0; b <= T - S; b++) {
                const upperVal = upperQ[b] || 0;
                const lowerVal = lowerQ[b] || 0;

                if (upperVal > a && a >= lowerVal) {
                    matrix[a][b] = 1;
                }
            }
        }

        return matrix;
    }

    function placeAllHorizontalLozenges(pathTriplets, addSquareFace) {
        const S = currentS;
        const T = currentT;
        const N = currentN;

        // Handle top boundary (above the first path at z=N)
        if (pathTriplets.length > 0) {
            const topZ = N;
            const firstPath = pathTriplets[0];

            // Top boundary path (extreme version of path 0 at same height)
            const topBoundary = [];
            for (let i = 0; i <= S; i++) {
                topBoundary.push([i, 0, topZ]);
            }
            for (let i = 1; i <= T - S; i++) {
                topBoundary.push([S, i, topZ]);
            }

            // Calculate horizontal lozenges between top boundary and first path
            const zLevel = topZ - 1;
            const horizontalMatrix = calculateHorizontalLozengeMatrix(topBoundary, firstPath, S, T);

            // Place squares where matrix value is 1
            for (let a = 0; a <= S; a++) {
                for (let b = 0; b <= T - S; b++) {
                    if (a < horizontalMatrix.length && b < horizontalMatrix[a].length && horizontalMatrix[a][b] === 1) {
                        const square = [
                            [a, b, zLevel],
                            [a + 1, b, zLevel],
                            [a + 1, b + 1, zLevel],
                            [a, b + 1, zLevel]
                        ];
                        addSquareFace(square[0], square[1], square[2], square[3], colors.gray3);
                    }
                }
            }
        }

        // Handle middle paths (between consecutive actual paths)
        for (let pathIdx = 0; pathIdx < pathTriplets.length - 1; pathIdx++) {
            const upperPath = pathTriplets[pathIdx];
            const lowerPath = pathTriplets[pathIdx + 1];

            const zLevel = upperPath[0][2] - 1;

            const horizontalMatrix = calculateHorizontalLozengeMatrix(upperPath, lowerPath, S, T);

            for (let a = 0; a <= S; a++) {
                for (let b = 0; b <= T - S; b++) {
                    if (a < horizontalMatrix.length && b < horizontalMatrix[a].length && horizontalMatrix[a][b] === 1) {
                        const square = [
                            [a, b, zLevel],
                            [a + 1, b, zLevel],
                            [a + 1, b + 1, zLevel],
                            [a, b + 1, zLevel]
                        ];
                        addSquareFace(square[0], square[1], square[2], square[3], colors.gray3);
                    }
                }
            }
        }

        // Handle bottom boundary (below the last path at z=0)
        if (pathTriplets.length > 0) {
            const lastPath = pathTriplets[pathTriplets.length - 1];

            // Bottom boundary path (extreme version of last path at height 0)
            const bottomBoundary = [];
            for (let i = 0; i <= T - S; i++) {
                bottomBoundary.push([0, i, 0]);
            }
            for (let i = 1; i <= S; i++) {
                bottomBoundary.push([i, T - S, 0]);
            }

            const zLevel = 0;
            const horizontalMatrix = calculateHorizontalLozengeMatrix(lastPath, bottomBoundary, S, T);

            for (let a = 0; a <= S; a++) {
                for (let b = 0; b <= T - S; b++) {
                    if (a < horizontalMatrix.length && b < horizontalMatrix[a].length && horizontalMatrix[a][b] === 1) {
                        const square = [
                            [a, b, zLevel],
                            [a + 1, b, zLevel],
                            [a + 1, b + 1, zLevel],
                            [a, b + 1, zLevel]
                        ];
                        addSquareFace(square[0], square[1], square[2], square[3], colors.gray3);
                    }
                }
            }
        }
    }

    function buildGeometry() {
        const paths = wasmInterface.paths;
        pathsTo3D(paths, wasmInterface.N_param, wasmInterface.T_param, wasmInterface.S_param);
        if (renderer && scene && camera) renderer.render(scene, camera);
    }

    // Initialize tiling with empty parallelogram (S=0)
    async function initTilingEmpty() {
        if (!wasmInterface.ready) {
            console.log('WASM not ready for initTiling, retrying...');
            setTimeout(initTilingEmpty, 100);
            return;
        }
        console.log('Starting tiling initialization (empty)...');
        await wasmInterface.initTiling();
        console.log('After initTiling, S_param:', wasmInterface.S_param, 'paths:', wasmInterface.paths?.length);
        buildGeometry();
    }

    // Very slow animation delay (ms between steps)
    const SLOW_STEP_DELAY = 800;  // 800ms = extra slow

    async function doSlowAnimationStep() {
        if (!isRunning || !renderer || !controls) return;

        // Check if we've reached target
        if (wasmInterface.S_param >= wasmInterface.S_target) {
            // Stop at midpoint
            isRunning = false;
            updatePlayBtn();
            return;
        }

        const stepped = await wasmInterface.stepForward();
        buildGeometry();
        controls.update();
        renderer.render(scene, camera);

        if (isRunning && stepped) {
            // Use setTimeout for slow animation instead of requestAnimationFrame
            animationId = setTimeout(doSlowAnimationStep, SLOW_STEP_DELAY);
        }
    }

    function animate() {
        doSlowAnimationStep();
    }

    const playBtn = document.getElementById('crystal-play-btn');

    function updatePlayBtn() {
        playBtn.textContent = isRunning ? '⏸' : '▶';
    }

    function start() {
        if (!isRunning) { isRunning = true; updatePlayBtn(); animate(); }
    }

    function pause() {
        isRunning = false;
        if (animationId) { clearTimeout(animationId); animationId = null; }
        updatePlayBtn();
        buildGeometry();
        if (renderer) renderer.render(scene, camera);
    }

    function toggle() {
        if (isRunning) pause(); else start();
    }

    playBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggle();
    });

    // Camera animation for q-Racah paths (close zoom metallic style)
    const cameraStart = { x: 29.7, y: -8.5, z: 3.9 };
    const cameraEnd = { x: 53.1, y: -37.2, z: 41.6 };
    const targetStart = { x: 17.3, y: 15.9, z: 5.8 };
    const targetEnd = { x: 25.9, y: 12.1, z: 9.8 };
    let isCameraAnimating = false;
    let cameraAnimationId = null;

    function animateCamera(duration = 3000) {
        if (!camera || !controls || !renderer) return;
        const startTime = performance.now();
        isCameraAnimating = true;

        function tick() {
            if (!camera || !controls || !renderer) { isCameraAnimating = false; return; }
            const elapsed = performance.now() - startTime;
            const t = Math.min(elapsed / duration, 1);
            // Smooth easing (ease-in-out)
            const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

            // Animate camera position
            camera.position.x = cameraStart.x + (cameraEnd.x - cameraStart.x) * ease;
            camera.position.y = cameraStart.y + (cameraEnd.y - cameraStart.y) * ease;
            camera.position.z = cameraStart.z + (cameraEnd.z - cameraStart.z) * ease;

            // Animate target position
            controls.target.x = targetStart.x + (targetEnd.x - targetStart.x) * ease;
            controls.target.y = targetStart.y + (targetEnd.y - targetStart.y) * ease;
            controls.target.z = targetStart.z + (targetEnd.z - targetStart.z) * ease;

            controls.update();

            if (t < 1) {
                cameraAnimationId = requestAnimationFrame(tick);
            } else {
                isCameraAnimating = false;
            }
        }
        tick();
    }

    function resetCamera() {
        if (cameraAnimationId) cancelAnimationFrame(cameraAnimationId);
        isCameraAnimating = false;
        if (!camera || !controls || !renderer) return;
        camera.position.set(cameraStart.x, cameraStart.y, cameraStart.z);
        camera.up.set(0, 0, 1);
        controls.target.set(17.3, 15.9, 5.8);
        controls.update();
        renderer.render(scene, camera);
    }

    const questionEl = document.getElementById('nature-builds-question');

    // 4 steps: 1=start slow animation, 2=stop, 3=camera transition, 4=text
    window.slideEngine.registerSimulation('nature-builds', {
        start, pause, steps: 4,
        onSlideEnter() {
            // Lazy init WebGL to avoid context limit
            initThreeJS();
            setTimeout(async () => {
                resize();
                if (renderer) renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
                // Initialize with empty parallelogram (S=0)
                await initTilingEmpty();
                if (controls) controls.update();
                if (renderer && scene && camera) renderer.render(scene, camera);
            }, 50);
        },
        onSlideLeave() {
            // Dispose WebGL context to free resources
            disposeThreeJS();
            questionEl.style.opacity = '0';
        },
        onStep(step) {
            if (step === 1) { start(); }  // Start VERY SLOW animation to midpoint
            else if (step === 2) { pause(); }
            else if (step === 3) { animateCamera(3000); }
            else if (step === 4) { questionEl.style.opacity = '1'; }
        },
        onStepBack(step) {
            if (step === 0) { pause(); initTilingEmpty(); resetCamera(); questionEl.style.opacity = '0'; }
            else if (step === 1) { start(); questionEl.style.opacity = '0'; }
            else if (step === 2) { resetCamera(); questionEl.style.opacity = '0'; }
            else if (step === 3) { questionEl.style.opacity = '0'; }
        }
    }, 1);
})();
</script>

<!-- ==================== PART 1: The 2D Warm-Up ==================== -->

<section class="slide slide-center" id="part1-intro" data-title="Part 1: 2D">
    <h2 style="font-size: clamp(3rem, 5vw, 5.5rem);">Part I</h2>
    <h3 style="font-size: clamp(3rem, 5vw, 5.5rem); color: var(--slide-muted); text-transform: uppercase; letter-spacing: 0.05em;">The 2D Warm-Up</h3>
</section>

<section class="slide" id="grid-paths" data-title="Grid Paths">
    <h2 class="slide-title">Paths on a Grid</h2>
    <div style="display: grid; grid-template-columns: 1fr 1.5fr; gap: 3vw; align-items: start; margin-top: 2vh;">
        <!-- Left column: grid visual, text and formula -->
        <div>
            <canvas id="grid-demo-canvas" width="400" height="400" style="width: 30vw; height: 30vw; max-width: 350px; max-height: 350px; margin-bottom: 2vh;"></canvas>
            <p style="font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Start at (0, 0), end at (a, b)</p>
            <p style="font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Move only right (R) or up (U)</p>
            <div id="grid-paths-answer" style="margin-top: 2vh;">
                <p style="font-size: clamp(1.5rem, 2.5vw, 2rem); color: var(--uva-orange);">
                    \(\displaystyle\binom{a+b}{a} = \frac{(a+b)!}{a!\, b!}\) paths
                </p>
            </div>
        </div>
        <!-- Right column: simulation (always visible) -->
        <div id="grid-paths-sim">
            <div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 1vh;">
                <label style="font-size: clamp(0.9rem, 1.5vw, 1.1rem);">a = <input type="number" id="path-a" value="4" min="1" max="7" style="width: 3rem; font-size: 1rem;"></label>
                <label style="font-size: clamp(0.9rem, 1.5vw, 1.1rem);">b = <input type="number" id="path-b" value="3" min="1" max="7" style="width: 3rem; font-size: 1rem;"></label>
                <span id="path-count" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); color: var(--uva-orange); margin-left: 1rem;"></span>
            </div>
            <canvas id="paths-canvas" width="700" height="500" style="width: 100%; height: auto;"></canvas>
        </div>
    </div>
</section>

<script>
(function() {
    const canvas = document.getElementById('paths-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const inputA = document.getElementById('path-a');
    const inputB = document.getElementById('path-b');
    const countSpan = document.getElementById('path-count');

    // Draw grid demo in left column
    const gridCanvas = document.getElementById('grid-demo-canvas');
    const gridCtx = gridCanvas.getContext('2d');
    function drawGridDemo() {
        const w = gridCanvas.width, h = gridCanvas.height;
        const padding = 30;
        const gridSize = 4;
        const stepX = (w - 2 * padding) / gridSize;
        const stepY = (h - 2 * padding) / gridSize;

        gridCtx.fillStyle = '#fff';
        gridCtx.fillRect(0, 0, w, h);

        // Draw grid lines
        gridCtx.strokeStyle = '#999';
        gridCtx.lineWidth = 2;
        for (let i = 0; i <= gridSize; i++) {
            gridCtx.beginPath();
            gridCtx.moveTo(padding + i * stepX, padding);
            gridCtx.lineTo(padding + i * stepX, h - padding);
            gridCtx.stroke();
            gridCtx.beginPath();
            gridCtx.moveTo(padding, padding + i * stepY);
            gridCtx.lineTo(w - padding, padding + i * stepY);
            gridCtx.stroke();
        }

        // Draw dots
        gridCtx.fillStyle = '#232D4B';
        for (let i = 0; i <= gridSize; i++) {
            for (let j = 0; j <= gridSize; j++) {
                gridCtx.beginPath();
                gridCtx.arc(padding + i * stepX, h - padding - j * stepY, 4, 0, Math.PI * 2);
                gridCtx.fill();
            }
        }

        // Draw sample path: UURURRUR
        // (0,0) -> U(0,1) -> U(0,2) -> R(1,2) -> U(1,3) -> R(2,3) -> R(3,3) -> U(3,4) -> R(4,4)
        gridCtx.strokeStyle = '#E57200';
        gridCtx.lineWidth = 8;
        gridCtx.lineCap = 'round';
        gridCtx.lineJoin = 'round';
        gridCtx.beginPath();
        gridCtx.moveTo(padding, h - padding);                           // (0,0)
        gridCtx.lineTo(padding, h - padding - stepY);                   // U -> (0,1)
        gridCtx.lineTo(padding, h - padding - 2 * stepY);               // U -> (0,2)
        gridCtx.lineTo(padding + stepX, h - padding - 2 * stepY);       // R -> (1,2)
        gridCtx.lineTo(padding + stepX, h - padding - 3 * stepY);       // U -> (1,3)
        gridCtx.lineTo(padding + 2 * stepX, h - padding - 3 * stepY);   // R -> (2,3)
        gridCtx.lineTo(padding + 3 * stepX, h - padding - 3 * stepY);   // R -> (3,3)
        gridCtx.lineTo(padding + 3 * stepX, h - padding - 4 * stepY);   // U -> (3,4)
        gridCtx.lineTo(padding + 4 * stepX, h - padding - 4 * stepY);   // R -> (4,4)
        gridCtx.stroke();

        // Labels
        gridCtx.fillStyle = '#232D4B';
        gridCtx.font = `${Math.round(gridCanvas.height * 0.053)}px sans-serif`;
        gridCtx.fillText('(0,0)', padding - 10, h - padding + Math.round(h * 0.067));
        gridCtx.fillText('(a,b)', w - padding - 5, padding - Math.round(h * 0.033));
    }
    drawGridDemo();

    function generatePaths(a, b) {
        const paths = [];
        function generate(x, y, path) {
            if (x === a && y === b) {
                paths.push([...path]);
                return;
            }
            if (x < a) {
                path.push('R');
                generate(x + 1, y, path);
                path.pop();
            }
            if (y < b) {
                path.push('U');
                generate(x, y + 1, path);
                path.pop();
            }
        }
        generate(0, 0, []);
        return paths;
    }

    function drawPaths() {
        const a = Math.min(7, Math.max(1, parseInt(inputA.value) || 2));
        const b = Math.min(7, Math.max(1, parseInt(inputB.value) || 2));
        inputA.value = a;
        inputB.value = b;

        const paths = generatePaths(a, b);
        const numPaths = paths.length;
        countSpan.textContent = `${numPaths} paths`;

        // Calculate grid layout
        const cols = Math.ceil(Math.sqrt(numPaths * 1.5));
        const rows = Math.ceil(numPaths / cols);

        const cellW = canvas.width / cols;
        const cellH = canvas.height / rows;
        const padding = Math.min(cellW, cellH) * 0.1;
        const gridW = cellW - 2 * padding;
        const gridH = cellH - 2 * padding;
        const stepX = gridW / a;
        const stepY = gridH / b;

        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        paths.forEach((path, idx) => {
            const col = idx % cols;
            const row = Math.floor(idx / cols);
            const baseX = col * cellW + padding;
            const baseY = row * cellH + padding;

            // Draw grid lines
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            for (let i = 0; i <= a; i++) {
                ctx.beginPath();
                ctx.moveTo(baseX + i * stepX, baseY);
                ctx.lineTo(baseX + i * stepX, baseY + gridH);
                ctx.stroke();
            }
            for (let j = 0; j <= b; j++) {
                ctx.beginPath();
                ctx.moveTo(baseX, baseY + gridH - j * stepY);
                ctx.lineTo(baseX + gridW, baseY + gridH - j * stepY);
                ctx.stroke();
            }

            // Draw grid dots
            ctx.fillStyle = '#232D4B';
            for (let i = 0; i <= a; i++) {
                for (let j = 0; j <= b; j++) {
                    ctx.beginPath();
                    ctx.arc(baseX + i * stepX, baseY + gridH - j * stepY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw path
            ctx.strokeStyle = '#E57200';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            let x = 0, y = 0;
            ctx.moveTo(baseX + x * stepX, baseY + gridH - y * stepY);
            for (const move of path) {
                if (move === 'R') x++;
                else y++;
                ctx.lineTo(baseX + x * stepX, baseY + gridH - y * stepY);
            }
            ctx.stroke();
        });
    }

    inputA.addEventListener('change', drawPaths);
    inputB.addEventListener('change', drawPaths);
    inputA.addEventListener('input', drawPaths);
    inputB.addEventListener('input', drawPaths);

    // Initial draw
    drawPaths();

    // No steps needed - everything visible on load
    // Register with slideEngine just for slide enter/leave hooks
    function waitForSlideEngine() {
        if (!window.slideEngine) {
            setTimeout(waitForSlideEngine, 50);
            return;
        }
        window.slideEngine.registerSimulation('grid-paths', {
            start() {},
            pause() {},
            onSlideEnter() {
                inputA.value = 4;
                inputB.value = 3;
                drawPaths();
            }
        }, 0);
    }
    waitForSlideEngine();
})();
</script>

<section class="slide slide-top" id="random-path" data-title="Local Bernoulli">
    <h2 class="slide-title">Random path: local structure</h2>

    <div style="display: grid; grid-template-columns: 1.2fr 1fr; gap: 2vw; margin-top: 1vh; width: 95%;">
        <!-- Left: Full path with highlighted region -->
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); margin-bottom: 0.5vh;">
                Random path in <span id="random-path-size">100 × 60</span> grid <span style="color: var(--slide-muted);">(click to resample)</span>
            </div>
            <canvas id="random-path-canvas" width="1000" height="600" style="height: 42vh; width: auto; cursor: pointer;"></canvas>
        </div>
        <!-- Right: Enlarged local view OR Brownian bridge -->
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div id="local-view-container">
                <div id="local-view-title" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); margin-bottom: 0.5vh; opacity: 0; transition: opacity 0.3s;">
                    Zoomed in: local segment
                </div>
                <canvas id="local-view-canvas" width="600" height="500" style="height: 35vh; width: auto; opacity: 0; transition: opacity 0.3s;"></canvas>
            </div>
            <div id="brownian-container" style="opacity: 0; transition: opacity 0.3s; display: flex; flex-direction: column; align-items: center;">
                <div style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); margin-bottom: 0.5vh;">
                    Fluctuations → Brownian bridge
                </div>
                <canvas id="brownian-bridge-canvas" width="600" height="300" style="height: 20vh; width: auto; border: 1px solid #ccc;"></canvas>
            </div>
        </div>
    </div>

    <!-- Bernoulli explanation -->
    <div id="bernoulli-explanation" style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: left; margin-top: 2vh; opacity: 0; transition: opacity 0.3s;">
        <strong style="color: var(--slide-accent);">Local structure is IID Bernoulli:</strong>
        At each step, choose <span style="color: #E57200; font-weight: bold;">R</span> with prob. \(\frac{a}{a+b}\), <span style="color: #232D4B; font-weight: bold;">U</span> with prob. \(\frac{b}{a+b}\) — independent trials!
    </div>

    <!-- Global observation -->
    <div id="global-observation" style="background: #f5f5f5; border-left: 4px solid #232D4B; padding: 1vh 1.5vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: left; margin-top: 1vh; opacity: 0; transition: opacity 0.3s;">
        <strong style="color: #232D4B;">Globally:</strong>
        Path follows the diagonal (LLN). Fluctuations converge to <strong>Brownian bridge</strong>.
    </div>
</section>

<script>
(function() {
    'use strict';

    const canvas = document.getElementById('random-path-canvas');
    const ctx = canvas.getContext('2d');
    const localCanvas = document.getElementById('local-view-canvas');
    const localCtx = localCanvas.getContext('2d');
    const bridgeCanvas = document.getElementById('brownian-bridge-canvas');
    const bridgeCtx = bridgeCanvas.getContext('2d');
    const sizeSpan = document.getElementById('random-path-size');
    const localTitle = document.getElementById('local-view-title');
    const localViewContainer = document.getElementById('local-view-container');
    const brownianContainer = document.getElementById('brownian-container');
    const bernoulliEl = document.getElementById('bernoulli-explanation');
    const globalEl = document.getElementById('global-observation');

    const A = 100, B = 60;  // Grid size
    let currentPath = null;
    let highlightLen = 16;     // Length of highlighted region
    let highlightStart = Math.floor((A + B) / 2 - highlightLen / 2);  // Always middle

    function generateRandomPath(a, b) {
        const moves = [];
        let remainingR = a;
        let remainingU = b;
        while (remainingR + remainingU > 0) {
            if (remainingR === 0) {
                moves.push('U');
                remainingU--;
            } else if (remainingU === 0) {
                moves.push('R');
                remainingR--;
            } else {
                if (Math.random() < remainingR / (remainingR + remainingU)) {
                    moves.push('R');
                    remainingR--;
                } else {
                    moves.push('U');
                    remainingU--;
                }
            }
        }
        return moves;
    }

    function drawMainPath(showHighlight = false) {
        const w = canvas.width, h = canvas.height;
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);

        if (!currentPath) {
            currentPath = generateRandomPath(A, B);
        }

        const padding = 50;
        const gridW = w - 2 * padding;
        const gridH = h - 2 * padding;
        const stepX = gridW / A;
        const stepY = gridH / B;
        const baseX = padding;
        const baseY = padding;

        // Draw bounding box
        ctx.strokeStyle = '#232D4B';
        ctx.lineWidth = 2;
        ctx.strokeRect(baseX, baseY, gridW, gridH);

        // Draw diagonal (limit shape)
        ctx.strokeStyle = '#232D4B';
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 4]);
        ctx.beginPath();
        ctx.moveTo(baseX, baseY + gridH);
        ctx.lineTo(baseX + gridW, baseY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw path
        ctx.strokeStyle = '#E57200';
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        let x = 0, y = 0;
        ctx.moveTo(baseX + x * stepX, baseY + gridH - y * stepY);
        for (const move of currentPath) {
            if (move === 'R') x++;
            else y++;
            ctx.lineTo(baseX + x * stepX, baseY + gridH - y * stepY);
        }
        ctx.stroke();

        // Draw highlighted region box if enabled
        if (showHighlight) {
            // Find coordinates at start and end of highlight region
            let hx = 0, hy = 0;
            for (let i = 0; i < highlightStart; i++) {
                if (currentPath[i] === 'R') hx++;
                else hy++;
            }
            const startX = hx, startY = hy;
            for (let i = highlightStart; i < highlightStart + highlightLen && i < currentPath.length; i++) {
                if (currentPath[i] === 'R') hx++;
                else hy++;
            }
            const endX = hx, endY = hy;

            // Draw orange box around highlighted region
            const boxPad = 8;
            const boxX1 = baseX + startX * stepX - boxPad;
            const boxY1 = baseY + gridH - endY * stepY - boxPad;
            const boxX2 = baseX + endX * stepX + boxPad;
            const boxY2 = baseY + gridH - startY * stepY + boxPad;

            ctx.strokeStyle = '#E57200';
            ctx.lineWidth = 4;
            ctx.setLineDash([]);
            ctx.strokeRect(boxX1, boxY1, boxX2 - boxX1, boxY2 - boxY1);

            // Draw the highlighted segment thicker
            ctx.strokeStyle = '#E57200';
            ctx.lineWidth = 8;
            ctx.beginPath();
            let sx = 0, sy = 0;
            for (let i = 0; i < highlightStart; i++) {
                if (currentPath[i] === 'R') sx++;
                else sy++;
            }
            ctx.moveTo(baseX + sx * stepX, baseY + gridH - sy * stepY);
            for (let i = highlightStart; i < highlightStart + highlightLen && i < currentPath.length; i++) {
                if (currentPath[i] === 'R') sx++;
                else sy++;
                ctx.lineTo(baseX + sx * stepX, baseY + gridH - sy * stepY);
            }
            ctx.stroke();
        }

        // Labels
        ctx.fillStyle = '#232D4B';
        ctx.font = 'bold 20px sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('(0,0)', baseX, baseY + gridH + 5);
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        ctx.fillText(`(${A},${B})`, baseX + gridW, baseY - 5);
    }

    function drawLocalView() {
        const w = localCanvas.width, h = localCanvas.height;
        localCtx.fillStyle = '#fff';
        localCtx.fillRect(0, 0, w, h);

        if (!currentPath) return;

        // Extract the highlighted segment
        const segment = currentPath.slice(highlightStart, highlightStart + highlightLen);
        const segLen = segment.length;
        if (segLen === 0) return;

        const padding = 80;
        const availW = w - 2 * padding;
        const availH = h - 2 * padding - 50;

        // Count R's and U's in segment
        let segR = 0, segU = 0;
        for (const m of segment) {
            if (m === 'R') segR++;
            else segU++;
        }
        if (segR === 0) segR = 1;
        if (segU === 0) segU = 1;

        // Use same step size for both directions (square grid cells)
        const step = Math.min(availW / segR, availH / segU);
        const gridW = segR * step;
        const gridH = segU * step;
        const baseX = padding + (availW - gridW) / 2;
        const baseY = padding + availH - (availH - gridH) / 2;

        // Draw grid
        localCtx.strokeStyle = '#ddd';
        localCtx.lineWidth = 1;
        for (let i = 0; i <= segR; i++) {
            localCtx.beginPath();
            localCtx.moveTo(baseX + i * step, baseY - gridH);
            localCtx.lineTo(baseX + i * step, baseY);
            localCtx.stroke();
        }
        for (let j = 0; j <= segU; j++) {
            localCtx.beginPath();
            localCtx.moveTo(baseX, baseY - j * step);
            localCtx.lineTo(baseX + gridW, baseY - j * step);
            localCtx.stroke();
        }

        // Draw path segments - track x,y in grid coordinates
        let x = 0, y = 0;

        for (let i = 0; i < segment.length; i++) {
            const move = segment[i];
            const fromPx = baseX + x * step;
            const fromPy = baseY - y * step;

            if (move === 'R') {
                // Draw R segment in orange (horizontal)
                localCtx.strokeStyle = '#E57200';
                localCtx.lineWidth = 6;
                localCtx.beginPath();
                localCtx.moveTo(fromPx, fromPy);
                localCtx.lineTo(fromPx + step, fromPy);
                localCtx.stroke();
                x++;
            } else {
                // Draw U segment in navy (vertical)
                localCtx.strokeStyle = '#232D4B';
                localCtx.lineWidth = 6;
                localCtx.beginPath();
                localCtx.moveTo(fromPx, fromPy);
                localCtx.lineTo(fromPx, fromPy - step);
                localCtx.stroke();
                y++;
            }
        }

        // Draw dots at vertices
        localCtx.fillStyle = '#232D4B';
        x = 0; y = 0;
        localCtx.beginPath();
        localCtx.arc(baseX, baseY, 5, 0, Math.PI * 2);
        localCtx.fill();
        for (const move of segment) {
            if (move === 'R') x++;
            else y++;
            localCtx.beginPath();
            localCtx.arc(baseX + x * step, baseY - y * step, 5, 0, Math.PI * 2);
            localCtx.fill();
        }

        // Draw annotation
        localCtx.fillStyle = '#666';
        localCtx.font = '18px sans-serif';
        localCtx.textAlign = 'center';
        localCtx.textBaseline = 'top';
        localCtx.fillText('Each step: independent Bernoulli trial', w / 2, baseY + 20);
    }

    function drawBrownianBridge() {
        if (!currentPath) return;

        const w = bridgeCanvas.width, h = bridgeCanvas.height;
        bridgeCtx.fillStyle = '#fff';
        bridgeCtx.fillRect(0, 0, w, h);

        const padding = 30;
        const drawW = w - 2 * padding;
        const drawH = h - 2 * padding;

        // Compute fluctuations: y - (B/A)*x at each point
        const points = [];
        let x = 0, y = 0;
        points.push({ x: 0, y: 0, diff: 0 });
        for (const move of currentPath) {
            if (move === 'R') x++;
            else y++;
            const expectedY = (B / A) * x;
            points.push({ x, y, diff: y - expectedY });
        }

        const maxDiff = Math.max(...points.map(p => Math.abs(p.diff)), 3);

        // Draw zero line
        const zeroY = padding + drawH / 2;
        bridgeCtx.strokeStyle = '#ccc';
        bridgeCtx.lineWidth = 1;
        bridgeCtx.beginPath();
        bridgeCtx.moveTo(padding, zeroY);
        bridgeCtx.lineTo(padding + drawW, zeroY);
        bridgeCtx.stroke();

        // Draw fluctuation curve
        bridgeCtx.strokeStyle = '#E57200';
        bridgeCtx.lineWidth = 3;
        bridgeCtx.beginPath();
        for (let i = 0; i < points.length; i++) {
            const px = padding + (points[i].x / A) * drawW;
            const py = zeroY - (points[i].diff / maxDiff) * (drawH / 2) * 0.9;
            if (i === 0) bridgeCtx.moveTo(px, py);
            else bridgeCtx.lineTo(px, py);
        }
        bridgeCtx.stroke();

        // Label
        bridgeCtx.fillStyle = '#232D4B';
        bridgeCtx.font = '16px sans-serif';
        bridgeCtx.textAlign = 'center';
        bridgeCtx.fillText('path − diagonal', w / 2, h - 8);
    }

    function resample() {
        currentPath = generateRandomPath(A, B);
        // Keep highlight in the middle
    }

    // Click to resample
    canvas.addEventListener('click', () => {
        resample();
        drawAll();
    });

    let currentStep = 0;

    function drawAll() {
        // Show highlight box only on step 3+
        const showHighlight = currentStep >= 3;
        drawMainPath(showHighlight);
        if (currentStep >= 3) {
            drawLocalView();
        }
        if (currentStep >= 5) {
            drawBrownianBridge();
        }
    }

    function reset() {
        currentStep = 0;
        currentPath = null;
        localCanvas.style.opacity = '0';
        localTitle.style.opacity = '0';
        brownianContainer.style.opacity = '0';
        bernoulliEl.style.opacity = '0';
        globalEl.style.opacity = '0';
        resample();
        drawMainPath(false);
    }

    // Register with slideEngine
    // Steps: 0=initial, 1-2=resample, 3-5=zoom+resample, 6=Bernoulli, 7=global+bridge
    function waitForSlideEngine() {
        if (!window.slideEngine) {
            setTimeout(waitForSlideEngine, 50);
            return;
        }
        window.slideEngine.registerSimulation('random-path', {
            start() {},
            pause() {},
            steps: 7,
            onStep(step) {
                currentStep = step;
                if (step === 1 || step === 2) {
                    // Resample without zoom
                    resample();
                    drawMainPath(false);
                } else if (step === 3) {
                    // Show zoom inset + resample
                    resample();
                    localCanvas.style.opacity = '1';
                    localTitle.style.opacity = '1';
                    drawAll();
                } else if (step === 4 || step === 5) {
                    // Resample with zoom showing
                    resample();
                    drawAll();
                } else if (step === 6) {
                    // Show Bernoulli explanation
                    bernoulliEl.style.opacity = '1';
                    drawAll();
                } else if (step === 7) {
                    // Show global observation + Brownian bridge
                    globalEl.style.opacity = '1';
                    brownianContainer.style.opacity = '1';
                    drawAll();
                }
            },
            onStepBack(step) {
                currentStep = step;
                if (step === 0 || step === 1 || step === 2) {
                    // Hide zoom panel
                    localCanvas.style.opacity = '0';
                    localTitle.style.opacity = '0';
                    bernoulliEl.style.opacity = '0';
                    globalEl.style.opacity = '0';
                    brownianContainer.style.opacity = '0';
                    resample();
                    drawMainPath(false);
                } else if (step === 3 || step === 4 || step === 5) {
                    bernoulliEl.style.opacity = '0';
                    globalEl.style.opacity = '0';
                    brownianContainer.style.opacity = '0';
                    resample();
                    drawAll();
                } else if (step === 6) {
                    globalEl.style.opacity = '0';
                    brownianContainer.style.opacity = '0';
                    drawAll();
                }
            },
            onSlideEnter() {
                reset();
            },
            onSlideLeave() {
                reset();
            }
        }, 0);
    }
    waitForSlideEngine();
})();
</script>

<section class="slide slide-top" id="q-deformation" data-title="q-Deformation">
    <h2 class="slide-title">q-Deformation</h2>

    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2vw; margin-top: 1vh; width: 95%;">
        <!-- Left: Explanation text blocks -->
        <div style="display: flex; flex-direction: column; gap: 1.5vh; padding-top: 1vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">
            <!-- Block 1: Area -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw;">
                <strong style="color: var(--slide-accent);">Area above a path:</strong><br>
                Count unit squares above the path
                <div style="display: flex; align-items: center; gap: 1vw; margin-top: 0.5vh;">
                    <canvas id="area-example-canvas" width="300" height="200" style="height: 10vh; width: auto;"></canvas>
                    <span style="font-weight: bold; font-size: clamp(1.5rem, 2.5vw, 2.2rem);">Area = 8</span>
                </div>
            </div>

            <!-- Block 2: q-weighting -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw;">
                \(\displaystyle\text{Probability} = \frac{q^{\text{area}}}{\sum_{\text{paths}} q^{\text{area}}}\)
            </div>

            <!-- Block 3: q-Binomial with example -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw;">
                <strong style="color: var(--slide-accent);">q-Binomial coefficient:</strong><br>
                \(\displaystyle\binom{a+b}{a}_q = \sum_{\text{paths}} q^{\text{area}}\)
            </div>

            <!-- Block 4: Polynomial example -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw;">
                <strong style="color: var(--slide-accent);">Example (a=4, b=3):</strong><br>
                <span id="q-binomial-formula"></span>
            </div>
        </div>

        <!-- Right: All 35 paths grid -->
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); margin-bottom: 0.5vh; display: flex; align-items: center; gap: 1vw;">
                <label for="q-slider">q = </label>
                <input type="range" id="q-slider" min="0" max="2" step="0.01" value="1" style="width: 12vw;">
                <span id="q-value" style="font-weight: bold; min-width: 3em;">1.00</span>
            </div>
            <div id="q-formula-display" style="font-size: clamp(1.4rem, 2.5vw, 2rem); margin-bottom: 1vh; font-weight: bold; color: var(--slide-accent);">
                q = 1: ordinary binomial (35 paths)
            </div>
            <canvas id="q-paths-canvas" width="1100" height="900" style="height: 72vh; width: auto;"></canvas>
        </div>
    </div>
</section>

<script>
(function() {
    'use strict';

    const canvas = document.getElementById('q-paths-canvas');
    const ctx = canvas.getContext('2d');
    const areaCanvas = document.getElementById('area-example-canvas');
    const areaCtx = areaCanvas.getContext('2d');
    const slider = document.getElementById('q-slider');
    const qValueSpan = document.getElementById('q-value');
    const formulaDisplay = document.getElementById('q-formula-display');
    const qBinomialEl = document.getElementById('q-binomial-formula');

    const A = 4, B = 3;

    // Generate all paths from (0,0) to (A,B)
    function generateAllPaths(a, b) {
        const paths = [];
        function generate(path, remainR, remainU) {
            if (remainR === 0 && remainU === 0) {
                paths.push([...path]);
                return;
            }
            if (remainR > 0) {
                path.push('R');
                generate(path, remainR - 1, remainU);
                path.pop();
            }
            if (remainU > 0) {
                path.push('U');
                generate(path, remainR, remainU - 1);
                path.pop();
            }
        }
        generate([], a, b);
        return paths;
    }

    // Calculate area ABOVE a path (unit squares above)
    // Area above = A*B - area below
    function calcArea(path) {
        let areaBelow = 0, y = 0;
        for (const move of path) {
            if (move === 'R') areaBelow += y;
            else y++;
        }
        return A * B - areaBelow;
    }

    const allPaths = generateAllPaths(A, B);
    const pathAreas = allPaths.map(calcArea);

    // Coefficients of the q-binomial polynomial (pre-computed)
    // 1 + q + 2q^2 + 3q^3 + 4q^4 + 4q^5 + 5q^6 + 4q^7 + 4q^8 + 3q^9 + 2q^10 + q^11 + q^12
    const qBinomCoeffs = [1, 1, 2, 3, 4, 4, 5, 4, 4, 3, 2, 1, 1];

    function evalQBinomial(q) {
        if (Math.abs(q - 1) < 1e-10) return 35;
        let sum = 0;
        for (let i = 0; i < qBinomCoeffs.length; i++) {
            sum += qBinomCoeffs[i] * Math.pow(q, i);
        }
        return sum;
    }

    function updateQBinomialFormula(q) {
        const val = evalQBinomial(q);
        if (Math.abs(q - 1) < 0.01) {
            qBinomialEl.innerHTML = `\\(\\displaystyle\\binom{7}{4}_q = 1 + q + 2q^2 + 3q^3 + 4q^4 + 4q^5 + 5q^6\\)<br>\\(\\phantom{\\binom{7}{4}_q =} +\\, 4q^7 + 4q^8 + 3q^9 + 2q^{10} + q^{11} + q^{12}\\)<br>At \\(q=1\\): <strong style="color: var(--slide-accent);">35</strong> paths`;
        } else {
            qBinomialEl.innerHTML = `\\(\\displaystyle\\binom{7}{4}_q = 1 + q + 2q^2 + 3q^3 + 4q^4 + 4q^5 + 5q^6\\)<br>\\(\\phantom{\\binom{7}{4}_q =} +\\, 4q^7 + 4q^8 + 3q^9 + 2q^{10} + q^{11} + q^{12}\\)<br>At \\(q=${q.toFixed(2)}\\): <strong style="color: var(--slide-accent);">${val.toFixed(2)}</strong>`;
        }
        if (window.renderMathInElement) {
            renderMathInElement(qBinomialEl, {
                delimiters: [
                    {left: "\\(", right: "\\)", display: false},
                    {left: "$$", right: "$$", display: true}
                ]
            });
        }
    }

    function drawAreaExample() {
        const w = areaCanvas.width, h = areaCanvas.height;
        areaCtx.fillStyle = '#fff';
        areaCtx.fillRect(0, 0, w, h);

        // Draw a specific path with area shaded
        // This path: R U R U R R U has area_below = 0+1+1+2 = 4, so area_above = 12-4 = 8
        const exPath = ['R', 'U', 'R', 'U', 'R', 'R', 'U'];
        const padding = h * 0.1;
        const gridW = w - 2 * padding;
        const gridH = h - 2 * padding;
        const step = Math.min(gridW / A, gridH / B);
        const stepX = step;
        const stepY = step;
        const baseX = (w - A * step) / 2;
        const baseY = (h - B * step) / 2;

        // Shade area ABOVE path
        areaCtx.fillStyle = 'rgba(229, 114, 0, 0.3)';
        let x = 0, y = 0;
        for (const move of exPath) {
            if (move === 'R') {
                // Shade column from y to B (above the path)
                if (y < B) {
                    areaCtx.fillRect(baseX + x * stepX, baseY, stepX, (B - y) * stepY);
                }
                x++;
            } else {
                y++;
            }
        }

        // Draw grid
        const actualGridW = A * stepX;
        const actualGridH = B * stepY;
        areaCtx.strokeStyle = '#ccc';
        areaCtx.lineWidth = 1;
        for (let i = 0; i <= A; i++) {
            areaCtx.beginPath();
            areaCtx.moveTo(baseX + i * stepX, baseY);
            areaCtx.lineTo(baseX + i * stepX, baseY + actualGridH);
            areaCtx.stroke();
        }
        for (let j = 0; j <= B; j++) {
            areaCtx.beginPath();
            areaCtx.moveTo(baseX, baseY + actualGridH - j * stepY);
            areaCtx.lineTo(baseX + actualGridW, baseY + actualGridH - j * stepY);
            areaCtx.stroke();
        }

        // Draw path
        areaCtx.strokeStyle = '#E57200';
        areaCtx.lineWidth = 3;
        areaCtx.lineCap = 'round';
        areaCtx.lineJoin = 'round';
        areaCtx.beginPath();
        x = 0; y = 0;
        areaCtx.moveTo(baseX + x * stepX, baseY + actualGridH - y * stepY);
        for (const move of exPath) {
            if (move === 'R') x++;
            else y++;
            areaCtx.lineTo(baseX + x * stepX, baseY + actualGridH - y * stepY);
        }
        areaCtx.stroke();
    }

    function drawAllPaths(q) {
        const w = canvas.width, h = canvas.height;
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);

        // Layout: 7 columns x 5 rows
        const cols = 7, rows = 5;
        const cellW = w / cols;
        const cellH = h / rows;
        const padding = 6;
        const gridPadding = 4;

        // Calculate weights
        const qSum = evalQBinomial(q);
        const weights = pathAreas.map(area => Math.pow(q, area));
        const probs = weights.map(wt => wt / qSum);
        const maxProb = Math.max(...probs);

        // Sort paths by area for nice display
        const sorted = allPaths.map((p, i) => ({ path: p, area: pathAreas[i], prob: probs[i], weight: weights[i] }));
        sorted.sort((a, b) => a.area - b.area);

        for (let idx = 0; idx < sorted.length; idx++) {
            const { path, area, prob, weight } = sorted[idx];
            const col = idx % cols;
            const row = Math.floor(idx / cols);

            const cellX = col * cellW + padding;
            const cellY = row * cellH + padding;
            const innerW = cellW - 2 * padding;
            const innerH = cellH - 2 * padding - 28; // leave space for text

            // Draw mini grid with correct 4:3 aspect ratio
            const availW = innerW - 2 * gridPadding;
            const availH = innerH - 2 * gridPadding;
            const step = Math.min(availW / A, availH / B); // uniform step for square cells
            const gridW = step * A;
            const gridH = step * B;
            const baseX = cellX + gridPadding + (availW - gridW) / 2; // center horizontally
            const baseY = cellY + gridPadding + (availH - gridH) / 2; // center vertically

            // Grid lines
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            for (let i = 0; i <= A; i++) {
                ctx.beginPath();
                ctx.moveTo(baseX + i * step, baseY);
                ctx.lineTo(baseX + i * step, baseY + gridH);
                ctx.stroke();
            }
            for (let j = 0; j <= B; j++) {
                ctx.beginPath();
                ctx.moveTo(baseX, baseY + gridH - j * step);
                ctx.lineTo(baseX + gridW, baseY + gridH - j * step);
                ctx.stroke();
            }

            // Path line weight based on probability (thicker = higher prob) - MORE DRAMATIC
            const probRatio = prob / maxProb;
            const minLineW = 1;
            const maxLineW = 16;
            const lineW = minLineW + (maxLineW - minLineW) * Math.pow(probRatio, 0.5);

            // Opacity based on probability
            const minAlpha = 0.15;
            const alpha = minAlpha + (1 - minAlpha) * Math.pow(probRatio, 0.7);

            // Draw path
            ctx.strokeStyle = `rgba(229, 114, 0, ${alpha})`;
            ctx.lineWidth = lineW;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            let x = 0, y = 0;
            ctx.moveTo(baseX, baseY + gridH);
            for (const move of path) {
                if (move === 'R') x++;
                else y++;
                ctx.lineTo(baseX + x * step, baseY + gridH - y * step);
            }
            ctx.stroke();

            // Probability only (no area label) - MORE DRAMATIC sizing
            const textY = cellY + innerH + 15;
            const minFontSize = 14;
            const maxFontSize = 28;
            const fontSize = minFontSize + (maxFontSize - minFontSize) * Math.pow(probRatio, 0.5);
            const fontWeight = probRatio > 0.3 ? 'bold' : 'normal';
            ctx.font = `${fontWeight} ${fontSize}px sans-serif`;
            const textAlpha = 0.3 + 0.7 * Math.pow(probRatio, 0.5);
            ctx.fillStyle = probRatio > 0.5 ? `rgba(229, 114, 0, ${textAlpha})` : `rgba(102, 102, 102, ${textAlpha})`;
            ctx.textAlign = 'center';
            const probStr = (prob * 100).toFixed(1) + '%';
            ctx.fillText(probStr, cellX + innerW / 2 + padding, textY);
        }
    }

    function update() {
        const q = parseFloat(slider.value);
        qValueSpan.textContent = q.toFixed(2);
        drawAllPaths(q);
        updateQBinomialFormula(q);

        // Update formula display
        const qBinom = evalQBinomial(q);
        if (Math.abs(q - 1) < 0.01) {
            formulaDisplay.textContent = 'q = 1: ordinary binomial (35 paths)';
        } else if (q < 1) {
            formulaDisplay.innerHTML = `q = ${q.toFixed(2)} < 1: favors <strong>small area</strong> (low paths)`;
        } else {
            formulaDisplay.innerHTML = `q = ${q.toFixed(2)} > 1: favors <strong>large area</strong> (high paths)`;
        }
    }

    slider.addEventListener('input', update);

    // Initial draw
    drawAreaExample();
    updateQBinomialFormula(1);
    update();

    // Step q values: step 0=1 (uniform), step 1=0.9, step 2=0.5 (favor low area), step 3=1.5 (favor high area)
    const stepQValues = [1, 0.9, 0.5, 1.5];

    function setQ(q) {
        slider.value = q;
        update();
    }

    // Register with slide engine
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('q-deformation', {
                start() {},
                pause() {},
                steps: 3,
                onStep(step) {
                    if (step >= 1 && step <= 3) {
                        setQ(stepQValues[step]);
                    }
                },
                onStepBack(step) {
                    setQ(stepQValues[step]);
                },
                onSlideEnter() {
                    setQ(1);
                },
                onSlideLeave() {
                    setQ(1);
                }
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();
</script>

<section class="slide slide-top" id="q-local" data-title="q-Local Bernoulli">
    <h2 class="slide-title">q-Volume: local structure</h2>

    <div style="display: grid; grid-template-columns: 1.2fr 1fr; gap: 2vw; margin-top: 1vh; width: 95%;">
        <!-- Left: Full q-weighted path with controls -->
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div style="display: flex; align-items: center; gap: 1vw; font-size: clamp(1rem, 1.8vw, 1.4rem); margin-bottom: 0.5vh;">
                <label for="q-local-gamma-slider" style="font-weight: bold;">γ = </label>
                <input type="range" id="q-local-gamma-slider" min="-5" max="5" step="0.1" value="3.6" style="width: 10vw;">
                <span id="q-local-gamma-value" style="font-weight: bold; min-width: 2.5em;">3.6</span>
                <span>(q = <span id="q-local-q-value">0.990</span>)</span>
                <button id="q-local-resample" style="padding: 0.3vh 0.8vw; cursor: pointer;">Resample</button>
            </div>
            <div id="q-local-gamma-explain" style="font-size: clamp(1rem, 1.8vw, 1.4rem); color: var(--slide-muted); margin-bottom: 0.5vh;">
                \(\text{Prob}(\text{path}) \propto q^{\text{area}}\), where \(q = e^{-\gamma/N}\)
            </div>
            <div style="font-size: clamp(0.9rem, 1.5vw, 1.1rem); color: var(--slide-muted); margin-bottom: 0.5vh;">
                <span>a = 180, b = 135</span> · <span id="q-local-status">Loading...</span>
            </div>
            <canvas id="q-local-canvas" width="1200" height="900" style="height: 50vh; width: auto; cursor: pointer;"></canvas>
        </div>
        <!-- Right: Local zoom view -->
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div id="q-local-view-title" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); margin-bottom: 0.5vh; opacity: 0; transition: opacity 0.3s;">
                Zoomed in: local segment
            </div>
            <canvas id="q-local-view-canvas" width="600" height="450" style="height: 35vh; width: auto; opacity: 0; transition: opacity 0.3s;"></canvas>
        </div>
    </div>

    <!-- Key insight -->
    <div id="q-local-insight" style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1.5vh 2vw; font-size: clamp(1.4rem, 2.5vw, 2rem); text-align: left; margin-top: 1vh; opacity: 0; transition: opacity 0.3s;">
        <strong style="color: var(--slide-accent); font-size: 1.2em;">Universality: still Bernoulli!</strong><br>
        Even with q-weighting, local structure remains <strong>independent Bernoulli trials</strong>.
    </div>

    <!-- Explanation -->
    <div id="q-local-explanation" style="background: #f5f5f5; border-left: 4px solid #232D4B; padding: 1vh 1.5vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: left; margin-top: 1vh; opacity: 0; transition: opacity 0.3s;">
        <strong style="color: #232D4B;">Key insight:</strong>
        The q-weighted path (computed by
				<span style="color: var(--slide-muted);">[Vershik 1996]</span>) 
				locally looks like the configuration that <em>maximizes</em>
				the total number of configurations around the path.
				The total number of configurations is approximately the integral
				of the local entropy over the path.
    </div>
</section>

<script src="/talk/visual/sim/q-partition-cftp.js"></script>
<script>
(function() {
    'use strict';

    const canvas = document.getElementById('q-local-canvas');
    const ctx = canvas.getContext('2d');
    const localCanvas = document.getElementById('q-local-view-canvas');
    const localCtx = localCanvas.getContext('2d');
    const gammaSlider = document.getElementById('q-local-gamma-slider');
    const gammaValueSpan = document.getElementById('q-local-gamma-value');
    const qValueSpan = document.getElementById('q-local-q-value');
    const statusEl = document.getElementById('q-local-status');
    const resampleBtn = document.getElementById('q-local-resample');
    const localTitle = document.getElementById('q-local-view-title');
    const insightEl = document.getElementById('q-local-insight');
    const explanationEl = document.getElementById('q-local-explanation');

    const N = 180;  // Width (a)
    const M = 135;  // Height (b)
    let q = 0.99;
    let highlightLen = 16;
    let highlightStart = Math.floor((N + M) / 2 - highlightLen / 2);

    // WASM module
    let wasm = null;
    let initSimulation, runCFTPBatch, getCoalesced, getPartitionPath, freeString;

    // Path as array of moves ['R', 'U', ...]
    let currentPath = [];
    let isRunning = false;

    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    async function initWasm() {
        if (typeof QPartitionModule === 'undefined') {
            statusEl.textContent = 'WASM not loaded';
            return false;
        }
        wasm = await QPartitionModule();
        initSimulation = wasm.cwrap('initSimulation', null, ['number', 'number', 'number']);
        runCFTPBatch = wasm.cwrap('runCFTPBatch', 'number', []);
        getCoalesced = wasm.cwrap('getCoalesced', 'number', []);
        getPartitionPath = wasm.cwrap('getPartitionPath', 'number', []);
        freeString = wasm.cwrap('freeString', null, ['number']);
        return true;
    }

    function getPathFromWasm() {
        const ptr = getPartitionPath();
        const str = wasm.UTF8ToString(ptr);
        freeString(ptr);
        // Returns [[x,y], [x,y], ...] - convert to ['R', 'U', ...]
        const coords = JSON.parse(str);
        const moves = [];
        for (let i = 1; i < coords.length; i++) {
            const dx = coords[i][0] - coords[i-1][0];
            const dy = coords[i][1] - coords[i-1][1];
            if (dx > 0) moves.push('R');
            else if (dy > 0) moves.push('U');
        }
        return moves;
    }

    async function runCFTP() {
        if (!wasm || isRunning) return;
        isRunning = true;
        statusEl.textContent = 'Sampling...';

        initSimulation(N, M, q);

        let totalSteps = 0;
        const batchSize = 10000000;

        while (!getCoalesced()) {
            runCFTPBatch();
            totalSteps += batchSize;
            statusEl.textContent = `Sampling... ${(totalSteps / 1e6).toFixed(0)}M steps`;
            await new Promise(r => setTimeout(r, 1));
        }

        currentPath = getPathFromWasm();
        statusEl.textContent = `Sampled in ${(totalSteps / 1e6).toFixed(1)}M steps`;
        isRunning = false;
        draw();
    }

    function drawLimitShape(baseX, baseY, gridW, gridH) {
        const aa = M / N;
        const gamma = -N * Math.log(q);

        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 3;
        ctx.setLineDash([8, 4]);

        if (Math.abs(gamma) < 1e-6) {
            ctx.beginPath();
            ctx.moveTo(baseX, baseY + gridH);
            ctx.lineTo(baseX + gridW, baseY);
            ctx.stroke();
            ctx.setLineDash([]);
            return;
        }

        const denom = 1 - Math.exp(-gamma * (1 + aa));
        const A = (1 - Math.exp(-gamma)) / denom;
        const B = (1 - Math.exp(-gamma * aa)) / denom;

        ctx.beginPath();
        ctx.moveTo(baseX, baseY + gridH);

        const steps = 200;
        for (let i = 1; i < steps; i++) {
            const x_norm = i / steps;
            const exp_neg_cx = Math.exp(-gamma * x_norm);
            const inside = (1 - B * exp_neg_cx) / A;
            if (inside > 0) {
                const y_formula = -Math.log(inside) / gamma;
                const y_scaled = (aa - y_formula) / aa * M;
                ctx.lineTo(baseX + x_norm * gridW, baseY + gridH - (y_scaled / M) * gridH);
            }
        }
        ctx.lineTo(baseX + gridW, baseY);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    function draw() {
        const w = canvas.width, h = canvas.height;
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);

        const padding = 60;
        const gridW = w - 2 * padding;
        const gridH = h - 2 * padding;
        const scaleX = gridW / N;
        const scaleY = gridH / M;
        const baseX = padding;
        const baseY = padding;

        // Bounding rectangle
        ctx.strokeStyle = colors[1];
        ctx.lineWidth = 2;
        ctx.strokeRect(baseX, baseY, gridW, gridH);

        // Draw limit shape (not for extreme q)
        if (currentStep < 3) {
            drawLimitShape(baseX, baseY, gridW, gridH);
        }

        // Draw path
        if (currentPath.length > 0) {
            ctx.strokeStyle = colors[0];
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            let x = 0, y = 0;
            ctx.moveTo(baseX, baseY + gridH);
            for (const move of currentPath) {
                if (move === 'R') x++;
                else y++;
                ctx.lineTo(baseX + x * scaleX, baseY + gridH - y * scaleY);
            }
            ctx.stroke();

            // Draw highlight box if zoom is showing
            if (currentStep >= 1) {
                let hx = 0, hy = 0;
                for (let i = 0; i < highlightStart; i++) {
                    if (currentPath[i] === 'R') hx++;
                    else hy++;
                }
                const startX = hx, startY = hy;
                for (let i = highlightStart; i < highlightStart + highlightLen && i < currentPath.length; i++) {
                    if (currentPath[i] === 'R') hx++;
                    else hy++;
                }
                const endX = hx, endY = hy;

                // Redraw path segment inside box thicker
                ctx.strokeStyle = colors[0];
                ctx.lineWidth = 8;
                ctx.beginPath();
                let px = startX, py = startY;
                ctx.moveTo(baseX + px * scaleX, baseY + gridH - py * scaleY);
                for (let i = highlightStart; i < highlightStart + highlightLen && i < currentPath.length; i++) {
                    if (currentPath[i] === 'R') px++;
                    else py++;
                    ctx.lineTo(baseX + px * scaleX, baseY + gridH - py * scaleY);
                }
                ctx.stroke();

                const boxPad = 8;
                const boxX1 = baseX + startX * scaleX - boxPad;
                const boxY1 = baseY + gridH - endY * scaleY - boxPad;
                const boxX2 = baseX + endX * scaleX + boxPad;
                const boxY2 = baseY + gridH - startY * scaleY + boxPad;

                ctx.strokeStyle = colors[0];
                ctx.lineWidth = 5;
                ctx.setLineDash([]);
                ctx.strokeRect(boxX1, boxY1, boxX2 - boxX1, boxY2 - boxY1);
            }
        }

        // Draw local view if visible
        if (currentStep >= 1) {
            drawLocalView();
        }
    }

    function drawLocalView() {
        const w = localCanvas.width, h = localCanvas.height;
        localCtx.fillStyle = '#fff';
        localCtx.fillRect(0, 0, w, h);

        const padding = 60;
        const availW = w - 2 * padding;
        const availH = h - 2 * padding - 40;

        if (currentPath.length === 0) return;

        const segment = currentPath.slice(highlightStart, highlightStart + highlightLen);
        if (segment.length === 0) return;

        let segR = 0, segU = 0;
        for (const m of segment) {
            if (m === 'R') segR++;
            else segU++;
        }
        if (segR === 0) segR = 1;
        if (segU === 0) segU = 1;

        const step = Math.min(availW / segR, availH / segU);
        const gridW = segR * step;
        const gridH = segU * step;
        const baseX = padding + (availW - gridW) / 2;
        const baseY = padding + availH - (availH - gridH) / 2;

        // Grid
        localCtx.strokeStyle = '#ddd';
        localCtx.lineWidth = 1;
        for (let i = 0; i <= segR; i++) {
            localCtx.beginPath();
            localCtx.moveTo(baseX + i * step, baseY - gridH);
            localCtx.lineTo(baseX + i * step, baseY);
            localCtx.stroke();
        }
        for (let j = 0; j <= segU; j++) {
            localCtx.beginPath();
            localCtx.moveTo(baseX, baseY - j * step);
            localCtx.lineTo(baseX + gridW, baseY - j * step);
            localCtx.stroke();
        }

        // Draw path segments
        let x = 0, y = 0;
        for (const move of segment) {
            const fromPx = baseX + x * step;
            const fromPy = baseY - y * step;
            if (move === 'R') {
                localCtx.strokeStyle = '#E57200';
                localCtx.lineWidth = 10;
                localCtx.lineCap = 'round';
                localCtx.beginPath();
                localCtx.moveTo(fromPx, fromPy);
                localCtx.lineTo(fromPx + step, fromPy);
                localCtx.stroke();
                x++;
            } else {
                localCtx.strokeStyle = '#232D4B';
                localCtx.lineWidth = 10;
                localCtx.lineCap = 'round';
                localCtx.beginPath();
                localCtx.moveTo(fromPx, fromPy);
                localCtx.lineTo(fromPx, fromPy - step);
                localCtx.stroke();
                y++;
            }
        }

        // Dots at vertices
        localCtx.fillStyle = '#232D4B';
        x = 0; y = 0;
        localCtx.beginPath();
        localCtx.arc(baseX, baseY, 6, 0, Math.PI * 2);
        localCtx.fill();
        for (const move of segment) {
            if (move === 'R') x++;
            else y++;
            localCtx.beginPath();
            localCtx.arc(baseX + x * step, baseY - y * step, 6, 0, Math.PI * 2);
            localCtx.fill();
        }

        // Only show Bernoulli text for non-extreme steps
        if (currentStep < 3) {
            localCtx.fillStyle = '#666';
            localCtx.font = '18px sans-serif';
            localCtx.textAlign = 'center';
            localCtx.textBaseline = 'top';
            localCtx.fillText('Locally still IID Bernoulli!', w / 2, baseY + 15);
        }
    }

    function updateGamma() {
        const gamma = parseFloat(gammaSlider.value);
        gammaValueSpan.textContent = gamma.toFixed(1);
        q = Math.exp(-gamma / N);
        qValueSpan.textContent = q.toFixed(4);
        draw();
    }

    gammaSlider.addEventListener('input', updateGamma);
    resampleBtn.addEventListener('click', () => runCFTP());
    canvas.addEventListener('click', () => runCFTP());

    let currentStep = 0;

    function setGamma(gamma) {
        gammaSlider.value = gamma;
        gammaValueSpan.textContent = gamma.toFixed(1);
        q = Math.exp(-gamma / N);
        qValueSpan.textContent = q.toFixed(4);
    }

    function reset() {
        currentStep = 0;
        currentPath = [];
        localCanvas.style.opacity = '0';
        localTitle.style.opacity = '0';
        insightEl.style.opacity = '0';
        explanationEl.style.opacity = '0';
        insightEl.innerHTML = '<strong style="color: var(--slide-accent); font-size: 1.2em;">Universality: still Bernoulli!</strong><br>Even with q-weighting, local structure remains <strong>independent Bernoulli trials</strong>.';
        setGamma(3);
    }

    async function init() {
        const ok = await initWasm();
        if (ok) {
            await runCFTP();
        }
    }

    // Set q directly (for extreme values that don't fit slider range)
    function setQDirect(newQ) {
        q = newQ;
        qValueSpan.textContent = q.toFixed(4);
        gammaValueSpan.textContent = '∞';
    }

    // Steps: 0=initial(γ=3), 1=show zoom, 2=insight, 3=extreme q(0.7)+resample, 4=broken insight
    function waitForSlideEngine() {
        if (!window.slideEngine) {
            setTimeout(waitForSlideEngine, 50);
            return;
        }
        window.slideEngine.registerSimulation('q-local', {
            start() {},
            pause() {},
            steps: 4,
            async onStep(step) {
                currentStep = step;
                if (step === 1) {
                    localCanvas.style.opacity = '1';
                    localTitle.style.opacity = '1';
                    draw();
                } else if (step === 2) {
                    insightEl.style.opacity = '1';
                    explanationEl.style.opacity = '1';
                    draw();
                } else if (step === 3) {
                    // Extreme q < 1 - breaks universality, path hugs bottom then right
                    setQDirect(0.6);
                    highlightStart = 130;
                    insightEl.style.opacity = '0';
                    explanationEl.style.opacity = '0';
                    await runCFTP();
                } else if (step === 4) {
                    insightEl.innerHTML = '<strong style="color: #c00; font-size: 1.2em;">Universality BROKEN at extreme q!</strong><br>When q is too extreme (q = 0.6), most of the path goes either up or right, and around the corner it is a finite perturbation of the boundary.';
                    insightEl.style.opacity = '1';
                    draw();
                }
            },
            onStepBack(step) {
                currentStep = step;
                if (step === 0) {
                    localCanvas.style.opacity = '0';
                    localTitle.style.opacity = '0';
                    insightEl.style.opacity = '0';
                    setGamma(3);
                    runCFTP();
                } else if (step === 1) {
                    insightEl.style.opacity = '0';
                    explanationEl.style.opacity = '0';
                } else if (step === 2) {
                    setGamma(3);
                    highlightStart = Math.floor((N + M) / 2 - highlightLen / 2);  // Back to middle
                    insightEl.innerHTML = '<strong style="color: var(--slide-accent); font-size: 1.2em;">Universality: still Bernoulli!</strong><br>Even with q-weighting, local structure remains <strong>independent Bernoulli trials</strong>.';
                    runCFTP();
                } else if (step === 3) {
                    insightEl.style.opacity = '0';
                }
                draw();
            },
            onSlideEnter() {
                reset();
                if (!wasm) {
                    init();
                } else if (currentPath.length === 0) {
                    runCFTP();
                } else {
                    draw();
                }
            },
            onSlideLeave() {
                reset();
            }
        }, 0);
    }
    waitForSlideEngine();
})();
</script>

<!-- ==================== PART 2: The 3D Main Event ==================== -->

<section class="slide slide-center" id="part2-intro" data-title="Part 2: 3D">
    <h2 style="font-size: clamp(3rem, 5vw, 5.5rem);">Part II</h2>
    <h3 style="font-size: clamp(3rem, 5vw, 5.5rem); color: var(--slide-muted); text-transform: uppercase; letter-spacing: 0.05em;">One dimension up</h3>
</section>

<section class="slide slide-center" id="2to3d" data-title="From Paths to 3D">
    <h2 class="slide-title">From Paths to 3D</h2>
    <div style="display: flex; gap: 2vw; align-items: center; width: 95vw; height: 78vh;">
        <!-- Left pane: 3D view + description -->
        <div style="flex: 1; display: flex; flex-direction: column; align-items: center; height: 100%;">
            <div style="position: relative; width: 100%; flex: 1;">
                <canvas id="bridge-3d-canvas" style="width: 100%; height: 100%;"></canvas>
            </div>
            <div id="bridge-description" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: center; line-height: 1.6; margin-top: 2vh;">
                surface in <span id="bridge-box-size">1 × 12 × 9</span> box = 2D path in 12 × 9 rectangle
            </div>
            <div id="macmahon-text" style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: left; line-height: 1.5; margin-top: 1vh; opacity: 0; transition: opacity 0.3s;">
                <strong style="color: var(--slide-accent);">Theorem [MacMahon, c. 1900]:</strong><br>
                Number of surfaces in \(a \times b \times c\) box is \(\displaystyle\prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c}\frac{i+j+k-1}{i+j+k-2}\)
            </div>
            <div id="macmahon-example" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: left; line-height: 1.5; margin-top: 1vh; opacity: 0; transition: opacity 0.3s;">
                <div>For 9 × 12 × 9: <span style="font-family: monospace; font-size: clamp(1.4rem, 2.5vw, 2rem); font-weight: bold; color: #E57200;">1,340,992,301,315,806,672,824,460,528,012,500</span></div>
                <div style="margin-top: 1vh;">... and we <strong>pick one at random from this collection</strong></div>
            </div>
        </div>
        <!-- Right pane: snowflake -->
        <div id="bridge-right-pane" style="flex: 1; display: flex; flex-direction: column; align-items: center; height: 100%;">
            <div id="snowflake-title" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: center; margin-bottom: 1vh; opacity: 0; transition: opacity 0.3s;">
                More complex boxes:
            </div>
            <div style="position: relative; width: 100%; flex: 1;">
                <canvas id="bridge-snowflake-canvas" style="width: 100%; height: 100%;"></canvas>
            </div>
            <div id="snowflake-description" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: center; line-height: 1.6; margin-top: 2vh;">
            </div>
        </div>
    </div>
</section>

<script>
// From Paths to 3D: Asymmetric hexagon a×12×9 with WASM CFTP sampling
(async function() {
    'use strict';

    const canvas = document.getElementById('bridge-3d-canvas');
    const descEl = document.getElementById('bridge-description');
    if (!canvas) return;

    // Wait for LozengeModule to be available
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }

    // Create our own WASM instance (isolated from other slides)
    const wasm = await LozengeModule();

    // WASM interface
    const initFromTriangles = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const runCFTP = wasm.cwrap('runCFTP', 'number', []);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeString = wasm.cwrap('freeString', null, ['number']);

    // Parameters: a x B x C hexagon (a varies 1-9)
    const B = 12, C = 9;
    let currentA = 1;
    let currentDimers = [];

    // Colors (UVA scheme)
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    // Triangle geometry helpers
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) { return { x: n, y: slope * n + j * deltaC }; }

    function getRightTriangleCentroid(n, j) {
        const v1 = getVertex(n, j), v2 = getVertex(n, j - 1), v3 = getVertex(n + 1, j - 1);
        return { x: (v1.x + v2.x + v3.x) / 3, y: (v1.y + v2.y + v3.y) / 3 };
    }
    function getLeftTriangleCentroid(n, j) {
        const v1 = getVertex(n, j), v2 = getVertex(n + 1, j), v3 = getVertex(n + 1, j - 1);
        return { x: (v1.x + v2.x + v3.x) / 3, y: (v1.y + v2.y + v3.y) / 3 };
    }

    function pointInPolygon(x, y, polygon) {
        if (polygon.length < 3) return false;
        let inside = false;
        for (let i = 0, pj = polygon.length - 1; i < polygon.length; pj = i++) {
            const xi = polygon[i].x, yi = polygon[i].y;
            const xj = polygon[pj].x, yj = polygon[pj].y;
            if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    }

    // Generate triangles for a×b×c hexagon and pass to WASM
    function generateHexagonTriangles(a, b, c) {
        // Generate asymmetric hexagon boundary: sides [a, b, c, a, b, c]
        const directions = [[1, -1], [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1]];
        const sideLengths = [a, b, c, a, b, c];
        const boundary = [];
        let bn = 0, bj = 0;
        for (let dir = 0; dir < 6; dir++) {
            for (let step = 0; step < sideLengths[dir]; step++) {
                boundary.push(getVertex(bn, bj));
                bn += directions[dir][0];
                bj += directions[dir][1];
            }
        }

        // Bounding box
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const v of boundary) {
            minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
            minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
        }
        const searchMinN = Math.floor(minX) - 2;
        const searchMaxN = Math.ceil(maxX) + 2;
        const nRange = searchMaxN - searchMinN;
        const searchMinJ = Math.floor(minY / deltaC) - nRange - 5;
        const searchMaxJ = Math.ceil(maxY / deltaC) + nRange + 5;

        // Generate triangles inside hexagon
        const triangleArr = [];
        for (let n = searchMinN; n <= searchMaxN; n++) {
            for (let j = searchMinJ; j <= searchMaxJ; j++) {
                // Type 1 = right-pointing (black), Type 2 = left-pointing (white)
                const rc = getRightTriangleCentroid(n, j);
                if (pointInPolygon(rc.x, rc.y, boundary)) {
                    triangleArr.push(n, j, 1);  // n, j, type=1 (black/right)
                }
                const lc = getLeftTriangleCentroid(n, j);
                if (pointInPolygon(lc.x, lc.y, boundary)) {
                    triangleArr.push(n, j, 2);  // n, j, type=2 (white/left)
                }
            }
        }

        return triangleArr;
    }

    // Initialize WASM with hexagon and run CFTP
    function sampleHexagon(a, b, c) {
        const triangleArr = generateHexagonTriangles(a, b, c);

        // Allocate memory and copy triangle data to WASM
        const dataPtr = wasm._malloc(triangleArr.length * 4);
        for (let i = 0; i < triangleArr.length; i++) {
            wasm.setValue(dataPtr + i * 4, triangleArr[i], 'i32');
        }

        // Initialize from triangles
        const initPtr = initFromTriangles(dataPtr, triangleArr.length);
        freeString(initPtr);
        wasm._free(dataPtr);

        // Run CFTP for exact sampling
        const cftpPtr = runCFTP();
        const cftpResult = wasm.UTF8ToString(cftpPtr);
        freeString(cftpPtr);

        // Export sampled dimers
        const dimersPtr = exportDimersWasm();
        const dimersJson = wasm.UTF8ToString(dimersPtr);
        freeString(dimersPtr);

        const parsed = JSON.parse(dimersJson);
        currentDimers = parsed.dimers || [];
    }

    // ===== THREE.JS RENDERING (LAZY LOADED) =====
    let scene = null;
    let renderer = null;
    let camera = null;
    let controls = null;
    let meshGroup = null;
    let rotationLights = [];
    const frustumSize = 30;
    let aspect = 1;

    function initThreeJS() {
        if (renderer) return;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Orthographic camera for clean 2D-like projection
        aspect = canvas.clientWidth / canvas.clientHeight || 1;
        camera = new THREE.OrthographicCamera(
            -frustumSize * aspect / 2, frustumSize * aspect / 2,
            frustumSize / 2, -frustumSize / 2,
            0.1, 1000
        );

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false;
        controls.enablePan = true;
        controls.enableZoom = true;

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.35));
        const hemi = new THREE.HemisphereLight(0x6666aa, 0x222244, 0.25);
        hemi.position.set(0, 20, 0);
        scene.add(hemi);
        const directional = new THREE.DirectionalLight(0xffffff, 1.2);
        directional.position.set(15, 20, 5);
        scene.add(directional);
        const fill = new THREE.DirectionalLight(0xffffff, 0.3);
        fill.position.set(-10, 5, -5);
        scene.add(fill);

        // Extra lights for rotation mode (warm orange tints)
        rotationLights = [];
        const rotationLightConfigs = [
            { pos: [-20, 10, 20], color: 0xffaa66, intensity: 0.7 },   // Orange tint
            { pos: [-20, 10, -20], color: 0xffcc88, intensity: 0.6 }   // Warm tint
        ];
        for (const cfg of rotationLightConfigs) {
            const light = new THREE.DirectionalLight(cfg.color, cfg.intensity);
            light.position.set(cfg.pos[0], cfg.pos[1], cfg.pos[2]);
            light.visible = false;
            scene.add(light);
            rotationLights.push(light);
        }

        meshGroup = new THREE.Group();
        scene.add(meshGroup);

        // Camera for a×12×9 hexagon (ortho view)
        camera.position.set(40.2, -28.6, -17.5);
        camera.zoom = 1.432;
        camera.updateProjectionMatrix();
        controls.target.set(2.3, -7.8, 0.8);
        controls.update();

        // Listen for controls changes to render when paused
        controls.addEventListener('change', () => {
            if (!isRunning && renderer) renderer.render(scene, camera);
        });

        resize();
    }

    function disposeThreeJS() {
        if (!renderer) return;

        stopAutoRotate();
        if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
        isRunning = false;

        if (meshGroup) {
            while (meshGroup.children.length > 0) {
                const child = meshGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                meshGroup.remove(child);
            }
        }

        renderer.dispose();
        renderer = null;
        scene = null;
        camera = null;
        controls = null;
        meshGroup = null;
        rotationLights = [];
    }

    function resize() {
        if (!renderer || !camera) return;
        const w = canvas.clientWidth, h = canvas.clientHeight;
        if (w === 0 || h === 0) return;
        renderer.setSize(w, h, false);
        aspect = w / h;
        camera.left = -frustumSize * aspect / 2;
        camera.right = frustumSize * aspect / 2;
        camera.top = frustumSize / 2;
        camera.bottom = -frustumSize / 2;
        camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);

    // Vertex and height helpers
    function getVertexKeys(dimer) {
        const { bn, bj, t } = dimer;
        if (t === 0) return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
        if (t === 1) return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
        return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
    }

    function getHeightPattern(t) {
        if (t === 0) return [0, 0, 0, 0];
        if (t === 1) return [1, 0, 0, 1];
        return [1, 1, 0, 0];
    }

    function to3D(n, j, h) {
        return { x: h, y: -n - h, z: j - h };
    }

    function buildGeometry() {
        if (!meshGroup) return;

        while (meshGroup.children.length > 0) {
            const child = meshGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
            meshGroup.remove(child);
        }

        if (currentDimers.length === 0) return;

        // Build height function via BFS (2to3d slide)
        const vertexToDimers = new Map();
        for (const dimer of currentDimers) {
            for (const [n, j] of getVertexKeys(dimer)) {
                const key = `${n},${j}`;
                if (!vertexToDimers.has(key)) vertexToDimers.set(key, []);
                vertexToDimers.get(key).push(dimer);
            }
        }

        const heights = new Map();
        const firstVerts = getVertexKeys(currentDimers[0]);
        const startKey = `${firstVerts[0][0]},${firstVerts[0][1]}`;
        heights.set(startKey, 0);

        const queue = [startKey];
        const visited = new Set();

        while (queue.length > 0) {
            const currentKey = queue.shift();
            if (visited.has(currentKey)) continue;
            visited.add(currentKey);

            const currentH = heights.get(currentKey);
            const [cn, cj] = currentKey.split(',').map(Number);

            for (const dimer of vertexToDimers.get(currentKey) || []) {
                const verts = getVertexKeys(dimer);
                const pattern = getHeightPattern(dimer.t);
                const myIdx = verts.findIndex(([vn, vj]) => vn === cn && vj === cj);
                if (myIdx >= 0) {
                    for (let i = 0; i < 4; i++) {
                        const vkey = `${verts[i][0]},${verts[i][1]}`;
                        if (!heights.has(vkey)) {
                            heights.set(vkey, currentH + (pattern[i] - pattern[myIdx]));
                            queue.push(vkey);
                        }
                    }
                }
            }
        }

        const geometry = new THREE.BufferGeometry();
        const vertices = [], normals = [], vertexColors = [], indices = [];

        function addQuad(v1, v2, v3, v4, color) {
            const baseIndex = vertices.length / 3;
            vertices.push(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z, v4.x, v4.y, v4.z);
            const edge1 = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
            const edge2 = { x: v4.x - v1.x, y: v4.y - v1.y, z: v4.z - v1.z };
            const nx = edge1.y * edge2.z - edge1.z * edge2.y;
            const ny = edge1.z * edge2.x - edge1.x * edge2.z;
            const nz = edge1.x * edge2.y - edge1.y * edge2.x;
            const len = Math.sqrt(nx*nx + ny*ny + nz*nz) || 1;
            for (let i = 0; i < 4; i++) normals.push(nx/len, ny/len, nz/len);
            const clr = new THREE.Color(color);
            for (let i = 0; i < 4; i++) vertexColors.push(clr.r, clr.g, clr.b);
            indices.push(baseIndex, baseIndex+1, baseIndex+2, baseIndex, baseIndex+2, baseIndex+3);
        }

        for (const dimer of currentDimers) {
            const verts = getVertexKeys(dimer);
            const v3d = verts.map(([n, j]) => to3D(n, j, heights.get(`${n},${j}`) || 0));
            addQuad(v3d[0], v3d[1], v3d[2], v3d[3], colors[dimer.t]);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
        geometry.setIndex(indices);

        currentMaterial = new THREE.MeshStandardMaterial({
            vertexColors: true, side: THREE.DoubleSide, flatShading: true, roughness: 0.3, metalness: autoRotate ? 0.35 : 0.5,
            color: 0xddeeff  // Subtle blue tint
        });
        meshGroup.add(new THREE.Mesh(geometry, currentMaterial));

        const edgesGeometry = new THREE.EdgesGeometry(geometry, 10);
        meshGroup.add(new THREE.LineSegments(edgesGeometry, new THREE.LineBasicMaterial({ color: 0x222222, opacity: 0.6, transparent: true })));
    }

    let isRunning = false;
    let animationId = null;
    let autoRotate = false;
    const rotateSpeed = 0.012; // radians per frame
    let currentMaterial = null; // Reference to mesh material

    function regenerate() {
        sampleHexagon(currentA, B, C);
        buildGeometry();
        // Update description
        if (currentA === 1) {
            descEl.innerHTML = `surface in <span id="bridge-box-size">1 × 12 × 9</span> box = 2D path in 12 × 9 rectangle`;
        } else {
            descEl.innerHTML = `uniformly random surface in <span id="bridge-box-size">${currentA} × 12 × 9</span> box`;
        }
        if (renderer) renderer.render(scene, camera);
    }

    function animate() {
        if (!isRunning || !renderer || !camera || !controls) return;

        if (autoRotate) {
            // Rotate camera around its up vector (visual vertical)
            const axis = camera.up.clone().normalize();
            const offset = camera.position.clone().sub(controls.target);
            offset.applyAxisAngle(axis, rotateSpeed);
            camera.position.copy(controls.target).add(offset);
            camera.lookAt(controls.target);
        }

        controls.update();
        renderer.render(scene, camera);
        animationId = requestAnimationFrame(animate);
    }

    function start() {
        if (isRunning) return;
        isRunning = true;
        animate();
    }

    function pause() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    function startAutoRotate() {
        autoRotate = true;
        // Turn on extra lights
        for (const light of rotationLights) if (light) light.visible = true;
        // Keep some metalness for vivid look
        if (currentMaterial) currentMaterial.metalness = 0.35;
        if (!isRunning) start();
    }

    function stopAutoRotate() {
        autoRotate = false;
        // Turn off extra lights
        for (const light of rotationLights) if (light) light.visible = false;
        // Restore metallic material
        if (currentMaterial) currentMaterial.metalness = 0.5;
    }

    function setLayerCount(a) {
        currentA = Math.max(1, Math.min(9, a));
        regenerate();
    }

    // Register with slide engine
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('2to3d', {
                start,
                pause,
                steps: 12,
                onSlideEnter() {
                    // Lazy init WebGL to avoid context limit
                    initThreeJS();

                    // Reset camera to default position
                    if (camera && controls) {
                        camera.position.set(40.2, -28.6, -17.5);
                        camera.zoom = 1.432;
                        camera.updateProjectionMatrix();
                        controls.target.set(2.3, -7.8, 0.8);
                        controls.update();
                    }
                    stopAutoRotate();

                    setTimeout(() => {
                        resize();
                        regenerate();
                        if (renderer) renderer.render(scene, camera);
                        if (window.bridgeSnowflake) {
                            window.bridgeSnowflake.resize();
                            window.bridgeSnowflake.render();
                        }
                    }, 50);
                    start();
                },
                onSlideLeave() {
                    stopAutoRotate();
                    pause();
                    // Dispose WebGL context to free resources
                    disposeThreeJS();
                },
                onStep(step) {
                    const macmahonEl = document.getElementById('macmahon-text');
                    const macmahonExEl = document.getElementById('macmahon-example');
                    if (step <= 8) {
                        stopAutoRotate();
                        setLayerCount(step + 1);
                        if (macmahonEl) macmahonEl.style.opacity = '0';
                        if (macmahonExEl) macmahonExEl.style.opacity = '0';
                    } else if (step === 9) {
                        // Start rotating the 9×12×9 hexagon
                        startAutoRotate();
                    } else if (step === 10) {
                        // Show MacMahon formula (keep rotating)
                        if (macmahonEl) macmahonEl.style.opacity = '1';
                        if (macmahonExEl) macmahonExEl.style.opacity = '1';
                        if (window.MathJax) MathJax.typeset();
                    } else if (step === 11 && window.bridgeSnowflake) {
                        // Stop hexagon rotation, show snowflake region (unsampled)
                        stopAutoRotate();
                        document.getElementById('snowflake-title').style.opacity = '1';
                        window.bridgeSnowflake.showRegion();
                    } else if (step === 12 && window.bridgeSnowflake) {
                        // CFTP sample the snowflake
                        const descEl = document.getElementById('snowflake-description');
                        if (descEl) descEl.textContent = 'picking one uniformly at random...';
                        setTimeout(() => {
                            window.bridgeSnowflake.regenerate();
                            if (descEl) descEl.textContent = 'picking one uniformly at random... done';
                        }, 50);
                    }
                },
                onStepBack(step) {
                    const macmahonEl = document.getElementById('macmahon-text');
                    const macmahonExEl = document.getElementById('macmahon-example');
                    const snowflakeTitleEl = document.getElementById('snowflake-title');
                    const snowflakeDescEl = document.getElementById('snowflake-description');
                    if (step <= 8) {
                        stopAutoRotate();
                        setLayerCount(step + 1);
                        if (macmahonEl) macmahonEl.style.opacity = '0';
                        if (macmahonExEl) macmahonExEl.style.opacity = '0';
                        if (snowflakeTitleEl) snowflakeTitleEl.style.opacity = '0';
                        if (snowflakeDescEl) snowflakeDescEl.textContent = '';
                        if (window.bridgeSnowflake) window.bridgeSnowflake.clear();
                    } else if (step === 9) {
                        startAutoRotate();
                        if (macmahonEl) macmahonEl.style.opacity = '0';
                        if (macmahonExEl) macmahonExEl.style.opacity = '0';
                        if (snowflakeTitleEl) snowflakeTitleEl.style.opacity = '0';
                        if (snowflakeDescEl) snowflakeDescEl.textContent = '';
                        if (window.bridgeSnowflake) window.bridgeSnowflake.clear();
                    } else if (step === 10) {
                        if (macmahonEl) macmahonEl.style.opacity = '1';
                        if (macmahonExEl) macmahonExEl.style.opacity = '1';
                        if (snowflakeTitleEl) snowflakeTitleEl.style.opacity = '0';
                        if (snowflakeDescEl) snowflakeDescEl.textContent = '';
                        if (window.bridgeSnowflake) window.bridgeSnowflake.clear();
                    } else if (step === 11 && window.bridgeSnowflake) {
                        if (snowflakeTitleEl) snowflakeTitleEl.style.opacity = '1';
                        if (snowflakeDescEl) snowflakeDescEl.textContent = '';
                        window.bridgeSnowflake.showRegion();
                    }
                }
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();

// Snowflake visualization (right pane) - 2D Canvas
(async function() {
    'use strict';

    const canvas = document.getElementById('bridge-snowflake-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    // Wait for LozengeModule
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }

    // Create separate WASM instance for snowflake
    const wasm = await LozengeModule();
    const initFromTriangles = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const runCFTP = wasm.cwrap('runCFTP', 'number', []);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeString = wasm.cwrap('freeString', null, ['number']);

    // Load snowflake triangles
    let snowflakeTriangles = null;
    try {
        const resp = await fetch('/letters/big_snoflake.json');
        const data = await resp.json();
        snowflakeTriangles = data.triangles;
    } catch (e) {
        return;
    }

    let currentDimers = [];
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    // Triangular lattice helpers
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);
    function getVertex(n, j) { return { x: n, y: slope * n + j * deltaC }; }

    // Get lozenge vertices
    function getLozengeVerts(dimer) {
        const { bn, bj, t } = dimer;
        if (t === 0) {
            return [getVertex(bn, bj), getVertex(bn+1, bj), getVertex(bn+1, bj-1), getVertex(bn, bj-1)];
        } else if (t === 1) {
            return [getVertex(bn, bj), getVertex(bn+1, bj-1), getVertex(bn+1, bj-2), getVertex(bn, bj-1)];
        } else {
            return [getVertex(bn-1, bj), getVertex(bn, bj), getVertex(bn+1, bj-1), getVertex(bn, bj-1)];
        }
    }

    // Convert world coords to canvas coords
    function toCanvas(x, y, centerX, centerY, scale) {
        return [centerX + x * scale, centerY - y * scale];
    }

    // Compute bounding box
    function computeBounds() {
        if (currentDimers.length === 0) return { minX: -50, maxX: 50, minY: -50, maxY: 50 };
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const d of currentDimers) {
            const verts = getLozengeVerts(d);
            for (const v of verts) {
                if (v.x < minX) minX = v.x;
                if (v.x > maxX) maxX = v.x;
                if (v.y < minY) minY = v.y;
                if (v.y > maxY) maxY = v.y;
            }
        }
        return { minX, maxX, minY, maxY };
    }

    function resize() {
        const w = canvas.clientWidth, h = canvas.clientHeight;
        if (w === 0 || h === 0) return;
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resize();
    window.addEventListener('resize', () => { resize(); draw(); });

    function draw() {
        const w = canvas.clientWidth, h = canvas.clientHeight;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, w, h);

        if (currentDimers.length === 0) return;

        const bounds = computeBounds();
        const worldW = bounds.maxX - bounds.minX;
        const worldH = bounds.maxY - bounds.minY;
        const padding = 0.1;
        const scale = Math.min(w / (worldW * (1 + padding)), h / (worldH * (1 + padding)));
        const centerX = w / 2 - (bounds.minX + bounds.maxX) / 2 * scale;
        const centerY = h / 2 + (bounds.minY + bounds.maxY) / 2 * scale;

        // Draw lozenges
        for (const d of currentDimers) {
            const verts = getLozengeVerts(d);
            const canvasVerts = verts.map(v => toCanvas(v.x, v.y, centerX, centerY, scale));

            ctx.fillStyle = colors[d.t];
            ctx.beginPath();
            ctx.moveTo(canvasVerts[0][0], canvasVerts[0][1]);
            for (let i = 1; i < canvasVerts.length; i++) {
                ctx.lineTo(canvasVerts[i][0], canvasVerts[i][1]);
            }
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#222222';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }

    // Initialize region and get Dinic's minimal tiling (no CFTP)
    function getMinimalTiling() {
        if (!snowflakeTriangles) {
            currentDimers = [];
            return;
        }

        const triArr = [];
        for (const tri of snowflakeTriangles) {
            triArr.push(tri.n, tri.j, tri.type);
        }

        const ptr = wasm._malloc(triArr.length * 4);
        for (let i = 0; i < triArr.length; i++) {
            wasm.setValue(ptr + i * 4, triArr[i], 'i32');
        }

        initFromTriangles(ptr, triArr.length);
        wasm._free(ptr);

        const strPtr = exportDimersWasm();
        const jsonStr = wasm.UTF8ToString(strPtr);
        freeString(strPtr);

        try {
            const parsed = JSON.parse(jsonStr);
            currentDimers = Array.isArray(parsed.dimers) ? parsed.dimers : [];
        } catch (e) {
            currentDimers = [];
        }
    }

    function sampleSnowflake() {
        if (!snowflakeTriangles) {
            currentDimers = [];
            return;
        }

        runCFTP();

        const strPtr = exportDimersWasm();
        const jsonStr = wasm.UTF8ToString(strPtr);
        freeString(strPtr);

        try {
            const parsed = JSON.parse(jsonStr);
            currentDimers = Array.isArray(parsed.dimers) ? parsed.dimers : [];
        } catch (e) {
            currentDimers = [];
        }
    }

    let hasSampled = false;

    function showRegion() {
        getMinimalTiling();
        draw();
    }

    function regenerate() {
        sampleSnowflake();
        draw();
        hasSampled = true;
    }

    function clear() {
        currentDimers = [];
        hasSampled = false;
        const w = canvas.clientWidth, h = canvas.clientHeight;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, w, h);
    }

    // Expose for step control
    window.bridgeSnowflake = {
        showRegion,
        regenerate,
        resize,
        clear,
        render: draw,
        hasSampled: () => hasSampled
    };
})();
</script>

<section class="slide slide-center" id="limit-shape" data-title="Limit Shape in 3D">
    <h2 class="slide-title">Limit Shape in 3D</h2>
    <div style="position: relative; width: 85vw; height: 52vh;">
        <canvas id="limit-shape-3d-canvas" style="width: 100%; height: 100%;"></canvas>
        <div id="limit-shape-presampled-label" style="position: absolute; top: 1vh; right: 1vw; background: rgba(229, 114, 0, 0.9); color: white; padding: 0.5vh 1vw; border-radius: 4px; font-size: clamp(0.9rem, 1.5vw, 1.2rem); font-weight: bold; opacity: 0; transition: opacity 0.5s;">pre-sampled</div>
    </div>
    <div id="limit-shape-3d-status" style="font-size: clamp(0.9rem, 1.5vw, 1.2rem); margin-top: 0.5vh;"></div>
    <div id="limit-shape-panels" style="opacity: 0; transition: opacity 0.5s; margin-top: 1vh; width: 85vw; display: grid; grid-template-columns: 1fr 1fr; gap: 2vw; text-align: left;">
        <div>
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">
                <strong style="color: var(--slide-accent);">Theorem [Cohn–Kenyon–Propp 2000]:</strong><br>
                As the mesh size → 0, the random stepped surface concentrates around a <strong>deterministic limit shape</strong>.
            </div>
            <div id="limit-shape-curved-text" style="margin-top: 1vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem); opacity: 0; transition: opacity 0.5s;">
                In examples we saw, the limit shape is "curved", like for q<sup>area</sup> examples from 2D.
            </div>
            <div id="limit-shape-right-panel" style="margin-top: 1.5vh; font-size: clamp(1.5rem, 2.8vw, 2.2rem); color: var(--slide-accent); opacity: 0; transition: opacity 0.5s;">
                What is the variational description?
                <div id="limit-shape-subtext" style="margin-top: 1vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem); color: #000; opacity: 0; transition: opacity 0.5s;">
                    We need to understand examples with flat (sloped) limit shape.
                </div>
            </div>
        </div>
        <div id="limit-shape-image-panel" style="display: flex; flex-direction: column; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.5s;">
            <div style="display: flex; gap: 1vw; align-items: center; justify-content: center;">
                <div style="position: relative;">
                    <img src="images/frozen_sample.png" alt="Frozen sample" style="max-height: 28vh; max-width: 100%; object-fit: contain;">
                    <div style="position: absolute; top: 0.5vh; right: 0.5vw; background: rgba(229, 114, 0, 0.9); color: white; padding: 0.3vh 0.6vw; border-radius: 3px; font-size: clamp(0.7rem, 1.2vw, 1rem); font-weight: bold;">pre-sampled</div>
                </div>
                <div style="position: relative;">
                    <img src="images/hexagon.png" alt="Hexagon" style="max-height: 28vh; max-width: 100%; object-fit: contain;">
                    <div style="position: absolute; top: 0.5vh; right: 0.5vw; background: rgba(229, 114, 0, 0.9); color: white; padding: 0.3vh 0.6vw; border-radius: 3px; font-size: clamp(0.7rem, 1.2vw, 1rem); font-weight: bold;">pre-sampled</div>
                </div>
            </div>
            <div style="margin-top: 1vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem); color: #333; text-align: left;">
                Part of final answer: Phases are separated by an inscribed <strong>algebraic curve</strong> (<strong>ellipse</strong> for the hexagon)
                                <strong style="color: var(--slide-accent);">[Kenyon-Okounkov 2007]</strong>
            </div>
        </div>
    </div>
</section>

<script>
// Limit Shape 3D Visualization
(async function() {
    'use strict';

    const canvas = document.getElementById('limit-shape-3d-canvas');
    const statusEl = document.getElementById('limit-shape-3d-status');
    const panelsEl = document.getElementById('limit-shape-panels');
    const rightPanelEl = document.getElementById('limit-shape-right-panel');
    const curvedTextEl = document.getElementById('limit-shape-curved-text');
    const subtextEl = document.getElementById('limit-shape-subtext');
    const imagePanelEl = document.getElementById('limit-shape-image-panel');
    const presampledLabel = document.getElementById('limit-shape-presampled-label');
    if (!canvas) return;

    // Wait for LozengeModule
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }

    // Create separate WASM instance
    const wasm = await LozengeModule();
    const initFromTriangles = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const runCFTPWasm = wasm.cwrap('runCFTP', 'number', []);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeString = wasm.cwrap('freeString', null, ['number']);
    // GPU CFTP wrappers
    const initCFTPWasm = wasm.cwrap('initCFTP', 'number', []);
    const getGridBoundsWasm = wasm.cwrap('getGridBounds', 'number', []);
    const getCFTPMinGridDataWasm = wasm.cwrap('getCFTPMinGridData', 'number', []);
    const getCFTPMaxGridDataWasm = wasm.cwrap('getCFTPMaxGridData', 'number', []);

    // WebGPU engine
    let gpuEngine = null;
    let gpuAvailable = false;

    // Initialize WebGPU engine
    async function initGPU() {
        if (gpuEngine) return gpuAvailable;
        if (typeof WebGPULozengeEngine === 'undefined') {
            console.log('WebGPULozengeEngine not available');
            return false;
        }
        try {
            gpuEngine = new WebGPULozengeEngine();
            await gpuEngine.init();
            gpuAvailable = true;
            console.log('WebGPU Lozenge Engine initialized for limit-shape');
            return true;
        } catch (e) {
            console.log('WebGPU not available:', e.message);
            gpuAvailable = false;
            return false;
        }
    }

    // Helper to get grid data from WASM
    function getGridBounds() {
        const ptr = getGridBoundsWasm();
        const jsonStr = wasm.UTF8ToString(ptr);
        freeString(ptr);
        return JSON.parse(jsonStr);
    }

    function getCFTPMinRawGridData(bounds) {
        const dataPtr = getCFTPMinGridDataWasm();
        if (!dataPtr) return null;
        const data = new Int32Array(bounds.size);
        for (let i = 0; i < bounds.size; i++) {
            data[i] = wasm.getValue(dataPtr + i * 4, 'i32');
        }
        wasm._free(dataPtr);
        return data;
    }

    function getCFTPMaxRawGridData(bounds) {
        const dataPtr = getCFTPMaxGridDataWasm();
        if (!dataPtr) return null;
        const data = new Int32Array(bounds.size);
        for (let i = 0; i < bounds.size; i++) {
            data[i] = wasm.getValue(dataPtr + i * 4, 'i32');
        }
        wasm._free(dataPtr);
        return data;
    }

    // Load shape triangles
    let shapeTriangles = null;
    try {
        const resp = await fetch('/letters/shape_for_arctic_small.json');
        const data = await resp.json();
        shapeTriangles = data.triangles;
    } catch (e) {
        return;
    }

    let currentDimers = [];
    const colors = ['#FFFFFF', '#FFFFFF', '#FFFFFF'];  // White lozenges like slide 2

    // Three.js setup - LAZY LOADED to avoid WebGL context limit
    let renderer = null;
    let scene = null;
    let camera = null;
    let controls = null;
    let meshGroup = null;
    let rotationLights = [];
    const frustumSize = 52;
    let aspect = 1;

    function initThreeJS() {
        if (renderer) return; // Already initialized

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);  // Dark background like slide 2
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        aspect = canvas.clientWidth / canvas.clientHeight || 1;
        camera = new THREE.OrthographicCamera(
            -frustumSize * aspect / 2, frustumSize * aspect / 2,
            frustumSize / 2, -frustumSize / 2,
            -5000, 6000  // Wider near/far for large OBJ during rotation
        );

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false;
        controls.enablePan = true;
        controls.enableZoom = true;

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.35));
        const hemi = new THREE.HemisphereLight(0x6666aa, 0x222244, 0.25);
        hemi.position.set(0, 20, 0);
        scene.add(hemi);
        const directional = new THREE.DirectionalLight(0xffffff, 1.2);
        directional.position.set(15, 20, 5);
        scene.add(directional);
        const fill = new THREE.DirectionalLight(0xffffff, 0.3);
        fill.position.set(-10, 5, -5);
        scene.add(fill);

        // Extra lights for rotation (warm orange tints)
        rotationLights = [];
        const rotationLightConfigs = [
            { pos: [-30, 10, 30], color: 0xffaa66, intensity: 0.7 },   // Orange tint
            { pos: [-30, 10, -30], color: 0xffcc88, intensity: 0.6 }   // Warm tint
        ];
        for (const cfg of rotationLightConfigs) {
            const light = new THREE.DirectionalLight(cfg.color, cfg.intensity);
            light.position.set(cfg.pos[0], cfg.pos[1], cfg.pos[2]);
            light.visible = false;
            scene.add(light);
            rotationLights.push(light);
        }

        meshGroup = new THREE.Group();
        scene.add(meshGroup);

        // Initial camera position
        camera.position.set(10.2, -110.4, -10.8);
        camera.zoom = 1.0;
        camera.updateProjectionMatrix();
        controls.target.set(-13.4, -89.2, 12.4);
        controls.update();

        resize();
    }

    function disposeThreeJS() {
        if (!renderer) return;

        stopAutoRotate();

        // Dispose meshes
        if (meshGroup) {
            while (meshGroup.children.length > 0) {
                const child = meshGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                meshGroup.remove(child);
            }
        }

        // Dispose renderer (releases WebGL context)
        renderer.dispose();
        renderer = null;
        scene = null;
        camera = null;
        controls = null;
        meshGroup = null;
        rotationLights = [];
    }

    function resize() {
        if (!renderer || !camera) return;
        const w = canvas.clientWidth, h = canvas.clientHeight;
        if (w === 0 || h === 0) return;
        renderer.setSize(w, h, false);
        aspect = w / h;
        camera.left = -frustumSize * aspect / 2;
        camera.right = frustumSize * aspect / 2;
        camera.top = frustumSize / 2;
        camera.bottom = -frustumSize / 2;
        camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);

    // Vertex and height helpers (limit-shape)
    function getVertexKeys(dimer) {
        const { bn, bj, t } = dimer;
        if (t === 0) return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
        if (t === 1) return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
        return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
    }

    function getHeightPattern(t) {
        if (t === 0) return [0, 0, 0, 0];
        if (t === 1) return [1, 0, 0, 1];
        return [1, 1, 0, 0];
    }

    function to3D(n, j, h) {
        return { x: h, y: -n - h, z: j - h };
    }

    function buildGeometry() {
        if (!meshGroup) return;
        // Don't rebuild if OBJ is showing
        if (objLoaded) {
            console.log('buildGeometry skipped - OBJ loaded');
            return;
        }
        while (meshGroup.children.length > 0) {
            const child = meshGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
            meshGroup.remove(child);
        }

        if (currentDimers.length === 0) return;

        // Build vertex-to-dimer map and calculate heights via BFS
        const vertexToDimers = new Map();
        for (const dimer of currentDimers) {
            for (const [n, j] of getVertexKeys(dimer)) {
                const key = `${n},${j}`;
                if (!vertexToDimers.has(key)) vertexToDimers.set(key, []);
                vertexToDimers.get(key).push(dimer);
            }
        }

        const heights = new Map();
        const firstVerts = getVertexKeys(currentDimers[0]);
        const startKey = `${firstVerts[0][0]},${firstVerts[0][1]}`;
        heights.set(startKey, 0);

        const queue = [startKey];
        const visited = new Set();

        while (queue.length > 0) {
            const currentKey = queue.shift();
            if (visited.has(currentKey)) continue;
            visited.add(currentKey);

            const currentH = heights.get(currentKey);
            const [cn, cj] = currentKey.split(',').map(Number);

            for (const dimer of vertexToDimers.get(currentKey) || []) {
                const verts = getVertexKeys(dimer);
                const pattern = getHeightPattern(dimer.t);
                const myIdx = verts.findIndex(([vn, vj]) => vn === cn && vj === cj);
                if (myIdx >= 0) {
                    for (let i = 0; i < 4; i++) {
                        const vkey = `${verts[i][0]},${verts[i][1]}`;
                        if (!heights.has(vkey)) {
                            heights.set(vkey, currentH + (pattern[i] - pattern[myIdx]));
                            queue.push(vkey);
                        }
                    }
                }
            }
        }

        const geometry = new THREE.BufferGeometry();
        const vertices = [], normals = [], vertexColors = [], indices = [];

        function addQuad(v1, v2, v3, v4, color) {
            const baseIndex = vertices.length / 3;
            vertices.push(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z, v4.x, v4.y, v4.z);
            const edge1 = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
            const edge2 = { x: v4.x - v1.x, y: v4.y - v1.y, z: v4.z - v1.z };
            const nx = edge1.y * edge2.z - edge1.z * edge2.y;
            const ny = edge1.z * edge2.x - edge1.x * edge2.z;
            const nz = edge1.x * edge2.y - edge1.y * edge2.x;
            const len = Math.sqrt(nx*nx + ny*ny + nz*nz) || 1;
            for (let i = 0; i < 4; i++) normals.push(nx/len, ny/len, nz/len);
            const clr = new THREE.Color(color);
            for (let i = 0; i < 4; i++) vertexColors.push(clr.r, clr.g, clr.b);
            indices.push(baseIndex, baseIndex+1, baseIndex+2, baseIndex, baseIndex+2, baseIndex+3);
        }

        for (const dimer of currentDimers) {
            const verts = getVertexKeys(dimer);
            const v3d = verts.map(([n, j]) => to3D(n, j, heights.get(`${n},${j}`) || 0));
            addQuad(v3d[0], v3d[1], v3d[2], v3d[3], colors[dimer.t]);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
        geometry.setIndex(indices);

        currentMaterial = new THREE.MeshStandardMaterial({
            vertexColors: true, side: THREE.DoubleSide, flatShading: true, roughness: 0.3, metalness: autoRotate ? 0.35 : 0.5,
            color: 0xddeeff  // Subtle blue tint
        });
        meshGroup.add(new THREE.Mesh(geometry, currentMaterial));

        const edgesGeometry = new THREE.EdgesGeometry(geometry, 10);
        meshGroup.add(new THREE.LineSegments(edgesGeometry, new THREE.LineBasicMaterial({ color: 0x222222, opacity: 0.4, transparent: true })));

        // Center camera on geometry
        if (controls) {
            const box = new THREE.Box3().setFromObject(meshGroup);
            const center = new THREE.Vector3();
            box.getCenter(center);
            controls.target.copy(center);
            controls.update();
        }
    }

    // Sampling functions
    function getMinimalTiling() {
        if (!shapeTriangles) { currentDimers = []; return; }

        const triArr = [];
        for (const tri of shapeTriangles) {
            triArr.push(tri.n, tri.j, tri.type);
        }

        const ptr = wasm._malloc(triArr.length * 4);
        for (let i = 0; i < triArr.length; i++) {
            wasm.setValue(ptr + i * 4, triArr[i], 'i32');
        }

        initFromTriangles(ptr, triArr.length);
        wasm._free(ptr);

        const strPtr = exportDimersWasm();
        const jsonStr = wasm.UTF8ToString(strPtr);
        freeString(strPtr);

        try {
            const parsed = JSON.parse(jsonStr);
            currentDimers = Array.isArray(parsed.dimers) ? parsed.dimers : [];
        } catch (e) {
            currentDimers = [];
        }
    }

    // Get black triangles from shape (type=1 triangles)
    function getBlackTriangles() {
        if (!shapeTriangles) return [];
        return shapeTriangles.filter(t => t.type === 1).map(t => ({ n: t.n, j: t.j }));
    }

    // GPU CFTP sampling with WASM fallback
    async function sampleCFTP() {
        if (!shapeTriangles) { currentDimers = []; return; }
        // Don't run CFTP if OBJ is showing
        if (objLoaded) {
            console.log('sampleCFTP skipped - OBJ loaded');
            return;
        }

        // Try GPU CFTP first
        const useGPU = await initGPU();
        if (useGPU && gpuEngine) {
            try {
                // Initialize CFTP on WASM side to create extremal states
                initCFTPWasm();
                const bounds = getGridBounds();

                // Get extremal states for GPU
                const minGridData = getCFTPMinRawGridData(bounds);
                const maxGridData = getCFTPMaxRawGridData(bounds);

                if (minGridData && maxGridData) {
                    // Initialize GPU engine with grid parameters
                    gpuEngine.initFromWasmData(minGridData, bounds.minN, bounds.maxN, bounds.minJ, bounds.maxJ);

                    // Initialize GPU CFTP
                    const gpuCftpOk = await gpuEngine.initCFTP(minGridData, maxGridData);
                    if (gpuCftpOk) {
                        // GPU CFTP epoch-doubling loop
                        let T = 1;
                        const maxT = 134217728; // 2^27 safety limit
                        let coalesced = false;

                        while (!coalesced && T <= maxT) {
                            gpuEngine.resetCFTPChains(minGridData, maxGridData);
                            const result = await gpuEngine.stepCFTP(T, Math.min(T, 10000));
                            coalesced = result.coalesced;
                            if (!coalesced) {
                                coalesced = await gpuEngine.checkCoalescence();
                            }
                            if (!coalesced) T *= 2;
                        }

                        if (coalesced) {
                            // Get result from GPU and convert to dimers directly
                            const resultGrid = await gpuEngine.getCFTPResult();
                            const blackTriangles = getBlackTriangles();
                            currentDimers = gpuEngine.gridToDimers(resultGrid, blackTriangles);
                            gpuEngine.destroyCFTP();
                            console.log('GPU CFTP completed, T=' + T + ', dimers=' + currentDimers.length);
                            return;
                        }
                        gpuEngine.destroyCFTP();
                    }
                }
            } catch (e) {
                console.log('GPU CFTP failed, falling back to WASM:', e.message);
            }
        }

        // Fallback to WASM CFTP
        console.log('Using WASM CFTP');
        runCFTPWasm();

        const strPtr = exportDimersWasm();
        const jsonStr = wasm.UTF8ToString(strPtr);
        freeString(strPtr);

        try {
            const parsed = JSON.parse(jsonStr);
            currentDimers = Array.isArray(parsed.dimers) ? parsed.dimers : [];
        } catch (e) {
            currentDimers = [];
        }
    }

    // OBJ Loader for pre-sampled mesh
    let objMesh = null;
    let objLoaded = false;

    async function loadPresampledOBJ() {
        if (objLoaded || !meshGroup) return;

        // Load OBJLoader dynamically if not available
        if (typeof THREE.OBJLoader === 'undefined') {
            // Use older Three.js version that has non-module OBJLoader
            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js';
                script.onload = resolve;
                script.onerror = () => {
                    console.warn('OBJLoader failed to load from CDN');
                    resolve(); // Don't reject, just continue without
                };
                document.head.appendChild(script);
            });
        }

        if (typeof THREE.OBJLoader === 'undefined') {
            console.error('OBJLoader not available');
            return;
        }

        const loader = new THREE.OBJLoader();
        try {
            const obj = await new Promise((resolve, reject) => {
                loader.load('images/big_shape.obj', resolve, undefined, reject);
            });

            // Clear existing geometry
            while (meshGroup.children.length > 0) {
                const child = meshGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                meshGroup.remove(child);
            }

            // Apply same material style as sampled mesh (no vertexColors for OBJ)
            const objMaterial = new THREE.MeshStandardMaterial({
                side: THREE.DoubleSide,
                flatShading: true,
                roughness: 0.3,
                metalness: autoRotate ? 0.35 : 0.5,
                color: 0xddeeff  // Same subtle blue tint
            });

            obj.traverse((child) => {
                if (child.isMesh) {
                    child.material = objMaterial;
                    meshGroup.add(child.clone());
                }
            });
            currentMaterial = objMaterial;

            // OBJ is 8x larger - zoom out to fit
            if (camera) {
                camera.zoom = 0.01;
                camera.updateProjectionMatrix();
            }

            objMesh = obj;
            objLoaded = true;
            if (renderer && scene && camera) renderer.render(scene, camera);
        } catch (e) {
            console.error('Failed to load OBJ:', e);
        }
    }

    let isRunning = false;
    let animationId = null;
    let autoRotate = false;
    const rotateSpeed = 0.008;
    let currentMaterial = null;
    let hasSampled = false;

    function animate() {
        if (!isRunning || !renderer || !camera || !controls) return;

        if (autoRotate) {
            // Rotate around (1,1,1) direction for natural 3D view
            const axis = new THREE.Vector3(1, 1, 1).normalize();
            const offset = camera.position.clone().sub(controls.target);
            offset.applyAxisAngle(axis, rotateSpeed);
            camera.position.copy(controls.target).add(offset);
            camera.lookAt(controls.target);
        }

        controls.update();
        renderer.render(scene, camera);
        animationId = requestAnimationFrame(animate);
    }

    function start() {
        if (isRunning) return;
        isRunning = true;
        animate();
    }

    function pause() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    function startAutoRotate() {
        autoRotate = true;
        for (const light of rotationLights) if (light) light.visible = true;
        if (currentMaterial) currentMaterial.metalness = 0.35;  // Keep some metalness for vivid look
        if (!isRunning) start();
    }

    function stopAutoRotate() {
        autoRotate = false;
        for (const light of rotationLights) if (light) light.visible = false;
        if (currentMaterial) currentMaterial.metalness = 0.5;
    }

    function clear() {
        if (meshGroup) {
            while (meshGroup.children.length > 0) {
                const child = meshGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                meshGroup.remove(child);
            }
        }
        currentDimers = [];
        hasSampled = false;
        if (statusEl) statusEl.textContent = '';
        if (renderer) renderer.render(scene, camera);
    }

    // Register with slide engine
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('limit-shape', {
                start,
                pause,
                steps: 7,
                onSlideEnter() {
                    // Lazy init WebGL to avoid context limit
                    initThreeJS();
                    if (camera && controls) {
                        camera.position.set(22.6, -118.1, 11.9);
                        camera.zoom = 1.0;
                        camera.updateProjectionMatrix();
                        controls.target.set(0.0, -48.0, 32.0);
                        controls.update();
                        // Listen for controls changes
                        controls.addEventListener('change', () => {
                            if (!isRunning && renderer) renderer.render(scene, camera);
                        });
                    }
                    stopAutoRotate();
                    hasSampled = false;
                    objLoaded = false;
                    if (presampledLabel) presampledLabel.style.opacity = '0';
                    // Show minimal tiling (shape outline) on load
                    setTimeout(() => {
                        resize();
                        getMinimalTiling();
                        buildGeometry();
                        if (renderer) renderer.render(scene, camera);
                    }, 50);
                    start();
                },
                onSlideLeave() {
                    stopAutoRotate();
                    pause();
                    // Dispose WebGL context to free resources
                    disposeThreeJS();
                    currentDimers = [];
                    hasSampled = false;
                    objLoaded = false;
                    if (statusEl) statusEl.textContent = '';
                    if (panelsEl) panelsEl.style.opacity = '0';
                    if (curvedTextEl) curvedTextEl.style.opacity = '0';
                    if (rightPanelEl) rightPanelEl.style.opacity = '0';
                    if (subtextEl) subtextEl.style.opacity = '0';
                    if (presampledLabel) presampledLabel.style.opacity = '0';
                },
                async onStep(step) {
                    if (step === 1) {
                        // Run CFTP to get random sample (async for GPU)
                        if (statusEl) statusEl.textContent = 'picking one uniformly at random...';
                        await new Promise(r => setTimeout(r, 50));
                        await sampleCFTP();
                        buildGeometry();
                        if (statusEl) statusEl.textContent = '';
                        hasSampled = true;
                        if (renderer) renderer.render(scene, camera);
                    } else if (step === 2) {
                        // Start auto-rotation
                        startAutoRotate();
                    } else if (step === 3) {
                        // Load pre-sampled OBJ and show label
                        if (statusEl) statusEl.textContent = 'loading pre-sampled...';
                        await loadPresampledOBJ();
                        if (statusEl) statusEl.textContent = '';
                        if (presampledLabel) presampledLabel.style.opacity = '1';
                    } else if (step === 4) {
                        // Show theorem panel
                        if (panelsEl) panelsEl.style.opacity = '1';
                    } else if (step === 5) {
                        // Show curved text
                        if (curvedTextEl) curvedTextEl.style.opacity = '1';
                    } else if (step === 6) {
                        // Show question in right panel with subtext
                        if (rightPanelEl) rightPanelEl.style.opacity = '1';
                        if (subtextEl) subtextEl.style.opacity = '1';
                    } else if (step === 7) {
                        // Show frozen sample image
                        if (imagePanelEl) imagePanelEl.style.opacity = '1';
                    }
                },
                onStepBack(step) {
                    // Only restore zoom and hide label when going back TO steps before OBJ (0, 1, 2)
                    if (step <= 2) {
                        if (camera && camera.zoom !== 1.0) {
                            camera.zoom = 1.0;
                            camera.updateProjectionMatrix();
                        }
                        if (presampledLabel) presampledLabel.style.opacity = '0';
                    }

                    if (step === 0) {
                        clear();
                        stopAutoRotate();
                        objLoaded = false;
                        // Rebuild minimal tiling for step 0
                        getMinimalTiling();
                        buildGeometry();
                        if (renderer && scene && camera) renderer.render(scene, camera);
                        if (panelsEl) panelsEl.style.opacity = '0';
                        if (curvedTextEl) curvedTextEl.style.opacity = '0';
                        if (rightPanelEl) rightPanelEl.style.opacity = '0';
                        if (subtextEl) subtextEl.style.opacity = '0';
                        if (imagePanelEl) imagePanelEl.style.opacity = '0';
                    } else if (step === 1) {
                        stopAutoRotate();
                        objLoaded = false;
                        // Rebuild sampled geometry
                        buildGeometry();
                        if (renderer && scene && camera) renderer.render(scene, camera);
                        if (panelsEl) panelsEl.style.opacity = '0';
                        if (curvedTextEl) curvedTextEl.style.opacity = '0';
                        if (rightPanelEl) rightPanelEl.style.opacity = '0';
                        if (subtextEl) subtextEl.style.opacity = '0';
                        if (imagePanelEl) imagePanelEl.style.opacity = '0';
                    } else if (step === 2) {
                        // Back to rotating coarse sample - rebuild coarse geometry
                        objLoaded = false;
                        buildGeometry(); // Rebuild from currentDimers
                        if (renderer && scene && camera) renderer.render(scene, camera);
                        if (panelsEl) panelsEl.style.opacity = '0';
                        if (curvedTextEl) curvedTextEl.style.opacity = '0';
                        if (rightPanelEl) rightPanelEl.style.opacity = '0';
                        if (subtextEl) subtextEl.style.opacity = '0';
                        if (imagePanelEl) imagePanelEl.style.opacity = '0';
                    } else if (step === 3) {
                        // At pre-sampled, hide panels
                        if (panelsEl) panelsEl.style.opacity = '0';
                        if (curvedTextEl) curvedTextEl.style.opacity = '0';
                        if (rightPanelEl) rightPanelEl.style.opacity = '0';
                        if (subtextEl) subtextEl.style.opacity = '0';
                        if (imagePanelEl) imagePanelEl.style.opacity = '0';
                    } else if (step === 4) {
                        // At theorem, hide curved text, question and image
                        if (curvedTextEl) curvedTextEl.style.opacity = '0';
                        if (rightPanelEl) rightPanelEl.style.opacity = '0';
                        if (subtextEl) subtextEl.style.opacity = '0';
                        if (imagePanelEl) imagePanelEl.style.opacity = '0';
                    } else if (step === 5) {
                        // At curved text, hide question and image
                        if (rightPanelEl) rightPanelEl.style.opacity = '0';
                        if (subtextEl) subtextEl.style.opacity = '0';
                        if (imagePanelEl) imagePanelEl.style.opacity = '0';
                    } else if (step === 6) {
                        // At question, hide image
                        if (imagePanelEl) imagePanelEl.style.opacity = '0';
                    }
                }
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();
</script>

<section class="slide slide-top" id="energy" data-title="Energy">
    <h2 class="slide-title">Local energy</h2>

    <div style="display: grid; grid-template-columns: 0.8fr 1.2fr; gap: 2vw; margin-top: 1vh; width: 100%; align-items: start;">
        <!-- Left: Text explanation -->
        <div style="display: flex; flex-direction: column; gap: 1.5vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">
            <!-- How to get limit shape -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">How to get limit shape?</strong>
                <ul style="margin: 0.5vh 0 0 1.5em; padding: 0;">
                    <li>Approximate any surface by piecewise-planar patches</li>
                    <li>Count configurations approximating a given slope \((A,B)\)</li>
                    <li>Integrate and maximize to get the typical shape</li>
                </ul>
            </div>

            <!-- CKP 2000 -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Energy σ(A,B) [Cohn-Kenyon-Propp 2000]</strong><br>
                    \(\sigma(A,B) = \dfrac1\pi
                    ( L(\pi p_1)+L(\pi p_2)+L(\pi (1-p_1-p_2))),
                    \)
                    where \(p_1, p_2, 1-p_1-p_2\) is the normal direction to the patch, and <br>
                    \(
                    L(z)=\int_0^z\log|2\sin t|\,dt
                    \) is the Lobachevsky function.
            </div>

            <!-- Integral -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Variational principle, subject to boundary conditions</strong><br>
                Limit shape $z=h(x,y)$ maximizes \(\displaystyle\iint \sigma(\nabla h)\, dxdy\)
            </div>

            <!-- KOS 2006 -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Generalization [Kenyon-Okounkov-Sheffield 2006]</strong><br>
                Our surfaces use \(1\times 1\) squares in three coordinate directions.
                The theory of limit shapes generalizes
                to surfaces from plaquettes of other shapes, possibly weighted.
                Local energy expressed through <b>algebraic geometry</b> of the plaquettes.
            </div>
        </div>

        <!-- Right: 3D tiling canvas -->
        <div style="position: relative; display: flex; flex-direction: column; align-items: center; gap: 1vh;">
            <!-- 3D tiling canvas (main) -->
            <canvas id="energy-tiling-canvas" width="1200" height="1000" style="height: 80vh; width:47vw; border: 1px solid #ccc;"></canvas>
            <!-- Controls below -->
            <div id="energy-controls" style="display: flex; gap: 1vw; align-items: center; flex-wrap: wrap; font-size: clamp(0.75rem, 1.5vw, 1.1rem);">
                <label style="display: flex; align-items: center; gap: 0.3vw;">
                    A: <input type="number" id="gradient-a" min="-5" max="5" step="0.1" value="-2" style="width: 4em; font-size: inherit; padding: 0.2em;">
                </label>
                <label style="display: flex; align-items: center; gap: 0.3vw;">
                    B: <input type="number" id="gradient-b" min="-5" max="5" step="0.1" value="0.3" style="width: 4em; font-size: inherit; padding: 0.2em;">
                </label>
                <button id="energy-sample" style="padding: 0.3em 0.6em; cursor: pointer; border: 2px solid var(--slide-accent); background: var(--slide-accent); color: white; border-radius: 4px; font-size: inherit;">Sample</button>
                <span style="color: #888; margin-left: 0.5vw;">plane z=Ax+By</span>
            </div>
        </div>
    </div>
</section>

<!-- Energy slide 3D Tiling (Lazy WebGL loading) -->
<script>
(async function() {
    'use strict';

    const canvas = document.getElementById('energy-tiling-canvas');
    if (!canvas) return;

    // ===== THREE.JS (LAZY LOADED) =====
    let scene = null;
    let camera = null;
    let renderer = null;
    let controls = null;
    let meshGroup = null;
    const frustumSize = 35;  // Smaller = more zoom

    function initThreeJS() {
        if (renderer) return;  // Already initialized

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);  // Dark background like limit-shape

        const w = canvas.clientWidth || canvas.width;
        const h = canvas.clientHeight || canvas.height;
        const aspect = w / h;
        camera = new THREE.OrthographicCamera(
            -frustumSize * aspect / 2, frustumSize * aspect / 2,
            frustumSize / 2, -frustumSize / 2, 0.1, 1000
        );
        // Y is up (Three.js default) - coordinates transformed to match
        camera.position.set(50, 50, 40);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(w, h);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableRotate = true;
        controls.enablePan = true;
        controls.enableZoom = true;
        // Lock polar angle - only allow horizontal rotation around Y axis
        const fixedPolarAngle = Math.PI / 3;  // 60 degrees from vertical (nice viewing angle)
        controls.minPolarAngle = fixedPolarAngle;
        controls.maxPolarAngle = fixedPolarAngle;
        controls.addEventListener('change', () => {
            if (renderer) renderer.render(scene, camera);
        });

        // Lighting (same as limit-shape)
        scene.add(new THREE.AmbientLight(0xffffff, 0.35));
        const hemi = new THREE.HemisphereLight(0x6666aa, 0x222244, 0.25);
        hemi.position.set(0, 20, 0);
        scene.add(hemi);
        const directional = new THREE.DirectionalLight(0xffffff, 1.2);
        directional.position.set(15, 20, 5);
        scene.add(directional);
        const fill = new THREE.DirectionalLight(0xffffff, 0.3);
        fill.position.set(-10, 5, -5);
        scene.add(fill);
        // Warm orange-tinted lights for rotation
        const warmLight1 = new THREE.DirectionalLight(0xffaa66, 0.7);
        warmLight1.position.set(-30, 10, 30);
        scene.add(warmLight1);
        const warmLight2 = new THREE.DirectionalLight(0xffcc88, 0.6);
        warmLight2.position.set(-30, 10, -30);
        scene.add(warmLight2);

        meshGroup = new THREE.Group();
        scene.add(meshGroup);

        renderer.render(scene, camera);
    }

    function disposeThreeJS() {
        if (!renderer) return;

        // Dispose meshes
        if (meshGroup) {
            while (meshGroup.children.length > 0) {
                const child = meshGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                meshGroup.remove(child);
            }
        }

        // Release WebGL context
        if (controls) controls.dispose();
        renderer.dispose();
        renderer = null;
        scene = null;
        camera = null;
        controls = null;
        meshGroup = null;
    }

    // Wait for LozengeModule
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }
    const wasm = await LozengeModule();

    const initFromTriangles = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const runCFTP = wasm.cwrap('runCFTP', 'number', []);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeString = wasm.cwrap('freeString', null, ['number']);
    const repairRegionWasm = wasm.cwrap('repairRegion', 'number', []);
    const initCFTPWasm = wasm.cwrap('initCFTP', 'number', []);
    const getGridBoundsWasm = wasm.cwrap('getGridBounds', 'number', []);
    const getCFTPMinGridDataWasm = wasm.cwrap('getCFTPMinGridData', 'number', []);
    const getCFTPMaxGridDataWasm = wasm.cwrap('getCFTPMaxGridData', 'number', []);
    const getBlackTrianglesWasm = wasm.cwrap('getBlackTriangles', 'number', []);

    // GPU engine
    let gpuEngine = null;
    let gpuAvailable = false;

    async function initGPU() {
        if (gpuEngine) return gpuAvailable;
        if (typeof WebGPULozengeEngine === 'undefined') return false;
        try {
            gpuEngine = new WebGPULozengeEngine();
            await gpuEngine.init();
            gpuAvailable = true;
            return true;
        } catch (e) {
            gpuAvailable = false;
            return false;
        }
    }

    function getGridBounds() {
        const ptr = getGridBoundsWasm();
        const jsonStr = wasm.UTF8ToString(ptr);
        freeString(ptr);
        return JSON.parse(jsonStr);
    }

    function getCFTPMinRawGridData(bounds) {
        const dataPtr = getCFTPMinGridDataWasm();
        if (!dataPtr) return null;
        const data = new Int32Array(bounds.size);
        for (let i = 0; i < bounds.size; i++) {
            data[i] = wasm.getValue(dataPtr + i * 4, 'i32');
        }
        wasm._free(dataPtr);
        return data;
    }

    function getCFTPMaxRawGridData(bounds) {
        const dataPtr = getCFTPMaxGridDataWasm();
        if (!dataPtr) return null;
        const data = new Int32Array(bounds.size);
        for (let i = 0; i < bounds.size; i++) {
            data[i] = wasm.getValue(dataPtr + i * 4, 'i32');
        }
        wasm._free(dataPtr);
        return data;
    }

    function getBlackTriangles() {
        const ptr = getBlackTrianglesWasm();
        const jsonStr = wasm.UTF8ToString(ptr);
        freeString(ptr);
        return JSON.parse(jsonStr);
    }

    const N = 50;
    const colors = ['#E57200', '#232D4B', '#F9DCBF']; // UVA colors
    let initialSampleDone = false;

    // Generate stepped path on cylinder (same as 3D viz)
    function generateSteppedPath(A, B) {
        const path = [];
        function addPoint(x, y, h, prevH) {
            if (path.length > 0 && h !== prevH) {
                const lastPt = path[path.length - 1];
                if (h > prevH) {
                    for (let hh = prevH + 1; hh <= h; hh++) {
                        path.push({ x: lastPt.x, y: lastPt.y, z: hh });
                    }
                } else {
                    for (let hh = prevH - 1; hh >= h; hh--) {
                        path.push({ x: lastPt.x, y: lastPt.y, z: hh });
                    }
                }
            }
            path.push({ x, y, z: h });
            return h;
        }

        let prevH = Math.round(A * 0 + B * 0);
        path.push({ x: 0, y: 0, z: prevH });

        for (let x = 1; x <= N; x++) {
            prevH = addPoint(x, 0, Math.round(A * x + B * 0), prevH);
        }
        for (let y = 1; y <= N; y++) {
            prevH = addPoint(N, y, Math.round(A * N + B * y), prevH);
        }
        for (let x = N - 1; x >= 0; x--) {
            prevH = addPoint(x, N, Math.round(A * x + B * N), prevH);
        }
        for (let y = N - 1; y >= 1; y--) {
            prevH = addPoint(0, y, Math.round(A * 0 + B * y), prevH);
        }
        const h0 = Math.round(A * 0 + B * 0);
        if (h0 !== prevH) {
            addPoint(0, 0, h0, prevH);
        }
        return path;
    }

    // Project to x+y+z=0 plane: (x,y,z) -> (x-t, y-t, z-t) where t=(x+y+z)/3
    function projectToLattice(path) {
        return path.map(p => {
            const t = (p.x + p.y + p.z) / 3;
            return { x: p.x - t, y: p.y - t, z: p.z - t };
        });
    }

    // Convert projected 3D coords to 2D triangular lattice coords
    // On x+y+z=0 plane, we use (u,v) where u = x-z, v = y-z (or similar)
    function to2DLattice(p3d) {
        // Standard projection: u = x - z, v = y - z
        return { u: p3d.x - p3d.z, v: p3d.y - p3d.z };
    }

    // Point-in-polygon test (ray casting)
    function pointInPolygon(px, py, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i].u, yi = polygon[i].v;
            const xj = polygon[j].u, yj = polygon[j].v;
            if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    }

    // Generate triangles inside the projected boundary
    function generateTriangles(A, B) {
        const steppedPath = generateSteppedPath(A, B);
        const projected3D = projectToLattice(steppedPath);
        const polygon2D = projected3D.map(to2DLattice);

        // Get bounding box
        const uVals = polygon2D.map(p => p.u);
        const vVals = polygon2D.map(p => p.v);
        const minU = Math.floor(Math.min(...uVals)) - 2;
        const maxU = Math.ceil(Math.max(...uVals)) + 2;
        const minV = Math.floor(Math.min(...vVals)) - 2;
        const maxV = Math.ceil(Math.max(...vVals)) + 2;

        const triangles = [];

        // For each lattice cell (n, j), check black and white triangles
        // Black (right-pointing) centroid: (n + 2/3, j + 1/3) in (u,v) coords
        // White (left-pointing) centroid: (n + 1/3, j + 2/3)
        for (let n = minU; n <= maxU; n++) {
            for (let j = minV; j <= maxV; j++) {
                // Black triangle centroid
                const blackU = n + 2/3, blackV = j + 1/3;
                if (pointInPolygon(blackU, blackV, polygon2D)) {
                    triangles.push(n, j, 1);
                }
                // White triangle centroid
                const whiteU = n + 1/3, whiteV = j + 2/3;
                if (pointInPolygon(whiteU, whiteV, polygon2D)) {
                    triangles.push(n, j, 2);
                }
            }
        }

        return triangles;
    }

    // ========================================================================
    // HEIGHT FUNCTION COMPUTATION (from ultimate-lozenge.md)
    // ========================================================================
    function computeHeightFunction(dimers) {
        // Vertex keys for each dimer type
        const getVertexKeys = (dimer) => {
            const { bn, bj, t } = dimer;
            if (t === 0) {
                return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
            } else if (t === 1) {
                return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
            } else {
                return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
            }
        };

        // Height patterns (relative z-heights of the 4 vertices)
        const getHeightPattern = (t) => {
            if (t === 0) return [0, 0, 0, 0];
            if (t === 1) return [1, 0, 0, 1];
            return [1, 1, 0, 0];
        };

        // Build Vertex-to-Dimer Map
        const vertexToDimers = new Map();
        for (const dimer of dimers) {
            const verts = getVertexKeys(dimer);
            for (const [n, j] of verts) {
                const key = `${n},${j}`;
                if (!vertexToDimers.has(key)) vertexToDimers.set(key, []);
                vertexToDimers.get(key).push(dimer);
            }
        }

        // BFS to calculate Height Function h(n,j)
        const heights = new Map();
        if (dimers.length > 0) {
            const firstDimer = dimers[0];
            const firstVerts = getVertexKeys(firstDimer);
            const startKey = `${firstVerts[0][0]},${firstVerts[0][1]}`;
            heights.set(startKey, 0);

            const queue = [startKey];
            const visited = new Set();

            while (queue.length > 0) {
                const currentKey = queue.shift();
                if (visited.has(currentKey)) continue;
                visited.add(currentKey);

                const currentH = heights.get(currentKey);
                const [cn, cj] = currentKey.split(',').map(Number);

                for (const dimer of vertexToDimers.get(currentKey) || []) {
                    const verts = getVertexKeys(dimer);
                    const pattern = getHeightPattern(dimer.t);

                    // Find index of current vertex in this dimer
                    let myIdx = -1;
                    for (let i = 0; i < 4; i++) {
                        if (verts[i][0] === cn && verts[i][1] === cj) {
                            myIdx = i;
                            break;
                        }
                    }

                    if (myIdx >= 0) {
                        for (let i = 0; i < 4; i++) {
                            const [vn, vj] = verts[i];
                            const vkey = `${vn},${vj}`;
                            if (!heights.has(vkey)) {
                                const newH = currentH + (pattern[i] - pattern[myIdx]);
                                heights.set(vkey, newH);
                                queue.push(vkey);
                            }
                        }
                    }
                }
            }
        }

        return heights;
    }

    // Draw lozenges as 3D stepped surface
    function drawFromDimers(dimers, triangleArr, resetCamera = true) {
        if (!meshGroup) return;

        // Clear previous meshes
        while (meshGroup.children.length > 0) {
            const child = meshGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
            meshGroup.remove(child);
        }

        if (!dimers || dimers.length === 0) {
            if (renderer) renderer.render(scene, camera);
            return;
        }

        // Vertex keys for each dimer type
        const getVertexKeys = (dimer) => {
            const { bn, bj, t } = dimer;
            if (t === 0) return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
            else if (t === 1) return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
            else return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
        };

        // Compute height function
        const heights = computeHeightFunction(dimers);

        // 3D Coordinate Transformation (from ultimate-lozenge.md, with Y as vertical)
        // Maps abstract lattice (n, j, h) to Cartesian (x, y, z)
        // Swapped y/z so Y is vertical (Three.js convention for OrbitControls)
        const to3D = (n, j, h) => ({ x: h, y: j - h, z: -n - h });

        // White lozenges like limit-shape
        const lozengeColors = ['#FFFFFF', '#FFFFFF', '#FFFFFF'];

        // Build single geometry with all quads
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const normals = [];
        const vertexColors = [];
        const indices = [];

        const addQuad = (v1, v2, v3, v4, color) => {
            const baseIndex = vertices.length / 3;
            vertices.push(v1.x, v1.y, v1.z);
            vertices.push(v2.x, v2.y, v2.z);
            vertices.push(v3.x, v3.y, v3.z);
            vertices.push(v4.x, v4.y, v4.z);

            // Compute flat normal
            const edge1 = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
            const edge2 = { x: v4.x - v1.x, y: v4.y - v1.y, z: v4.z - v1.z };
            const nx = edge1.y * edge2.z - edge1.z * edge2.y;
            const ny = edge1.z * edge2.x - edge1.x * edge2.z;
            const nz = edge1.x * edge2.y - edge1.y * edge2.x;
            const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;

            for (let i = 0; i < 4; i++) {
                normals.push(nx / len, ny / len, nz / len);
            }

            const c = new THREE.Color(color);
            for (let i = 0; i < 4; i++) {
                vertexColors.push(c.r, c.g, c.b);
            }

            indices.push(baseIndex, baseIndex + 1, baseIndex + 2);
            indices.push(baseIndex, baseIndex + 2, baseIndex + 3);
        };

        // Generate geometry for each dimer
        for (const dimer of dimers) {
            const verts = getVertexKeys(dimer);
            const v3d = verts.map(([n, j]) => {
                const h = heights.get(`${n},${j}`) || 0;
                return to3D(n, j, h);
            });
            addQuad(v3d[0], v3d[1], v3d[2], v3d[3], lozengeColors[dimer.t]);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
        geometry.setIndex(indices);
        geometry.computeBoundingSphere();

        // Create mesh with vertex colors (same material as limit-shape)
        const material = new THREE.MeshStandardMaterial({
            vertexColors: true,
            side: THREE.DoubleSide,
            flatShading: true,
            roughness: 0.3,
            metalness: 0.35,
            color: 0xddeeff  // Subtle blue tint
        });
        const mesh = new THREE.Mesh(geometry, material);
        meshGroup.add(mesh);

        // Add edge lines (subtle for dark background)
        const edgesGeometry = new THREE.EdgesGeometry(geometry, 10);
        const edgesMaterial = new THREE.LineBasicMaterial({
            color: 0x444466,
            linewidth: 1,
            opacity: 0.6,
            transparent: true
        });
        const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
        meshGroup.add(edges);

        // Update camera to follow geometry
        if (geometry.boundingSphere) {
            const center = geometry.boundingSphere.center;
            const radius = geometry.boundingSphere.radius;

            if (resetCamera) {
                // Full reset: position camera at default angle
                controls.target.copy(center);
                camera.position.set(center.x + radius, center.y + radius * 0.8, center.z + radius);
                camera.lookAt(center);
            } else {
                // Preserve angle: move camera relative to new center
                const offset = new THREE.Vector3().subVectors(camera.position, controls.target);
                controls.target.copy(center);
                camera.position.copy(center).add(offset);
            }
            controls.update();
        }

        renderer.render(scene, camera);
    }

    // Sample function
    async function sample(A, B, resetCamera = true) {
        const triangles = generateTriangles(A, B);

        // Pass to WASM
        const dataPtr = wasm._malloc(triangles.length * 4);
        for (let i = 0; i < triangles.length; i++) {
            wasm.setValue(dataPtr + i * 4, triangles[i], 'i32');
        }
        const initPtr = initFromTriangles(dataPtr, triangles.length);
        const initResult = wasm.UTF8ToString(initPtr);
        freeString(initPtr);
        wasm._free(dataPtr);

        // Parse init result to check if valid
        const initParsed = JSON.parse(initResult);

        // If invalid (flow < count or black ≠ white), repair the region
        if (initParsed.status === 'invalid') {
            const repairPtr = repairRegionWasm();
            const repairResult = wasm.UTF8ToString(repairPtr);
            freeString(repairPtr);

            // Check if repair succeeded
            const repairParsed = JSON.parse(repairResult);
            if (repairParsed.status === 'invalid') {
                return;
            }
        }

        // Try GPU CFTP first, fall back to CPU
        let dimers = [];
        const useGPU = await initGPU();

        if (useGPU && gpuEngine) {
            try {
                // Initialize CFTP on WASM side to create extremal states
                initCFTPWasm();
                const bounds = getGridBounds();

                const minGridData = getCFTPMinRawGridData(bounds);
                const maxGridData = getCFTPMaxRawGridData(bounds);

                if (minGridData && maxGridData) {
                    gpuEngine.initFromWasmData(minGridData, bounds.minN, bounds.maxN, bounds.minJ, bounds.maxJ);
                    const gpuCftpOk = await gpuEngine.initCFTP(minGridData, maxGridData);

                    if (gpuCftpOk) {
                        let T = 1;
                        const maxT = 134217728;
                        let coalesced = false;

                        while (!coalesced && T <= maxT) {
                            gpuEngine.resetCFTPChains(minGridData, maxGridData);
                            const result = await gpuEngine.stepCFTP(T, Math.min(T, 10000));
                            coalesced = result.coalesced;
                            if (!coalesced) coalesced = await gpuEngine.checkCoalescence();
                            if (!coalesced) T *= 2;
                        }

                        if (coalesced) {
                            const resultGrid = await gpuEngine.getCFTPResult();
                            const blackTriangles = getBlackTriangles();
                            dimers = gpuEngine.gridToDimers(resultGrid, blackTriangles);
                            gpuEngine.destroyCFTP();
                        } else {
                            gpuEngine.destroyCFTP();
                            throw new Error('GPU CFTP did not coalesce');
                        }
                    } else {
                        throw new Error('GPU CFTP init failed');
                    }
                } else {
                    throw new Error('Could not get grid data');
                }
            } catch (e) {
                // Fall through to CPU
                dimers = [];
            }
        }

        // CPU fallback
        if (dimers.length === 0) {
            const cftpPtr = runCFTP();
            const cftpResult = wasm.UTF8ToString(cftpPtr);
            freeString(cftpPtr);

            const dimersPtr = exportDimersWasm();
            const dimersJson = wasm.UTF8ToString(dimersPtr);
            freeString(dimersPtr);

            const parsed = JSON.parse(dimersJson);
            dimers = parsed.dimers || [];
        }

        drawFromDimers(dimers, triangles, resetCamera);
    }

    // Wire up Sample button
    const btn = document.getElementById('energy-sample');
    const inputA = document.getElementById('gradient-a');
    const inputB = document.getElementById('gradient-b');

    if (btn && inputA && inputB) {
        btn.addEventListener('click', () => {
            if (!renderer) return;
            sample(parseFloat(inputA.value), parseFloat(inputB.value));
        });
    }

    // Auto-rotation
    let autoRotateId = null;
    function startAutoRotate() {
        if (autoRotateId) return;
        const rotateSpeed = 0.0075;
        function rotate() {
            if (!controls || !renderer) return;
            const x = camera.position.x - controls.target.x;
            const z = camera.position.z - controls.target.z;
            const cos = Math.cos(rotateSpeed);
            const sin = Math.sin(rotateSpeed);
            camera.position.x = controls.target.x + x * cos - z * sin;
            camera.position.z = controls.target.z + x * sin + z * cos;
            camera.lookAt(controls.target);
            renderer.render(scene, camera);
            autoRotateId = requestAnimationFrame(rotate);
        }
        rotate();
    }

    function stopAutoRotate() {
        if (autoRotateId) {
            cancelAnimationFrame(autoRotateId);
            autoRotateId = null;
        }
    }

    // Register with slide engine for lazy WebGL loading
    function waitForSlideEngine() {
        if (typeof window.slideEngine !== 'undefined') {
            // Presets for stepping through (preset 0 is pre-sampled on slide enter)
            const presets = [
                { A: -2, B: 0.3 },
                { A: -0.05, B: 0.4 },
                { A: -0.2, B: 0.3 },
                { A: -0.2, B: 0 },
                { A: 0, B: 0 }
            ];
            let currentPreset = 0;

            function applyPreset(idx, resetCamera = true) {
                if (idx < 0 || idx >= presets.length) return;
                currentPreset = idx;
                const { A, B } = presets[idx];
                document.getElementById('gradient-a').value = A;
                document.getElementById('gradient-b').value = B;
                sample(A, B, resetCamera);
            }

            window.slideEngine.registerSimulation('energy', {
                start() { startAutoRotate(); },
                pause() { stopAutoRotate(); },
                steps: presets.length - 1,  // 3 steps (presets 1, 2, 3)
                onStep(step) {
                    // step 1 -> preset 1, step 2 -> preset 2, step 3 -> preset 3
                    if (step >= 1 && step < presets.length) {
                        applyPreset(step, false);  // Don't reset camera angle
                    }
                },
                onStepBack(step) {
                    // step 0 -> preset 0, step 1 -> preset 1, step 2 -> preset 2
                    if (step >= 0 && step < presets.length) {
                        applyPreset(step, false);  // Don't reset camera angle
                    }
                },
                onSlideEnter() {
                    // Wait for Three.js then initialize
                    const initWhenReady = () => {
                        if (typeof THREE !== 'undefined' && typeof THREE.OrbitControls !== 'undefined') {
                            initThreeJS();
                            if (!initialSampleDone) {
                                applyPreset(0);  // Pre-sample with first preset
                                initialSampleDone = true;
                            } else if (renderer) {
                                renderer.render(scene, camera);
                            }
                            startAutoRotate();
                        } else {
                            setTimeout(initWhenReady, 50);
                        }
                    };
                    initWhenReady();
                },
                onSlideLeave() {
                    stopAutoRotate();
                    disposeThreeJS();
                    initialSampleDone = false;  // Reset so re-entering slide will resample
                }
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();
</script>

<!-- ==================== Q-volume deformations ==================== -->
<section class="slide slide-top" id="q-volume" data-title="Q-volume deformation">
    <h2 class="slide-title">Q-volume deformation</h2>
    <!-- Top: Five tilings with q inputs -->
    <div style="display: flex; gap: 0.8vw; justify-content: center; margin-top: 1vh;">
        <div style="text-align: center;">
            <canvas id="qvol-canvas-0" width="400" height="400" style="width: 16vw; height: 16vw; border: 1px solid #ccc;"></canvas>
            <div style="font-size: clamp(0.8rem, 1.2vw, 1rem); margin-top: 0.3vh;">q = <input type="text" id="qvol-input-0" value="0.7" style="width: 3em; text-align: center; font-size: inherit; border: 1px solid #ccc; border-radius: 3px;"></div>
        </div>
        <div style="text-align: center;">
            <canvas id="qvol-canvas-1" width="400" height="400" style="width: 16vw; height: 16vw; border: 1px solid #ccc;"></canvas>
            <div style="font-size: clamp(0.8rem, 1.2vw, 1rem); margin-top: 0.3vh;">q = <input type="text" id="qvol-input-1" value="0.9" style="width: 3em; text-align: center; font-size: inherit; border: 1px solid #ccc; border-radius: 3px;"></div>
        </div>
        <div style="text-align: center;">
            <canvas id="qvol-canvas-2" width="400" height="400" style="width: 16vw; height: 16vw; border: 1px solid #ccc;"></canvas>
            <div style="font-size: clamp(0.8rem, 1.2vw, 1rem); margin-top: 0.3vh;">q = <input type="text" id="qvol-input-2" value="1" style="width: 3em; text-align: center; font-size: inherit; border: 1px solid #ccc; border-radius: 3px;"></div>
        </div>
        <div style="text-align: center;">
            <canvas id="qvol-canvas-3" width="400" height="400" style="width: 16vw; height: 16vw; border: 1px solid #ccc;"></canvas>
            <div style="font-size: clamp(0.8rem, 1.2vw, 1rem); margin-top: 0.3vh;">q = <input type="text" id="qvol-input-3" value="1.1" style="width: 3em; text-align: center; font-size: inherit; border: 1px solid #ccc; border-radius: 3px;"></div>
        </div>
        <div style="text-align: center;">
            <canvas id="qvol-canvas-4" width="400" height="400" style="width: 16vw; height: 16vw; border: 1px solid #ccc;"></canvas>
            <div style="font-size: clamp(0.8rem, 1.2vw, 1rem); margin-top: 0.3vh;">q = <input type="text" id="qvol-input-4" value="1.4" style="width: 3em; text-align: center; font-size: inherit; border: 1px solid #ccc; border-radius: 3px;"></div>
        </div>
    </div>
    <!-- Resample button under pictures -->
    <button id="qvol-sample-btn" style="margin-top: 1vh; padding: 0.4em 1.2em; cursor: pointer; border: 2px solid var(--slide-accent); background: var(--slide-accent); color: white; border-radius: 4px; font-size: clamp(0.8rem, 1.2vw, 1rem);">Re-sample All</button>
    <!-- Bottom: Text explanation (2 columns) -->
    <div style="display: grid; grid-template-columns: 1.2fr 0.8fr; gap: 2vw; margin-top: 1.5vh; width: 100%;">
        <!-- Left column: stacked panes -->
        <div style="display: flex; flex-direction: column; gap: 0.8vh;">
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 0.8vh 1.5vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: left;">
                \(\displaystyle \text{Probability} = \frac{q^{\text{volume}}}{\sum_{\text{all surfaces}} q^{\text{volume}}}\)
            </div>
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 0.8vh 1.5vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: left;">
                <strong style="color: var(--slide-accent);">Variational principle</strong> <span style="font-size: 0.85em;">(\(q = e^{-\gamma/N}\))</span><br>
                Maximize \(\displaystyle \iint \sigma \, dx\,dy - \gamma \iint f \, dx\,dy\)<br>
                <span style="font-size: 0.85em;">\(\gamma>0\) and \(\gamma<0\) tilts toward less/more volume</span>
            </div>
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 0.8vh 1.5vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: left;">
                <strong style="color: var(--slide-accent);">Entropy vs Energy</strong> <span style="font-size: 0.85em;">(assume \(q < 1\))</span>
                <ul style="margin: 0.3vh 0 0 1.2em; padding: 0; font-size: 0.85em;">
                    <li>Most weight when empty (no cubes) — but only 1 configuration</li>
                    <li>Adding cubes ↑ volume (↓ energy), but also ↑ configurations (↑ entropy)</li>
                    <li>Balance determines the typical (limit) shape</li>
                </ul>
            </div>
        </div>
        <!-- Right column: image (appears on next build) -->
        <div class="fragment" style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
            <div style="position: relative; display: inline-block;">
                <img src="images/q_1.025.png" alt="q=1.025 sample" style="height: 48vh; width: auto; object-fit: contain;">
                <div style="position: absolute; top: 0.5vh; right: 0.5vw; background: rgba(229, 114, 0, 0.9); color: white; padding: 0.3vh 0.6vw; border-radius: 3px; font-size: clamp(0.7rem, 1.2vw, 1rem); font-weight: bold;">pre-sampled</div>
            </div>
            <div style="color: #888; font-size: clamp(0.8rem, 1.2vw, 1rem); margin-top: 0.5vh;">\(q = 1.025\), larger size \(N\)</div>
        </div>
    </div>
</section>

<!-- Q-volume slide script -->
<script>
(async function() {
    'use strict';

    // 5 canvases with q inputs
    const canvases = [0,1,2,3,4].map(i => document.getElementById(`qvol-canvas-${i}`));
    const qInputs = [0,1,2,3,4].map(i => document.getElementById(`qvol-input-${i}`));
    const sampleBtn = document.getElementById('qvol-sample-btn');
    if (canvases.some(c => !c) || qInputs.some(i => !i)) return;

    function getQValues() {
        return qInputs.map(input => parseFloat(input.value) || 1.0);
    }

    // Wait for LozengeModule
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }

    // Create 5 separate WASM instances
    const wasms = await Promise.all([0,1,2,3,4].map(() => LozengeModule()));

    function setupWasm(wasm) {
        return {
            wasm,
            initFromTriangles: wasm.cwrap('initFromTriangles', 'number', ['number', 'number']),
            performGlauberSteps: wasm.cwrap('performGlauberSteps', 'number', ['number']),
            exportDimers: wasm.cwrap('exportDimers', 'number', []),
            freeString: wasm.cwrap('freeString', null, ['number']),
            setQBias: wasm.cwrap('setQBias', null, ['number']),
            setUseRandomSweeps: wasm.cwrap('setUseRandomSweeps', null, ['number']),
            initCFTP: wasm.cwrap('initCFTP', 'number', []),
            runCFTP: wasm.cwrap('runCFTP', 'number', []),
            getGridBounds: wasm.cwrap('getGridBounds', 'number', []),
            getCFTPMinGridData: wasm.cwrap('getCFTPMinGridData', 'number', []),
            getCFTPMaxGridData: wasm.cwrap('getCFTPMaxGridData', 'number', [])
        };
    }

    const sims = wasms.map(w => setupWasm(w));

    const colors = ['#E57200', '#232D4B', '#F9DCBF'];
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) { return { x: n, y: slope * n + j * deltaC }; }

    // Load shape from JSON file
    let shapeTriangles = null;
    try {
        const resp = await fetch('/letters/shape_for_arctic_small.json');
        const data = await resp.json();
        shapeTriangles = data.triangles;
    } catch (e) {
        console.error('Failed to load shape_for_arctic_small.json:', e);
        return;
    }

    function getTrianglesArray() {
        if (!shapeTriangles) return [];
        const arr = [];
        for (const tri of shapeTriangles) {
            arr.push(tri.n, tri.j, tri.type);
        }
        return arr;
    }

    function initSim(sim, triangles) {
        const dataPtr = sim.wasm._malloc(triangles.length * 4);
        for (let i = 0; i < triangles.length; i++) {
            sim.wasm.setValue(dataPtr + i * 4, triangles[i], 'i32');
        }
        const ptr = sim.initFromTriangles(dataPtr, triangles.length);
        sim.freeString(ptr);
        sim.wasm._free(dataPtr);
        sim.setUseRandomSweeps(1);
    }

    // CPU CFTP - updates internal WASM state
    function runCFTP(sim) {
        const ptr = sim.runCFTP();
        sim.freeString(ptr);
    }

    function runGlauber(sim, steps) {
        const ptr = sim.performGlauberSteps(steps);
        sim.freeString(ptr);
    }

    function getDimers(sim) {
        const ptr = sim.exportDimers();
        const json = sim.wasm.UTF8ToString(ptr);
        sim.freeString(ptr);
        const parsed = JSON.parse(json);
        return parsed.dimers || [];
    }

    function drawTiling(canvas, dimers) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, w, h);

        if (!dimers || dimers.length === 0) return;

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const d of dimers) {
            const verts = getLozengeVerts(d);
            for (const v of verts) {
                minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
            }
        }

        // Rotate 90 degrees: swap width/height for scale calculation
        const scale = Math.min(w / (maxY - minY), h / (maxX - minX)) * 0.9;
        const cx = w / 2;
        const cy = h / 2;
        const offsetX = (minY + maxY) / 2;
        const offsetY = (minX + maxX) / 2;

        for (const d of dimers) {
            const verts = getLozengeVerts(d);
            ctx.beginPath();
            // Rotate 90°: (x,y) -> (y, -x)
            ctx.moveTo(cx + (verts[0].y - offsetX) * scale, cy + (verts[0].x - offsetY) * scale);
            for (let i = 1; i < 4; i++) {
                ctx.lineTo(cx + (verts[i].y - offsetX) * scale, cy + (verts[i].x - offsetY) * scale);
            }
            ctx.closePath();
            ctx.fillStyle = colors[d.t];
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }

    function getLozengeVerts(d) {
        const { bn, bj, t } = d;
        if (t === 0) return [getVertex(bn, bj), getVertex(bn+1, bj), getVertex(bn+1, bj-1), getVertex(bn, bj-1)];
        if (t === 1) return [getVertex(bn, bj), getVertex(bn+1, bj-1), getVertex(bn+1, bj-2), getVertex(bn, bj-1)];
        return [getVertex(bn-1, bj), getVertex(bn, bj), getVertex(bn+1, bj-1), getVertex(bn, bj-1)];
    }

    const triangles = getTrianglesArray();
    let sampling = false;
    let sampled = false;

    async function sampleAll() {
        if (sampling) return;
        sampling = true;
        sampled = true;

        const qValues = getQValues();

        // Sample each q value sequentially, showing result immediately
        for (let i = 0; i < qValues.length; i++) {
            const q = qValues[i];
            const sim = sims[i];

            // Clear canvas to show we're working on it
            const ctx = canvases[i].getContext('2d');
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvases[i].width, canvases[i].height);
            ctx.fillStyle = '#999';
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Sampling...', canvases[i].width/2, canvases[i].height/2);

            // Yield to let UI update
            await new Promise(r => setTimeout(r, 50));

            // Reinitialize region
            initSim(sim, triangles);

            // Set q-bias BEFORE CFTP
            sim.setQBias(q);

            // Run CPU CFTP (uses q-bias for q-weighted sampling)
            runCFTP(sim);

            // Draw this result immediately
            drawTiling(canvases[i], getDimers(sim));

            // Small delay between samples so user can see progress
            await new Promise(r => setTimeout(r, 100));
        }

        sampling = false;
    }

    sampleBtn.addEventListener('click', sampleAll);

    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('q-volume', {
                start() {},
                pause() {},
                onSlideEnter() { if (!sampled) sampleAll(); },
                onSlideLeave() {}
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();
</script>

<!-- ==================== Fluctuations ==================== -->
<section class="slide slide-top" id="fluctuations" data-title="Fluctuations">
    <h2 class="slide-title">Fluctuations & 2D Models</h2>

    <!-- TODO placeholder -->
    <div style="background: #fff3cd; border: 2px dashed #ffc107; padding: 1vh 1.5vw; margin-bottom: 1.5vh; font-size: clamp(1rem, 1.8vw, 1.4rem); text-align: left;">
        <strong style="color: #856404;">TODO - Slide not ready:</strong>
        <ul style="margin: 0.5vh 0 0 1.5vw; padding: 0;">
            <li>Explain Gaussian fluctuations</li>
            <li>Add Brownian bridge example to compare with GFF (= Brownian bridge with 2D "time")</li>
            <li><strong>Pictures needed:</strong> bigger sampleable example; even bigger pre-sampled example; examples with holes</li>
            <li><strong>Open problem:</strong> No general universal result for GFF convergence — only specific classes of shapes are covered (with or without holes)</li>
        </ul>
    </div>

    <div style="display: grid; grid-template-columns: 0.45fr 0.55fr; gap: 2vw; margin-top: 1vh; width: 100%; align-items: start;">
        <!-- Left: Text explanation -->
        <div style="display: flex; flex-direction: column; gap: 1.5vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Double dimer model</strong><br>
                Superimpose two independent tilings<br>
                → symmetric difference forms loops
            </div>
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Height fluctuations</strong><br>
                Difference of two height functions:<br>
                \(\displaystyle\frac{h_1 - h_2}{\sqrt{2}} \to \text{GFF}\) (Gaussian Free Field)
            </div>
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Back to 2D</strong><br>
                3D surfaces → 2D height function<br>
                Fluctuations governed by conformal field theory<br>
                Loop statistics ↔ SLE curves
            </div>
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Universal behavior</strong><br>
                Same GFF appears in many 2D models:<br>
                dimers, spanning trees, Ising, ...
            </div>
        </div>
        <!-- Right: GFF heatmap visualization -->
        <div style="display: flex; flex-direction: column; align-items: center; gap: 1vh;">
            <canvas id="gff-canvas" width="800" height="700" style="width: 45vw; height: 70vh; border: 1px solid #ccc;"></canvas>
            <button id="gff-sample-btn" style="padding: 0.5em 1.5em; cursor: pointer; border: 2px solid var(--slide-accent); background: var(--slide-accent); color: white; border-radius: 4px; font-size: clamp(0.9rem, 1.5vw, 1.2rem);">Re-sample GFF</button>
        </div>
    </div>
</section>
<!-- Fluctuations slide script with GPU CFTP (WebGPU engine loaded at top of file) -->
<script>
(async function() {
    'use strict';

    const canvas = document.getElementById('gff-canvas');
    const sampleBtn = document.getElementById('gff-sample-btn');
    if (!canvas) return;

    // Wait for LozengeModule
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }

    const wasm = await LozengeModule();

    // WASM function wrappers
    const initFromTriangles = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const freeString = wasm.cwrap('freeString', null, ['number']);
    const initCFTPWasm = wasm.cwrap('initCFTP', 'number', []);
    const getGridBoundsWasm = wasm.cwrap('getGridBounds', 'number', []);
    const getCFTPMinGridDataWasm = wasm.cwrap('getCFTPMinGridData', 'number', []);
    const getCFTPMaxGridDataWasm = wasm.cwrap('getCFTPMaxGridData', 'number', []);
    const exportDimers = wasm.cwrap('exportDimers', 'number', []);
    const runCFTP = wasm.cwrap('runCFTP', 'number', []);

    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);
    const sqrt2 = Math.sqrt(2);
    function getVertex(n, j) { return { x: n, y: slope * n + j * deltaC }; }

    // GPU engine
    let gpuEngine = null;
    let gpuAvailable = false;

    // Initialize GPU engine if available
    async function initGpuEngine() {
        if (!navigator.gpu) return false;

        // Wait for WebGPU engine script to load (loaded at top of file)
        let waitCount = 0;
        while (!window.WebGPULozengeEngine && waitCount < 50) {
            await new Promise(r => setTimeout(r, 100));
            waitCount++;
        }
        if (!window.WebGPULozengeEngine) return false;
        try {
            gpuEngine = new WebGPULozengeEngine();
            const initPromise = gpuEngine.init();
            const timeoutPromise = new Promise((_, reject) =>
                setTimeout(() => reject(new Error('GPU init timeout')), 5000)
            );
            await Promise.race([initPromise, timeoutPromise]);
            gpuAvailable = gpuEngine.isAvailable();
            console.log('GFF slide: GPU engine', gpuAvailable ? 'ready' : 'unavailable');
            return gpuAvailable;
        } catch (e) {
            console.warn('GFF slide: GPU init failed:', e);
            return false;
        }
    }

    // Load shape from JSON file
    let shapeData = null;

    async function loadShapeData() {
        const response = await fetch('/letters/K.json');
        const json = await response.json();

        const triangleArr = [];
        const blackTriangles = [];
        const whiteTriangles = [];

        for (const tri of json.triangles) {
            const { n, j, type } = tri;
            triangleArr.push(n, j, type);

            if (type === 1) {
                const bv1 = getVertex(n, j), bv2 = getVertex(n, j-1), bv3 = getVertex(n+1, j-1);
                blackTriangles.push({ n, j, verts: [bv1, bv2, bv3] });
            } else {
                const wv1 = getVertex(n, j), wv2 = getVertex(n+1, j), wv3 = getVertex(n+1, j-1);
                whiteTriangles.push({ n, j, verts: [wv1, wv2, wv3] });
            }
        }

        return { triangleArr, blackTriangles, whiteTriangles };
    }

    function initRegion() {
        const dataPtr = wasm._malloc(shapeData.triangleArr.length * 4);
        for (let i = 0; i < shapeData.triangleArr.length; i++) {
            wasm.setValue(dataPtr + i * 4, shapeData.triangleArr[i], 'i32');
        }
        const ptr = initFromTriangles(dataPtr, shapeData.triangleArr.length);
        freeString(ptr);
        wasm._free(dataPtr);
    }

    // Get extremal grid data for GPU
    function getGridBounds() {
        const ptr = getGridBoundsWasm();
        const str = wasm.UTF8ToString(ptr);
        freeString(ptr);
        return JSON.parse(str);
    }

    function getCFTPMinRawGridData(bounds) {
        const dataPtr = getCFTPMinGridDataWasm();
        if (!dataPtr) return null;
        const data = new Int32Array(bounds.size);
        for (let i = 0; i < bounds.size; i++) {
            data[i] = wasm.getValue(dataPtr + i * 4, 'i32');
        }
        wasm._free(dataPtr);
        return data;
    }

    function getCFTPMaxRawGridData(bounds) {
        const dataPtr = getCFTPMaxGridDataWasm();
        if (!dataPtr) return null;
        const data = new Int32Array(bounds.size);
        for (let i = 0; i < bounds.size; i++) {
            data[i] = wasm.getValue(dataPtr + i * 4, 'i32');
        }
        wasm._free(dataPtr);
        return data;
    }

    // WASM CFTP fallback
    function sampleCFTPWasm() {
        const ptr = runCFTP();
        freeString(ptr);
        const dimPtr = exportDimers();
        const json = wasm.UTF8ToString(dimPtr);
        freeString(dimPtr);
        return JSON.parse(json).dimers || [];
    }

    // Compute height function from dimers
    function computeHeightFunction(dimers) {
        const getVertexKeys = (dimer) => {
            const { bn, bj, t } = dimer;
            if (t === 0) return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
            if (t === 1) return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
            return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
        };
        const getHeightPattern = (t) => {
            if (t === 0) return [0, 0, 0, 0];
            if (t === 1) return [1, 0, 0, 1];
            return [1, 1, 0, 0];
        };

        const vertexToDimers = new Map();
        for (const dimer of dimers) {
            for (const [n, j] of getVertexKeys(dimer)) {
                const key = `${n},${j}`;
                if (!vertexToDimers.has(key)) vertexToDimers.set(key, []);
                vertexToDimers.get(key).push(dimer);
            }
        }

        const heights = new Map();
        if (dimers.length === 0) return heights;

        const firstVerts = getVertexKeys(dimers[0]);
        const startKey = `${firstVerts[0][0]},${firstVerts[0][1]}`;
        heights.set(startKey, 0);

        const queue = [startKey];
        const visited = new Set();

        while (queue.length > 0) {
            const currentKey = queue.shift();
            if (visited.has(currentKey)) continue;
            visited.add(currentKey);

            const currentH = heights.get(currentKey);
            const [cn, cj] = currentKey.split(',').map(Number);

            for (const dimer of vertexToDimers.get(currentKey) || []) {
                const verts = getVertexKeys(dimer);
                const pattern = getHeightPattern(dimer.t);

                let myIdx = -1;
                for (let i = 0; i < 4; i++) {
                    if (verts[i][0] === cn && verts[i][1] === cj) { myIdx = i; break; }
                }

                if (myIdx >= 0) {
                    for (let i = 0; i < 4; i++) {
                        const [vn, vj] = verts[i];
                        const nkey = `${vn},${vj}`;
                        if (!heights.has(nkey)) {
                            heights.set(nkey, currentH + (pattern[i] - pattern[myIdx]));
                            queue.push(nkey);
                        }
                    }
                }
            }
        }
        return heights;
    }

    // Diverging colormap: blue (negative) -> white (zero) -> red (positive)
    function valueToColor(val, absMax) {
        if (absMax === 0) return 'rgb(255, 255, 255)';
        const t = Math.max(-1, Math.min(1, val / absMax));
        const gamma = 0.5;
        if (t < 0) {
            const s = Math.pow(-t, gamma);
            return `rgb(${Math.round(255 * (1 - s))}, ${Math.round(255 * (1 - s))}, 255)`;
        } else {
            const s = Math.pow(t, gamma);
            return `rgb(255, ${Math.round(255 * (1 - s))}, ${Math.round(255 * (1 - s))})`;
        }
    }

    function drawGFF(dimers1, dimers2) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, w, h);

        const h1 = computeHeightFunction(dimers1);
        const h2 = computeHeightFunction(dimers2);

        const fluctuations = new Map();
        for (const [key, val1] of h1) {
            const val2 = h2.get(key);
            if (val2 !== undefined) {
                fluctuations.set(key, (val1 - val2) / sqrt2);
            }
        }

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const tri of [...shapeData.blackTriangles, ...shapeData.whiteTriangles]) {
            for (const v of tri.verts) {
                minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
            }
        }

        const scale = Math.min(w / (maxX - minX), h / (maxY - minY)) * 0.9;
        const cx = w / 2 - ((minX + maxX) / 2) * scale;
        const cy = h / 2 + ((minY + maxY) / 2) * scale;

        function tx(x) { return cx + x * scale; }
        function ty(y) { return cy - y * scale; }

        let absMax = 0;
        for (const [, val] of fluctuations) {
            absMax = Math.max(absMax, Math.abs(val));
        }

        function getFluctValue(n, j) {
            return fluctuations.get(`${n},${j}`) || 0;
        }

        for (const tri of shapeData.blackTriangles) {
            const { n, j, verts } = tri;
            const avgVal = (getFluctValue(n, j) + getFluctValue(n, j-1) + getFluctValue(n+1, j-1)) / 3;
            ctx.beginPath();
            ctx.moveTo(tx(verts[0].x), ty(verts[0].y));
            ctx.lineTo(tx(verts[1].x), ty(verts[1].y));
            ctx.lineTo(tx(verts[2].x), ty(verts[2].y));
            ctx.closePath();
            ctx.fillStyle = valueToColor(avgVal, absMax);
            ctx.fill();
        }

        for (const tri of shapeData.whiteTriangles) {
            const { n, j, verts } = tri;
            const avgVal = (getFluctValue(n, j) + getFluctValue(n+1, j) + getFluctValue(n+1, j-1)) / 3;
            ctx.beginPath();
            ctx.moveTo(tx(verts[0].x), ty(verts[0].y));
            ctx.lineTo(tx(verts[1].x), ty(verts[1].y));
            ctx.lineTo(tx(verts[2].x), ty(verts[2].y));
            ctx.closePath();
            ctx.fillStyle = valueToColor(avgVal, absMax);
            ctx.fill();
        }
    }

    let initialized = false;
    let sampling = false;

    // GPU CFTP sampling
    async function sampleGPU() {
        sampleBtn.textContent = 'Sampling...';
        sampleBtn.disabled = true;

        // Initialize WASM CFTP to get extremal states
        const initPtr = initCFTPWasm();
        freeString(initPtr);

        const bounds = getGridBounds();
        const minGridData = getCFTPMinRawGridData(bounds);
        const maxGridData = getCFTPMaxRawGridData(bounds);

        if (!minGridData || !maxGridData) {
            console.error('Failed to get extremal states');
            sampleBtn.textContent = 'Re-sample GFF';
            sampleBtn.disabled = false;
            return;
        }

        // Initialize GPU fluctuations CFTP
        const gpuOk = await gpuEngine.initFluctuationsCFTP(minGridData, maxGridData);
        if (!gpuOk) {
            console.warn('GPU CFTP init failed, falling back to WASM');
            gpuEngine.destroyFluctuationsCFTP();
            const dimers1 = sampleCFTPWasm();
            const dimers2 = sampleCFTPWasm();
            drawGFF(dimers1, dimers2);
            sampleBtn.textContent = 'Re-sample GFF';
            sampleBtn.disabled = false;
            return;
        }

        // Set uniform weights (q=1)
        gpuEngine.setFluctuationsWeights(null, 1, false, 1.0);

        // GPU CFTP loop with epoch doubling
        let T = 1;
        const maxT = 1073741824;
        const stepsPerBatch = 1000;
        const checkInterval = 1000;

        let totalStepsAllEpochs = 0;

        async function gpuFluctStep() {
            gpuEngine.resetFluctuationsChains();

            let totalStepsRun = 0;
            let coalesced = [false, false];

            while (totalStepsRun < T && !(coalesced[0] && coalesced[1])) {
                const batchSize = Math.min(stepsPerBatch, T - totalStepsRun);
                const result = await gpuEngine.stepFluctuationsCFTP(batchSize, checkInterval);
                totalStepsRun += result.stepsRun;
                coalesced = result.coalesced;

                // Update progress
                const c0 = coalesced[0] ? '✓' : '○';
                const c1 = coalesced[1] ? '✓' : '○';
                const kSteps = Math.round((totalStepsAllEpochs + totalStepsRun) / 1000);
                sampleBtn.textContent = `T=${T} ${kSteps}k [${c0}${c1}]`;
                await new Promise(r => setTimeout(r, 0)); // yield for UI
            }
            totalStepsAllEpochs += totalStepsRun;

            const finalCoalesced = await gpuEngine.checkFluctuationsCoalescence();

            if (finalCoalesced[0] && finalCoalesced[1]) {
                const samples = await gpuEngine.getFluctuationsSamples(shapeData.blackTriangles);
                gpuEngine.destroyFluctuationsCFTP();
                drawGFF(samples.sample0, samples.sample1);
                sampleBtn.textContent = 'Re-sample GFF';
                sampleBtn.disabled = false;
                sampling = false;
            } else if (T >= maxT) {
                gpuEngine.destroyFluctuationsCFTP();
                sampleBtn.textContent = 'Timeout';
                sampleBtn.disabled = false;
                sampling = false;
            } else {
                T *= 2;
                setTimeout(gpuFluctStep, 0);
            }
        }

        setTimeout(gpuFluctStep, 10);
    }

    // WASM CFTP sampling (fallback)
    function sampleWASM() {
        sampleBtn.textContent = 'Sampling...';
        sampleBtn.disabled = true;

        setTimeout(() => {
            const dimers1 = sampleCFTPWasm();
            const dimers2 = sampleCFTPWasm();
            drawGFF(dimers1, dimers2);
            sampleBtn.textContent = 'Re-sample GFF';
            sampleBtn.disabled = false;
            sampling = false;
        }, 10);
    }

    async function sample() {
        if (sampling) return;
        sampling = true;

        if (!initialized) {
            sampleBtn.textContent = 'Loading...';
            shapeData = await loadShapeData();
            initRegion();
            await initGpuEngine();
            initialized = true;
        }

        if (gpuAvailable) {
            await sampleGPU();
        } else {
            sampleWASM();
        }
    }

    sampleBtn.addEventListener('click', sample);

    // Register with slide engine
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('fluctuations', {
                start() {},
                pause() {},
                onSlideEnter() { if (!initialized) sample(); },
                onSlideLeave() {}
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();
</script>

<!-- ==================== PART 3: Algorithmic Magic ==================== -->

<section class="slide slide-center" id="part3-intro" data-title="Part 3: Algorithms">
    <h2 style="font-size: clamp(3rem, 5vw, 5.5rem);">Part III</h2>
    <h3 style="font-size: clamp(2rem, 3.5vw, 3.5rem); color: var(--slide-muted); text-transform: uppercase; letter-spacing: 0.05em;">How to draw pictures</h3>
    <ol style="margin-top: 3vh; text-align: left; display: inline-block; font-size: clamp(1.2rem, 2.2vw, 1.8rem); line-height: 1.6;">
        <li class="fragment">Sampling from very large sets — direct picking is prohibitively expensive</li>
        <li class="fragment">Markov Chain Monte Carlo: run a chain preserving the distribution</li>
        <li class="fragment">How long to wait? Mixing time bounds (mathematically hard)</li>
        <li class="fragment">Sometimes: <strong>Coupling From The Past</strong> (works for 3D surfaces!)</li>
        <li class="fragment">CFTP for 2D paths and 3D stepped surfaces</li>
        <li class="fragment">Examples</li>
    </ol>
</section>

<!-- ==================== Slide: Thank You ==================== -->
<section class="slide slide-center" id="thankyou" data-title="Thank You">
    <div style="display: flex; flex-direction: column; gap: clamp(0.5rem, 1.5vh, 1.5rem); align-items: center; justify-content: center;">
        <!-- THANK YOU letters -->
        <div style="display: flex; gap: clamp(0.5rem, 1.5vw, 1.5rem); justify-content: center;">
            <canvas id="letter-T" width="200" height="260" style="width: 20vh; height: 26vh;"></canvas>
            <canvas id="letter-H" width="200" height="260" style="width: 20vh; height: 26vh;"></canvas>
            <canvas id="letter-A" width="200" height="260" style="width: 20vh; height: 26vh;"></canvas>
            <canvas id="letter-N" width="200" height="260" style="width: 20vh; height: 26vh;"></canvas>
            <canvas id="letter-K" width="200" height="260" style="width: 20vh; height: 26vh;"></canvas>
        </div>
        <div style="display: flex; gap: clamp(0.5rem, 1.5vw, 1.5rem); justify-content: center;">
            <canvas id="letter-Y" width="200" height="260" style="width: 20vh; height: 26vh;"></canvas>
            <canvas id="letter-O" width="200" height="260" style="width: 20vh; height: 26vh;"></canvas>
            <canvas id="letter-U" width="200" height="260" style="width: 20vh; height: 26vh;"></canvas>
        </div>
        <!-- QR code centered below -->
        <div style="display: flex; align-items: center; gap: 2vw; margin-top: 6vh;">
            <img src="images/qr-lozenge-draw.png" alt="QR code for lozenge-draw" style="height: 24vh; width: auto;">
            <div style="text-align: left;">
                <div style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); color: #333;">
                    draw any shape and stack with boxes!
                </div>
                <a href="https://lpetrov.cc/lozenge-draw/" target="_blank" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); color: var(--slide-accent);">lpetrov.cc/lozenge-draw</a>
            </div>
        </div>
    </div>
</section>

<script>
(async function initThankYou() {
    // Wait for LozengeModule to be available (polling instead of event listener)
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }

    // Create isolated WASM instance for Thank You slide - completely separate from Title!
    const wasm = await LozengeModule();

    const letters = ['T', 'H', 'A', 'N', 'K', 'Y', 'O', 'U'];
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) {
        return { x: n, y: slope * n + j * deltaC };
    }

    // WASM interface (using our isolated instance)
    const initFromTrianglesWasm = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const performGlauberStepsWasm = wasm.cwrap('performGlauberSteps', 'number', ['number']);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeStringWasm = wasm.cwrap('freeString', null, ['number']);
    const setUseRandomSweepsWasm = wasm.cwrap('setUseRandomSweeps', null, ['number']);
    const setDimersWasm = wasm.cwrap('setDimers', 'number', ['number', 'number']);

    // Helper to restore dimers to WASM after reinit
    function restoreDimers(dimers) {
        if (!dimers || dimers.length === 0) return;
        // Convert to flat array: [bn, bj, wn, wj, type, ...]
        const arr = [];
        for (const d of dimers) {
            arr.push(d.bn, d.bj, d.wn, d.wj, d.t);
        }
        const dataPtr = wasm._malloc(arr.length * 4);
        for (let i = 0; i < arr.length; i++) {
            wasm.setValue(dataPtr + i * 4, arr[i], 'i32');
        }
        const ptr = setDimersWasm(dataPtr, arr.length);
        freeStringWasm(ptr);
        wasm._free(dataPtr);
    }

    // Store state for each letter
    const letterStates = [];

    // Load all letters
    for (const letter of letters) {
        const canvasId = `letter-${letter}`;
        const canvas = document.getElementById(canvasId);
        if (!canvas) continue;

        try {
            const response = await fetch(`/letters/${letter}.json`);
            if (!response.ok) continue;
            const data = await response.json();
            if (!data.triangles) continue;

            const triangles = new Map();
            const triangleArr = [];
            for (const t of data.triangles) {
                const type = t.type || t.t;
                triangles.set(`${t.n},${t.j},${type}`, { n: t.n, j: t.j, type });
                triangleArr.push(t.n, t.j, type);
            }

            // Calculate bounds
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const [, tri] of triangles) {
                let verts;
                if (tri.type === 1) {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
                } else {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j), getVertex(tri.n + 1, tri.j - 1)];
                }
                for (const v of verts) {
                    minX = Math.min(minX, v.x);
                    maxX = Math.max(maxX, v.x);
                    minY = Math.min(minY, v.y);
                    maxY = Math.max(maxY, v.y);
                }
            }

            letterStates.push({
                letter,
                canvas,
                ctx: canvas.getContext('2d'),
                triangles,
                triangleArr,
                dimers: [],
                bounds: { minX, maxX, minY, maxY }
            });
        } catch (e) {
            // Skip failed letters
        }
    }

    // Initialize each letter and get initial dimers
    for (const state of letterStates) {
        const dataPtr = wasm._malloc(state.triangleArr.length * 4);
        for (let i = 0; i < state.triangleArr.length; i++) {
            wasm.setValue(dataPtr + i * 4, state.triangleArr[i], 'i32');
        }
        const ptr = initFromTrianglesWasm(dataPtr, state.triangleArr.length);
        const jsonStr = wasm.UTF8ToString(ptr);
        freeStringWasm(ptr);
        wasm._free(dataPtr);

        const result = JSON.parse(jsonStr);
        if (result.status === 'valid') {
            setUseRandomSweepsWasm(1);
            const dPtr = exportDimersWasm();
            const dimerStr = wasm.UTF8ToString(dPtr);
            freeStringWasm(dPtr);
            const dimerResult = JSON.parse(dimerStr);
            state.dimers = Array.isArray(dimerResult) ? dimerResult : (dimerResult.dimers || []);
        }
    }

    // Draw function for a letter
    function drawLetter(state) {
        const { canvas, ctx, bounds, dimers } = state;
        const { minX, maxX, minY, maxY } = bounds;

        // Use fixed dimensions to prevent zoom issues
        const displayWidth = 200;
        const displayHeight = 260;
        const dpr = window.devicePixelRatio || 1;
        if (canvas.width !== displayWidth * dpr) {
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
        }
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        const regionWidth = maxX - minX;
        const regionHeight = maxY - minY;
        // Scale by HEIGHT only so all letters have same lozenge height (K aligns with others)
        const scale = (displayHeight / regionHeight) * 0.85;
        const centerX = displayWidth / 2 - ((minX + maxX) / 2) * scale;
        const centerY = displayHeight / 2 + ((minY + maxY) / 2) * scale;

        // Draw lozenges
        for (const d of dimers) {
            const bn = d.bn, bj = d.bj, t = d.t;
            let verts;
            if (t === 0) {
                verts = [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            } else if (t === 1) {
                verts = [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
            } else {
                verts = [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            }

            ctx.beginPath();
            const p0 = [centerX + verts[0].x * scale, centerY - verts[0].y * scale];
            ctx.moveTo(p0[0], p0[1]);
            for (let i = 1; i < 4; i++) {
                const p = [centerX + verts[i].x * scale, centerY - verts[i].y * scale];
                ctx.lineTo(p[0], p[1]);
            }
            ctx.closePath();
            ctx.fillStyle = colors[t];
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }

    // Initial draw
    for (const state of letterStates) {
        drawLetter(state);
    }

    // Animation: cycle through letters, updating one per frame
    // With isolated WASM instance, no need to reinit - just run Glauber on current state!
    let currentLetterIdx = 0;
    let isRunning = false;
    let animationId = null;

    function animate() {
        if (!isRunning) return;

        // Update current letter
        const state = letterStates[currentLetterIdx];
        if (state) {
            // Re-init WASM with this letter's triangles (still needed since we cycle through letters)
            const dataPtr = wasm._malloc(state.triangleArr.length * 4);
            for (let i = 0; i < state.triangleArr.length; i++) {
                wasm.setValue(dataPtr + i * 4, state.triangleArr[i], 'i32');
            }
            const ptr = initFromTrianglesWasm(dataPtr, state.triangleArr.length);
            freeStringWasm(ptr);
            wasm._free(dataPtr);

            // Restore previous dimers so Glauber continues from current state
            restoreDimers(state.dimers);

            setUseRandomSweepsWasm(1);

            // Run Glauber steps
            const stepPtr = performGlauberStepsWasm(10);
            freeStringWasm(stepPtr);

            // Export new dimers
            const dPtr = exportDimersWasm();
            const dimerStr = wasm.UTF8ToString(dPtr);
            freeStringWasm(dPtr);
            const dimerResult = JSON.parse(dimerStr);
            state.dimers = Array.isArray(dimerResult) ? dimerResult : (dimerResult.dimers || []);

            drawLetter(state);
        }

        currentLetterIdx = (currentLetterIdx + 1) % letterStates.length;
        animationId = requestAnimationFrame(animate);
    }

    function start() {
        if (isRunning) return;
        isRunning = true;
        animate();
    }

    function pause() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    // Register with slide engine - auto-start when slide is shown
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('thankyou', {
                start,
                pause,
                onSlideEnter() {
                    for (const state of letterStates) {
                        drawLetter(state);
                    }
                    start();
                }
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();
</script>

<!-- Global: Escape/Enter key blurs input fields for slide navigation -->
<script>
document.addEventListener('keydown', (e) => {
    if ((e.key === 'Escape' || e.key === 'Enter') && document.activeElement &&
        (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) {
        document.activeElement.blur();
        e.preventDefault();
    }
});
</script>
