---
layout: slides
title: "Random Surfaces from Stacking Cubes: A Visual Journey"
description: "Interactive talk on random lozenge tilings and their limit shapes"
---

<!-- ==================== Slide 1: Title ==================== -->
<section class="slide slide-center" id="title" data-title="Title" style="display: flex; flex-direction: column;">
    <h1 style="font-size: clamp(2.5rem, 3.5vw, 4rem); line-height: 1.2;">Random Surfaces from Stacking Cubes:<br><span style="font-style: italic;">A Visual Journey</span></h1>

    <p class="author" style="margin-top: 1vh; font-size: clamp(1.5rem, 2.5vw, 2.2rem);">Leonid Petrov</p>
    <p style="font-size: clamp(1.2rem, 2vw, 1.8rem); color: var(--slide-muted);">University of Virginia</p>

    <div style="flex: 1; display: flex; align-items: center; justify-content: center; min-height: 0;">
        <canvas id="title-canvas" width="1600" height="1200" style="cursor: pointer; height: 55vh; width: auto;"></canvas>
    </div>

    <!-- Funding acknowledgment logos -->
    <div style="position: absolute; bottom: 2vh; left: 2vw; display: flex; align-items: center; gap: 2vw;">
        <img src="images/nsf-logo.png" alt="NSF" style="height: 7.5vh;">
        <img src="images/simons-logo.svg" alt="Simons Foundation" style="height: 3vh;">
    </div>
</section>

<!-- Load simulation dependencies (colorschemes.js already loaded by slides layout) -->
<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>

<!-- Dynamic WASM loader: use threaded version if SharedArrayBuffer is available -->
<script>
window.VISUAL_THREADED = typeof SharedArrayBuffer !== 'undefined';
window.VISUAL_WEBGPU = !!navigator.gpu;

// Load WASM module dynamically (no document.write)
function loadScript(src) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

const wasmSrc = '/talk/visual/sim/visual-lozenge' + (window.VISUAL_THREADED ? '-threaded' : '') + '.js';
loadScript(wasmSrc).then(() => {
    // Load WebGPU lozenge engine for GPU CFTP
    loadScript('/js/webgpu-lozenge-engine.js').catch(e => console.log('WebGPU engine not available'));
    window.dispatchEvent(new Event('wasm-loaded'));
});
</script>

<script>
window.addEventListener('wasm-loaded', async function() {
    // Wait for LozengeModule factory to be available
    if (typeof LozengeModule === 'undefined') {
        console.error('LozengeModule not loaded');
        return;
    }

    // Create isolated WASM instance for Title slide
    const wasm = await LozengeModule();

    // Triangular lattice constants (for equilateral triangles)
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) {
        return { x: n, y: slope * n + j * deltaC };
    }

    // WASM interface (using our isolated instance)
    const initFromTrianglesWasm = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const performGlauberStepsWasm = wasm.cwrap('performGlauberSteps', 'number', ['number']);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeStringWasm = wasm.cwrap('freeString', null, ['number']);
    const setUseRandomSweepsWasm = wasm.cwrap('setUseRandomSweeps', null, ['number']);

    // Color palette (UVA)
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    // Simulation state
    let activeTriangles = new Map();
    let dimers = [];
    let isValid = false;

    // Load Rotunda preset
    try {
        const response = await fetch('/letters/Rotunda.json');
        if (response.ok) {
            const data = await response.json();
            if (data.triangles) {
                for (const t of data.triangles) {
                    const type = t.type || t.t;
                    activeTriangles.set(`${t.n},${t.j},${type}`, { n: t.n, j: t.j, type });
                }

                // Initialize WASM region
                const arr = [];
                for (const [key, tri] of activeTriangles) {
                    arr.push(tri.n, tri.j, tri.type);
                }

                if (arr.length > 0) {
                    const dataPtr = wasm._malloc(arr.length * 4);
                    for (let i = 0; i < arr.length; i++) {
                        wasm.setValue(dataPtr + i * 4, arr[i], 'i32');
                    }

                    const ptr = initFromTrianglesWasm(dataPtr, arr.length);
                    const jsonStr = wasm.UTF8ToString(ptr);
                    freeStringWasm(ptr);
                    wasm._free(dataPtr);

                    const result = JSON.parse(jsonStr);
                    isValid = result.status === 'valid';

                    if (isValid) {
                        setUseRandomSweepsWasm(1);
                        // Export initial dimers so we can show lozenges on load
                        const dPtr = exportDimersWasm();
                        const jsonStr = wasm.UTF8ToString(dPtr);
                        freeStringWasm(dPtr);
                        const result = JSON.parse(jsonStr);
                        const dimerArr = Array.isArray(result) ? result : (result.dimers || []);
                        dimers.push(...dimerArr);
                    }
                }
            }
        }
    } catch (e) {
        // Failed to load preset
    }

    // High-DPI canvas for crisp rendering (2x resolution for 1920x1080 projector)
    const canvas = document.getElementById('title-canvas');
    const ctx = canvas.getContext('2d');
    const displayWidth = 800, displayHeight = 600;  // 55vh at 1080p ≈ 600px
    const dpr = 2; // 2x for retina/crisp rendering

    // Simulation state
    let isRunning = false;
    let animationId = null;

    // Pre-calculate transform (bounds don't change)
    let scale, centerX, centerY;
    function calcTransform() {
        if (!activeTriangles || activeTriangles.size === 0) return;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const [, tri] of activeTriangles) {
            let verts;
            if (tri.type === 1) {
                verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
            } else {
                verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j), getVertex(tri.n + 1, tri.j - 1)];
            }
            for (const v of verts) {
                minX = Math.min(minX, v.x);
                maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y);
                maxY = Math.max(maxY, v.y);
            }
        }
        const regionWidth = maxX - minX;
        const regionHeight = maxY - minY;
        scale = Math.min(displayWidth / regionWidth, displayHeight / regionHeight) * 0.85;
        centerX = displayWidth / 2 - ((minX + maxX) / 2) * scale;
        centerY = displayHeight / 2 + ((minY + maxY) / 2) * scale;
    }
    calcTransform();

    function draw() {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        if (!activeTriangles || activeTriangles.size === 0) return;

        // Draw lozenges
        if (Array.isArray(dimers) && dimers.length > 0) {
            for (const d of dimers) {
                const bn = d.bn, bj = d.bj, t = d.t;
                let verts;
                if (t === 0) {
                    verts = [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                } else if (t === 1) {
                    verts = [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
                } else {
                    verts = [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                }

                ctx.beginPath();
                ctx.moveTo(centerX + verts[0].x * scale, centerY - verts[0].y * scale);
                for (let i = 1; i < 4; i++) {
                    ctx.lineTo(centerX + verts[i].x * scale, centerY - verts[i].y * scale);
                }
                ctx.closePath();
                ctx.fillStyle = colors[t];
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
        } else {
            // Draw triangles (shape outline)
            for (const [, tri] of activeTriangles) {
                const n = tri.n, j = tri.j, type = tri.type;
                let verts;
                if (type === 1) {
                    verts = [getVertex(n, j), getVertex(n, j - 1), getVertex(n + 1, j - 1)];
                } else {
                    verts = [getVertex(n, j), getVertex(n + 1, j), getVertex(n + 1, j - 1)];
                }

                ctx.beginPath();
                ctx.moveTo(centerX + verts[0].x * scale, centerY - verts[0].y * scale);
                for (let i = 1; i < 3; i++) {
                    ctx.lineTo(centerX + verts[i].x * scale, centerY - verts[i].y * scale);
                }
                ctx.closePath();
                ctx.fillStyle = type === 1 ? '#232D4B' : '#F9DCBF';
                ctx.fill();
            }
        }
    }

    function animate() {
        if (!isValid || !isRunning) return;

        // Run Glauber steps
        const ptr = performGlauberStepsWasm(10000);
        freeStringWasm(ptr);

        // Refresh dimers
        const dPtr = exportDimersWasm();
        const jsonStr = wasm.UTF8ToString(dPtr);
        freeStringWasm(dPtr);
        const result = JSON.parse(jsonStr);
        dimers = Array.isArray(result) ? result : (result.dimers || []);

        draw();
        animationId = requestAnimationFrame(animate);
    }

    function startSim() {
        if (!isRunning) {
            isRunning = true;
            animate();
        }
    }

    function pauseSim() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    // Click to toggle
    canvas.addEventListener('click', () => {
        if (isRunning) pauseSim();
        else startSim();
    });

    // Initial draw
    draw();

    // Register with slide engine for step control
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('title', {
                start: startSim,
                pause: pauseSim
            }, 1);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
});
</script>

<!-- ==================== PART 0: How Nature Creates Shape ==================== -->

<section class="slide slide-top" id="nature-builds" data-title="How Nature Makes Shape">
    <h2 class="slide-title">How Nature Makes Shape?</h2>

    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: clamp(1rem, 3vw, 4rem); margin-top: 2vh; align-items: start;">
        <!-- Left column: Salt crystal images -->
        <div>
            <p style="text-align: left; margin-bottom: 2vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Salt — same substance with cubic crystal structure, at different scales and growth conditions</p>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: clamp(0.5rem, 1vw, 1rem);">
                <figure style="margin: 0;">
                    <img src="images/salt-micro-public-domain.jpg" alt="Salt crystals microscopic" style="width: 100%; height: 28vh; object-fit: cover; border-radius: 4px;">
                    <figcaption><strong style="color: var(--slide-navy);">Microscopic</strong> · Public domain</figcaption>
                </figure>
                <figure style="margin: 0;">
                    <img src="images/salt-halite-doronenko-cc-by-3.jpg" alt="Hopper salt crystal" style="width: 100%; height: 28vh; object-fit: cover; border-radius: 4px;">
                    <figcaption><strong style="color: var(--slide-navy);">Mesoscopic</strong> · Doronenko, CC BY 3.0</figcaption>
                </figure>
                <figure style="margin: 0;">
                    <img src="images/salt-halite-lavinsky-irocks-cc-by-sa-3.jpg" alt="Halite crystal" style="width: 100%; height: 28vh; object-fit: cover; border-radius: 4px;">
                    <figcaption><strong style="color: var(--slide-navy);">Mesoscopic</strong> · Lavinsky, CC BY-SA 3.0</figcaption>
                </figure>
                <figure style="margin: 0;">
                    <div style="overflow: hidden; border-radius: 4px; height: 28vh;">
                        <img src="images/salt-smooth-deadsea-xta11-cc-by-sa-4.jpg" alt="Smooth salt formation" style="width: 100%; height: 100%; object-fit: cover; transform: scale(1.5); transform-origin: right bottom;">
                    </div>
                    <figcaption><strong style="color: var(--slide-navy);">Macroscopic</strong> · xta11, CC BY-SA 4.0</figcaption>
                </figure>
            </div>
        </div>

        <!-- Right column: Crystal growth simulation -->
        <div>
            <p style="text-align: left; margin-bottom: 2vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Mathematical (random) crystal growth<br><span style="visibility: hidden;">phantom</span></p>
            <div style="position: relative; display: inline-block; width: 100%;">
                <canvas id="crystal-growth-canvas" style="width: 100%; height: 62vh; border-radius: 8px;"></canvas>
                <button id="crystal-play-btn" style="position: absolute; bottom: 1vh; right: 1vh; width: 4vh; height: 4vh; border-radius: 50%; border: none; background: rgba(35, 45, 75, 0.8); color: white; font-size: clamp(0.9rem, 1.5vw, 1.2rem); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: opacity 0.3s;">▶</button>
            </div>
        </div>
    </div>

    <p id="nature-builds-question" style="font-size: clamp(1.5rem, 2.8vw, 2.2rem); margin-top: 3vh; text-align: center; font-style: italic; color: var(--slide-navy); opacity: 0; transition: opacity 0.3s;">When can a random pile of cubes become smooth?</p>
</section>

<script>
// 3D Hexagon Glauber simulation - Complete JS port of ultimate-lozenge.cpp
(function initCrystalSim() {
    if (!window.slideEngine) {
        setTimeout(initCrystalSim, 50);
        return;
    }
    const canvas = document.getElementById('crystal-growth-canvas');
    if (!canvas) return;

    // ===== LOZENGE TILING ENGINE (ported from C++) =====
    const hexSide = 100;

    // Triangular lattice constants
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    // Dimer grid and bounds
    let dimerGrid = [];
    let gridMinN, gridMaxN, gridMinJ, gridMaxJ, gridStrideJ;

    // Triangle storage
    const blackTriangles = [];
    const whiteTriangles = [];
    const blackMap = new Map();
    const whiteMap = new Map();
    const triangularVertices = [];

    // Helpers
    function makeKey(n, j) { return `${n},${j}`; }
    function getGridIdx(n, j) { return (n - gridMinN) * gridStrideJ + (j - gridMinJ); }
    function getVertex(n, j) { return { x: n, y: slope * n + j * deltaC }; }

    function getRightTriangleCentroid(n, j) {
        const v1 = getVertex(n, j), v2 = getVertex(n, j - 1), v3 = getVertex(n + 1, j - 1);
        return { x: (v1.x + v2.x + v3.x) / 3, y: (v1.y + v2.y + v3.y) / 3 };
    }
    function getLeftTriangleCentroid(n, j) {
        const v1 = getVertex(n, j), v2 = getVertex(n + 1, j), v3 = getVertex(n + 1, j - 1);
        return { x: (v1.x + v2.x + v3.x) / 3, y: (v1.y + v2.y + v3.y) / 3 };
    }

    function getDimerType(blackN, blackJ, whiteN, whiteJ) {
        const dn = whiteN - blackN, dj = whiteJ - blackJ;
        if (dn === 0 && dj === 0) return 0;
        if (dn === 0 && dj === -1) return 1;
        if (dn === -1 && dj === 0) return 2;
        return -1;
    }

    function getWhiteFromType(blackN, blackJ, type) {
        if (type === 0) return [blackN, blackJ];
        if (type === 1) return [blackN, blackJ - 1];
        if (type === 2) return [blackN - 1, blackJ];
        return [blackN, blackJ];
    }

    function pointInPolygon(x, y, polygon) {
        if (polygon.length < 3) return false;
        let inside = false;
        for (let i = 0, pj = polygon.length - 1; i < polygon.length; pj = i++) {
            const xi = polygon[i].x, yi = polygon[i].y;
            const xj = polygon[pj].x, yj = polygon[pj].y;
            if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    }

    // ===== DINIC'S MAX-FLOW (ported from C++) =====
    let flowAdj = [];
    let level = [];
    let ptr = [];

    function addFlowEdge(from, to, cap) {
        flowAdj[from].push({ to, cap, flow: 0, rev: flowAdj[to].length });
        flowAdj[to].push({ to: from, cap: 0, flow: 0, rev: flowAdj[from].length - 1 });
    }

    function bfsFlow(s, t) {
        level.fill(-1);
        level[s] = 0;
        const q = [s];
        let head = 0;
        while (head < q.length) {
            const v = q[head++];
            for (const edge of flowAdj[v]) {
                if (edge.cap - edge.flow > 0 && level[edge.to] === -1) {
                    level[edge.to] = level[v] + 1;
                    q.push(edge.to);
                }
            }
        }
        return level[t] !== -1;
    }

    function dfsFlow(v, t, pushed) {
        if (pushed === 0) return 0;
        if (v === t) return pushed;
        for (; ptr[v] < flowAdj[v].length; ptr[v]++) {
            const edge = flowAdj[v][ptr[v]];
            if (level[v] + 1 !== level[edge.to] || edge.cap - edge.flow === 0) continue;
            const push = dfsFlow(edge.to, t, Math.min(pushed, edge.cap - edge.flow));
            if (push === 0) continue;
            edge.flow += push;
            flowAdj[edge.to][edge.rev].flow -= push;
            return push;
        }
        return 0;
    }

    function dinic(s, t) {
        let flow = 0;
        while (bfsFlow(s, t)) {
            ptr.fill(0);
            let pushed;
            while ((pushed = dfsFlow(s, t, Infinity)) > 0) {
                flow += pushed;
            }
        }
        return flow;
    }

    // ===== HEX EDGES FOR GLAUBER =====
    function getHexEdgesAroundVertex(n, j) {
        return [
            { blackN: n, blackJ: j+1, whiteN: n, whiteJ: j, type: 1 },
            { blackN: n, blackJ: j, whiteN: n, whiteJ: j, type: 0 },
            { blackN: n, blackJ: j, whiteN: n-1, whiteJ: j, type: 2 },
            { blackN: n-1, blackJ: j+1, whiteN: n-1, whiteJ: j, type: 1 },
            { blackN: n-1, blackJ: j+1, whiteN: n-1, whiteJ: j+1, type: 0 },
            { blackN: n, blackJ: j+1, whiteN: n-1, whiteJ: j+1, type: 2 }
        ];
    }

    function dimerExists(blackN, blackJ, whiteN, whiteJ) {
        if (blackN < gridMinN || blackN > gridMaxN || blackJ < gridMinJ || blackJ > gridMaxJ) return false;
        const idx = getGridIdx(blackN, blackJ);
        if (idx < 0 || idx >= dimerGrid.length) return false;
        const typeInGrid = dimerGrid[idx];
        if (typeInGrid === -1) return false;
        return typeInGrid === getDimerType(blackN, blackJ, whiteN, whiteJ);
    }

    const qParam = 0;  // q=0 means pure removal, never add cubes

    function tryRotation(n, j, execute) {
        const edges = getHexEdgesAroundVertex(n, j);
        const coveredIdx = [], uncoveredIdx = [];

        for (let i = 0; i < 6; i++) {
            const e = edges[i];
            if (dimerExists(e.blackN, e.blackJ, e.whiteN, e.whiteJ)) {
                if (coveredIdx.length < 3) coveredIdx.push(i);
                else return 0;
            } else {
                if (uncoveredIdx.length < 3) uncoveredIdx.push(i);
                else return 0;
            }
        }

        if (coveredIdx.length !== 3 || uncoveredIdx.length !== 3) return 0;

        if (!execute) return 1;

        // q-weighted acceptance: covered sum 6 = {0,2,4}, sum 9 = {1,3,5}
        // Going from sum=9 to sum=6 adds cube, sum=6 to sum=9 removes
        const coveredSum = coveredIdx[0] + coveredIdx[1] + coveredIdx[2];
        const addingCube = (coveredSum === 9);  // {1,3,5} -> {0,2,4}
        if (addingCube && Math.random() > qParam) return 0;  // reject add with prob 1 - q
        if (!addingCube && qParam > 0 && Math.random() > 1 / qParam) return 0;  // reject remove with prob 1 - 1/q

        for (const idx of coveredIdx) {
            const e = edges[idx];
            if (e.blackN >= gridMinN && e.blackN <= gridMaxN && e.blackJ >= gridMinJ && e.blackJ <= gridMaxJ) {
                const gridIdx = getGridIdx(e.blackN, e.blackJ);
                if (gridIdx >= 0 && gridIdx < dimerGrid.length) dimerGrid[gridIdx] = -1;
            }
        }
        for (const idx of uncoveredIdx) {
            const e = edges[idx];
            if (e.blackN < gridMinN || e.blackN > gridMaxN || e.blackJ < gridMinJ || e.blackJ > gridMaxJ) continue;
            if (blackMap.has(makeKey(e.blackN, e.blackJ)) && whiteMap.has(makeKey(e.whiteN, e.whiteJ))) {
                const gridIdx = getGridIdx(e.blackN, e.blackJ);
                if (gridIdx >= 0 && gridIdx < dimerGrid.length) dimerGrid[gridIdx] = e.type;
            }
        }
        return 1;
    }

    // ===== INITIALIZATION WITH MAX-FLOW =====
    function initHexagon() {
        blackTriangles.length = 0;
        whiteTriangles.length = 0;
        blackMap.clear();
        whiteMap.clear();
        triangularVertices.length = 0;

        const N = hexSide;

        // Generate hexagon boundary
        const directions = [[1, -1], [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1]];
        const boundary = [];
        let bn = 0, bj = 0;
        for (let dir = 0; dir < 6; dir++) {
            for (let step = 0; step < N; step++) {
                boundary.push(getVertex(bn, bj));
                bn += directions[dir][0];
                bj += directions[dir][1];
            }
        }

        // Bounding box
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const v of boundary) {
            minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
            minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
        }
        const searchMinN = Math.floor(minX) - 2;
        const searchMaxN = Math.ceil(maxX) + 2;
        const nRange = searchMaxN - searchMinN;
        const searchMinJ = Math.floor(minY / deltaC) - nRange - 5;
        const searchMaxJ = Math.ceil(maxY / deltaC) + nRange + 5;

        // Generate triangles
        for (let n = searchMinN; n <= searchMaxN; n++) {
            for (let j = searchMinJ; j <= searchMaxJ; j++) {
                const rc = getRightTriangleCentroid(n, j);
                if (pointInPolygon(rc.x, rc.y, boundary)) {
                    blackMap.set(makeKey(n, j), blackTriangles.length);
                    blackTriangles.push({ n, j });
                }
                const lc = getLeftTriangleCentroid(n, j);
                if (pointInPolygon(lc.x, lc.y, boundary)) {
                    whiteMap.set(makeKey(n, j), whiteTriangles.length);
                    whiteTriangles.push({ n, j });
                }
            }
        }

        // Grid setup
        gridMinN = searchMinN - 2; gridMaxN = searchMaxN + 2;
        gridMinJ = searchMinJ - 2; gridMaxJ = searchMaxJ + 2;
        gridStrideJ = gridMaxJ - gridMinJ + 1;
        dimerGrid = new Array((gridMaxN - gridMinN + 1) * gridStrideJ).fill(-1);

        // ===== DINIC'S MAX-FLOW FOR PERFECT MATCHING =====
        const numBlack = blackTriangles.length;
        const numWhite = whiteTriangles.length;
        const S = numBlack + numWhite;  // Source
        const T = S + 1;                 // Sink

        flowAdj = Array.from({ length: T + 1 }, () => []);
        level = new Array(T + 1).fill(-1);
        ptr = new Array(T + 1).fill(0);

        // Source -> black triangles
        for (let i = 0; i < numBlack; i++) {
            addFlowEdge(S, i, 1);
        }

        // White triangles -> sink
        for (let i = 0; i < numWhite; i++) {
            addFlowEdge(numBlack + i, T, 1);
        }

        // Black -> white neighbors (3 possible neighbors per black)
        for (let i = 0; i < numBlack; i++) {
            const bt = blackTriangles[i];
            const neighbors = [
                [bt.n, bt.j],        // Type 0
                [bt.n, bt.j - 1],    // Type 1
                [bt.n - 1, bt.j]     // Type 2
            ];
            for (const [wn, wj] of neighbors) {
                const wKey = makeKey(wn, wj);
                if (whiteMap.has(wKey)) {
                    addFlowEdge(i, numBlack + whiteMap.get(wKey), 1);
                }
            }
        }

        // Run Dinic's algorithm
        const maxFlow = dinic(S, T);

        // Extract matching from flow
        for (let i = 0; i < numBlack; i++) {
            for (const edge of flowAdj[i]) {
                if (edge.to >= numBlack && edge.to < S && edge.flow === 1) {
                    const wIdx = edge.to - numBlack;
                    const bt = blackTriangles[i];
                    const wt = whiteTriangles[wIdx];
                    const type = getDimerType(bt.n, bt.j, wt.n, wt.j);
                    const gridIdx = getGridIdx(bt.n, bt.j);
                    if (gridIdx >= 0 && gridIdx < dimerGrid.length) {
                        dimerGrid[gridIdx] = type;
                    }
                    break;
                }
            }
        }

        // Build triangular vertices
        const vertexSet = new Set();
        for (const bt of blackTriangles) {
            vertexSet.add(makeKey(bt.n, bt.j));
            vertexSet.add(makeKey(bt.n, bt.j - 1));
            vertexSet.add(makeKey(bt.n + 1, bt.j - 1));
        }
        for (const wt of whiteTriangles) {
            vertexSet.add(makeKey(wt.n, wt.j));
            vertexSet.add(makeKey(wt.n + 1, wt.j));
            vertexSet.add(makeKey(wt.n + 1, wt.j - 1));
        }
        for (const key of vertexSet) {
            const [n, j] = key.split(',').map(Number);
            triangularVertices.push({ n, j });
        }

    }

    function glauberSteps(count) {
        const N = triangularVertices.length;
        if (N === 0) return;
        for (let s = 0; s < count; s++) {
            const idx = Math.floor(Math.random() * N);
            const v = triangularVertices[idx];
            tryRotation(v.n, v.j, true);
        }
    }

    function exportDimers() {
        const dimers = [];
        for (const bt of blackTriangles) {
            const gridIdx = getGridIdx(bt.n, bt.j);
            if (gridIdx >= 0 && gridIdx < dimerGrid.length) {
                const type = dimerGrid[gridIdx];
                if (type !== -1) {
                    const [wn, wj] = getWhiteFromType(bt.n, bt.j, type);
                    dimers.push({ bn: bt.n, bj: bt.j, wn, wj, t: type });
                }
            }
        }
        return dimers;
    }

    // ===== THREE.JS RENDERING (LAZY LOADED) =====
    let scene = null;
    let renderer = null;
    let camera = null;
    let controls = null;
    let meshGroup = null;
    let aspect = 1;

    function initThreeJS() {
        if (renderer) return;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        aspect = canvas.clientWidth / canvas.clientHeight || 1;
        camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 5000);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false;
        controls.enablePan = true;
        controls.enableZoom = true;

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.35));
        const hemi = new THREE.HemisphereLight(0x6666aa, 0x222244, 0.25);
        hemi.position.set(0, 20, 0);
        scene.add(hemi);
        const directional = new THREE.DirectionalLight(0xffffff, 1.2);
        directional.position.set(15, 20, 5);
        scene.add(directional);
        const fill = new THREE.DirectionalLight(0xffffff, 0.3);
        fill.position.set(-10, 5, -5);
        scene.add(fill);

        meshGroup = new THREE.Group();
        scene.add(meshGroup);

        camera.position.set(10.2, -110.4, -10.8);
        controls.target.set(-13.4, -89.2, 12.4);
        controls.update();

        // Listen for controls changes
        controls.addEventListener('change', () => {
            if (!isRunning && !isCameraAnimating && renderer) renderer.render(scene, camera);
        });

        resize();
    }

    function disposeThreeJS() {
        if (!renderer) return;

        if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
        if (cameraAnimationId) { cancelAnimationFrame(cameraAnimationId); cameraAnimationId = null; }
        isRunning = false;
        isCameraAnimating = false;

        if (meshGroup) {
            while (meshGroup.children.length > 0) {
                const child = meshGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                meshGroup.remove(child);
            }
        }

        renderer.dispose();
        renderer = null;
        scene = null;
        camera = null;
        controls = null;
        meshGroup = null;
    }

    function resize() {
        if (!renderer || !camera) return;
        const w = canvas.clientWidth, h = canvas.clientHeight;
        if (w === 0 || h === 0) return;
        renderer.setSize(w, h, false);
        aspect = w / h;
        camera.aspect = aspect;
        camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);

    const colors = ['#FFFFFF', '#FFFFFF', '#FFFFFF'];
    let isRunning = false;
    let animationId = null;

    // Vertex keys for each dimer type (same as before)
    function getVertexKeys(dimer) {
        const { bn, bj, t } = dimer;
        if (t === 0) return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
        if (t === 1) return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
        return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
    }

    function getHeightPattern(t) {
        if (t === 0) return [0, 0, 0, 0];
        if (t === 1) return [1, 0, 0, 1];
        return [1, 1, 0, 0];
    }

    function to3D(n, j, h) {
        return { x: h, y: -n - h, z: j - h };
    }

    function buildGeometry() {
        if (!meshGroup) return;

        while (meshGroup.children.length > 0) {
            const child = meshGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
            meshGroup.remove(child);
        }

        const dimers = exportDimers();
        if (dimers.length === 0) return;

        // Build vertex-to-dimer map and calculate heights via BFS
        const vertexToDimers = new Map();
        for (const dimer of dimers) {
            for (const [n, j] of getVertexKeys(dimer)) {
                const key = `${n},${j}`;
                if (!vertexToDimers.has(key)) vertexToDimers.set(key, []);
                vertexToDimers.get(key).push(dimer);
            }
        }

        const heights = new Map();
        const firstVerts = getVertexKeys(dimers[0]);
        const startKey = `${firstVerts[0][0]},${firstVerts[0][1]}`;
        heights.set(startKey, 0);

        const queue = [startKey];
        const visited = new Set();

        while (queue.length > 0) {
            const currentKey = queue.shift();
            if (visited.has(currentKey)) continue;
            visited.add(currentKey);

            const currentH = heights.get(currentKey);
            const [cn, cj] = currentKey.split(',').map(Number);

            for (const dimer of vertexToDimers.get(currentKey) || []) {
                const verts = getVertexKeys(dimer);
                const pattern = getHeightPattern(dimer.t);
                const myIdx = verts.findIndex(([vn, vj]) => vn === cn && vj === cj);
                if (myIdx >= 0) {
                    for (let i = 0; i < 4; i++) {
                        const vkey = `${verts[i][0]},${verts[i][1]}`;
                        if (!heights.has(vkey)) {
                            heights.set(vkey, currentH + (pattern[i] - pattern[myIdx]));
                            queue.push(vkey);
                        }
                    }
                }
            }
        }

        const geometry = new THREE.BufferGeometry();
        const vertices = [], normals = [], vertexColors = [], indices = [];

        function addQuad(v1, v2, v3, v4, color) {
            const baseIndex = vertices.length / 3;
            vertices.push(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z, v4.x, v4.y, v4.z);
            const edge1 = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
            const edge2 = { x: v4.x - v1.x, y: v4.y - v1.y, z: v4.z - v1.z };
            const nx = edge1.y * edge2.z - edge1.z * edge2.y;
            const ny = edge1.z * edge2.x - edge1.x * edge2.z;
            const nz = edge1.x * edge2.y - edge1.y * edge2.x;
            const len = Math.sqrt(nx*nx + ny*ny + nz*nz) || 1;
            for (let i = 0; i < 4; i++) normals.push(nx/len, ny/len, nz/len);
            const c = new THREE.Color(color);
            for (let i = 0; i < 4; i++) vertexColors.push(c.r, c.g, c.b);
            indices.push(baseIndex, baseIndex+1, baseIndex+2, baseIndex, baseIndex+2, baseIndex+3);
        }

        for (const dimer of dimers) {
            const verts = getVertexKeys(dimer);
            const v3d = verts.map(([n, j]) => to3D(n, j, heights.get(`${n},${j}`) || 0));
            addQuad(v3d[0], v3d[1], v3d[2], v3d[3], colors[dimer.t]);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
        geometry.setIndex(indices);

        const material = new THREE.MeshStandardMaterial({
            vertexColors: true, side: THREE.DoubleSide, flatShading: true, roughness: 0.3, metalness: 0.5
        });
        meshGroup.add(new THREE.Mesh(geometry, material));

        if (!isRunning) {
            const edgesGeometry = new THREE.EdgesGeometry(geometry, 10);
            meshGroup.add(new THREE.LineSegments(edgesGeometry, new THREE.LineBasicMaterial({ color: 0x222222, opacity: 0.6, transparent: true })));
        }
    }

    // Initialize hexagon shape (not Three.js - that's lazy loaded)
    initHexagon();

    function animate() {
        if (!isRunning || !renderer || !controls) return;
        glauberSteps(15000);
        buildGeometry();
        controls.update();
        renderer.render(scene, camera);
        animationId = requestAnimationFrame(animate);
    }

    const playBtn = document.getElementById('crystal-play-btn');

    function updatePlayBtn() {
        playBtn.textContent = isRunning ? '⏸' : '▶';
    }

    function start() {
        if (!isRunning) { isRunning = true; updatePlayBtn(); animate(); }
    }

    function pause() {
        isRunning = false;
        if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
        updatePlayBtn();
        buildGeometry();
        if (renderer) renderer.render(scene, camera);
    }

    function toggle() {
        if (isRunning) pause(); else start();
    }

    playBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggle();
    });

    // Camera animation (end is 2x farther from target)
    const cameraStart = { x: 10.2, y: -110.4, z: -10.8 };
    const cameraEnd = { x: 39.6, y: -140.4, z: 39.6 };
    let isCameraAnimating = false;
    let cameraAnimationId = null;

    function animateCamera(duration = 3000) {
        if (!camera || !controls || !renderer) return;
        const startTime = performance.now();
        const startPos = { ...cameraStart };
        isCameraAnimating = true;

        function tick() {
            if (!camera || !controls || !renderer) { isCameraAnimating = false; return; }
            const elapsed = performance.now() - startTime;
            const t = Math.min(elapsed / duration, 1);
            // Smooth easing (ease-in-out)
            const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

            camera.position.x = startPos.x + (cameraEnd.x - startPos.x) * ease;
            camera.position.y = startPos.y + (cameraEnd.y - startPos.y) * ease;
            camera.position.z = startPos.z + (cameraEnd.z - startPos.z) * ease;
            controls.update();
            renderer.render(scene, camera);

            if (t < 1) {
                cameraAnimationId = requestAnimationFrame(tick);
            } else {
                isCameraAnimating = false;
            }
        }
        tick();
    }

    function resetCamera() {
        if (cameraAnimationId) cancelAnimationFrame(cameraAnimationId);
        isCameraAnimating = false;
        if (!camera || !controls || !renderer) return;
        camera.position.set(cameraStart.x, cameraStart.y, cameraStart.z);
        controls.update();
        renderer.render(scene, camera);
    }

    const questionEl = document.getElementById('nature-builds-question');

    // 4 steps: 1=start, 2=stop, 3=camera transition, 4=text
    window.slideEngine.registerSimulation('nature-builds', {
        start, pause, steps: 4,
        onSlideEnter() {
            // Lazy init WebGL to avoid context limit
            initThreeJS();
            setTimeout(() => {
                resize();
                if (renderer) renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
                buildGeometry();
                if (controls) controls.update();
                if (renderer) renderer.render(scene, camera);
                requestAnimationFrame(() => { resize(); if (renderer) renderer.render(scene, camera); });
            }, 50);
        },
        onSlideLeave() {
            // Dispose WebGL context to free resources
            disposeThreeJS();
            questionEl.style.opacity = '0';
        },
        onStep(step) {
            if (step === 1) { start(); }
            else if (step === 2) { pause(); }
            else if (step === 3) { animateCamera(3000); }
            else if (step === 4) { questionEl.style.opacity = '1'; }
        },
        onStepBack(step) {
            if (step === 0) { pause(); initHexagon(); buildGeometry(); resetCamera(); questionEl.style.opacity = '0'; }
            else if (step === 1) { start(); questionEl.style.opacity = '0'; }
            else if (step === 2) { resetCamera(); questionEl.style.opacity = '0'; }
            else if (step === 3) { questionEl.style.opacity = '0'; }
        }
    }, 1);
})();
</script>

<!-- ==================== PART 1: The 2D Warm-Up ==================== -->

<section class="slide slide-center" id="part1-intro" data-title="Part 1: 2D">
    <h2 style="font-size: clamp(3rem, 5vw, 5.5rem);">Part I</h2>
    <h3 style="font-size: clamp(3rem, 5vw, 5.5rem); color: var(--slide-muted); text-transform: uppercase; letter-spacing: 0.05em;">The 2D Warm-Up</h3>
</section>

<section class="slide" id="grid-paths" data-title="Grid Paths">
    <h2 class="slide-title">Paths on a Grid</h2>
    <div style="display: grid; grid-template-columns: 1fr 1.5fr; gap: 3vw; align-items: start; margin-top: 2vh;">
        <!-- Left column: grid visual, text and formula -->
        <div>
            <canvas id="grid-demo-canvas" width="400" height="400" style="width: 30vw; height: 30vw; max-width: 350px; max-height: 350px; margin-bottom: 2vh;"></canvas>
            <p style="font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Start at (0, 0), end at (a, b)</p>
            <p style="font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Move only right (R) or up (U)</p>
            <p style="margin-top: 2vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">How many paths exist?</p>
            <div id="grid-paths-answer" style="margin-top: 3vh; opacity: 0; transition: opacity 0.3s;">
                <p style="font-size: clamp(1.5rem, 2.5vw, 2rem); color: var(--uva-orange);">
                    \(\displaystyle\binom{a+b}{a} = \frac{(a+b)!}{a!\, b!}\)
                </p>
                <p style="font-size: clamp(1rem, 1.8vw, 1.4rem); color: var(--slide-muted); margin-top: 1vh;">
                    \(n! = n \times (n-1) \times \cdots \times 2 \times 1\)
                </p>
            </div>
        </div>
        <!-- Right column: simulation -->
        <div id="grid-paths-sim" style="opacity: 0; transition: opacity 0.3s;">
            <div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 1vh;">
                <label style="font-size: clamp(0.9rem, 1.5vw, 1.1rem);">a = <input type="number" id="path-a" value="2" min="1" max="7" style="width: 3rem; font-size: 1rem;"></label>
                <label style="font-size: clamp(0.9rem, 1.5vw, 1.1rem);">b = <input type="number" id="path-b" value="2" min="1" max="7" style="width: 3rem; font-size: 1rem;"></label>
                <span id="path-count" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); color: var(--uva-orange); margin-left: 1rem;"></span>
            </div>
            <canvas id="paths-canvas" width="700" height="500" style="width: 100%; height: auto;"></canvas>
        </div>
    </div>
</section>

<script>
(function() {
    const canvas = document.getElementById('paths-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const inputA = document.getElementById('path-a');
    const inputB = document.getElementById('path-b');
    const countSpan = document.getElementById('path-count');
    const simDiv = document.getElementById('grid-paths-sim');
    const answerDiv = document.getElementById('grid-paths-answer');

    // Draw grid demo in left column
    const gridCanvas = document.getElementById('grid-demo-canvas');
    const gridCtx = gridCanvas.getContext('2d');
    function drawGridDemo() {
        const w = gridCanvas.width, h = gridCanvas.height;
        const padding = 30;
        const gridSize = 4;
        const stepX = (w - 2 * padding) / gridSize;
        const stepY = (h - 2 * padding) / gridSize;

        gridCtx.fillStyle = '#fff';
        gridCtx.fillRect(0, 0, w, h);

        // Draw grid lines
        gridCtx.strokeStyle = '#999';
        gridCtx.lineWidth = 2;
        for (let i = 0; i <= gridSize; i++) {
            gridCtx.beginPath();
            gridCtx.moveTo(padding + i * stepX, padding);
            gridCtx.lineTo(padding + i * stepX, h - padding);
            gridCtx.stroke();
            gridCtx.beginPath();
            gridCtx.moveTo(padding, padding + i * stepY);
            gridCtx.lineTo(w - padding, padding + i * stepY);
            gridCtx.stroke();
        }

        // Draw dots
        gridCtx.fillStyle = '#232D4B';
        for (let i = 0; i <= gridSize; i++) {
            for (let j = 0; j <= gridSize; j++) {
                gridCtx.beginPath();
                gridCtx.arc(padding + i * stepX, h - padding - j * stepY, 4, 0, Math.PI * 2);
                gridCtx.fill();
            }
        }

        // Draw sample path: UURURRUR
        // (0,0) -> U(0,1) -> U(0,2) -> R(1,2) -> U(1,3) -> R(2,3) -> R(3,3) -> U(3,4) -> R(4,4)
        gridCtx.strokeStyle = '#E57200';
        gridCtx.lineWidth = 8;
        gridCtx.lineCap = 'round';
        gridCtx.lineJoin = 'round';
        gridCtx.beginPath();
        gridCtx.moveTo(padding, h - padding);                           // (0,0)
        gridCtx.lineTo(padding, h - padding - stepY);                   // U -> (0,1)
        gridCtx.lineTo(padding, h - padding - 2 * stepY);               // U -> (0,2)
        gridCtx.lineTo(padding + stepX, h - padding - 2 * stepY);       // R -> (1,2)
        gridCtx.lineTo(padding + stepX, h - padding - 3 * stepY);       // U -> (1,3)
        gridCtx.lineTo(padding + 2 * stepX, h - padding - 3 * stepY);   // R -> (2,3)
        gridCtx.lineTo(padding + 3 * stepX, h - padding - 3 * stepY);   // R -> (3,3)
        gridCtx.lineTo(padding + 3 * stepX, h - padding - 4 * stepY);   // U -> (3,4)
        gridCtx.lineTo(padding + 4 * stepX, h - padding - 4 * stepY);   // R -> (4,4)
        gridCtx.stroke();

        // Labels
        gridCtx.fillStyle = '#232D4B';
        gridCtx.font = `${Math.round(gridCanvas.height * 0.053)}px sans-serif`;
        gridCtx.fillText('(0,0)', padding - 10, h - padding + Math.round(h * 0.067));
        gridCtx.fillText('(a,b)', w - padding - 5, padding - Math.round(h * 0.033));
    }
    drawGridDemo();

    function generatePaths(a, b) {
        const paths = [];
        function generate(x, y, path) {
            if (x === a && y === b) {
                paths.push([...path]);
                return;
            }
            if (x < a) {
                path.push('R');
                generate(x + 1, y, path);
                path.pop();
            }
            if (y < b) {
                path.push('U');
                generate(x, y + 1, path);
                path.pop();
            }
        }
        generate(0, 0, []);
        return paths;
    }

    function drawPaths() {
        const a = Math.min(7, Math.max(1, parseInt(inputA.value) || 2));
        const b = Math.min(7, Math.max(1, parseInt(inputB.value) || 2));
        inputA.value = a;
        inputB.value = b;

        const paths = generatePaths(a, b);
        const numPaths = paths.length;
        countSpan.textContent = `${numPaths} paths`;

        // Calculate grid layout
        const cols = Math.ceil(Math.sqrt(numPaths * 1.5));
        const rows = Math.ceil(numPaths / cols);

        const cellW = canvas.width / cols;
        const cellH = canvas.height / rows;
        const padding = Math.min(cellW, cellH) * 0.1;
        const gridW = cellW - 2 * padding;
        const gridH = cellH - 2 * padding;
        const stepX = gridW / a;
        const stepY = gridH / b;

        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        paths.forEach((path, idx) => {
            const col = idx % cols;
            const row = Math.floor(idx / cols);
            const baseX = col * cellW + padding;
            const baseY = row * cellH + padding;

            // Draw grid lines
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            for (let i = 0; i <= a; i++) {
                ctx.beginPath();
                ctx.moveTo(baseX + i * stepX, baseY);
                ctx.lineTo(baseX + i * stepX, baseY + gridH);
                ctx.stroke();
            }
            for (let j = 0; j <= b; j++) {
                ctx.beginPath();
                ctx.moveTo(baseX, baseY + gridH - j * stepY);
                ctx.lineTo(baseX + gridW, baseY + gridH - j * stepY);
                ctx.stroke();
            }

            // Draw grid dots
            ctx.fillStyle = '#232D4B';
            for (let i = 0; i <= a; i++) {
                for (let j = 0; j <= b; j++) {
                    ctx.beginPath();
                    ctx.arc(baseX + i * stepX, baseY + gridH - j * stepY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw path
            ctx.strokeStyle = '#E57200';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            let x = 0, y = 0;
            ctx.moveTo(baseX + x * stepX, baseY + gridH - y * stepY);
            for (const move of path) {
                if (move === 'R') x++;
                else y++;
                ctx.lineTo(baseX + x * stepX, baseY + gridH - y * stepY);
            }
            ctx.stroke();
        });
    }

    inputA.addEventListener('change', drawPaths);
    inputB.addEventListener('change', drawPaths);
    inputA.addEventListener('input', drawPaths);
    inputB.addEventListener('input', drawPaths);

    // Initial draw
    drawPaths();

    // Register with slideEngine for step-based reveal
    function waitForSlideEngine() {
        if (!window.slideEngine) {
            setTimeout(waitForSlideEngine, 50);
            return;
        }
        window.slideEngine.registerSimulation('grid-paths', {
            start() {},
            pause() {},
            steps: 3,
            onStep(step) {
                simDiv.style.opacity = '1';
                if (step === 1) {
                    inputA.value = 2;
                    inputB.value = 2;
                    drawPaths();
                } else if (step === 2) {
                    inputA.value = 4;
                    inputB.value = 3;
                    drawPaths();
                } else if (step === 3) {
                    answerDiv.style.opacity = '1';
                }
            },
            onStepBack(step) {
                // Mirror forward steps exactly
                answerDiv.style.opacity = '0';
                if (step === 0) {
                    simDiv.style.opacity = '0';
                } else {
                    simDiv.style.opacity = '1';
                    if (step === 1) {
                        inputA.value = 2;
                        inputB.value = 2;
                        drawPaths();
                    } else if (step === 2) {
                        inputA.value = 4;
                        inputB.value = 3;
                        drawPaths();
                    }
                }
            },
            onSlideEnter() {
                simDiv.style.opacity = '0';
                answerDiv.style.opacity = '0';
                inputA.value = 2;
                inputB.value = 2;
                drawPaths();
            }
        }, 1);
    }
    waitForSlideEngine();
})();
</script>

<section class="slide slide-center" id="random-path" data-title="Random Path">
    <h2 class="slide-title">Pick one path at random</h2>

    <p style="font-size: clamp(1.8rem, 3.5vw, 2.8rem); margin-top: 2vh;">
        <span id="random-path-text1">Pick one path at random from \(\displaystyle\binom{a+b}{a}\) possible ones.</span>
        <span id="random-path-question" style="color: var(--slide-accent);"> How does it look like?</span>
    </p>

    <div id="random-path-sim" style="opacity: 0; transition: opacity 0.3s; margin-top: 2vh; display: flex; flex-direction: column; align-items: center;">
        <div style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); margin-bottom: 1vh;">
            <span id="random-path-formula"></span>
        </div>
        <canvas id="random-path-canvas" width="1200" height="900" style="height: 65vh; width: auto;"></canvas>
    </div>
</section>
<script>
(function() {
    const text1 = document.getElementById('random-path-text1');
    const question = document.getElementById('random-path-question');
    const simDiv = document.getElementById('random-path-sim');
    const canvas = document.getElementById('random-path-canvas');
    const ctx = canvas.getContext('2d');
    const formulaSpan = document.getElementById('random-path-formula');

    let currentA = 4;
    let currentB = 3;
    let currentPath = null;
    let showPath = true;

    function binomial(n, k) {
        if (k > n) return 0;
        if (k === 0 || k === n) return 1;
        let result = 1;
        for (let i = 0; i < k; i++) {
            result = result * (n - i) / (i + 1);
        }
        return Math.round(result);
    }

    function generateRandomPath(a, b) {
        // Generate a random path: a R's and b U's
        const moves = [];
        let remainingR = a;
        let remainingU = b;
        while (remainingR + remainingU > 0) {
            if (remainingR === 0) {
                moves.push('U');
                remainingU--;
            } else if (remainingU === 0) {
                moves.push('R');
                remainingR--;
            } else {
                // Choose R with probability remainingR / (remainingR + remainingU)
                if (Math.random() < remainingR / (remainingR + remainingU)) {
                    moves.push('R');
                    remainingR--;
                } else {
                    moves.push('U');
                    remainingU--;
                }
            }
        }
        return moves;
    }

    function updateDisplay() {
        const n = currentA + currentB;
        const count = binomial(n, currentA);
        // Use KaTeX for rendering
        formulaSpan.innerHTML = `\\(a = ${currentA},\\; b = ${currentB} \\quad \\displaystyle\\binom{${n}}{${currentA}} =\\) <strong style="color: var(--slide-accent);">${count.toLocaleString()}</strong> paths`;
        if (window.renderMathInElement) {
            renderMathInElement(formulaSpan, {
                delimiters: [
                    {left: "\\(", right: "\\)", display: false},
                    {left: "$$", right: "$$", display: true}
                ]
            });
        }
    }

    function drawPath() {
        const a = currentA;
        const b = currentB;

        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (!showPath) {
            // For large a,b, just show a big sad face
            ctx.font = `${Math.round(canvas.height * 0.6)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('😢', canvas.width / 2, canvas.height / 2);
            return;
        }

        // Generate random path if needed
        if (!currentPath || currentPath.length !== a + b) {
            currentPath = generateRandomPath(a, b);
        }

        const padding = 80;
        const gridW = canvas.width - 2 * padding;
        const gridH = canvas.height - 2 * padding;
        const stepX = gridW / a;
        const stepY = gridH / b;
        const baseX = padding;
        const baseY = padding;

        // Draw grid lines
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 2;
        for (let i = 0; i <= a; i++) {
            ctx.beginPath();
            ctx.moveTo(baseX + i * stepX, baseY);
            ctx.lineTo(baseX + i * stepX, baseY + gridH);
            ctx.stroke();
        }
        for (let j = 0; j <= b; j++) {
            ctx.beginPath();
            ctx.moveTo(baseX, baseY + gridH - j * stepY);
            ctx.lineTo(baseX + gridW, baseY + gridH - j * stepY);
            ctx.stroke();
        }

        // Draw grid dots
        ctx.fillStyle = '#232D4B';
        for (let i = 0; i <= a; i++) {
            for (let j = 0; j <= b; j++) {
                ctx.beginPath();
                ctx.arc(baseX + i * stepX, baseY + gridH - j * stepY, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw path
        ctx.strokeStyle = '#E57200';
        ctx.lineWidth = 16;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        let x = 0, y = 0;
        ctx.moveTo(baseX + x * stepX, baseY + gridH - y * stepY);
        for (const move of currentPath) {
            if (move === 'R') x++;
            else y++;
            ctx.lineTo(baseX + x * stepX, baseY + gridH - y * stepY);
        }
        ctx.stroke();

        // Label endpoints
        ctx.fillStyle = '#232D4B';
        ctx.font = `bold ${Math.round(canvas.height * 0.031)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('(0,0)', baseX, baseY + gridH + Math.round(canvas.height * 0.011));
        ctx.textBaseline = 'bottom';
        ctx.fillText('(' + a + ',' + b + ')', baseX + gridW, baseY - Math.round(canvas.height * 0.011));
    }

    function setParams(a, b, draw = true) {
        currentA = a;
        currentB = b;
        showPath = (a <= 15 && b <= 15);
        currentPath = null;
        updateDisplay();
        if (draw) drawPath();
    }

    // Click to resample
    canvas.addEventListener('click', () => {
        if (showPath) {
            currentPath = generateRandomPath(currentA, currentB);
            drawPath();
        }
    });

    // Register with slideEngine for step-based reveal
    function waitForSlideEngine() {
        if (!window.slideEngine) {
            setTimeout(waitForSlideEngine, 50);
            return;
        }
        window.slideEngine.registerSimulation('random-path', {
            start() {},
            pause() {},
            steps: 5,
            onStep(step) {
                simDiv.style.opacity = '1';
                if (step === 1) {
                    setParams(4, 3);
                } else if (step === 2) {
                    setParams(12, 9);
                } else if (step === 3 || step === 4) {
                    // Resample - setParams ensures grid size is correct
                    setParams(12, 9);
                } else if (step === 5) {
                    setParams(120, 90);
                }
            },
            onStepBack(step) {
                // Each step must fully set state and redraw
                if (step === 0) {
                    simDiv.style.opacity = '0';
                } else {
                    simDiv.style.opacity = '1';
                    if (step === 1) {
                        setParams(4, 3);  // 4x3 grid with new random path
                    } else if (step === 2 || step === 3 || step === 4) {
                        // All these steps show 12x9 grid - setParams handles everything
                        setParams(12, 9);
                    }
                }
            },
            onSlideEnter() {
                simDiv.style.opacity = '0';
                // Reset to initial state
                currentA = 4;
                currentB = 3;
                currentPath = null;
                showPath = true;
            },
            onSlideLeave() {
                simDiv.style.opacity = '0';
                currentA = 4;
                currentB = 3;
                currentPath = null;
                showPath = true;
            }
        }, 1);
    }
    waitForSlideEngine();
})();
</script>

<section class="slide slide-center" id="limit-shape-2d" data-title="Limit Shape">
    <h2 class="slide-title">Limit shape and fluctuations</h2>

    <p style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); margin-top: 1vh;">
        Sample a <strong style="color: var(--slide-accent);">uniformly random path</strong> in a large box: <span id="limit-shape-formula" style="display: inline;"></span>
    </p>

    <div style="margin-top: 1vh; display: grid; grid-template-columns: 1fr 1fr; gap: 2vw; align-items: start; width: 95%;">
        <!-- Left: Path overlay -->
        <div style="display: flex; flex-direction: column; align-items: center;">
            <canvas id="limit-shape-canvas" width="1200" height="700" style="height: 45vh; width: auto;"></canvas>
            <div id="limit-shape-status" style="margin-top: 0.5vh; font-size: clamp(0.75rem, 1vw, 1rem); font-style: italic; color: var(--slide-muted);">Ready</div>
        </div>
        <!-- Right: Histogram (hidden initially) -->
        <div id="histogram-container" style="opacity: 0; transition: opacity 0.3s; display: flex; flex-direction: column; align-items: center;">
            <canvas id="histogram-canvas" width="800" height="700" style="height: 45vh; width: auto;"></canvas>
            <div id="histogram-stats" style="margin-top: 0.5vh; font-size: clamp(0.75rem, 1vw, 1rem); color: var(--slide-muted);">
                <span id="histogram-count">0</span> samples
            </div>
            <!-- Mobile placeholder -->
            <div id="histogram-mobile-placeholder" style="display: none; height: 45vh; width: 35vw; background: rgba(35, 45, 75, 0.05); border-radius: 8px; justify-content: center; align-items: center; text-align: center; padding: 2vw;">
                <p style="font-size: clamp(1rem, 1.8vw, 1.4rem); color: var(--slide-muted);">Histogram available<br>on desktop only</p>
            </div>
        </div>
    </div>

    <p id="limit-shape-observation" style="opacity: 0; transition: opacity 0.3s; font-size: clamp(1.2rem, 2.2vw, 1.8rem); margin-top: 1vh;">
        The path follows the <strong style="color: #232D4B;">diagonal</strong> — this is the <strong>Law of Large Numbers</strong> (Limit Shape phenomenon).
    </p>

    <p id="limit-shape-question" style="opacity: 0; transition: opacity 0.3s; font-size: clamp(1.2rem, 2.2vw, 1.8rem); margin-top: 1vh; color: var(--slide-accent);">
        What does the histogram of the fluctuations resemble?
    </p>

    <div id="limit-shape-answer" style="opacity: 0; transition: opacity 0.3s; margin-top: 1vh; display: flex; align-items: center; gap: 2vw;">
        <p style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); flex: 1;">
            The distribution at the middle point has the familiar <strong>Bell-shape histogram</strong><br>(also called Gaussian / normal distribution).<br>
            The whole random curve minus the diagonal converges to the <strong>Brownian bridge</strong>.
        </p>
        <div style="flex-shrink: 0;">
            <canvas id="brownian-bridge-canvas" width="400" height="200" style="height: 15vh; width: auto; border: 1px solid #ccc;"></canvas>
        </div>
    </div>
</section>

<script src="/talk/visual/sim/q-partition-cftp.js"></script>
<script src="/js/webgpu-qpartition-engine.js"></script>
<script>
(async function() {
    'use strict';

    // Wait for QPartitionModule to be available
    if (typeof QPartitionModule === 'undefined') {
        console.error('QPartitionModule not loaded');
        return;
    }

    // Detect mobile
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

    // Initialize GPU engine if WebGPU available (skip on mobile)
    let gpuEngine = null;
    if (!isMobile && WebGPUQPartitionEngine.isAvailable()) {
        try {
            gpuEngine = new WebGPUQPartitionEngine();
            await gpuEngine.init();
            console.log('WebGPU engine ready');
        } catch (e) {
            console.warn('WebGPU init failed, using CPU fallback:', e);
            gpuEngine = null;
        }
    } else {
        console.log(isMobile ? 'Mobile: simple mode' : 'WebGPU not available, using CPU');
    }

    // Path canvas (left)
    const canvas = document.getElementById('limit-shape-canvas');
    const ctx = canvas.getContext('2d');

    // Histogram canvas (right)
    const histCanvas = document.getElementById('histogram-canvas');
    const histCtx = histCanvas.getContext('2d');
    const histContainer = document.getElementById('histogram-container');
    const histCountEl = document.getElementById('histogram-count');
    const histStats = document.getElementById('histogram-stats');
    const histPlaceholder = document.getElementById('histogram-mobile-placeholder');

    // On mobile: hide canvas, show placeholder
    if (isMobile) {
        histCanvas.style.display = 'none';
        histStats.style.display = 'none';
        histPlaceholder.style.display = 'flex';
    }

    // Other elements
    const statusEl = document.getElementById('limit-shape-status');
    const formulaEl = document.getElementById('limit-shape-formula');
    const observationEl = document.getElementById('limit-shape-observation');
    const questionEl = document.getElementById('limit-shape-question');
    const answerEl = document.getElementById('limit-shape-answer');
    const bridgeCanvas = document.getElementById('brownian-bridge-canvas');
    const bridgeCtx = bridgeCanvas.getContext('2d');

    // Fixed size: 210 x 120 (matching previous slide)
    const N = 210;
    const M = 120;
    const midX = Math.floor(N / 2);  // x = 105, expected y ≈ 60

    // Create isolated WASM instance
    const wasm = await QPartitionModule();
    const initSimulation = wasm.cwrap('initSimulation', null, ['number', 'number', 'number']);
    const runCFTPBatch = wasm.cwrap('runCFTPBatch', 'number', []);
    const getPartitionPath = wasm.cwrap('getPartitionPath', 'number', []);
    const freeString = wasm.cwrap('freeString', null, ['number']);

    let samples = [];      // Store full paths for overlay
    let middleYs = [];     // Store y-values at x = N/2 for histogram
    let isRunning = false;
    let cachedInitialBits = null;  // Cache the initial path bits after first CFTP

    function updateFormula() {
        const count = middleYs.length;  // Use histogram sample count
        if (count === 0) {
            formulaEl.innerHTML = `\\(a = ${N},\\; b = ${M}\\)`;
        } else if (count === 1) {
            formulaEl.innerHTML = `\\(a = ${N},\\; b = ${M}\\) — <strong style="color: var(--slide-accent);">1 sample</strong>`;
        } else {
            formulaEl.innerHTML = `\\(a = ${N},\\; b = ${M}\\) — <strong style="color: var(--slide-accent);">${count} samples</strong>`;
        }
        if (window.renderMathInElement) {
            renderMathInElement(formulaEl, {
                delimiters: [
                    {left: "\\(", right: "\\)", display: false},
                    {left: "$$", right: "$$", display: true}
                ]
            });
        }
    }

    function drawPathCanvas() {
        const padding = 60;
        const gridW = canvas.width - 2 * padding;
        const gridH = canvas.height - 2 * padding;
        const scaleX = gridW / N;
        const scaleY = gridH / M;
        const baseX = padding;
        const baseY = padding;

        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw bounding box
        ctx.strokeStyle = '#232D4B';
        ctx.lineWidth = 2;
        ctx.strokeRect(baseX, baseY, gridW, gridH);

        // Draw grid dots at corners only
        ctx.fillStyle = '#232D4B';
        const dotRadius = 6;
        ctx.beginPath();
        ctx.arc(baseX, baseY + gridH, dotRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(baseX + gridW, baseY, dotRadius, 0, Math.PI * 2);
        ctx.fill();

        // Draw diagonal (limit shape) - dashed dark blue line
        ctx.strokeStyle = '#232D4B';
        ctx.lineWidth = 3;
        ctx.setLineDash([12, 6]);
        ctx.beginPath();
        ctx.moveTo(baseX, baseY + gridH);
        ctx.lineTo(baseX + gridW, baseY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw vertical line at x = N/2 (where we measure y)
        if (middleYs.length > 0) {
            const midCanvasX = baseX + midX * scaleX;
            ctx.strokeStyle = 'rgba(35, 45, 75, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(midCanvasX, baseY);
            ctx.lineTo(midCanvasX, baseY + gridH);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Draw all stored samples (oldest faded, newest bold)
        for (let i = 0; i < samples.length; i++) {
            const path = samples[i];
            const isLast = (i === samples.length - 1);
            ctx.strokeStyle = isLast ? '#E57200' : 'rgba(229, 114, 0, 0.25)';
            ctx.lineWidth = isLast ? 4 : 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            for (let j = 0; j < path.length; j++) {
                const [x, y] = path[j];
                const canvasX = baseX + x * scaleX;
                const canvasY = baseY + gridH - y * scaleY;
                if (j === 0) ctx.moveTo(canvasX, canvasY);
                else ctx.lineTo(canvasX, canvasY);
            }
            ctx.stroke();
        }

        // Coordinate labels
        ctx.fillStyle = '#232D4B';
        ctx.font = `bold ${Math.round(canvas.height * 0.022)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('(0, 0)', baseX, baseY + gridH + Math.round(canvas.height * 0.01));
        ctx.textBaseline = 'bottom';
        ctx.fillText(`(${N}, ${M})`, baseX + gridW, baseY - Math.round(canvas.height * 0.01));
    }

    function drawHistogram() {
        const padding = { top: 40, right: 40, bottom: 60, left: 70 };
        const w = histCanvas.width - padding.left - padding.right;
        const h = histCanvas.height - padding.top - padding.bottom;

        histCtx.fillStyle = '#fff';
        histCtx.fillRect(0, 0, histCanvas.width, histCanvas.height);

        if (middleYs.length === 0) return;

        // Compute histogram bins - use fixed bin width of 2 for smooth Gaussian look
        const minY = Math.min(...middleYs);
        const maxY = Math.max(...middleYs);
        const range = Math.max(maxY - minY, 10);
        const binCount = Math.max(10, Math.min(20, Math.ceil(range / 2)));  // ~2 units per bin
        const binWidth = range / binCount;
        const bins = new Array(binCount).fill(0);

        for (const y of middleYs) {
            const binIdx = Math.min(binCount - 1, Math.floor((y - minY) / binWidth));
            bins[binIdx]++;
        }
        const maxBin = Math.max(...bins);

        // Draw axes
        histCtx.strokeStyle = '#232D4B';
        histCtx.lineWidth = 2;
        histCtx.beginPath();
        histCtx.moveTo(padding.left, padding.top);
        histCtx.lineTo(padding.left, padding.top + h);
        histCtx.lineTo(padding.left + w, padding.top + h);
        histCtx.stroke();

        // Draw bars
        const barW = w / binCount;
        for (let i = 0; i < binCount; i++) {
            const barH = (bins[i] / maxBin) * h * 0.9;
            const x = padding.left + i * barW;
            const y = padding.top + h - barH;

            histCtx.fillStyle = '#E57200';
            histCtx.fillRect(x + 1, y, barW - 2, barH);
            histCtx.strokeStyle = '#232D4B';
            histCtx.lineWidth = 1;
            histCtx.strokeRect(x + 1, y, barW - 2, barH);
        }


        // X-axis labels
        histCtx.fillStyle = '#232D4B';
        histCtx.font = `${Math.round(histCanvas.height * 0.026)}px sans-serif`;
        histCtx.textAlign = 'center';
        histCtx.textBaseline = 'top';
        histCtx.fillText(`${Math.round(minY)}`, padding.left, padding.top + h + 8);
        histCtx.fillText(`${Math.round(maxY)}`, padding.left + w, padding.top + h + 8);
        histCtx.fillText(`y at x=${midX}`, padding.left + w / 2, padding.top + h + 30);

        // Y-axis label
        histCtx.save();
        histCtx.translate(20, padding.top + h / 2);
        histCtx.rotate(-Math.PI / 2);
        histCtx.textAlign = 'center';
        histCtx.fillText('frequency', 0, 0);
        histCtx.restore();

        // Update sample count
        histCountEl.textContent = middleYs.length;
    }

    // Extract y-value at x = N/2 from a path
    function getMiddleY(path) {
        // Path is array of [x, y] pairs, find the one where x = midX
        for (let i = 0; i < path.length; i++) {
            if (path[i][0] === midX) {
                return path[i][1];
            }
        }
        // Fallback: interpolate
        for (let i = 0; i < path.length - 1; i++) {
            if (path[i][0] <= midX && path[i + 1][0] > midX) {
                return path[i][1];
            }
        }
        return M / 2;
    }

    async function runCFTP() {
        if (isRunning) return null;
        isRunning = true;

        initSimulation(N, M, 1.0);  // q=1 for uniform
        statusEl.textContent = 'Sampling...';
        statusEl.style.color = '#E57200';

        return new Promise((resolve) => {
            function step() {
                const done = runCFTPBatch();

                if (done) {
                    const ptr = getPartitionPath();
                    const str = wasm.UTF8ToString(ptr);
                    freeString(ptr);
                    const path = JSON.parse(str);
                    samples.push(path);
                    middleYs.push(getMiddleY(path));
                    // Cache the bits for future Glauber sampling
                    cachedInitialBits = pathToBits(path);
                    statusEl.textContent = `${samples.length} sample${samples.length > 1 ? 's' : ''}`;
                    statusEl.style.color = 'var(--slide-muted)';
                    updateFormula();
                    drawPathCanvas();
                    isRunning = false;
                    resolve(path);
                } else {
                    requestAnimationFrame(step);
                }
            }
            step();
        });
    }

    // Convert coordinate path [[x,y], ...] to bit array (0=right, 1=up)
    function pathToBits(coordPath) {
        const bits = [];
        for (let i = 1; i < coordPath.length; i++) {
            const dx = coordPath[i][0] - coordPath[i-1][0];
            const dy = coordPath[i][1] - coordPath[i-1][1];
            bits.push(dy > 0 ? 1 : 0);  // 1 = up, 0 = right
        }
        return bits;
    }

    async function collectSamplesGPU(count) {
        if (!gpuEngine) return collectSamplesCPU(count);

        try {
            // Use cached bits, or run CFTP if needed
            if (!cachedInitialBits) {
                statusEl.textContent = 'Getting initial sample...';
                statusEl.style.color = '#E57200';
                const initialPath = await runCFTP();
                if (!initialPath) return collectSamplesCPU(count);
            }

            const initialBits = cachedInitialBits;

            // Run GPU Glauber chains in batches of 5k (20k = 4 batches)
            const batchSize = 5000;
            let remaining = count;
            while (remaining > 0) {
                const thisBatch = Math.min(batchSize, remaining);
                statusEl.textContent = `GPU: ${middleYs.length}/${count + middleYs.length - remaining} samples...`;

                // Add timeout for GPU operations (10 seconds)
                const gpuPromise = gpuEngine.sample(N, M, thisBatch, initialBits, 1000000);
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('GPU timeout')), 10000)
                );

                const gpuMiddleYs = await Promise.race([gpuPromise, timeoutPromise]);

                for (let i = 0; i < gpuMiddleYs.length; i++) {
                    middleYs.push(gpuMiddleYs[i]);
                }

                remaining -= thisBatch;
                drawHistogram();
                await new Promise(r => setTimeout(r, 0));  // Yield to UI
            }

            statusEl.textContent = `${middleYs.length} samples (GPU)`;
            statusEl.style.color = 'var(--slide-muted)';
            updateFormula();
            drawPathCanvas();
            drawHistogram();
        } catch (e) {
            console.error('GPU sampling failed, falling back to CPU:', e);
            gpuEngine = null;  // Disable GPU for future calls
            return collectSamplesCPU(count);
        }
    }

    // WASM Glauber wrappers
    const setPath = wasm.cwrap('setPath', null, ['number', 'number']);
    const runGlauberAndGetMiddleY = wasm.cwrap('runGlauberAndGetMiddleY', 'number', ['number']);

    function runGlauberWASM(initialBits, steps) {
        // Copy bits to WASM memory
        const len = initialBits.length;
        const ptr = wasm._malloc(len * 4);  // int array
        for (let i = 0; i < len; i++) {
            wasm.setValue(ptr + i * 4, initialBits[i], 'i32');
        }
        setPath(ptr, len);
        wasm._free(ptr);

        // Run Glauber and get result
        return runGlauberAndGetMiddleY(steps);
    }

    async function collectSamplesCPU(count) {
        // Use cached bits, or run CFTP if needed
        if (!cachedInitialBits) {
            statusEl.textContent = 'Getting initial sample...';
            statusEl.style.color = '#E57200';
            const initialPath = await runCFTP();
            if (!initialPath) return;
        }

        const initialBits = cachedInitialBits;
        const stepsPerSample = 1000000;  // 1M steps per sample

        for (let i = 0; i < count; i++) {
            const y = runGlauberWASM(initialBits, stepsPerSample);
            middleYs.push(y);
            statusEl.textContent = `${middleYs.length} samples (CPU)`;
            drawHistogram();
            await new Promise(r => setTimeout(r, 0));  // Yield to UI after each sample
        }
        statusEl.textContent = `${middleYs.length} samples`;
        statusEl.style.color = 'var(--slide-muted)';
        updateFormula();
        drawHistogram();
    }

    async function collectSamples(count) {
        if (gpuEngine) {
            await collectSamplesGPU(count);
        } else {
            await collectSamplesCPU(count);
        }
    }

    // Draw the difference between path and diagonal (Brownian bridge visualization)
    function drawBrownianBridge() {
        if (samples.length === 0) return;

        const path = samples[samples.length - 1];  // Use last sample
        const w = bridgeCanvas.width;
        const h = bridgeCanvas.height;
        const padding = 20;

        bridgeCtx.fillStyle = '#fff';
        bridgeCtx.fillRect(0, 0, w, h);

        // Compute differences: y - (M/N)*x at each point
        const diffs = [];
        for (let i = 0; i < path.length; i++) {
            const x = path[i][0];
            const y = path[i][1];
            const expectedY = (M / N) * x;
            diffs.push(y - expectedY);
        }

        const maxDiff = Math.max(...diffs.map(Math.abs), 5);
        const scaleX = (w - 2 * padding) / N;
        const scaleY = (h - 2 * padding) / (2 * maxDiff);

        // Draw zero line
        bridgeCtx.strokeStyle = '#ccc';
        bridgeCtx.lineWidth = 1;
        bridgeCtx.beginPath();
        bridgeCtx.moveTo(padding, h / 2);
        bridgeCtx.lineTo(w - padding, h / 2);
        bridgeCtx.stroke();

        // Draw difference curve
        bridgeCtx.strokeStyle = '#E57200';
        bridgeCtx.lineWidth = 2;
        bridgeCtx.beginPath();
        for (let i = 0; i < path.length; i++) {
            const px = padding + path[i][0] * scaleX;
            const py = h / 2 - diffs[i] * scaleY;
            if (i === 0) bridgeCtx.moveTo(px, py);
            else bridgeCtx.lineTo(px, py);
        }
        bridgeCtx.stroke();

        // Labels
        bridgeCtx.fillStyle = '#232D4B';
        bridgeCtx.font = `${Math.round(h * 0.18)}px sans-serif`;
        bridgeCtx.textAlign = 'center';
        bridgeCtx.fillText('path minus diagonal', w / 2, h - Math.round(h * 0.05));
    }

    function reset() {
        samples = [];
        middleYs = [];
        cachedInitialBits = null;
        observationEl.style.opacity = '0';
        questionEl.style.opacity = '0';
        answerEl.style.opacity = '0';
        histContainer.style.opacity = '0';
        statusEl.textContent = 'Ready';
        statusEl.style.color = 'var(--slide-muted)';
        histCountEl.textContent = '0';
        updateFormula();
        drawPathCanvas();
    }

    // Register with slide engine
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('limit-shape-2d', {
                start() {},
                pause() {},
                steps: 5,
                async onStep(step) {
                    console.log('limit-shape-2d step:', step, 'isMobile:', isMobile);
                    if (isMobile) {
                        // Mobile: simple mode - just CFTP samples, no histogram
                        if (step === 1) {
                            samples = [];
                            middleYs = [];
                            await runCFTP();
                            observationEl.style.opacity = '1';
                        } else if (step === 2) {
                            // Run 4 more CFTP samples (5 total)
                            for (let i = 0; i < 4; i++) {
                                await runCFTP();
                            }
                            histContainer.style.opacity = '1';  // Shows placeholder
                        } else if (step === 3) {
                            // Skip on mobile
                        } else if (step === 4) {
                            questionEl.style.opacity = '1';
                        } else if (step === 5) {
                            answerEl.style.opacity = '1';
                            drawBrownianBridge();
                        }
                    } else {
                        // Desktop: full experience
                        if (step === 1) {
                            samples = [];
                            middleYs = [];
                            await runCFTP();
                            observationEl.style.opacity = '1';
                            drawHistogram();
                        } else if (step === 2) {
                            histContainer.style.opacity = '1';
                            drawHistogram();
                            await collectSamples(19);
                        } else if (step === 3) {
                            const count = gpuEngine ? 20000 : 200;
                            await collectSamples(count);
                        } else if (step === 4) {
                            questionEl.style.opacity = '1';
                        } else if (step === 5) {
                            answerEl.style.opacity = '1';
                            drawBrownianBridge();
                        }
                    }
                },
                onStepBack(step) {
                    // Always reset to step 0 on any back motion
                    reset();
                    // Also reset the slide engine's step counter for this slide
                    if (window.slideEngine) {
                        window.slideEngine.currentSimStep = 0;
                        window.slideEngine.slideHistory.set('limit-shape-2d', { fragment: 0, simStep: 0 });
                    }
                },
                onSlideEnter() {
                    // Always reset to step 0 when entering (whether forward or back)
                    reset();
                    histContainer.style.opacity = '0';
                    observationEl.style.opacity = '0';
                    questionEl.style.opacity = '0';
                    answerEl.style.opacity = '0';
                    // Reset the slide engine's step counter
                    if (window.slideEngine) {
                        window.slideEngine.currentSimStep = 0;
                        window.slideEngine.slideHistory.set('limit-shape-2d', { fragment: 0, simStep: 0 });
                    }
                }
            }, 1);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();

    // Initial draw
    updateFormula();
    drawPathCanvas();
})();
</script>

<section class="slide slide-top" id="q-deformation" data-title="q-Deformation">
    <h2 class="slide-title">q-Deformation</h2>

    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2vw; margin-top: 1vh; width: 95%;">
        <!-- Left: Explanation text blocks -->
        <div style="display: flex; flex-direction: column; gap: 1.5vh; padding-top: 1vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">
            <!-- Block 1: Area -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw;">
                <strong style="color: var(--slide-accent);">Area above a path:</strong><br>
                Count unit squares above the path
                <div style="display: flex; align-items: center; gap: 1vw; margin-top: 0.5vh;">
                    <canvas id="area-example-canvas" width="300" height="200" style="height: 10vh; width: auto;"></canvas>
                    <span style="font-weight: bold; font-size: clamp(1.5rem, 2.5vw, 2.2rem);">Area = 8</span>
                </div>
            </div>

            <!-- Block 2: q-weighting -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw;">
                <strong style="color: var(--slide-accent);">q-weighting:</strong><br>
                Weight = \(q^{\text{area}}\), &nbsp; Probability = \(\displaystyle\frac{q^{\text{area}}}{\sum_{\text{paths}} q^{\text{area}}}\)
            </div>

            <!-- Block 3: q-Binomial -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw;">
                <strong style="color: var(--slide-accent);">q-Binomial coefficient:</strong><br>
                \(\displaystyle\binom{a+b}{a}_q = \sum_{\text{paths}} q^{\text{area}}\)
            </div>

            <!-- Block 4: Example -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw;">
                <strong style="color: var(--slide-accent);">Example (a=4, b=3):</strong><br>
                <span id="q-binomial-formula"></span>
            </div>
        </div>

        <!-- Right: All 35 paths grid -->
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); margin-bottom: 0.5vh; display: flex; align-items: center; gap: 1vw;">
                <label for="q-slider">q = </label>
                <input type="range" id="q-slider" min="0" max="2" step="0.01" value="1" style="width: 12vw;">
                <span id="q-value" style="font-weight: bold; min-width: 3em;">1.00</span>
            </div>
            <canvas id="q-paths-canvas" width="1100" height="900" style="height: 78vh; width: auto;"></canvas>
        </div>
    </div>
</section>

<script>
(function() {
    'use strict';

    const canvas = document.getElementById('q-paths-canvas');
    const ctx = canvas.getContext('2d');
    const areaCanvas = document.getElementById('area-example-canvas');
    const areaCtx = areaCanvas.getContext('2d');
    const slider = document.getElementById('q-slider');
    const qValueSpan = document.getElementById('q-value');
    const qBinomialEl = document.getElementById('q-binomial-formula');

    const A = 4, B = 3;

    // Generate all paths from (0,0) to (A,B)
    function generateAllPaths(a, b) {
        const paths = [];
        function generate(path, remainR, remainU) {
            if (remainR === 0 && remainU === 0) {
                paths.push([...path]);
                return;
            }
            if (remainR > 0) {
                path.push('R');
                generate(path, remainR - 1, remainU);
                path.pop();
            }
            if (remainU > 0) {
                path.push('U');
                generate(path, remainR, remainU - 1);
                path.pop();
            }
        }
        generate([], a, b);
        return paths;
    }

    // Calculate area ABOVE a path (unit squares above)
    // Area above = A*B - area below
    function calcArea(path) {
        let areaBelow = 0, y = 0;
        for (const move of path) {
            if (move === 'R') areaBelow += y;
            else y++;
        }
        return A * B - areaBelow;
    }

    const allPaths = generateAllPaths(A, B);
    const pathAreas = allPaths.map(calcArea);

    // Coefficients of the q-binomial polynomial (pre-computed)
    // 1 + q + 2q^2 + 3q^3 + 4q^4 + 4q^5 + 5q^6 + 4q^7 + 4q^8 + 3q^9 + 2q^10 + q^11 + q^12
    const qBinomCoeffs = [1, 1, 2, 3, 4, 4, 5, 4, 4, 3, 2, 1, 1];

    function evalQBinomial(q) {
        if (Math.abs(q - 1) < 1e-10) return 35;
        let sum = 0;
        for (let i = 0; i < qBinomCoeffs.length; i++) {
            sum += qBinomCoeffs[i] * Math.pow(q, i);
        }
        return sum;
    }

    function updateQBinomialFormula(q) {
        const val = evalQBinomial(q);
        if (Math.abs(q - 1) < 0.01) {
            qBinomialEl.innerHTML = `\\(\\displaystyle\\binom{7}{4}_q = 1 + q + 2q^2 + 3q^3 + 4q^4 + 4q^5 + 5q^6\\)<br>\\(\\phantom{\\binom{7}{4}_q =} +\\, 4q^7 + 4q^8 + 3q^9 + 2q^{10} + q^{11} + q^{12}\\)<br>At \\(q=1\\): <strong style="color: var(--slide-accent);">35</strong> paths`;
        } else {
            qBinomialEl.innerHTML = `\\(\\displaystyle\\binom{7}{4}_q = 1 + q + 2q^2 + 3q^3 + 4q^4 + 4q^5 + 5q^6\\)<br>\\(\\phantom{\\binom{7}{4}_q =} +\\, 4q^7 + 4q^8 + 3q^9 + 2q^{10} + q^{11} + q^{12}\\)<br>At \\(q=${q.toFixed(2)}\\): <strong style="color: var(--slide-accent);">${val.toFixed(2)}</strong>`;
        }
        if (window.renderMathInElement) {
            renderMathInElement(qBinomialEl, {
                delimiters: [
                    {left: "\\(", right: "\\)", display: false},
                    {left: "$$", right: "$$", display: true}
                ]
            });
        }
    }

    function drawAreaExample() {
        const w = areaCanvas.width, h = areaCanvas.height;
        areaCtx.fillStyle = '#fff';
        areaCtx.fillRect(0, 0, w, h);

        // Draw a specific path with area shaded
        // This path: R U R U R R U has area_below = 0+1+1+2 = 4, so area_above = 12-4 = 8
        const exPath = ['R', 'U', 'R', 'U', 'R', 'R', 'U'];
        const padding = h * 0.1;
        const gridW = w - 2 * padding;
        const gridH = h - 2 * padding;
        const step = Math.min(gridW / A, gridH / B);
        const stepX = step;
        const stepY = step;
        const baseX = (w - A * step) / 2;
        const baseY = (h - B * step) / 2;

        // Shade area ABOVE path
        areaCtx.fillStyle = 'rgba(229, 114, 0, 0.3)';
        let x = 0, y = 0;
        for (const move of exPath) {
            if (move === 'R') {
                // Shade column from y to B (above the path)
                if (y < B) {
                    areaCtx.fillRect(baseX + x * stepX, baseY, stepX, (B - y) * stepY);
                }
                x++;
            } else {
                y++;
            }
        }

        // Draw grid
        const actualGridW = A * stepX;
        const actualGridH = B * stepY;
        areaCtx.strokeStyle = '#ccc';
        areaCtx.lineWidth = 1;
        for (let i = 0; i <= A; i++) {
            areaCtx.beginPath();
            areaCtx.moveTo(baseX + i * stepX, baseY);
            areaCtx.lineTo(baseX + i * stepX, baseY + actualGridH);
            areaCtx.stroke();
        }
        for (let j = 0; j <= B; j++) {
            areaCtx.beginPath();
            areaCtx.moveTo(baseX, baseY + actualGridH - j * stepY);
            areaCtx.lineTo(baseX + actualGridW, baseY + actualGridH - j * stepY);
            areaCtx.stroke();
        }

        // Draw path
        areaCtx.strokeStyle = '#E57200';
        areaCtx.lineWidth = 3;
        areaCtx.lineCap = 'round';
        areaCtx.lineJoin = 'round';
        areaCtx.beginPath();
        x = 0; y = 0;
        areaCtx.moveTo(baseX + x * stepX, baseY + actualGridH - y * stepY);
        for (const move of exPath) {
            if (move === 'R') x++;
            else y++;
            areaCtx.lineTo(baseX + x * stepX, baseY + actualGridH - y * stepY);
        }
        areaCtx.stroke();
    }

    function drawAllPaths(q) {
        const w = canvas.width, h = canvas.height;
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);

        // Layout: 7 columns x 5 rows
        const cols = 7, rows = 5;
        const cellW = w / cols;
        const cellH = h / rows;
        const padding = 6;
        const gridPadding = 4;

        // Calculate weights
        const qSum = evalQBinomial(q);
        const weights = pathAreas.map(area => Math.pow(q, area));
        const probs = weights.map(wt => wt / qSum);
        const maxProb = Math.max(...probs);

        // Sort paths by area for nice display
        const sorted = allPaths.map((p, i) => ({ path: p, area: pathAreas[i], prob: probs[i], weight: weights[i] }));
        sorted.sort((a, b) => a.area - b.area);

        for (let idx = 0; idx < sorted.length; idx++) {
            const { path, area, prob, weight } = sorted[idx];
            const col = idx % cols;
            const row = Math.floor(idx / cols);

            const cellX = col * cellW + padding;
            const cellY = row * cellH + padding;
            const innerW = cellW - 2 * padding;
            const innerH = cellH - 2 * padding - 28; // leave space for text

            // Draw mini grid with correct 4:3 aspect ratio
            const availW = innerW - 2 * gridPadding;
            const availH = innerH - 2 * gridPadding;
            const step = Math.min(availW / A, availH / B); // uniform step for square cells
            const gridW = step * A;
            const gridH = step * B;
            const baseX = cellX + gridPadding + (availW - gridW) / 2; // center horizontally
            const baseY = cellY + gridPadding + (availH - gridH) / 2; // center vertically

            // Grid lines
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            for (let i = 0; i <= A; i++) {
                ctx.beginPath();
                ctx.moveTo(baseX + i * step, baseY);
                ctx.lineTo(baseX + i * step, baseY + gridH);
                ctx.stroke();
            }
            for (let j = 0; j <= B; j++) {
                ctx.beginPath();
                ctx.moveTo(baseX, baseY + gridH - j * step);
                ctx.lineTo(baseX + gridW, baseY + gridH - j * step);
                ctx.stroke();
            }

            // Path line weight based on probability (thicker = higher prob) - MORE DRAMATIC
            const probRatio = prob / maxProb;
            const minLineW = 1;
            const maxLineW = 16;
            const lineW = minLineW + (maxLineW - minLineW) * Math.pow(probRatio, 0.5);

            // Opacity based on probability
            const minAlpha = 0.15;
            const alpha = minAlpha + (1 - minAlpha) * Math.pow(probRatio, 0.7);

            // Draw path
            ctx.strokeStyle = `rgba(229, 114, 0, ${alpha})`;
            ctx.lineWidth = lineW;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            let x = 0, y = 0;
            ctx.moveTo(baseX, baseY + gridH);
            for (const move of path) {
                if (move === 'R') x++;
                else y++;
                ctx.lineTo(baseX + x * step, baseY + gridH - y * step);
            }
            ctx.stroke();

            // Probability only (no area label) - MORE DRAMATIC sizing
            const textY = cellY + innerH + 15;
            const minFontSize = 14;
            const maxFontSize = 28;
            const fontSize = minFontSize + (maxFontSize - minFontSize) * Math.pow(probRatio, 0.5);
            const fontWeight = probRatio > 0.3 ? 'bold' : 'normal';
            ctx.font = `${fontWeight} ${fontSize}px sans-serif`;
            const textAlpha = 0.3 + 0.7 * Math.pow(probRatio, 0.5);
            ctx.fillStyle = probRatio > 0.5 ? `rgba(229, 114, 0, ${textAlpha})` : `rgba(102, 102, 102, ${textAlpha})`;
            ctx.textAlign = 'center';
            const probStr = (prob * 100).toFixed(1) + '%';
            ctx.fillText(probStr, cellX + innerW / 2 + padding, textY);
        }
    }

    function update() {
        const q = parseFloat(slider.value);
        qValueSpan.textContent = q.toFixed(2);
        drawAllPaths(q);
        updateQBinomialFormula(q);
    }

    slider.addEventListener('input', update);

    // Initial draw
    drawAreaExample();
    update();

    // Step q values: stage 0=1, 1=0.9, 2=0.5, 3=0.95, 4=1.2, 5=2
    const stepQValues = [1, 0.9, 0.5, 0.95, 1.2, 2];

    function setQ(q) {
        slider.value = q;
        update();
    }

    // Register with slide engine
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('q-deformation', {
                start() {},
                pause() {},
                steps: 5,
                onStep(step) {
                    if (step >= 1 && step <= 5) {
                        setQ(stepQValues[step]);
                    }
                },
                onStepBack(step) {
                    setQ(stepQValues[step]);
                },
                onSlideEnter() {
                    setQ(1);
                },
                onSlideLeave() {
                    setQ(1);
                }
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();
</script>

<section class="slide slide-top" id="q-limit-shape" data-title="q-Limit Shape">
    <h2 class="slide-title">q-Limit Shape</h2>

    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2vw; margin-top: 1vh; width: 95%; height: 85vh;">
        <!-- Left: Explanation -->
        <div style="display: flex; flex-direction: column; gap: 1.5vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem); justify-content: space-between; height: 100%;">
            <!-- Block 1: Limit Shape -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw;">
                <strong style="color: var(--slide-accent);">Limit shape [Vershik 1996]</strong><br>
                As \(N \to \infty\) with \(q = e^{-\gamma/N}\), limit shape:
                $$A e^{-\gamma y} + B e^{-\gamma x} = 1$$
                <span style="font-size: 0.85em;">
                \(\displaystyle A = \frac{1-e^{-\gamma}}{1-e^{-\gamma(1+\alpha)}}\), \(\displaystyle B = \frac{1-e^{-\gamma \alpha}}{1-e^{-\gamma(1+\alpha)}}\)<br>
                \(\alpha\) = rectangle aspect ratio
                </span>
            </div>

            <!-- Block 2: How to get limit shape -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw;">
                <strong style="color: var(--slide-accent);">How to get limit shape?</strong><br>
                <ul style="margin: 0.5vh 0 0 1.5em; padding: 0;">
                    <li>Approximate any curve by a piecewise-linear trajectory</li>
                    <li>Locally, we know how many configurations approximate a given line</li>
                    <li>Integrate and maximize to get the typical shape</li>
                </ul>
            </div>

            <!-- Block 3: Energy Functional -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw;">
                <strong style="color: var(--slide-accent);">Variational principle for the limit shape \(y=f(x)\):</strong><br>
                Maximize
<span style="color: #232D4B; font-weight: 800; font-size: 1.15em; letter-spacing: 0.01em;">energy − γ·area</span>
								= <br>
                \(\displaystyle \int \sigma(f'(x)) \, dx - \gamma \cdot \int f(x) \, dx\);<br>
                <span style="font-size: 0.85em;">\(\sigma(s) = \lim \frac{1}{N}\log \binom{N(s+1)}{N}\) = energy.<br>The binomial coefficient is the number of paths having slope \(s\); we get the limit $\sigma(s) = (s+1)\log(s+1) - s\log(s)$.</span>
            </div>

        </div>

        <!-- Right: Simulation canvas -->
        <div style="display: flex; flex-direction: column; align-items: center; justify-content: space-between; height: 100%;">
            <!-- Controls at top -->
            <div>
                <div style="display: flex; align-items: center; gap: 1vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">
                    <label for="gamma-slider" style="font-weight: bold;">γ = </label>
                    <input type="range" id="gamma-slider" min="-50" max="50" step="0.01" value="3.6" style="width: 12vw;">
                    <span id="gamma-value" style="font-weight: bold; min-width: 3em;">3.6</span>
                    <span style="margin-left: 1vw;">(q = <span id="q-limit-value">0.990</span>)</span>
                    <button id="q-limit-resample" style="padding: 0.5vh 1vw; cursor: pointer;">Resample</button>
                </div>
                <div style="font-size: clamp(0.9rem, 1.5vw, 1.1rem); color: var(--slide-muted); text-align: center;">
                    <span>a = 360, b = 270</span> · <span id="q-limit-status">Loading...</span>
                </div>
            </div>
            <canvas id="q-limit-canvas" width="1200" height="900" style="max-height: 58vh; width: auto;"></canvas>
            <!-- Fluctuations block -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 0.5vh 1vw; width: 100%; box-sizing: border-box;">
                <strong style="color: var(--slide-accent); font-size: clamp(1rem, 1.8vw, 1.4rem);">Fluctuations:</strong> <span style="font-size: clamp(1rem, 1.8vw, 1.4rem);">Random curve minus limit shape</span><br>
                <canvas id="fluctuations-canvas" width="800" height="200" style="width: 100%; height: 12vh;"></canvas>
            </div>
        </div>
    </div>
</section>

<script src="/talk/visual/sim/q-partition-cftp.js"></script>
<script>
(function() {
    'use strict';

    const canvas = document.getElementById('q-limit-canvas');
    const ctx = canvas.getContext('2d');
    const flucCanvas = document.getElementById('fluctuations-canvas');
    const flucCtx = flucCanvas.getContext('2d');
    const gammaSlider = document.getElementById('gamma-slider');
    const gammaValueSpan = document.getElementById('gamma-value');
    const qValueSpan = document.getElementById('q-limit-value');
    const statusEl = document.getElementById('q-limit-status');
    const resampleBtn = document.getElementById('q-limit-resample');

    const N = 360;  // Width (a)
    const M = 270;  // Height (b)
    let q = 0.99;

    // WASM module
    let wasm = null;
    let initSimulation, runCFTPBatch, getCoalesced, getPartitionPath, freeString, getM, getN;

    // Partition path (sequence of 0=right, 1=up)
    let partitionPath = [];
    let isRunning = false;

    // Colors
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    async function initWasm() {
        if (typeof QPartitionModule === 'undefined') {
            statusEl.textContent = 'WASM not loaded';
            return false;
        }
        wasm = await QPartitionModule();
        initSimulation = wasm.cwrap('initSimulation', null, ['number', 'number', 'number']);
        runCFTPBatch = wasm.cwrap('runCFTPBatch', 'number', []);
        getCoalesced = wasm.cwrap('getCoalesced', 'number', []);
        getPartitionPath = wasm.cwrap('getPartitionPath', 'number', []);
        freeString = wasm.cwrap('freeString', null, ['number']);
        getM = wasm.cwrap('getM', 'number', []);
        getN = wasm.cwrap('getN', 'number', []);
        return true;
    }

    function getPathFromWasm() {
        const ptr = getPartitionPath();
        const str = wasm.UTF8ToString(ptr);
        freeString(ptr);
        return JSON.parse(str);
    }

    async function runCFTP() {
        if (!wasm || isRunning) return;
        isRunning = true;
        statusEl.textContent = 'Sampling...';

        initSimulation(N, M, q);

        let totalSteps = 0;
        const batchSize = 10000000;  // Hardcoded in WASM

        while (!getCoalesced()) {
            runCFTPBatch();
            totalSteps += batchSize;
            statusEl.textContent = `Sampling... ${(totalSteps / 1e6).toFixed(0)}M steps`;
            await new Promise(r => setTimeout(r, 1));
        }

        partitionPath = getPathFromWasm();
        statusEl.textContent = `Sampled in ${(totalSteps / 1e6).toFixed(1)}M steps`;
        isRunning = false;
        draw();
    }

    function draw() {
        const w = canvas.width, h = canvas.height;
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);

        const padding = 60;
        const drawW = w - 2 * padding;
        const drawH = h - 2 * padding;

        // Scale to fit M x N rectangle
        const scaleX = drawW / N;
        const scaleY = drawH / M;
        const scale = Math.min(scaleX, scaleY);

        const offsetX = padding + (drawW - N * scale) / 2;
        const offsetY = padding + (drawH - M * scale) / 2;

        // Bounding rectangle
        ctx.strokeStyle = colors[1];
        ctx.lineWidth = 2;
        ctx.strokeRect(offsetX, offsetY, N * scale, M * scale);

        // Draw partition (filled region)
        // partitionPath is [[x,y], [x,y], ...] from (0,0) to (N,M)
        if (partitionPath.length > 0) {
            ctx.fillStyle = colors[0] + '60';
            ctx.beginPath();
            // Start at bottom-left corner
            ctx.moveTo(offsetX, offsetY + M * scale);

            // Path goes from (0,0) to (N,M) in math coords
            // Canvas: x goes right, y goes DOWN, so we flip y
            for (const [px, py] of partitionPath) {
                ctx.lineTo(offsetX + px * scale, offsetY + (M - py) * scale);
            }

            // Close: go to top-left, then back to start
            ctx.lineTo(offsetX, offsetY);
            ctx.lineTo(offsetX, offsetY + M * scale);
            ctx.closePath();
            ctx.fill();

            // Draw path line
            ctx.strokeStyle = colors[0];
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < partitionPath.length; i++) {
                const [px, py] = partitionPath[i];
                const cx = offsetX + px * scale;
                const cy = offsetY + (M - py) * scale;
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            }
            ctx.stroke();
        }

        // Draw limit shape curve
        drawLimitShape(offsetX, offsetY, scale);

        // Draw fluctuations
        drawFluctuations();
    }

    function drawLimitShape(offsetX, offsetY, scale) {
        const aa = M / N;  // aspect ratio
        const gamma = -N * Math.log(q);

        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 3;
        ctx.setLineDash([8, 4]);
        ctx.beginPath();

        // For γ ≈ 0: straight diagonal
        if (Math.abs(gamma) < 1e-6) {
            ctx.moveTo(offsetX, offsetY + M * scale);
            ctx.lineTo(offsetX + N * scale, offsetY);
            ctx.stroke();
            ctx.setLineDash([]);
            return;
        }

        // A·e^{-γy} + B·e^{-γx} = 1 with y measured from TOP
        const denom = 1 - Math.exp(-gamma * (1 + aa));
        const A = (1 - Math.exp(-gamma)) / denom;
        const B = (1 - Math.exp(-gamma * aa)) / denom;

        const steps = 200;

        // Start at bottom-left corner
        ctx.moveTo(offsetX, offsetY + M * scale);

        for (let i = 1; i < steps; i++) {
            const x_norm = i / steps;
            const exp_neg_cx = Math.exp(-gamma * x_norm);
            const inside = (1 - B * exp_neg_cx) / A;

            if (inside > 0) {
                const y_formula = -Math.log(inside) / gamma;
                // y_formula goes from aa (at x=0) to 0 (at x=1)
                // We want y to go from 0 to M as x goes from 0 to N
                const y_scaled = (aa - y_formula) / aa * M;

                const canvasX = offsetX + x_norm * N * scale;
                const canvasY = offsetY + (M - y_scaled) * scale;
                ctx.lineTo(canvasX, canvasY);
            }
        }

        // End at top-right corner
        ctx.lineTo(offsetX + N * scale, offsetY);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    function getLimitShapeY(x_norm) {
        // Returns y in [0, 1] range (normalized to M)
        const aa = M / N;
        const gamma = -N * Math.log(q);
        if (Math.abs(gamma) < 1e-6) {
            return x_norm;  // Straight diagonal: y/M = x/N
        }
        const denom = 1 - Math.exp(-gamma * (1 + aa));
        const A = (1 - Math.exp(-gamma)) / denom;
        const B = (1 - Math.exp(-gamma * aa)) / denom;
        const exp_neg_cx = Math.exp(-gamma * x_norm);
        const inside = (1 - B * exp_neg_cx) / A;
        if (inside <= 0) return x_norm;
        const y_formula = -Math.log(inside) / gamma;
        // y_formula goes from aa to 0 as x goes 0 to 1
        // We want output in [0, 1] where 0 at x=0 and 1 at x=1
        return (aa - y_formula) / aa;
    }

    function drawFluctuations() {
        const w = flucCanvas.width, h = flucCanvas.height;
        flucCtx.fillStyle = '#ffffff';
        flucCtx.fillRect(0, 0, w, h);

        if (partitionPath.length === 0) return;

        const padding = 20;
        const drawW = w - 2 * padding;
        const drawH = h - 2 * padding;

        // Compute fluctuations: path_y - limit_shape_y at each x
        const fluctuations = [];
        for (const [px, py] of partitionPath) {
            const x_norm = px / N;
            const limitY = getLimitShapeY(x_norm) * M;  // Scale to M
            const diff = py - limitY;
            fluctuations.push({ x: px, diff: diff, x_norm: x_norm });
        }

        if (fluctuations.length === 0) return;

        // Find max deviation for scaling
        let maxDev = 1;
        for (const f of fluctuations) {
            maxDev = Math.max(maxDev, Math.abs(f.diff));
        }

        // Draw zero line
        const zeroY = padding + drawH / 2;
        flucCtx.strokeStyle = '#ccc';
        flucCtx.lineWidth = 1;
        flucCtx.beginPath();
        flucCtx.moveTo(padding, zeroY);
        flucCtx.lineTo(padding + drawW, zeroY);
        flucCtx.stroke();

        // Draw fluctuation curve
        flucCtx.strokeStyle = colors[0];
        flucCtx.lineWidth = 4;
        flucCtx.beginPath();
        for (let i = 0; i < fluctuations.length; i++) {
            const f = fluctuations[i];
            const cx = padding + f.x_norm * drawW;
            const cy = zeroY - (f.diff / maxDev) * (drawH / 2) * 0.9;
            if (i === 0) flucCtx.moveTo(cx, cy);
            else flucCtx.lineTo(cx, cy);
        }
        flucCtx.stroke();
    }

    function updateGamma() {
        const gamma = parseFloat(gammaSlider.value);
        gammaValueSpan.textContent = gamma.toFixed(1);
        q = Math.exp(-gamma / N);
        qValueSpan.textContent = q.toFixed(4);
        draw();
    }

    gammaSlider.addEventListener('input', updateGamma);
    resampleBtn.addEventListener('click', () => runCFTP());

    // Initialize
    async function init() {
        const ok = await initWasm();
        if (ok) {
            await runCFTP();
        }
    }

    // Set gamma programmatically and resample
    function setGamma(gamma) {
        gammaSlider.value = gamma;
        gammaValueSpan.textContent = gamma.toFixed(1);
        q = Math.exp(-gamma / N);
        qValueSpan.textContent = q.toFixed(4);
        draw();  // Update limit shape curve immediately
        runCFTP();  // Start sampling in background
    }

    // Step gamma values
    const stepGammas = [3.6, 1, -8];  // step 0 (initial), step 1, step 2
    let currentStep = 0;

    // Register with slide engine
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('q-limit-shape', {
                start() {},
                pause() {},
                steps: 2,
                onSlideEnter() {
                    // Restore gamma for current step
                    const gamma = stepGammas[currentStep];
                    gammaSlider.value = gamma;
                    gammaValueSpan.textContent = gamma.toFixed(1);
                    q = Math.exp(-gamma / N);
                    qValueSpan.textContent = q.toFixed(4);

                    if (!wasm) {
                        init();
                    } else if (partitionPath.length === 0) {
                        runCFTP();
                    } else {
                        draw();
                    }
                },
                onStep(step) {
                    currentStep = step;
                    if (step >= 1 && step <= stepGammas.length - 1) {
                        setGamma(stepGammas[step]);
                    }
                },
                onStepBack(step) {
                    currentStep = step;
                    if (step >= 0 && step <= stepGammas.length - 1) {
                        setGamma(stepGammas[step]);
                    }
                }
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();

    // Initial draw placeholder
    draw();
})();
</script>

<!-- ==================== PART 2: The 3D Main Event ==================== -->

<section class="slide slide-center" id="part2-intro" data-title="Part 2: 3D">
    <h2 style="font-size: clamp(3rem, 5vw, 5.5rem);">Part II</h2>
    <h3 style="font-size: clamp(3rem, 5vw, 5.5rem); color: var(--slide-muted); text-transform: uppercase; letter-spacing: 0.05em;">One dimension up</h3>
</section>

<section class="slide slide-center" id="2to3d" data-title="From Paths to 3D">
    <h2 class="slide-title">From Paths to 3D</h2>
    <div style="display: flex; gap: 2vw; align-items: center; width: 95vw; height: 78vh;">
        <!-- Left pane: 3D view + description -->
        <div style="flex: 1; display: flex; flex-direction: column; align-items: center; height: 100%;">
            <div style="position: relative; width: 100%; flex: 1;">
                <canvas id="bridge-3d-canvas" style="width: 100%; height: 100%;"></canvas>
            </div>
            <div id="bridge-description" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: center; line-height: 1.6; margin-top: 2vh;">
                surface in <span id="bridge-box-size">1 × 12 × 9</span> box = 2D path in 12 × 9 rectangle
            </div>
            <div id="macmahon-text" style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: left; line-height: 1.5; margin-top: 1vh; opacity: 0; transition: opacity 0.3s;">
                <strong style="color: var(--slide-accent);">Theorem [MacMahon, c. 1900]:</strong><br>
                Number of surfaces in \(a \times b \times c\) box is \(\displaystyle\prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c}\frac{i+j+k-1}{i+j+k-2}\)
            </div>
            <div id="macmahon-example" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: left; line-height: 1.5; margin-top: 1vh; opacity: 0; transition: opacity 0.3s;">
                <div>For 9 × 12 × 9: <span style="font-family: monospace; font-size: clamp(1.4rem, 2.5vw, 2rem); font-weight: bold; color: #E57200;">1,340,992,301,315,806,672,824,460,528,012,500</span></div>
                <div style="margin-top: 1vh;">... and we <strong>pick one at random from this collection</strong></div>
            </div>
        </div>
        <!-- Right pane: snowflake -->
        <div id="bridge-right-pane" style="flex: 1; display: flex; flex-direction: column; align-items: center; height: 100%;">
            <div id="snowflake-title" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: center; margin-bottom: 1vh; opacity: 0; transition: opacity 0.3s;">
                More complex boxes:
            </div>
            <div style="position: relative; width: 100%; flex: 1;">
                <canvas id="bridge-snowflake-canvas" style="width: 100%; height: 100%;"></canvas>
            </div>
            <div id="snowflake-description" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: center; line-height: 1.6; margin-top: 2vh;">
            </div>
        </div>
    </div>
</section>

<script>
// From Paths to 3D: Asymmetric hexagon a×12×9 with WASM CFTP sampling
(async function() {
    'use strict';

    const canvas = document.getElementById('bridge-3d-canvas');
    const descEl = document.getElementById('bridge-description');
    if (!canvas) return;

    // Wait for LozengeModule to be available
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }

    // Create our own WASM instance (isolated from other slides)
    const wasm = await LozengeModule();

    // WASM interface
    const initFromTriangles = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const runCFTP = wasm.cwrap('runCFTP', 'number', []);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeString = wasm.cwrap('freeString', null, ['number']);

    // Parameters: a x B x C hexagon (a varies 1-9)
    const B = 12, C = 9;
    let currentA = 1;
    let currentDimers = [];

    // Colors (UVA scheme)
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    // Triangle geometry helpers
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) { return { x: n, y: slope * n + j * deltaC }; }

    function getRightTriangleCentroid(n, j) {
        const v1 = getVertex(n, j), v2 = getVertex(n, j - 1), v3 = getVertex(n + 1, j - 1);
        return { x: (v1.x + v2.x + v3.x) / 3, y: (v1.y + v2.y + v3.y) / 3 };
    }
    function getLeftTriangleCentroid(n, j) {
        const v1 = getVertex(n, j), v2 = getVertex(n + 1, j), v3 = getVertex(n + 1, j - 1);
        return { x: (v1.x + v2.x + v3.x) / 3, y: (v1.y + v2.y + v3.y) / 3 };
    }

    function pointInPolygon(x, y, polygon) {
        if (polygon.length < 3) return false;
        let inside = false;
        for (let i = 0, pj = polygon.length - 1; i < polygon.length; pj = i++) {
            const xi = polygon[i].x, yi = polygon[i].y;
            const xj = polygon[pj].x, yj = polygon[pj].y;
            if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    }

    // Generate triangles for a×b×c hexagon and pass to WASM
    function generateHexagonTriangles(a, b, c) {
        // Generate asymmetric hexagon boundary: sides [a, b, c, a, b, c]
        const directions = [[1, -1], [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1]];
        const sideLengths = [a, b, c, a, b, c];
        const boundary = [];
        let bn = 0, bj = 0;
        for (let dir = 0; dir < 6; dir++) {
            for (let step = 0; step < sideLengths[dir]; step++) {
                boundary.push(getVertex(bn, bj));
                bn += directions[dir][0];
                bj += directions[dir][1];
            }
        }

        // Bounding box
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const v of boundary) {
            minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
            minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
        }
        const searchMinN = Math.floor(minX) - 2;
        const searchMaxN = Math.ceil(maxX) + 2;
        const nRange = searchMaxN - searchMinN;
        const searchMinJ = Math.floor(minY / deltaC) - nRange - 5;
        const searchMaxJ = Math.ceil(maxY / deltaC) + nRange + 5;

        // Generate triangles inside hexagon
        const triangleArr = [];
        for (let n = searchMinN; n <= searchMaxN; n++) {
            for (let j = searchMinJ; j <= searchMaxJ; j++) {
                // Type 1 = right-pointing (black), Type 2 = left-pointing (white)
                const rc = getRightTriangleCentroid(n, j);
                if (pointInPolygon(rc.x, rc.y, boundary)) {
                    triangleArr.push(n, j, 1);  // n, j, type=1 (black/right)
                }
                const lc = getLeftTriangleCentroid(n, j);
                if (pointInPolygon(lc.x, lc.y, boundary)) {
                    triangleArr.push(n, j, 2);  // n, j, type=2 (white/left)
                }
            }
        }

        return triangleArr;
    }

    // Initialize WASM with hexagon and run CFTP
    function sampleHexagon(a, b, c) {
        const triangleArr = generateHexagonTriangles(a, b, c);

        // Allocate memory and copy triangle data to WASM
        const dataPtr = wasm._malloc(triangleArr.length * 4);
        for (let i = 0; i < triangleArr.length; i++) {
            wasm.setValue(dataPtr + i * 4, triangleArr[i], 'i32');
        }

        // Initialize from triangles
        const initPtr = initFromTriangles(dataPtr, triangleArr.length);
        freeString(initPtr);
        wasm._free(dataPtr);

        // Run CFTP for exact sampling
        const cftpPtr = runCFTP();
        const cftpResult = wasm.UTF8ToString(cftpPtr);
        freeString(cftpPtr);

        // Export sampled dimers
        const dimersPtr = exportDimersWasm();
        const dimersJson = wasm.UTF8ToString(dimersPtr);
        freeString(dimersPtr);

        const parsed = JSON.parse(dimersJson);
        currentDimers = parsed.dimers || [];
    }

    // ===== THREE.JS RENDERING (LAZY LOADED) =====
    let scene = null;
    let renderer = null;
    let camera = null;
    let controls = null;
    let meshGroup = null;
    let rotationLights = [];
    const frustumSize = 30;
    let aspect = 1;

    function initThreeJS() {
        if (renderer) return;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Orthographic camera for clean 2D-like projection
        aspect = canvas.clientWidth / canvas.clientHeight || 1;
        camera = new THREE.OrthographicCamera(
            -frustumSize * aspect / 2, frustumSize * aspect / 2,
            frustumSize / 2, -frustumSize / 2,
            0.1, 1000
        );

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false;
        controls.enablePan = true;
        controls.enableZoom = true;

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.35));
        const hemi = new THREE.HemisphereLight(0x6666aa, 0x222244, 0.25);
        hemi.position.set(0, 20, 0);
        scene.add(hemi);
        const directional = new THREE.DirectionalLight(0xffffff, 1.2);
        directional.position.set(15, 20, 5);
        scene.add(directional);
        const fill = new THREE.DirectionalLight(0xffffff, 0.3);
        fill.position.set(-10, 5, -5);
        scene.add(fill);

        // Extra lights for rotation mode (warm orange tints)
        rotationLights = [];
        const rotationLightConfigs = [
            { pos: [-20, 10, 20], color: 0xffaa66, intensity: 0.7 },   // Orange tint
            { pos: [-20, 10, -20], color: 0xffcc88, intensity: 0.6 }   // Warm tint
        ];
        for (const cfg of rotationLightConfigs) {
            const light = new THREE.DirectionalLight(cfg.color, cfg.intensity);
            light.position.set(cfg.pos[0], cfg.pos[1], cfg.pos[2]);
            light.visible = false;
            scene.add(light);
            rotationLights.push(light);
        }

        meshGroup = new THREE.Group();
        scene.add(meshGroup);

        // Camera for a×12×9 hexagon (ortho view)
        camera.position.set(40.2, -28.6, -17.5);
        camera.zoom = 1.432;
        camera.updateProjectionMatrix();
        controls.target.set(2.3, -7.8, 0.8);
        controls.update();

        // Listen for controls changes to render when paused
        controls.addEventListener('change', () => {
            if (!isRunning && renderer) renderer.render(scene, camera);
        });

        resize();
    }

    function disposeThreeJS() {
        if (!renderer) return;

        stopAutoRotate();
        if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
        isRunning = false;

        if (meshGroup) {
            while (meshGroup.children.length > 0) {
                const child = meshGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                meshGroup.remove(child);
            }
        }

        renderer.dispose();
        renderer = null;
        scene = null;
        camera = null;
        controls = null;
        meshGroup = null;
        rotationLights = [];
    }

    function resize() {
        if (!renderer || !camera) return;
        const w = canvas.clientWidth, h = canvas.clientHeight;
        if (w === 0 || h === 0) return;
        renderer.setSize(w, h, false);
        aspect = w / h;
        camera.left = -frustumSize * aspect / 2;
        camera.right = frustumSize * aspect / 2;
        camera.top = frustumSize / 2;
        camera.bottom = -frustumSize / 2;
        camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);

    // Vertex and height helpers
    function getVertexKeys(dimer) {
        const { bn, bj, t } = dimer;
        if (t === 0) return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
        if (t === 1) return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
        return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
    }

    function getHeightPattern(t) {
        if (t === 0) return [0, 0, 0, 0];
        if (t === 1) return [1, 0, 0, 1];
        return [1, 1, 0, 0];
    }

    function to3D(n, j, h) {
        return { x: h, y: -n - h, z: j - h };
    }

    function buildGeometry() {
        if (!meshGroup) return;

        while (meshGroup.children.length > 0) {
            const child = meshGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
            meshGroup.remove(child);
        }

        if (currentDimers.length === 0) return;

        // Build height function via BFS (2to3d slide)
        const vertexToDimers = new Map();
        for (const dimer of currentDimers) {
            for (const [n, j] of getVertexKeys(dimer)) {
                const key = `${n},${j}`;
                if (!vertexToDimers.has(key)) vertexToDimers.set(key, []);
                vertexToDimers.get(key).push(dimer);
            }
        }

        const heights = new Map();
        const firstVerts = getVertexKeys(currentDimers[0]);
        const startKey = `${firstVerts[0][0]},${firstVerts[0][1]}`;
        heights.set(startKey, 0);

        const queue = [startKey];
        const visited = new Set();

        while (queue.length > 0) {
            const currentKey = queue.shift();
            if (visited.has(currentKey)) continue;
            visited.add(currentKey);

            const currentH = heights.get(currentKey);
            const [cn, cj] = currentKey.split(',').map(Number);

            for (const dimer of vertexToDimers.get(currentKey) || []) {
                const verts = getVertexKeys(dimer);
                const pattern = getHeightPattern(dimer.t);
                const myIdx = verts.findIndex(([vn, vj]) => vn === cn && vj === cj);
                if (myIdx >= 0) {
                    for (let i = 0; i < 4; i++) {
                        const vkey = `${verts[i][0]},${verts[i][1]}`;
                        if (!heights.has(vkey)) {
                            heights.set(vkey, currentH + (pattern[i] - pattern[myIdx]));
                            queue.push(vkey);
                        }
                    }
                }
            }
        }

        const geometry = new THREE.BufferGeometry();
        const vertices = [], normals = [], vertexColors = [], indices = [];

        function addQuad(v1, v2, v3, v4, color) {
            const baseIndex = vertices.length / 3;
            vertices.push(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z, v4.x, v4.y, v4.z);
            const edge1 = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
            const edge2 = { x: v4.x - v1.x, y: v4.y - v1.y, z: v4.z - v1.z };
            const nx = edge1.y * edge2.z - edge1.z * edge2.y;
            const ny = edge1.z * edge2.x - edge1.x * edge2.z;
            const nz = edge1.x * edge2.y - edge1.y * edge2.x;
            const len = Math.sqrt(nx*nx + ny*ny + nz*nz) || 1;
            for (let i = 0; i < 4; i++) normals.push(nx/len, ny/len, nz/len);
            const clr = new THREE.Color(color);
            for (let i = 0; i < 4; i++) vertexColors.push(clr.r, clr.g, clr.b);
            indices.push(baseIndex, baseIndex+1, baseIndex+2, baseIndex, baseIndex+2, baseIndex+3);
        }

        for (const dimer of currentDimers) {
            const verts = getVertexKeys(dimer);
            const v3d = verts.map(([n, j]) => to3D(n, j, heights.get(`${n},${j}`) || 0));
            addQuad(v3d[0], v3d[1], v3d[2], v3d[3], colors[dimer.t]);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
        geometry.setIndex(indices);

        currentMaterial = new THREE.MeshStandardMaterial({
            vertexColors: true, side: THREE.DoubleSide, flatShading: true, roughness: 0.3, metalness: autoRotate ? 0.35 : 0.5,
            color: 0xddeeff  // Subtle blue tint
        });
        meshGroup.add(new THREE.Mesh(geometry, currentMaterial));

        const edgesGeometry = new THREE.EdgesGeometry(geometry, 10);
        meshGroup.add(new THREE.LineSegments(edgesGeometry, new THREE.LineBasicMaterial({ color: 0x222222, opacity: 0.6, transparent: true })));
    }

    let isRunning = false;
    let animationId = null;
    let autoRotate = false;
    const rotateSpeed = 0.012; // radians per frame
    let currentMaterial = null; // Reference to mesh material

    function regenerate() {
        sampleHexagon(currentA, B, C);
        buildGeometry();
        // Update description
        if (currentA === 1) {
            descEl.innerHTML = `surface in <span id="bridge-box-size">1 × 12 × 9</span> box = 2D path in 12 × 9 rectangle`;
        } else {
            descEl.innerHTML = `uniformly random surface in <span id="bridge-box-size">${currentA} × 12 × 9</span> box`;
        }
        if (renderer) renderer.render(scene, camera);
    }

    function animate() {
        if (!isRunning || !renderer || !camera || !controls) return;

        if (autoRotate) {
            // Rotate camera around its up vector (visual vertical)
            const axis = camera.up.clone().normalize();
            const offset = camera.position.clone().sub(controls.target);
            offset.applyAxisAngle(axis, rotateSpeed);
            camera.position.copy(controls.target).add(offset);
            camera.lookAt(controls.target);
        }

        controls.update();
        renderer.render(scene, camera);
        animationId = requestAnimationFrame(animate);
    }

    function start() {
        if (isRunning) return;
        isRunning = true;
        animate();
    }

    function pause() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    function startAutoRotate() {
        autoRotate = true;
        // Turn on extra lights
        for (const light of rotationLights) if (light) light.visible = true;
        // Keep some metalness for vivid look
        if (currentMaterial) currentMaterial.metalness = 0.35;
        if (!isRunning) start();
    }

    function stopAutoRotate() {
        autoRotate = false;
        // Turn off extra lights
        for (const light of rotationLights) if (light) light.visible = false;
        // Restore metallic material
        if (currentMaterial) currentMaterial.metalness = 0.5;
    }

    function setLayerCount(a) {
        currentA = Math.max(1, Math.min(9, a));
        regenerate();
    }

    // Register with slide engine
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('2to3d', {
                start,
                pause,
                steps: 12,
                onSlideEnter() {
                    // Lazy init WebGL to avoid context limit
                    initThreeJS();

                    // Reset camera to default position
                    if (camera && controls) {
                        camera.position.set(40.2, -28.6, -17.5);
                        camera.zoom = 1.432;
                        camera.updateProjectionMatrix();
                        controls.target.set(2.3, -7.8, 0.8);
                        controls.update();
                    }
                    stopAutoRotate();

                    setTimeout(() => {
                        resize();
                        regenerate();
                        if (renderer) renderer.render(scene, camera);
                        if (window.bridgeSnowflake) {
                            window.bridgeSnowflake.resize();
                            window.bridgeSnowflake.render();
                        }
                    }, 50);
                    start();
                },
                onSlideLeave() {
                    stopAutoRotate();
                    pause();
                    // Dispose WebGL context to free resources
                    disposeThreeJS();
                },
                onStep(step) {
                    const macmahonEl = document.getElementById('macmahon-text');
                    const macmahonExEl = document.getElementById('macmahon-example');
                    if (step <= 8) {
                        stopAutoRotate();
                        setLayerCount(step + 1);
                        if (macmahonEl) macmahonEl.style.opacity = '0';
                        if (macmahonExEl) macmahonExEl.style.opacity = '0';
                    } else if (step === 9) {
                        // Start rotating the 9×12×9 hexagon
                        startAutoRotate();
                    } else if (step === 10) {
                        // Show MacMahon formula (keep rotating)
                        if (macmahonEl) macmahonEl.style.opacity = '1';
                        if (macmahonExEl) macmahonExEl.style.opacity = '1';
                        if (window.MathJax) MathJax.typeset();
                    } else if (step === 11 && window.bridgeSnowflake) {
                        // Stop hexagon rotation, show snowflake region (unsampled)
                        stopAutoRotate();
                        document.getElementById('snowflake-title').style.opacity = '1';
                        window.bridgeSnowflake.showRegion();
                    } else if (step === 12 && window.bridgeSnowflake) {
                        // CFTP sample the snowflake
                        const descEl = document.getElementById('snowflake-description');
                        if (descEl) descEl.textContent = 'picking one uniformly at random...';
                        setTimeout(() => {
                            window.bridgeSnowflake.regenerate();
                            if (descEl) descEl.textContent = 'picking one uniformly at random... done';
                        }, 50);
                    }
                },
                onStepBack(step) {
                    const macmahonEl = document.getElementById('macmahon-text');
                    const macmahonExEl = document.getElementById('macmahon-example');
                    const snowflakeTitleEl = document.getElementById('snowflake-title');
                    const snowflakeDescEl = document.getElementById('snowflake-description');
                    if (step <= 8) {
                        stopAutoRotate();
                        setLayerCount(step + 1);
                        if (macmahonEl) macmahonEl.style.opacity = '0';
                        if (macmahonExEl) macmahonExEl.style.opacity = '0';
                        if (snowflakeTitleEl) snowflakeTitleEl.style.opacity = '0';
                        if (snowflakeDescEl) snowflakeDescEl.textContent = '';
                        if (window.bridgeSnowflake) window.bridgeSnowflake.clear();
                    } else if (step === 9) {
                        startAutoRotate();
                        if (macmahonEl) macmahonEl.style.opacity = '0';
                        if (macmahonExEl) macmahonExEl.style.opacity = '0';
                        if (snowflakeTitleEl) snowflakeTitleEl.style.opacity = '0';
                        if (snowflakeDescEl) snowflakeDescEl.textContent = '';
                        if (window.bridgeSnowflake) window.bridgeSnowflake.clear();
                    } else if (step === 10) {
                        if (macmahonEl) macmahonEl.style.opacity = '1';
                        if (macmahonExEl) macmahonExEl.style.opacity = '1';
                        if (snowflakeTitleEl) snowflakeTitleEl.style.opacity = '0';
                        if (snowflakeDescEl) snowflakeDescEl.textContent = '';
                        if (window.bridgeSnowflake) window.bridgeSnowflake.clear();
                    } else if (step === 11 && window.bridgeSnowflake) {
                        if (snowflakeTitleEl) snowflakeTitleEl.style.opacity = '1';
                        if (snowflakeDescEl) snowflakeDescEl.textContent = '';
                        window.bridgeSnowflake.showRegion();
                    }
                }
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();

// Snowflake visualization (right pane) - 2D Canvas
(async function() {
    'use strict';

    const canvas = document.getElementById('bridge-snowflake-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    // Wait for LozengeModule
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }

    // Create separate WASM instance for snowflake
    const wasm = await LozengeModule();
    const initFromTriangles = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const runCFTP = wasm.cwrap('runCFTP', 'number', []);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeString = wasm.cwrap('freeString', null, ['number']);

    // Load snowflake triangles
    let snowflakeTriangles = null;
    try {
        const resp = await fetch('/letters/big_snoflake.json');
        const data = await resp.json();
        snowflakeTriangles = data.triangles;
    } catch (e) {
        return;
    }

    let currentDimers = [];
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    // Triangular lattice helpers
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);
    function getVertex(n, j) { return { x: n, y: slope * n + j * deltaC }; }

    // Get lozenge vertices
    function getLozengeVerts(dimer) {
        const { bn, bj, t } = dimer;
        if (t === 0) {
            return [getVertex(bn, bj), getVertex(bn+1, bj), getVertex(bn+1, bj-1), getVertex(bn, bj-1)];
        } else if (t === 1) {
            return [getVertex(bn, bj), getVertex(bn+1, bj-1), getVertex(bn+1, bj-2), getVertex(bn, bj-1)];
        } else {
            return [getVertex(bn-1, bj), getVertex(bn, bj), getVertex(bn+1, bj-1), getVertex(bn, bj-1)];
        }
    }

    // Convert world coords to canvas coords
    function toCanvas(x, y, centerX, centerY, scale) {
        return [centerX + x * scale, centerY - y * scale];
    }

    // Compute bounding box
    function computeBounds() {
        if (currentDimers.length === 0) return { minX: -50, maxX: 50, minY: -50, maxY: 50 };
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const d of currentDimers) {
            const verts = getLozengeVerts(d);
            for (const v of verts) {
                if (v.x < minX) minX = v.x;
                if (v.x > maxX) maxX = v.x;
                if (v.y < minY) minY = v.y;
                if (v.y > maxY) maxY = v.y;
            }
        }
        return { minX, maxX, minY, maxY };
    }

    function resize() {
        const w = canvas.clientWidth, h = canvas.clientHeight;
        if (w === 0 || h === 0) return;
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resize();
    window.addEventListener('resize', () => { resize(); draw(); });

    function draw() {
        const w = canvas.clientWidth, h = canvas.clientHeight;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, w, h);

        if (currentDimers.length === 0) return;

        const bounds = computeBounds();
        const worldW = bounds.maxX - bounds.minX;
        const worldH = bounds.maxY - bounds.minY;
        const padding = 0.1;
        const scale = Math.min(w / (worldW * (1 + padding)), h / (worldH * (1 + padding)));
        const centerX = w / 2 - (bounds.minX + bounds.maxX) / 2 * scale;
        const centerY = h / 2 + (bounds.minY + bounds.maxY) / 2 * scale;

        // Draw lozenges
        for (const d of currentDimers) {
            const verts = getLozengeVerts(d);
            const canvasVerts = verts.map(v => toCanvas(v.x, v.y, centerX, centerY, scale));

            ctx.fillStyle = colors[d.t];
            ctx.beginPath();
            ctx.moveTo(canvasVerts[0][0], canvasVerts[0][1]);
            for (let i = 1; i < canvasVerts.length; i++) {
                ctx.lineTo(canvasVerts[i][0], canvasVerts[i][1]);
            }
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#222222';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }

    // Initialize region and get Dinic's minimal tiling (no CFTP)
    function getMinimalTiling() {
        if (!snowflakeTriangles) {
            currentDimers = [];
            return;
        }

        const triArr = [];
        for (const tri of snowflakeTriangles) {
            triArr.push(tri.n, tri.j, tri.type);
        }

        const ptr = wasm._malloc(triArr.length * 4);
        for (let i = 0; i < triArr.length; i++) {
            wasm.setValue(ptr + i * 4, triArr[i], 'i32');
        }

        initFromTriangles(ptr, triArr.length);
        wasm._free(ptr);

        const strPtr = exportDimersWasm();
        const jsonStr = wasm.UTF8ToString(strPtr);
        freeString(strPtr);

        try {
            const parsed = JSON.parse(jsonStr);
            currentDimers = Array.isArray(parsed.dimers) ? parsed.dimers : [];
        } catch (e) {
            currentDimers = [];
        }
    }

    function sampleSnowflake() {
        if (!snowflakeTriangles) {
            currentDimers = [];
            return;
        }

        runCFTP();

        const strPtr = exportDimersWasm();
        const jsonStr = wasm.UTF8ToString(strPtr);
        freeString(strPtr);

        try {
            const parsed = JSON.parse(jsonStr);
            currentDimers = Array.isArray(parsed.dimers) ? parsed.dimers : [];
        } catch (e) {
            currentDimers = [];
        }
    }

    let hasSampled = false;

    function showRegion() {
        getMinimalTiling();
        draw();
    }

    function regenerate() {
        sampleSnowflake();
        draw();
        hasSampled = true;
    }

    function clear() {
        currentDimers = [];
        hasSampled = false;
        const w = canvas.clientWidth, h = canvas.clientHeight;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, w, h);
    }

    // Expose for step control
    window.bridgeSnowflake = {
        showRegion,
        regenerate,
        resize,
        clear,
        render: draw,
        hasSampled: () => hasSampled
    };
})();
</script>

<section class="slide slide-center" id="limit-shape" data-title="Limit Shape in 3D">
    <h2 class="slide-title">Limit Shape in 3D</h2>
    <div style="position: relative; width: 85vw; height: 52vh;">
        <canvas id="limit-shape-3d-canvas" style="width: 100%; height: 100%;"></canvas>
    </div>
    <div id="limit-shape-3d-status" style="font-size: clamp(0.9rem, 1.5vw, 1.2rem); margin-top: 0.5vh;"></div>
    <div id="limit-shape-panels" style="opacity: 0; transition: opacity 0.5s; margin-top: 1vh; width: 85vw; display: grid; grid-template-columns: 1fr 1fr; gap: 2vw; text-align: left;">
        <div>
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">
                <strong style="color: var(--slide-accent);">Theorem [Cohn–Kenyon–Propp 2000]:</strong><br>
                As the mesh size → 0, the random stepped surface concentrates around a <strong>deterministic limit shape</strong>.
            </div>
            <div id="limit-shape-curved-text" style="margin-top: 1vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem); opacity: 0; transition: opacity 0.5s;">
                In examples we saw, the limit shape is "curved", like for q<sup>area</sup> examples from 2D.
            </div>
        </div>
        <div id="limit-shape-right-panel" style="padding: 1vh 1.5vw; font-size: clamp(1.5rem, 2.8vw, 2.2rem); color: var(--slide-accent); opacity: 0; transition: opacity 0.5s;">
            What is the variational description?
            <div id="limit-shape-subtext" style="margin-top: 1vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem); color: #000; opacity: 0; transition: opacity 0.5s;">
                We need to understand examples with flat (sloped) limit shape.
            </div>
        </div>
    </div>
</section>

<script>
// Limit Shape 3D Visualization
(async function() {
    'use strict';

    const canvas = document.getElementById('limit-shape-3d-canvas');
    const statusEl = document.getElementById('limit-shape-3d-status');
    const panelsEl = document.getElementById('limit-shape-panels');
    const rightPanelEl = document.getElementById('limit-shape-right-panel');
    const curvedTextEl = document.getElementById('limit-shape-curved-text');
    const subtextEl = document.getElementById('limit-shape-subtext');
    if (!canvas) return;

    // Wait for LozengeModule
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }

    // Create separate WASM instance
    const wasm = await LozengeModule();
    const initFromTriangles = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const runCFTPWasm = wasm.cwrap('runCFTP', 'number', []);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeString = wasm.cwrap('freeString', null, ['number']);
    // GPU CFTP wrappers
    const initCFTPWasm = wasm.cwrap('initCFTP', 'number', []);
    const getGridBoundsWasm = wasm.cwrap('getGridBounds', 'number', []);
    const getCFTPMinGridDataWasm = wasm.cwrap('getCFTPMinGridData', 'number', []);
    const getCFTPMaxGridDataWasm = wasm.cwrap('getCFTPMaxGridData', 'number', []);

    // WebGPU engine
    let gpuEngine = null;
    let gpuAvailable = false;

    // Initialize WebGPU engine
    async function initGPU() {
        if (gpuEngine) return gpuAvailable;
        if (typeof WebGPULozengeEngine === 'undefined') {
            console.log('WebGPULozengeEngine not available');
            return false;
        }
        try {
            gpuEngine = new WebGPULozengeEngine();
            await gpuEngine.init();
            gpuAvailable = true;
            console.log('WebGPU Lozenge Engine initialized for limit-shape');
            return true;
        } catch (e) {
            console.log('WebGPU not available:', e.message);
            gpuAvailable = false;
            return false;
        }
    }

    // Helper to get grid data from WASM
    function getGridBounds() {
        const ptr = getGridBoundsWasm();
        const jsonStr = wasm.UTF8ToString(ptr);
        freeString(ptr);
        return JSON.parse(jsonStr);
    }

    function getCFTPMinRawGridData(bounds) {
        const dataPtr = getCFTPMinGridDataWasm();
        if (!dataPtr) return null;
        const data = new Int32Array(bounds.size);
        for (let i = 0; i < bounds.size; i++) {
            data[i] = wasm.getValue(dataPtr + i * 4, 'i32');
        }
        wasm._free(dataPtr);
        return data;
    }

    function getCFTPMaxRawGridData(bounds) {
        const dataPtr = getCFTPMaxGridDataWasm();
        if (!dataPtr) return null;
        const data = new Int32Array(bounds.size);
        for (let i = 0; i < bounds.size; i++) {
            data[i] = wasm.getValue(dataPtr + i * 4, 'i32');
        }
        wasm._free(dataPtr);
        return data;
    }

    // Load shape triangles
    let shapeTriangles = null;
    try {
        const resp = await fetch('/letters/shape_for_arctic.json');
        const data = await resp.json();
        shapeTriangles = data.triangles;
    } catch (e) {
        return;
    }

    let currentDimers = [];
    const colors = ['#FFFFFF', '#FFFFFF', '#FFFFFF'];  // White lozenges like slide 2

    // Three.js setup - LAZY LOADED to avoid WebGL context limit
    let renderer = null;
    let scene = null;
    let camera = null;
    let controls = null;
    let meshGroup = null;
    let rotationLights = [];
    const frustumSize = 80;
    let aspect = 1;

    function initThreeJS() {
        if (renderer) return; // Already initialized

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);  // Dark background like slide 2
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        aspect = canvas.clientWidth / canvas.clientHeight || 1;
        camera = new THREE.OrthographicCamera(
            -frustumSize * aspect / 2, frustumSize * aspect / 2,
            frustumSize / 2, -frustumSize / 2,
            0.1, 1000
        );

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false;
        controls.enablePan = true;
        controls.enableZoom = true;

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.35));
        const hemi = new THREE.HemisphereLight(0x6666aa, 0x222244, 0.25);
        hemi.position.set(0, 20, 0);
        scene.add(hemi);
        const directional = new THREE.DirectionalLight(0xffffff, 1.2);
        directional.position.set(15, 20, 5);
        scene.add(directional);
        const fill = new THREE.DirectionalLight(0xffffff, 0.3);
        fill.position.set(-10, 5, -5);
        scene.add(fill);

        // Extra lights for rotation (warm orange tints)
        rotationLights = [];
        const rotationLightConfigs = [
            { pos: [-30, 10, 30], color: 0xffaa66, intensity: 0.7 },   // Orange tint
            { pos: [-30, 10, -30], color: 0xffcc88, intensity: 0.6 }   // Warm tint
        ];
        for (const cfg of rotationLightConfigs) {
            const light = new THREE.DirectionalLight(cfg.color, cfg.intensity);
            light.position.set(cfg.pos[0], cfg.pos[1], cfg.pos[2]);
            light.visible = false;
            scene.add(light);
            rotationLights.push(light);
        }

        meshGroup = new THREE.Group();
        scene.add(meshGroup);

        // Initial camera position
        camera.position.set(10.2, -110.4, -10.8);
        camera.zoom = 1.0;
        camera.updateProjectionMatrix();
        controls.target.set(-13.4, -89.2, 12.4);
        controls.update();

        resize();
    }

    function disposeThreeJS() {
        if (!renderer) return;

        stopAutoRotate();

        // Dispose meshes
        if (meshGroup) {
            while (meshGroup.children.length > 0) {
                const child = meshGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                meshGroup.remove(child);
            }
        }

        // Dispose renderer (releases WebGL context)
        renderer.dispose();
        renderer = null;
        scene = null;
        camera = null;
        controls = null;
        meshGroup = null;
        rotationLights = [];
    }

    function resize() {
        if (!renderer || !camera) return;
        const w = canvas.clientWidth, h = canvas.clientHeight;
        if (w === 0 || h === 0) return;
        renderer.setSize(w, h, false);
        aspect = w / h;
        camera.left = -frustumSize * aspect / 2;
        camera.right = frustumSize * aspect / 2;
        camera.top = frustumSize / 2;
        camera.bottom = -frustumSize / 2;
        camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);

    // Vertex and height helpers (limit-shape)
    function getVertexKeys(dimer) {
        const { bn, bj, t } = dimer;
        if (t === 0) return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
        if (t === 1) return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
        return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
    }

    function getHeightPattern(t) {
        if (t === 0) return [0, 0, 0, 0];
        if (t === 1) return [1, 0, 0, 1];
        return [1, 1, 0, 0];
    }

    function to3D(n, j, h) {
        return { x: h, y: -n - h, z: j - h };
    }

    function buildGeometry() {
        if (!meshGroup) return;
        while (meshGroup.children.length > 0) {
            const child = meshGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
            meshGroup.remove(child);
        }

        if (currentDimers.length === 0) return;

        // Build vertex-to-dimer map and calculate heights via BFS
        const vertexToDimers = new Map();
        for (const dimer of currentDimers) {
            for (const [n, j] of getVertexKeys(dimer)) {
                const key = `${n},${j}`;
                if (!vertexToDimers.has(key)) vertexToDimers.set(key, []);
                vertexToDimers.get(key).push(dimer);
            }
        }

        const heights = new Map();
        const firstVerts = getVertexKeys(currentDimers[0]);
        const startKey = `${firstVerts[0][0]},${firstVerts[0][1]}`;
        heights.set(startKey, 0);

        const queue = [startKey];
        const visited = new Set();

        while (queue.length > 0) {
            const currentKey = queue.shift();
            if (visited.has(currentKey)) continue;
            visited.add(currentKey);

            const currentH = heights.get(currentKey);
            const [cn, cj] = currentKey.split(',').map(Number);

            for (const dimer of vertexToDimers.get(currentKey) || []) {
                const verts = getVertexKeys(dimer);
                const pattern = getHeightPattern(dimer.t);
                const myIdx = verts.findIndex(([vn, vj]) => vn === cn && vj === cj);
                if (myIdx >= 0) {
                    for (let i = 0; i < 4; i++) {
                        const vkey = `${verts[i][0]},${verts[i][1]}`;
                        if (!heights.has(vkey)) {
                            heights.set(vkey, currentH + (pattern[i] - pattern[myIdx]));
                            queue.push(vkey);
                        }
                    }
                }
            }
        }

        const geometry = new THREE.BufferGeometry();
        const vertices = [], normals = [], vertexColors = [], indices = [];

        function addQuad(v1, v2, v3, v4, color) {
            const baseIndex = vertices.length / 3;
            vertices.push(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z, v4.x, v4.y, v4.z);
            const edge1 = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
            const edge2 = { x: v4.x - v1.x, y: v4.y - v1.y, z: v4.z - v1.z };
            const nx = edge1.y * edge2.z - edge1.z * edge2.y;
            const ny = edge1.z * edge2.x - edge1.x * edge2.z;
            const nz = edge1.x * edge2.y - edge1.y * edge2.x;
            const len = Math.sqrt(nx*nx + ny*ny + nz*nz) || 1;
            for (let i = 0; i < 4; i++) normals.push(nx/len, ny/len, nz/len);
            const clr = new THREE.Color(color);
            for (let i = 0; i < 4; i++) vertexColors.push(clr.r, clr.g, clr.b);
            indices.push(baseIndex, baseIndex+1, baseIndex+2, baseIndex, baseIndex+2, baseIndex+3);
        }

        for (const dimer of currentDimers) {
            const verts = getVertexKeys(dimer);
            const v3d = verts.map(([n, j]) => to3D(n, j, heights.get(`${n},${j}`) || 0));
            addQuad(v3d[0], v3d[1], v3d[2], v3d[3], colors[dimer.t]);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
        geometry.setIndex(indices);

        currentMaterial = new THREE.MeshStandardMaterial({
            vertexColors: true, side: THREE.DoubleSide, flatShading: true, roughness: 0.3, metalness: autoRotate ? 0.35 : 0.5,
            color: 0xddeeff  // Subtle blue tint
        });
        meshGroup.add(new THREE.Mesh(geometry, currentMaterial));

        const edgesGeometry = new THREE.EdgesGeometry(geometry, 10);
        meshGroup.add(new THREE.LineSegments(edgesGeometry, new THREE.LineBasicMaterial({ color: 0x222222, opacity: 0.4, transparent: true })));

        // Center camera on geometry
        if (controls) {
            const box = new THREE.Box3().setFromObject(meshGroup);
            const center = new THREE.Vector3();
            box.getCenter(center);
            controls.target.copy(center);
            controls.update();
        }
    }

    // Sampling functions
    function getMinimalTiling() {
        if (!shapeTriangles) { currentDimers = []; return; }

        const triArr = [];
        for (const tri of shapeTriangles) {
            triArr.push(tri.n, tri.j, tri.type);
        }

        const ptr = wasm._malloc(triArr.length * 4);
        for (let i = 0; i < triArr.length; i++) {
            wasm.setValue(ptr + i * 4, triArr[i], 'i32');
        }

        initFromTriangles(ptr, triArr.length);
        wasm._free(ptr);

        const strPtr = exportDimersWasm();
        const jsonStr = wasm.UTF8ToString(strPtr);
        freeString(strPtr);

        try {
            const parsed = JSON.parse(jsonStr);
            currentDimers = Array.isArray(parsed.dimers) ? parsed.dimers : [];
        } catch (e) {
            currentDimers = [];
        }
    }

    // Get black triangles from shape (type=1 triangles)
    function getBlackTriangles() {
        if (!shapeTriangles) return [];
        return shapeTriangles.filter(t => t.type === 1).map(t => ({ n: t.n, j: t.j }));
    }

    // GPU CFTP sampling with WASM fallback
    async function sampleCFTP() {
        if (!shapeTriangles) { currentDimers = []; return; }

        // Try GPU CFTP first
        const useGPU = await initGPU();
        if (useGPU && gpuEngine) {
            try {
                // Initialize CFTP on WASM side to create extremal states
                initCFTPWasm();
                const bounds = getGridBounds();

                // Get extremal states for GPU
                const minGridData = getCFTPMinRawGridData(bounds);
                const maxGridData = getCFTPMaxRawGridData(bounds);

                if (minGridData && maxGridData) {
                    // Initialize GPU engine with grid parameters
                    gpuEngine.initFromWasmData(minGridData, bounds.minN, bounds.maxN, bounds.minJ, bounds.maxJ);

                    // Initialize GPU CFTP
                    const gpuCftpOk = await gpuEngine.initCFTP(minGridData, maxGridData);
                    if (gpuCftpOk) {
                        // GPU CFTP epoch-doubling loop
                        let T = 1;
                        const maxT = 134217728; // 2^27 safety limit
                        let coalesced = false;

                        while (!coalesced && T <= maxT) {
                            gpuEngine.resetCFTPChains(minGridData, maxGridData);
                            const result = await gpuEngine.stepCFTP(T, Math.min(T, 10000));
                            coalesced = result.coalesced;
                            if (!coalesced) {
                                coalesced = await gpuEngine.checkCoalescence();
                            }
                            if (!coalesced) T *= 2;
                        }

                        if (coalesced) {
                            // Get result from GPU and convert to dimers directly
                            const resultGrid = await gpuEngine.getCFTPResult();
                            const blackTriangles = getBlackTriangles();
                            currentDimers = gpuEngine.gridToDimers(resultGrid, blackTriangles);
                            gpuEngine.destroyCFTP();
                            console.log('GPU CFTP completed, T=' + T + ', dimers=' + currentDimers.length);
                            return;
                        }
                        gpuEngine.destroyCFTP();
                    }
                }
            } catch (e) {
                console.log('GPU CFTP failed, falling back to WASM:', e.message);
            }
        }

        // Fallback to WASM CFTP
        console.log('Using WASM CFTP');
        runCFTPWasm();

        const strPtr = exportDimersWasm();
        const jsonStr = wasm.UTF8ToString(strPtr);
        freeString(strPtr);

        try {
            const parsed = JSON.parse(jsonStr);
            currentDimers = Array.isArray(parsed.dimers) ? parsed.dimers : [];
        } catch (e) {
            currentDimers = [];
        }
    }

    let isRunning = false;
    let animationId = null;
    let autoRotate = false;
    const rotateSpeed = 0.008;
    let currentMaterial = null;
    let hasSampled = false;

    function animate() {
        if (!isRunning || !renderer || !camera || !controls) return;

        if (autoRotate) {
            // Rotate around (1,1,1) direction for natural 3D view
            const axis = new THREE.Vector3(1, 1, 1).normalize();
            const offset = camera.position.clone().sub(controls.target);
            offset.applyAxisAngle(axis, rotateSpeed);
            camera.position.copy(controls.target).add(offset);
            camera.lookAt(controls.target);
        }

        controls.update();
        renderer.render(scene, camera);
        animationId = requestAnimationFrame(animate);
    }

    function start() {
        if (isRunning) return;
        isRunning = true;
        animate();
    }

    function pause() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    function startAutoRotate() {
        autoRotate = true;
        for (const light of rotationLights) if (light) light.visible = true;
        if (currentMaterial) currentMaterial.metalness = 0.35;  // Keep some metalness for vivid look
        if (!isRunning) start();
    }

    function stopAutoRotate() {
        autoRotate = false;
        for (const light of rotationLights) if (light) light.visible = false;
        if (currentMaterial) currentMaterial.metalness = 0.5;
    }

    function clear() {
        if (meshGroup) {
            while (meshGroup.children.length > 0) {
                const child = meshGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                meshGroup.remove(child);
            }
        }
        currentDimers = [];
        hasSampled = false;
        if (statusEl) statusEl.textContent = '';
        if (renderer) renderer.render(scene, camera);
    }

    // Register with slide engine
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('limit-shape', {
                start,
                pause,
                steps: 5,
                onSlideEnter() {
                    // Lazy init WebGL to avoid context limit
                    initThreeJS();
                    if (camera && controls) {
                        camera.position.set(22.6, -118.1, 11.9);
                        camera.zoom = 1.0;
                        camera.updateProjectionMatrix();
                        controls.target.set(0.0, -48.0, 32.0);
                        controls.update();
                        // Listen for controls changes
                        controls.addEventListener('change', () => {
                            if (!isRunning && renderer) renderer.render(scene, camera);
                        });
                    }
                    stopAutoRotate();
                    hasSampled = false;
                    // Show minimal tiling (shape outline) on load
                    setTimeout(() => {
                        resize();
                        getMinimalTiling();
                        buildGeometry();
                        if (renderer) renderer.render(scene, camera);
                    }, 50);
                    start();
                },
                onSlideLeave() {
                    stopAutoRotate();
                    pause();
                    // Dispose WebGL context to free resources
                    disposeThreeJS();
                    currentDimers = [];
                    hasSampled = false;
                    if (statusEl) statusEl.textContent = '';
                    if (panelsEl) panelsEl.style.opacity = '0';
                    if (curvedTextEl) curvedTextEl.style.opacity = '0';
                    if (rightPanelEl) rightPanelEl.style.opacity = '0';
                    if (subtextEl) subtextEl.style.opacity = '0';
                },
                async onStep(step) {
                    if (step === 1) {
                        // Run CFTP to get random sample (async for GPU)
                        if (statusEl) statusEl.textContent = 'picking one uniformly at random...';
                        await new Promise(r => setTimeout(r, 50));
                        await sampleCFTP();
                        buildGeometry();
                        if (statusEl) statusEl.textContent = '';
                        hasSampled = true;
                        if (renderer) renderer.render(scene, camera);
                    } else if (step === 2) {
                        // Start auto-rotation
                        startAutoRotate();
                    } else if (step === 3) {
                        // Show theorem panel
                        if (panelsEl) panelsEl.style.opacity = '1';
                    } else if (step === 4) {
                        // Show curved text
                        if (curvedTextEl) curvedTextEl.style.opacity = '1';
                    } else if (step === 5) {
                        // Show question in right panel with subtext
                        if (rightPanelEl) rightPanelEl.style.opacity = '1';
                        if (subtextEl) subtextEl.style.opacity = '1';
                    }
                },
                onStepBack(step) {
                    if (step === 0) {
                        clear();
                        stopAutoRotate();
                        if (panelsEl) panelsEl.style.opacity = '0';
                        if (curvedTextEl) curvedTextEl.style.opacity = '0';
                        if (rightPanelEl) rightPanelEl.style.opacity = '0';
                        if (subtextEl) subtextEl.style.opacity = '0';
                    } else if (step === 1) {
                        stopAutoRotate();
                        if (panelsEl) panelsEl.style.opacity = '0';
                        if (curvedTextEl) curvedTextEl.style.opacity = '0';
                        if (rightPanelEl) rightPanelEl.style.opacity = '0';
                        if (subtextEl) subtextEl.style.opacity = '0';
                    } else if (step === 2) {
                        if (panelsEl) panelsEl.style.opacity = '0';
                        if (curvedTextEl) curvedTextEl.style.opacity = '0';
                        if (rightPanelEl) rightPanelEl.style.opacity = '0';
                        if (subtextEl) subtextEl.style.opacity = '0';
                    } else if (step === 3) {
                        // At theorem, hide curved text and question
                        if (curvedTextEl) curvedTextEl.style.opacity = '0';
                        if (rightPanelEl) rightPanelEl.style.opacity = '0';
                        if (subtextEl) subtextEl.style.opacity = '0';
                    } else if (step === 4) {
                        // At curved text, hide question
                        if (rightPanelEl) rightPanelEl.style.opacity = '0';
                        if (subtextEl) subtextEl.style.opacity = '0';
                    }
                }
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();
</script>

<section class="slide slide-top" id="energy" data-title="Energy">
    <h2 class="slide-title">Local energy</h2>

    <div style="display: grid; grid-template-columns: 0.8fr 1.2fr; gap: 2vw; margin-top: 1vh; width: 100%; align-items: start;">
        <!-- Left: Text explanation -->
        <div style="display: flex; flex-direction: column; gap: 1.5vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">
            <!-- How to get limit shape -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">How to get limit shape?</strong>
                <ul style="margin: 0.5vh 0 0 1.5em; padding: 0;">
                    <li>Approximate any surface by piecewise-planar patches</li>
                    <li>Count configurations approximating a given slope \((A,B)\)</li>
                    <li>Integrate and maximize to get the typical shape</li>
                </ul>
            </div>

            <!-- CKP 2000 -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Energy σ(A,B) [Cohn-Kenyon-Propp 2000]</strong><br>
                    \(\sigma(A,B) = \dfrac1\pi
                    ( L(\pi p_1)+L(\pi p_2)+L(\pi (1-p_1-p_2))),
                    \)
                    where \(p_1, p_2, 1-p_1-p_2\) is the normal direction to the patch, and <br>
                    \(
                    L(z)=\int_0^z\log|2\sin t|\,dt
                    \) is the Lobachevsky function.
            </div>

            <!-- Integral -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Variational principle, subject to boundary conditions</strong><br>
                Limit shape $z=h(x,y)$ maximizes \(\displaystyle\iint \sigma(\nabla h)\, dxdy\)
            </div>

            <!-- KOS 2006 -->
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Generalization [Kenyon-Okounkov-Sheffield 2006]</strong><br>
                Our surfaces use \(1\times 1\) squares in three coordinate directions.
                The theory of limit shapes generalizes
                to surfaces from plaquettes of other shapes, possibly weighted.
                Local energy expressed through <b>algebraic geometry</b> of the plaquettes.
            </div>
        </div>

        <!-- Right: 3D tiling canvas -->
        <div style="position: relative; display: flex; flex-direction: column; align-items: center; gap: 1vh;">
            <!-- 3D tiling canvas (main) -->
            <canvas id="energy-tiling-canvas" width="1200" height="1000" style="height: 80vh; width:47vw; border: 1px solid #ccc;"></canvas>
            <!-- Controls below -->
            <div id="energy-controls" style="display: flex; gap: 1vw; align-items: center; flex-wrap: wrap; font-size: clamp(0.75rem, 1.5vw, 1.1rem);">
                <label style="display: flex; align-items: center; gap: 0.3vw;">
                    A: <input type="number" id="gradient-a" min="-5" max="5" step="0.1" value="-2" style="width: 4em; font-size: inherit; padding: 0.2em;">
                </label>
                <label style="display: flex; align-items: center; gap: 0.3vw;">
                    B: <input type="number" id="gradient-b" min="-5" max="5" step="0.1" value="0.3" style="width: 4em; font-size: inherit; padding: 0.2em;">
                </label>
                <button id="energy-sample" style="padding: 0.3em 0.6em; cursor: pointer; border: 2px solid var(--slide-accent); background: var(--slide-accent); color: white; border-radius: 4px; font-size: inherit;">Sample</button>
                <span style="color: #888; margin-left: 0.5vw;">plane z=Ax+By</span>
            </div>
        </div>
    </div>
</section>

<!-- Energy slide 3D Tiling (Lazy WebGL loading) -->
<script>
(async function() {
    'use strict';

    const canvas = document.getElementById('energy-tiling-canvas');
    if (!canvas) return;

    // ===== THREE.JS (LAZY LOADED) =====
    let scene = null;
    let camera = null;
    let renderer = null;
    let controls = null;
    let meshGroup = null;
    const frustumSize = 35;  // Smaller = more zoom

    function initThreeJS() {
        if (renderer) return;  // Already initialized

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);  // Dark background like limit-shape

        const w = canvas.clientWidth || canvas.width;
        const h = canvas.clientHeight || canvas.height;
        const aspect = w / h;
        camera = new THREE.OrthographicCamera(
            -frustumSize * aspect / 2, frustumSize * aspect / 2,
            frustumSize / 2, -frustumSize / 2, 0.1, 1000
        );
        // Y is up (Three.js default) - coordinates transformed to match
        camera.position.set(50, 50, 40);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(w, h);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableRotate = true;
        controls.enablePan = true;
        controls.enableZoom = true;
        // Lock polar angle - only allow horizontal rotation around Y axis
        const fixedPolarAngle = Math.PI / 3;  // 60 degrees from vertical (nice viewing angle)
        controls.minPolarAngle = fixedPolarAngle;
        controls.maxPolarAngle = fixedPolarAngle;
        controls.addEventListener('change', () => {
            if (renderer) renderer.render(scene, camera);
        });

        // Lighting (same as limit-shape)
        scene.add(new THREE.AmbientLight(0xffffff, 0.35));
        const hemi = new THREE.HemisphereLight(0x6666aa, 0x222244, 0.25);
        hemi.position.set(0, 20, 0);
        scene.add(hemi);
        const directional = new THREE.DirectionalLight(0xffffff, 1.2);
        directional.position.set(15, 20, 5);
        scene.add(directional);
        const fill = new THREE.DirectionalLight(0xffffff, 0.3);
        fill.position.set(-10, 5, -5);
        scene.add(fill);
        // Warm orange-tinted lights for rotation
        const warmLight1 = new THREE.DirectionalLight(0xffaa66, 0.7);
        warmLight1.position.set(-30, 10, 30);
        scene.add(warmLight1);
        const warmLight2 = new THREE.DirectionalLight(0xffcc88, 0.6);
        warmLight2.position.set(-30, 10, -30);
        scene.add(warmLight2);

        meshGroup = new THREE.Group();
        scene.add(meshGroup);

        renderer.render(scene, camera);
    }

    function disposeThreeJS() {
        if (!renderer) return;

        // Dispose meshes
        if (meshGroup) {
            while (meshGroup.children.length > 0) {
                const child = meshGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                meshGroup.remove(child);
            }
        }

        // Release WebGL context
        if (controls) controls.dispose();
        renderer.dispose();
        renderer = null;
        scene = null;
        camera = null;
        controls = null;
        meshGroup = null;
    }

    // Wait for LozengeModule
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }
    const wasm = await LozengeModule();

    const initFromTriangles = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const runCFTP = wasm.cwrap('runCFTP', 'number', []);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeString = wasm.cwrap('freeString', null, ['number']);
    const repairRegionWasm = wasm.cwrap('repairRegion', 'number', []);
    const initCFTPWasm = wasm.cwrap('initCFTP', 'number', []);
    const getGridBoundsWasm = wasm.cwrap('getGridBounds', 'number', []);
    const getCFTPMinGridDataWasm = wasm.cwrap('getCFTPMinGridData', 'number', []);
    const getCFTPMaxGridDataWasm = wasm.cwrap('getCFTPMaxGridData', 'number', []);
    const getBlackTrianglesWasm = wasm.cwrap('getBlackTriangles', 'number', []);

    // GPU engine
    let gpuEngine = null;
    let gpuAvailable = false;

    async function initGPU() {
        if (gpuEngine) return gpuAvailable;
        if (typeof WebGPULozengeEngine === 'undefined') return false;
        try {
            gpuEngine = new WebGPULozengeEngine();
            await gpuEngine.init();
            gpuAvailable = true;
            return true;
        } catch (e) {
            gpuAvailable = false;
            return false;
        }
    }

    function getGridBounds() {
        const ptr = getGridBoundsWasm();
        const jsonStr = wasm.UTF8ToString(ptr);
        freeString(ptr);
        return JSON.parse(jsonStr);
    }

    function getCFTPMinRawGridData(bounds) {
        const dataPtr = getCFTPMinGridDataWasm();
        if (!dataPtr) return null;
        const data = new Int32Array(bounds.size);
        for (let i = 0; i < bounds.size; i++) {
            data[i] = wasm.getValue(dataPtr + i * 4, 'i32');
        }
        wasm._free(dataPtr);
        return data;
    }

    function getCFTPMaxRawGridData(bounds) {
        const dataPtr = getCFTPMaxGridDataWasm();
        if (!dataPtr) return null;
        const data = new Int32Array(bounds.size);
        for (let i = 0; i < bounds.size; i++) {
            data[i] = wasm.getValue(dataPtr + i * 4, 'i32');
        }
        wasm._free(dataPtr);
        return data;
    }

    function getBlackTriangles() {
        const ptr = getBlackTrianglesWasm();
        const jsonStr = wasm.UTF8ToString(ptr);
        freeString(ptr);
        return JSON.parse(jsonStr);
    }

    const N = 50;
    const colors = ['#E57200', '#232D4B', '#F9DCBF']; // UVA colors
    let initialSampleDone = false;

    // Generate stepped path on cylinder (same as 3D viz)
    function generateSteppedPath(A, B) {
        const path = [];
        function addPoint(x, y, h, prevH) {
            if (path.length > 0 && h !== prevH) {
                const lastPt = path[path.length - 1];
                if (h > prevH) {
                    for (let hh = prevH + 1; hh <= h; hh++) {
                        path.push({ x: lastPt.x, y: lastPt.y, z: hh });
                    }
                } else {
                    for (let hh = prevH - 1; hh >= h; hh--) {
                        path.push({ x: lastPt.x, y: lastPt.y, z: hh });
                    }
                }
            }
            path.push({ x, y, z: h });
            return h;
        }

        let prevH = Math.round(A * 0 + B * 0);
        path.push({ x: 0, y: 0, z: prevH });

        for (let x = 1; x <= N; x++) {
            prevH = addPoint(x, 0, Math.round(A * x + B * 0), prevH);
        }
        for (let y = 1; y <= N; y++) {
            prevH = addPoint(N, y, Math.round(A * N + B * y), prevH);
        }
        for (let x = N - 1; x >= 0; x--) {
            prevH = addPoint(x, N, Math.round(A * x + B * N), prevH);
        }
        for (let y = N - 1; y >= 1; y--) {
            prevH = addPoint(0, y, Math.round(A * 0 + B * y), prevH);
        }
        const h0 = Math.round(A * 0 + B * 0);
        if (h0 !== prevH) {
            addPoint(0, 0, h0, prevH);
        }
        return path;
    }

    // Project to x+y+z=0 plane: (x,y,z) -> (x-t, y-t, z-t) where t=(x+y+z)/3
    function projectToLattice(path) {
        return path.map(p => {
            const t = (p.x + p.y + p.z) / 3;
            return { x: p.x - t, y: p.y - t, z: p.z - t };
        });
    }

    // Convert projected 3D coords to 2D triangular lattice coords
    // On x+y+z=0 plane, we use (u,v) where u = x-z, v = y-z (or similar)
    function to2DLattice(p3d) {
        // Standard projection: u = x - z, v = y - z
        return { u: p3d.x - p3d.z, v: p3d.y - p3d.z };
    }

    // Point-in-polygon test (ray casting)
    function pointInPolygon(px, py, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i].u, yi = polygon[i].v;
            const xj = polygon[j].u, yj = polygon[j].v;
            if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    }

    // Generate triangles inside the projected boundary
    function generateTriangles(A, B) {
        const steppedPath = generateSteppedPath(A, B);
        const projected3D = projectToLattice(steppedPath);
        const polygon2D = projected3D.map(to2DLattice);

        // Get bounding box
        const uVals = polygon2D.map(p => p.u);
        const vVals = polygon2D.map(p => p.v);
        const minU = Math.floor(Math.min(...uVals)) - 2;
        const maxU = Math.ceil(Math.max(...uVals)) + 2;
        const minV = Math.floor(Math.min(...vVals)) - 2;
        const maxV = Math.ceil(Math.max(...vVals)) + 2;

        const triangles = [];

        // For each lattice cell (n, j), check black and white triangles
        // Black (right-pointing) centroid: (n + 2/3, j + 1/3) in (u,v) coords
        // White (left-pointing) centroid: (n + 1/3, j + 2/3)
        for (let n = minU; n <= maxU; n++) {
            for (let j = minV; j <= maxV; j++) {
                // Black triangle centroid
                const blackU = n + 2/3, blackV = j + 1/3;
                if (pointInPolygon(blackU, blackV, polygon2D)) {
                    triangles.push(n, j, 1);
                }
                // White triangle centroid
                const whiteU = n + 1/3, whiteV = j + 2/3;
                if (pointInPolygon(whiteU, whiteV, polygon2D)) {
                    triangles.push(n, j, 2);
                }
            }
        }

        return triangles;
    }

    // ========================================================================
    // HEIGHT FUNCTION COMPUTATION (from ultimate-lozenge.md)
    // ========================================================================
    function computeHeightFunction(dimers) {
        // Vertex keys for each dimer type
        const getVertexKeys = (dimer) => {
            const { bn, bj, t } = dimer;
            if (t === 0) {
                return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
            } else if (t === 1) {
                return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
            } else {
                return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
            }
        };

        // Height patterns (relative z-heights of the 4 vertices)
        const getHeightPattern = (t) => {
            if (t === 0) return [0, 0, 0, 0];
            if (t === 1) return [1, 0, 0, 1];
            return [1, 1, 0, 0];
        };

        // Build Vertex-to-Dimer Map
        const vertexToDimers = new Map();
        for (const dimer of dimers) {
            const verts = getVertexKeys(dimer);
            for (const [n, j] of verts) {
                const key = `${n},${j}`;
                if (!vertexToDimers.has(key)) vertexToDimers.set(key, []);
                vertexToDimers.get(key).push(dimer);
            }
        }

        // BFS to calculate Height Function h(n,j)
        const heights = new Map();
        if (dimers.length > 0) {
            const firstDimer = dimers[0];
            const firstVerts = getVertexKeys(firstDimer);
            const startKey = `${firstVerts[0][0]},${firstVerts[0][1]}`;
            heights.set(startKey, 0);

            const queue = [startKey];
            const visited = new Set();

            while (queue.length > 0) {
                const currentKey = queue.shift();
                if (visited.has(currentKey)) continue;
                visited.add(currentKey);

                const currentH = heights.get(currentKey);
                const [cn, cj] = currentKey.split(',').map(Number);

                for (const dimer of vertexToDimers.get(currentKey) || []) {
                    const verts = getVertexKeys(dimer);
                    const pattern = getHeightPattern(dimer.t);

                    // Find index of current vertex in this dimer
                    let myIdx = -1;
                    for (let i = 0; i < 4; i++) {
                        if (verts[i][0] === cn && verts[i][1] === cj) {
                            myIdx = i;
                            break;
                        }
                    }

                    if (myIdx >= 0) {
                        for (let i = 0; i < 4; i++) {
                            const [vn, vj] = verts[i];
                            const vkey = `${vn},${vj}`;
                            if (!heights.has(vkey)) {
                                const newH = currentH + (pattern[i] - pattern[myIdx]);
                                heights.set(vkey, newH);
                                queue.push(vkey);
                            }
                        }
                    }
                }
            }
        }

        return heights;
    }

    // Draw lozenges as 3D stepped surface
    function drawFromDimers(dimers, triangleArr, resetCamera = true) {
        if (!meshGroup) return;

        // Clear previous meshes
        while (meshGroup.children.length > 0) {
            const child = meshGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
            meshGroup.remove(child);
        }

        if (!dimers || dimers.length === 0) {
            if (renderer) renderer.render(scene, camera);
            return;
        }

        // Vertex keys for each dimer type
        const getVertexKeys = (dimer) => {
            const { bn, bj, t } = dimer;
            if (t === 0) return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
            else if (t === 1) return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
            else return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
        };

        // Compute height function
        const heights = computeHeightFunction(dimers);

        // 3D Coordinate Transformation (from ultimate-lozenge.md, with Y as vertical)
        // Maps abstract lattice (n, j, h) to Cartesian (x, y, z)
        // Swapped y/z so Y is vertical (Three.js convention for OrbitControls)
        const to3D = (n, j, h) => ({ x: h, y: j - h, z: -n - h });

        // White lozenges like limit-shape
        const lozengeColors = ['#FFFFFF', '#FFFFFF', '#FFFFFF'];

        // Build single geometry with all quads
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const normals = [];
        const vertexColors = [];
        const indices = [];

        const addQuad = (v1, v2, v3, v4, color) => {
            const baseIndex = vertices.length / 3;
            vertices.push(v1.x, v1.y, v1.z);
            vertices.push(v2.x, v2.y, v2.z);
            vertices.push(v3.x, v3.y, v3.z);
            vertices.push(v4.x, v4.y, v4.z);

            // Compute flat normal
            const edge1 = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
            const edge2 = { x: v4.x - v1.x, y: v4.y - v1.y, z: v4.z - v1.z };
            const nx = edge1.y * edge2.z - edge1.z * edge2.y;
            const ny = edge1.z * edge2.x - edge1.x * edge2.z;
            const nz = edge1.x * edge2.y - edge1.y * edge2.x;
            const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;

            for (let i = 0; i < 4; i++) {
                normals.push(nx / len, ny / len, nz / len);
            }

            const c = new THREE.Color(color);
            for (let i = 0; i < 4; i++) {
                vertexColors.push(c.r, c.g, c.b);
            }

            indices.push(baseIndex, baseIndex + 1, baseIndex + 2);
            indices.push(baseIndex, baseIndex + 2, baseIndex + 3);
        };

        // Generate geometry for each dimer
        for (const dimer of dimers) {
            const verts = getVertexKeys(dimer);
            const v3d = verts.map(([n, j]) => {
                const h = heights.get(`${n},${j}`) || 0;
                return to3D(n, j, h);
            });
            addQuad(v3d[0], v3d[1], v3d[2], v3d[3], lozengeColors[dimer.t]);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
        geometry.setIndex(indices);
        geometry.computeBoundingSphere();

        // Create mesh with vertex colors (same material as limit-shape)
        const material = new THREE.MeshStandardMaterial({
            vertexColors: true,
            side: THREE.DoubleSide,
            flatShading: true,
            roughness: 0.3,
            metalness: 0.35,
            color: 0xddeeff  // Subtle blue tint
        });
        const mesh = new THREE.Mesh(geometry, material);
        meshGroup.add(mesh);

        // Add edge lines (subtle for dark background)
        const edgesGeometry = new THREE.EdgesGeometry(geometry, 10);
        const edgesMaterial = new THREE.LineBasicMaterial({
            color: 0x444466,
            linewidth: 1,
            opacity: 0.6,
            transparent: true
        });
        const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
        meshGroup.add(edges);

        // Update camera to follow geometry
        if (geometry.boundingSphere) {
            const center = geometry.boundingSphere.center;
            const radius = geometry.boundingSphere.radius;

            if (resetCamera) {
                // Full reset: position camera at default angle
                controls.target.copy(center);
                camera.position.set(center.x + radius, center.y + radius * 0.8, center.z + radius);
                camera.lookAt(center);
            } else {
                // Preserve angle: move camera relative to new center
                const offset = new THREE.Vector3().subVectors(camera.position, controls.target);
                controls.target.copy(center);
                camera.position.copy(center).add(offset);
            }
            controls.update();
        }

        renderer.render(scene, camera);
    }

    // Sample function
    async function sample(A, B, resetCamera = true) {
        const triangles = generateTriangles(A, B);

        // Pass to WASM
        const dataPtr = wasm._malloc(triangles.length * 4);
        for (let i = 0; i < triangles.length; i++) {
            wasm.setValue(dataPtr + i * 4, triangles[i], 'i32');
        }
        const initPtr = initFromTriangles(dataPtr, triangles.length);
        const initResult = wasm.UTF8ToString(initPtr);
        freeString(initPtr);
        wasm._free(dataPtr);

        // Parse init result to check if valid
        const initParsed = JSON.parse(initResult);

        // If invalid (flow < count or black ≠ white), repair the region
        if (initParsed.status === 'invalid') {
            const repairPtr = repairRegionWasm();
            const repairResult = wasm.UTF8ToString(repairPtr);
            freeString(repairPtr);

            // Check if repair succeeded
            const repairParsed = JSON.parse(repairResult);
            if (repairParsed.status === 'invalid') {
                return;
            }
        }

        // Try GPU CFTP first, fall back to CPU
        let dimers = [];
        const useGPU = await initGPU();

        if (useGPU && gpuEngine) {
            try {
                // Initialize CFTP on WASM side to create extremal states
                initCFTPWasm();
                const bounds = getGridBounds();

                const minGridData = getCFTPMinRawGridData(bounds);
                const maxGridData = getCFTPMaxRawGridData(bounds);

                if (minGridData && maxGridData) {
                    gpuEngine.initFromWasmData(minGridData, bounds.minN, bounds.maxN, bounds.minJ, bounds.maxJ);
                    const gpuCftpOk = await gpuEngine.initCFTP(minGridData, maxGridData);

                    if (gpuCftpOk) {
                        let T = 1;
                        const maxT = 134217728;
                        let coalesced = false;

                        while (!coalesced && T <= maxT) {
                            gpuEngine.resetCFTPChains(minGridData, maxGridData);
                            const result = await gpuEngine.stepCFTP(T, Math.min(T, 10000));
                            coalesced = result.coalesced;
                            if (!coalesced) coalesced = await gpuEngine.checkCoalescence();
                            if (!coalesced) T *= 2;
                        }

                        if (coalesced) {
                            const resultGrid = await gpuEngine.getCFTPResult();
                            const blackTriangles = getBlackTriangles();
                            dimers = gpuEngine.gridToDimers(resultGrid, blackTriangles);
                            gpuEngine.destroyCFTP();
                        } else {
                            gpuEngine.destroyCFTP();
                            throw new Error('GPU CFTP did not coalesce');
                        }
                    } else {
                        throw new Error('GPU CFTP init failed');
                    }
                } else {
                    throw new Error('Could not get grid data');
                }
            } catch (e) {
                // Fall through to CPU
                dimers = [];
            }
        }

        // CPU fallback
        if (dimers.length === 0) {
            const cftpPtr = runCFTP();
            const cftpResult = wasm.UTF8ToString(cftpPtr);
            freeString(cftpPtr);

            const dimersPtr = exportDimersWasm();
            const dimersJson = wasm.UTF8ToString(dimersPtr);
            freeString(dimersPtr);

            const parsed = JSON.parse(dimersJson);
            dimers = parsed.dimers || [];
        }

        drawFromDimers(dimers, triangles, resetCamera);
    }

    // Wire up Sample button
    const btn = document.getElementById('energy-sample');
    const inputA = document.getElementById('gradient-a');
    const inputB = document.getElementById('gradient-b');

    if (btn && inputA && inputB) {
        btn.addEventListener('click', () => {
            if (!renderer) return;
            sample(parseFloat(inputA.value), parseFloat(inputB.value));
        });
    }

    // Auto-rotation
    let autoRotateId = null;
    function startAutoRotate() {
        if (autoRotateId) return;
        const rotateSpeed = 0.0075;
        function rotate() {
            if (!controls || !renderer) return;
            const x = camera.position.x - controls.target.x;
            const z = camera.position.z - controls.target.z;
            const cos = Math.cos(rotateSpeed);
            const sin = Math.sin(rotateSpeed);
            camera.position.x = controls.target.x + x * cos - z * sin;
            camera.position.z = controls.target.z + x * sin + z * cos;
            camera.lookAt(controls.target);
            renderer.render(scene, camera);
            autoRotateId = requestAnimationFrame(rotate);
        }
        rotate();
    }

    function stopAutoRotate() {
        if (autoRotateId) {
            cancelAnimationFrame(autoRotateId);
            autoRotateId = null;
        }
    }

    // Register with slide engine for lazy WebGL loading
    function waitForSlideEngine() {
        if (typeof window.slideEngine !== 'undefined') {
            // Presets for stepping through (preset 0 is pre-sampled on slide enter)
            const presets = [
                { A: -2, B: 0.3 },
                { A: -0.05, B: 0.4 },
                { A: -0.2, B: 0.3 },
                { A: -0.2, B: 0 },
                { A: 0, B: 0 }
            ];
            let currentPreset = 0;

            function applyPreset(idx, resetCamera = true) {
                if (idx < 0 || idx >= presets.length) return;
                currentPreset = idx;
                const { A, B } = presets[idx];
                document.getElementById('gradient-a').value = A;
                document.getElementById('gradient-b').value = B;
                sample(A, B, resetCamera);
            }

            window.slideEngine.registerSimulation('energy', {
                start() { startAutoRotate(); },
                pause() { stopAutoRotate(); },
                steps: presets.length - 1,  // 3 steps (presets 1, 2, 3)
                onStep(step) {
                    // step 1 -> preset 1, step 2 -> preset 2, step 3 -> preset 3
                    if (step >= 1 && step < presets.length) {
                        applyPreset(step, false);  // Don't reset camera angle
                    }
                },
                onStepBack(step) {
                    // step 0 -> preset 0, step 1 -> preset 1, step 2 -> preset 2
                    if (step >= 0 && step < presets.length) {
                        applyPreset(step, false);  // Don't reset camera angle
                    }
                },
                onSlideEnter() {
                    // Wait for Three.js then initialize
                    const initWhenReady = () => {
                        if (typeof THREE !== 'undefined' && typeof THREE.OrbitControls !== 'undefined') {
                            initThreeJS();
                            if (!initialSampleDone) {
                                applyPreset(0);  // Pre-sample with first preset
                                initialSampleDone = true;
                            } else if (renderer) {
                                renderer.render(scene, camera);
                            }
                            startAutoRotate();
                        } else {
                            setTimeout(initWhenReady, 50);
                        }
                    };
                    initWhenReady();
                },
                onSlideLeave() {
                    stopAutoRotate();
                    disposeThreeJS();
                    initialSampleDone = false;  // Reset so re-entering slide will resample
                }
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();
</script>

<!-- ==================== Q-volume deformations ==================== -->
<section class="slide slide-top" id="q-volume" data-title="Q-volume deformations">
    <h2 class="slide-title">Q-volume deformations</h2>
    <!-- Top: Five tilings with q inputs -->
    <div style="display: flex; gap: 0.8vw; justify-content: center; margin-top: 1vh;">
        <div style="text-align: center;">
            <canvas id="qvol-canvas-0" width="400" height="400" style="width: 16vw; height: 16vw; border: 1px solid #ccc;"></canvas>
            <div style="font-size: clamp(0.8rem, 1.2vw, 1rem); margin-top: 0.3vh;">q = <input type="text" id="qvol-input-0" value="0.7" style="width: 3em; text-align: center; font-size: inherit; border: 1px solid #ccc; border-radius: 3px;"></div>
        </div>
        <div style="text-align: center;">
            <canvas id="qvol-canvas-1" width="400" height="400" style="width: 16vw; height: 16vw; border: 1px solid #ccc;"></canvas>
            <div style="font-size: clamp(0.8rem, 1.2vw, 1rem); margin-top: 0.3vh;">q = <input type="text" id="qvol-input-1" value="0.9" style="width: 3em; text-align: center; font-size: inherit; border: 1px solid #ccc; border-radius: 3px;"></div>
        </div>
        <div style="text-align: center;">
            <canvas id="qvol-canvas-2" width="400" height="400" style="width: 16vw; height: 16vw; border: 1px solid #ccc;"></canvas>
            <div style="font-size: clamp(0.8rem, 1.2vw, 1rem); margin-top: 0.3vh;">q = <input type="text" id="qvol-input-2" value="1" style="width: 3em; text-align: center; font-size: inherit; border: 1px solid #ccc; border-radius: 3px;"></div>
        </div>
        <div style="text-align: center;">
            <canvas id="qvol-canvas-3" width="400" height="400" style="width: 16vw; height: 16vw; border: 1px solid #ccc;"></canvas>
            <div style="font-size: clamp(0.8rem, 1.2vw, 1rem); margin-top: 0.3vh;">q = <input type="text" id="qvol-input-3" value="1.1" style="width: 3em; text-align: center; font-size: inherit; border: 1px solid #ccc; border-radius: 3px;"></div>
        </div>
        <div style="text-align: center;">
            <canvas id="qvol-canvas-4" width="400" height="400" style="width: 16vw; height: 16vw; border: 1px solid #ccc;"></canvas>
            <div style="font-size: clamp(0.8rem, 1.2vw, 1rem); margin-top: 0.3vh;">q = <input type="text" id="qvol-input-4" value="1.4" style="width: 3em; text-align: center; font-size: inherit; border: 1px solid #ccc; border-radius: 3px;"></div>
        </div>
    </div>
    <!-- Resample button under pictures -->
    <button id="qvol-sample-btn" style="margin-top: 1vh; padding: 0.4em 1.2em; cursor: pointer; border: 2px solid var(--slide-accent); background: var(--slide-accent); color: white; border-radius: 4px; font-size: clamp(0.8rem, 1.2vw, 1rem);">Re-sample All</button>
    <!-- Bottom: Text explanation (2 panes) -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2vw; margin-top: 1.5vh; width: 100%;">
        <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: left;">
            <strong style="color: var(--slide-accent);">q-weighted measure</strong><br>
            \(\displaystyle P(T) = \frac{q^{\mathrm{vol}(T)}}{\sum_{T'} q^{\mathrm{vol}(T')}}\)<br>
            <span style="font-size: 0.85em;">\(q < 1\): tilted surface &nbsp;|&nbsp; \(q = 1\): uniform &nbsp;|&nbsp; \(q > 1\): flat surface</span>
        </div>
        <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; font-size: clamp(1.2rem, 2.2vw, 1.8rem); text-align: left;">
            <strong style="color: var(--slide-accent);">Variational principle</strong> <span style="font-size: 0.85em;">(\(\gamma = -\log q\))</span><br>
            Maximize <span style="color: #232D4B; font-weight: 800;">entropy − γ·volume</span><br>
            <span style="font-size: 0.85em;">Entropy favors "typical" shapes; \(\gamma\) tilts the balance toward more/less volume</span>
        </div>
    </div>
</section>

<!-- Q-volume slide script -->
<script>
(async function() {
    'use strict';

    // 5 canvases with q inputs
    const canvases = [0,1,2,3,4].map(i => document.getElementById(`qvol-canvas-${i}`));
    const qInputs = [0,1,2,3,4].map(i => document.getElementById(`qvol-input-${i}`));
    const sampleBtn = document.getElementById('qvol-sample-btn');
    if (canvases.some(c => !c) || qInputs.some(i => !i)) return;

    function getQValues() {
        return qInputs.map(input => parseFloat(input.value) || 1.0);
    }

    // Wait for LozengeModule
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }

    // Create 5 separate WASM instances
    const wasms = await Promise.all([0,1,2,3,4].map(() => LozengeModule()));

    function setupWasm(wasm) {
        return {
            wasm,
            initFromTriangles: wasm.cwrap('initFromTriangles', 'number', ['number', 'number']),
            performGlauberSteps: wasm.cwrap('performGlauberSteps', 'number', ['number']),
            exportDimers: wasm.cwrap('exportDimers', 'number', []),
            freeString: wasm.cwrap('freeString', null, ['number']),
            setQBias: wasm.cwrap('setQBias', null, ['number']),
            setUseRandomSweeps: wasm.cwrap('setUseRandomSweeps', null, ['number']),
            initCFTP: wasm.cwrap('initCFTP', 'number', []),
            runCFTP: wasm.cwrap('runCFTP', 'number', []),
            getGridBounds: wasm.cwrap('getGridBounds', 'number', []),
            getCFTPMinGridData: wasm.cwrap('getCFTPMinGridData', 'number', []),
            getCFTPMaxGridData: wasm.cwrap('getCFTPMaxGridData', 'number', [])
        };
    }

    const sims = wasms.map(w => setupWasm(w));

    const colors = ['#E57200', '#232D4B', '#F9DCBF'];
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) { return { x: n, y: slope * n + j * deltaC }; }

    // Load shape from JSON file
    let shapeTriangles = null;
    try {
        const resp = await fetch('/letters/shape_for_arctic_small.json');
        const data = await resp.json();
        shapeTriangles = data.triangles;
    } catch (e) {
        console.error('Failed to load shape_for_arctic_small.json:', e);
        return;
    }

    function getTrianglesArray() {
        if (!shapeTriangles) return [];
        const arr = [];
        for (const tri of shapeTriangles) {
            arr.push(tri.n, tri.j, tri.type);
        }
        return arr;
    }

    function initSim(sim, triangles) {
        const dataPtr = sim.wasm._malloc(triangles.length * 4);
        for (let i = 0; i < triangles.length; i++) {
            sim.wasm.setValue(dataPtr + i * 4, triangles[i], 'i32');
        }
        const ptr = sim.initFromTriangles(dataPtr, triangles.length);
        sim.freeString(ptr);
        sim.wasm._free(dataPtr);
        sim.setUseRandomSweeps(1);
    }

    // CPU CFTP - updates internal WASM state
    function runCFTP(sim) {
        const ptr = sim.runCFTP();
        sim.freeString(ptr);
    }

    function runGlauber(sim, steps) {
        const ptr = sim.performGlauberSteps(steps);
        sim.freeString(ptr);
    }

    function getDimers(sim) {
        const ptr = sim.exportDimers();
        const json = sim.wasm.UTF8ToString(ptr);
        sim.freeString(ptr);
        const parsed = JSON.parse(json);
        return parsed.dimers || [];
    }

    function drawTiling(canvas, dimers) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, w, h);

        if (!dimers || dimers.length === 0) return;

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const d of dimers) {
            const verts = getLozengeVerts(d);
            for (const v of verts) {
                minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
            }
        }

        // Rotate 90 degrees: swap width/height for scale calculation
        const scale = Math.min(w / (maxY - minY), h / (maxX - minX)) * 0.9;
        const cx = w / 2;
        const cy = h / 2;
        const offsetX = (minY + maxY) / 2;
        const offsetY = (minX + maxX) / 2;

        for (const d of dimers) {
            const verts = getLozengeVerts(d);
            ctx.beginPath();
            // Rotate 90°: (x,y) -> (y, -x)
            ctx.moveTo(cx + (verts[0].y - offsetX) * scale, cy + (verts[0].x - offsetY) * scale);
            for (let i = 1; i < 4; i++) {
                ctx.lineTo(cx + (verts[i].y - offsetX) * scale, cy + (verts[i].x - offsetY) * scale);
            }
            ctx.closePath();
            ctx.fillStyle = colors[d.t];
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }

    function getLozengeVerts(d) {
        const { bn, bj, t } = d;
        if (t === 0) return [getVertex(bn, bj), getVertex(bn+1, bj), getVertex(bn+1, bj-1), getVertex(bn, bj-1)];
        if (t === 1) return [getVertex(bn, bj), getVertex(bn+1, bj-1), getVertex(bn+1, bj-2), getVertex(bn, bj-1)];
        return [getVertex(bn-1, bj), getVertex(bn, bj), getVertex(bn+1, bj-1), getVertex(bn, bj-1)];
    }

    const triangles = getTrianglesArray();
    let sampling = false;
    let sampled = false;

    async function sampleAll() {
        if (sampling) return;
        sampling = true;
        sampled = true;

        const qValues = getQValues();

        // Sample each q value sequentially, showing result immediately
        for (let i = 0; i < qValues.length; i++) {
            const q = qValues[i];
            const sim = sims[i];

            // Clear canvas to show we're working on it
            const ctx = canvases[i].getContext('2d');
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvases[i].width, canvases[i].height);
            ctx.fillStyle = '#999';
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Sampling...', canvases[i].width/2, canvases[i].height/2);

            // Yield to let UI update
            await new Promise(r => setTimeout(r, 50));

            // Reinitialize region
            initSim(sim, triangles);

            // Set q-bias BEFORE CFTP
            sim.setQBias(q);

            // Run CPU CFTP (uses q-bias for q-weighted sampling)
            runCFTP(sim);

            // Draw this result immediately
            drawTiling(canvases[i], getDimers(sim));

            // Small delay between samples so user can see progress
            await new Promise(r => setTimeout(r, 100));
        }

        sampling = false;
    }

    sampleBtn.addEventListener('click', sampleAll);

    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('q-volume', {
                start() {},
                pause() {},
                onSlideEnter() { if (!sampled) sampleAll(); },
                onSlideLeave() {}
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();
</script>

<!-- ==================== Fluctuations ==================== -->
<section class="slide slide-top" id="fluctuations" data-title="Fluctuations">
    <h2 class="slide-title">Fluctuations & 2D Models</h2>
    <div style="display: grid; grid-template-columns: 0.45fr 0.55fr; gap: 2vw; margin-top: 1vh; width: 100%; align-items: start;">
        <!-- Left: Text explanation -->
        <div style="display: flex; flex-direction: column; gap: 1.5vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Double dimer model</strong><br>
                Superimpose two independent tilings<br>
                → symmetric difference forms loops
            </div>
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Height fluctuations</strong><br>
                Difference of two height functions:<br>
                \(\displaystyle\frac{h_1 - h_2}{\sqrt{2}} \to \text{GFF}\) (Gaussian Free Field)
            </div>
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Back to 2D</strong><br>
                3D surfaces → 2D height function<br>
                Fluctuations governed by conformal field theory<br>
                Loop statistics ↔ SLE curves
            </div>
            <div style="background: #f5f5f5; border-left: 4px solid var(--slide-accent); padding: 1vh 1.5vw; text-align: left;">
                <strong style="color: var(--slide-accent);">Universal behavior</strong><br>
                Same GFF appears in many 2D models:<br>
                dimers, spanning trees, Ising, ...
            </div>
        </div>
        <!-- Right: GFF heatmap visualization -->
        <div style="display: flex; flex-direction: column; align-items: center; gap: 1vh;">
            <canvas id="gff-canvas" width="800" height="700" style="width: 45vw; height: 70vh; border: 1px solid #ccc;"></canvas>
            <button id="gff-sample-btn" style="padding: 0.5em 1.5em; cursor: pointer; border: 2px solid var(--slide-accent); background: var(--slide-accent); color: white; border-radius: 4px; font-size: clamp(0.9rem, 1.5vw, 1.2rem);">Re-sample GFF</button>
        </div>
    </div>
</section>
<!-- Fluctuations slide script with GPU CFTP (WebGPU engine loaded at top of file) -->
<script>
(async function() {
    'use strict';

    const canvas = document.getElementById('gff-canvas');
    const sampleBtn = document.getElementById('gff-sample-btn');
    if (!canvas) return;

    // Wait for LozengeModule
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }

    const wasm = await LozengeModule();

    // WASM function wrappers
    const initFromTriangles = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const freeString = wasm.cwrap('freeString', null, ['number']);
    const initCFTPWasm = wasm.cwrap('initCFTP', 'number', []);
    const getGridBoundsWasm = wasm.cwrap('getGridBounds', 'number', []);
    const getCFTPMinGridDataWasm = wasm.cwrap('getCFTPMinGridData', 'number', []);
    const getCFTPMaxGridDataWasm = wasm.cwrap('getCFTPMaxGridData', 'number', []);
    const exportDimers = wasm.cwrap('exportDimers', 'number', []);
    const runCFTP = wasm.cwrap('runCFTP', 'number', []);

    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);
    const sqrt2 = Math.sqrt(2);
    function getVertex(n, j) { return { x: n, y: slope * n + j * deltaC }; }

    // GPU engine
    let gpuEngine = null;
    let gpuAvailable = false;

    // Initialize GPU engine if available
    async function initGpuEngine() {
        if (!navigator.gpu) return false;

        // Wait for WebGPU engine script to load (loaded at top of file)
        let waitCount = 0;
        while (!window.WebGPULozengeEngine && waitCount < 50) {
            await new Promise(r => setTimeout(r, 100));
            waitCount++;
        }
        if (!window.WebGPULozengeEngine) return false;
        try {
            gpuEngine = new WebGPULozengeEngine();
            const initPromise = gpuEngine.init();
            const timeoutPromise = new Promise((_, reject) =>
                setTimeout(() => reject(new Error('GPU init timeout')), 5000)
            );
            await Promise.race([initPromise, timeoutPromise]);
            gpuAvailable = gpuEngine.isAvailable();
            console.log('GFF slide: GPU engine', gpuAvailable ? 'ready' : 'unavailable');
            return gpuAvailable;
        } catch (e) {
            console.warn('GFF slide: GPU init failed:', e);
            return false;
        }
    }

    // Load shape from JSON file
    let shapeData = null;

    async function loadShapeData() {
        const response = await fetch('/letters/shape_for_arctic.json');
        const json = await response.json();

        const triangleArr = [];
        const blackTriangles = [];
        const whiteTriangles = [];

        for (const tri of json.triangles) {
            const { n, j, type } = tri;
            triangleArr.push(n, j, type);

            if (type === 1) {
                const bv1 = getVertex(n, j), bv2 = getVertex(n, j-1), bv3 = getVertex(n+1, j-1);
                blackTriangles.push({ n, j, verts: [bv1, bv2, bv3] });
            } else {
                const wv1 = getVertex(n, j), wv2 = getVertex(n+1, j), wv3 = getVertex(n+1, j-1);
                whiteTriangles.push({ n, j, verts: [wv1, wv2, wv3] });
            }
        }

        return { triangleArr, blackTriangles, whiteTriangles };
    }

    function initRegion() {
        const dataPtr = wasm._malloc(shapeData.triangleArr.length * 4);
        for (let i = 0; i < shapeData.triangleArr.length; i++) {
            wasm.setValue(dataPtr + i * 4, shapeData.triangleArr[i], 'i32');
        }
        const ptr = initFromTriangles(dataPtr, shapeData.triangleArr.length);
        freeString(ptr);
        wasm._free(dataPtr);
    }

    // Get extremal grid data for GPU
    function getGridBounds() {
        const ptr = getGridBoundsWasm();
        const str = wasm.UTF8ToString(ptr);
        freeString(ptr);
        return JSON.parse(str);
    }

    function getCFTPMinRawGridData(bounds) {
        const dataPtr = getCFTPMinGridDataWasm();
        if (!dataPtr) return null;
        const data = new Int32Array(bounds.size);
        for (let i = 0; i < bounds.size; i++) {
            data[i] = wasm.getValue(dataPtr + i * 4, 'i32');
        }
        wasm._free(dataPtr);
        return data;
    }

    function getCFTPMaxRawGridData(bounds) {
        const dataPtr = getCFTPMaxGridDataWasm();
        if (!dataPtr) return null;
        const data = new Int32Array(bounds.size);
        for (let i = 0; i < bounds.size; i++) {
            data[i] = wasm.getValue(dataPtr + i * 4, 'i32');
        }
        wasm._free(dataPtr);
        return data;
    }

    // WASM CFTP fallback
    function sampleCFTPWasm() {
        const ptr = runCFTP();
        freeString(ptr);
        const dimPtr = exportDimers();
        const json = wasm.UTF8ToString(dimPtr);
        freeString(dimPtr);
        return JSON.parse(json).dimers || [];
    }

    // Compute height function from dimers
    function computeHeightFunction(dimers) {
        const getVertexKeys = (dimer) => {
            const { bn, bj, t } = dimer;
            if (t === 0) return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
            if (t === 1) return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
            return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
        };
        const getHeightPattern = (t) => {
            if (t === 0) return [0, 0, 0, 0];
            if (t === 1) return [1, 0, 0, 1];
            return [1, 1, 0, 0];
        };

        const vertexToDimers = new Map();
        for (const dimer of dimers) {
            for (const [n, j] of getVertexKeys(dimer)) {
                const key = `${n},${j}`;
                if (!vertexToDimers.has(key)) vertexToDimers.set(key, []);
                vertexToDimers.get(key).push(dimer);
            }
        }

        const heights = new Map();
        if (dimers.length === 0) return heights;

        const firstVerts = getVertexKeys(dimers[0]);
        const startKey = `${firstVerts[0][0]},${firstVerts[0][1]}`;
        heights.set(startKey, 0);

        const queue = [startKey];
        const visited = new Set();

        while (queue.length > 0) {
            const currentKey = queue.shift();
            if (visited.has(currentKey)) continue;
            visited.add(currentKey);

            const currentH = heights.get(currentKey);
            const [cn, cj] = currentKey.split(',').map(Number);

            for (const dimer of vertexToDimers.get(currentKey) || []) {
                const verts = getVertexKeys(dimer);
                const pattern = getHeightPattern(dimer.t);

                let myIdx = -1;
                for (let i = 0; i < 4; i++) {
                    if (verts[i][0] === cn && verts[i][1] === cj) { myIdx = i; break; }
                }

                if (myIdx >= 0) {
                    for (let i = 0; i < 4; i++) {
                        const [vn, vj] = verts[i];
                        const nkey = `${vn},${vj}`;
                        if (!heights.has(nkey)) {
                            heights.set(nkey, currentH + (pattern[i] - pattern[myIdx]));
                            queue.push(nkey);
                        }
                    }
                }
            }
        }
        return heights;
    }

    // Diverging colormap: blue (negative) -> white (zero) -> red (positive)
    function valueToColor(val, absMax) {
        if (absMax === 0) return 'rgb(255, 255, 255)';
        const t = Math.max(-1, Math.min(1, val / absMax));
        const gamma = 0.5;
        if (t < 0) {
            const s = Math.pow(-t, gamma);
            return `rgb(${Math.round(255 * (1 - s))}, ${Math.round(255 * (1 - s))}, 255)`;
        } else {
            const s = Math.pow(t, gamma);
            return `rgb(255, ${Math.round(255 * (1 - s))}, ${Math.round(255 * (1 - s))})`;
        }
    }

    function drawGFF(dimers1, dimers2) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, w, h);

        const h1 = computeHeightFunction(dimers1);
        const h2 = computeHeightFunction(dimers2);

        const fluctuations = new Map();
        for (const [key, val1] of h1) {
            const val2 = h2.get(key);
            if (val2 !== undefined) {
                fluctuations.set(key, (val1 - val2) / sqrt2);
            }
        }

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const tri of [...shapeData.blackTriangles, ...shapeData.whiteTriangles]) {
            for (const v of tri.verts) {
                minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
            }
        }

        const scale = Math.min(w / (maxX - minX), h / (maxY - minY)) * 0.9;
        const cx = w / 2 - ((minX + maxX) / 2) * scale;
        const cy = h / 2 + ((minY + maxY) / 2) * scale;

        function tx(x) { return cx + x * scale; }
        function ty(y) { return cy - y * scale; }

        let absMax = 0;
        for (const [, val] of fluctuations) {
            absMax = Math.max(absMax, Math.abs(val));
        }

        function getFluctValue(n, j) {
            return fluctuations.get(`${n},${j}`) || 0;
        }

        for (const tri of shapeData.blackTriangles) {
            const { n, j, verts } = tri;
            const avgVal = (getFluctValue(n, j) + getFluctValue(n, j-1) + getFluctValue(n+1, j-1)) / 3;
            ctx.beginPath();
            ctx.moveTo(tx(verts[0].x), ty(verts[0].y));
            ctx.lineTo(tx(verts[1].x), ty(verts[1].y));
            ctx.lineTo(tx(verts[2].x), ty(verts[2].y));
            ctx.closePath();
            ctx.fillStyle = valueToColor(avgVal, absMax);
            ctx.fill();
        }

        for (const tri of shapeData.whiteTriangles) {
            const { n, j, verts } = tri;
            const avgVal = (getFluctValue(n, j) + getFluctValue(n+1, j) + getFluctValue(n+1, j-1)) / 3;
            ctx.beginPath();
            ctx.moveTo(tx(verts[0].x), ty(verts[0].y));
            ctx.lineTo(tx(verts[1].x), ty(verts[1].y));
            ctx.lineTo(tx(verts[2].x), ty(verts[2].y));
            ctx.closePath();
            ctx.fillStyle = valueToColor(avgVal, absMax);
            ctx.fill();
        }
    }

    let initialized = false;
    let sampling = false;

    // GPU CFTP sampling
    async function sampleGPU() {
        sampleBtn.textContent = 'Sampling...';
        sampleBtn.disabled = true;

        // Initialize WASM CFTP to get extremal states
        const initPtr = initCFTPWasm();
        freeString(initPtr);

        const bounds = getGridBounds();
        const minGridData = getCFTPMinRawGridData(bounds);
        const maxGridData = getCFTPMaxRawGridData(bounds);

        if (!minGridData || !maxGridData) {
            console.error('Failed to get extremal states');
            sampleBtn.textContent = 'Re-sample GFF';
            sampleBtn.disabled = false;
            return;
        }

        // Initialize GPU fluctuations CFTP
        const gpuOk = await gpuEngine.initFluctuationsCFTP(minGridData, maxGridData);
        if (!gpuOk) {
            console.warn('GPU CFTP init failed, falling back to WASM');
            gpuEngine.destroyFluctuationsCFTP();
            const dimers1 = sampleCFTPWasm();
            const dimers2 = sampleCFTPWasm();
            drawGFF(dimers1, dimers2);
            sampleBtn.textContent = 'Re-sample GFF';
            sampleBtn.disabled = false;
            return;
        }

        // Set uniform weights (q=1)
        gpuEngine.setFluctuationsWeights(null, 1, false, 1.0);

        // GPU CFTP loop with epoch doubling
        let T = 1;
        const maxT = 1073741824;
        const stepsPerBatch = 1000;
        const checkInterval = 1000;

        let totalStepsAllEpochs = 0;

        async function gpuFluctStep() {
            gpuEngine.resetFluctuationsChains();

            let totalStepsRun = 0;
            let coalesced = [false, false];

            while (totalStepsRun < T && !(coalesced[0] && coalesced[1])) {
                const batchSize = Math.min(stepsPerBatch, T - totalStepsRun);
                const result = await gpuEngine.stepFluctuationsCFTP(batchSize, checkInterval);
                totalStepsRun += result.stepsRun;
                coalesced = result.coalesced;

                // Update progress
                const c0 = coalesced[0] ? '✓' : '○';
                const c1 = coalesced[1] ? '✓' : '○';
                const kSteps = Math.round((totalStepsAllEpochs + totalStepsRun) / 1000);
                sampleBtn.textContent = `T=${T} ${kSteps}k [${c0}${c1}]`;
                await new Promise(r => setTimeout(r, 0)); // yield for UI
            }
            totalStepsAllEpochs += totalStepsRun;

            const finalCoalesced = await gpuEngine.checkFluctuationsCoalescence();

            if (finalCoalesced[0] && finalCoalesced[1]) {
                const samples = await gpuEngine.getFluctuationsSamples(shapeData.blackTriangles);
                gpuEngine.destroyFluctuationsCFTP();
                drawGFF(samples.sample0, samples.sample1);
                sampleBtn.textContent = 'Re-sample GFF';
                sampleBtn.disabled = false;
                sampling = false;
            } else if (T >= maxT) {
                gpuEngine.destroyFluctuationsCFTP();
                sampleBtn.textContent = 'Timeout';
                sampleBtn.disabled = false;
                sampling = false;
            } else {
                T *= 2;
                setTimeout(gpuFluctStep, 0);
            }
        }

        setTimeout(gpuFluctStep, 10);
    }

    // WASM CFTP sampling (fallback)
    function sampleWASM() {
        sampleBtn.textContent = 'Sampling...';
        sampleBtn.disabled = true;

        setTimeout(() => {
            const dimers1 = sampleCFTPWasm();
            const dimers2 = sampleCFTPWasm();
            drawGFF(dimers1, dimers2);
            sampleBtn.textContent = 'Re-sample GFF';
            sampleBtn.disabled = false;
            sampling = false;
        }, 10);
    }

    async function sample() {
        if (sampling) return;
        sampling = true;

        if (!initialized) {
            sampleBtn.textContent = 'Loading...';
            shapeData = await loadShapeData();
            initRegion();
            await initGpuEngine();
            initialized = true;
        }

        if (gpuAvailable) {
            await sampleGPU();
        } else {
            sampleWASM();
        }
    }

    sampleBtn.addEventListener('click', sample);

    // Register with slide engine
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('fluctuations', {
                start() {},
                pause() {},
                onSlideEnter() { if (!initialized) sample(); },
                onSlideLeave() {}
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();
</script>

<!-- ==================== PART 3: Algorithmic Magic ==================== -->

<section class="slide slide-center" id="part3-intro" data-title="Part 3: Algorithms">
    <h2 style="font-size: clamp(3rem, 5vw, 5.5rem);">Part III</h2>
    <h3 style="font-size: clamp(2rem, 3.5vw, 3.5rem); color: var(--slide-muted); text-transform: uppercase; letter-spacing: 0.05em;">How to draw pictures</h3>
    <ol style="margin-top: 3vh; text-align: left; display: inline-block; font-size: clamp(1.2rem, 2.2vw, 1.8rem); line-height: 1.6;">
        <li class="fragment">Sampling from very large sets — direct picking is prohibitively expensive</li>
        <li class="fragment">Markov Chain Monte Carlo: run a chain preserving the distribution</li>
        <li class="fragment">How long to wait? Mixing time bounds (mathematically hard)</li>
        <li class="fragment">Sometimes: <strong>Coupling From The Past</strong> (works for 3D surfaces!)</li>
        <li class="fragment">CFTP for 2D paths and 3D stepped surfaces</li>
        <li class="fragment">Examples</li>
    </ol>
</section>

<!-- ==================== Slide: Thank You ==================== -->
<section class="slide slide-center" id="thankyou" data-title="Thank You">
    <div style="display: flex; flex-direction: column; gap: clamp(1rem, 3vh, 3rem); align-items: center; justify-content: center;">
        <div style="display: flex; gap: clamp(0.5rem, 1.5vw, 1.5rem); justify-content: center;">
            <canvas id="letter-T" width="200" height="260" style="width: 24vh; height: 30vh;"></canvas>
            <canvas id="letter-H" width="200" height="260" style="width: 24vh; height: 30vh;"></canvas>
            <canvas id="letter-A" width="200" height="260" style="width: 24vh; height: 30vh;"></canvas>
            <canvas id="letter-N" width="200" height="260" style="width: 24vh; height: 30vh;"></canvas>
            <canvas id="letter-K" width="200" height="260" style="width: 24vh; height: 30vh;"></canvas>
        </div>
        <div style="display: flex; gap: clamp(0.5rem, 1.5vw, 1.5rem); justify-content: center;">
            <canvas id="letter-Y" width="200" height="260" style="width: 24vh; height: 30vh;"></canvas>
            <canvas id="letter-O" width="200" height="260" style="width: 24vh; height: 30vh;"></canvas>
            <canvas id="letter-U" width="200" height="260" style="width: 24vh; height: 30vh;"></canvas>
        </div>
    </div>
</section>

<script>
(async function initThankYou() {
    // Wait for LozengeModule to be available (polling instead of event listener)
    while (typeof LozengeModule === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
    }

    // Create isolated WASM instance for Thank You slide - completely separate from Title!
    const wasm = await LozengeModule();

    const letters = ['T', 'H', 'A', 'N', 'K', 'Y', 'O', 'U'];
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) {
        return { x: n, y: slope * n + j * deltaC };
    }

    // WASM interface (using our isolated instance)
    const initFromTrianglesWasm = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const performGlauberStepsWasm = wasm.cwrap('performGlauberSteps', 'number', ['number']);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeStringWasm = wasm.cwrap('freeString', null, ['number']);
    const setUseRandomSweepsWasm = wasm.cwrap('setUseRandomSweeps', null, ['number']);
    const setDimersWasm = wasm.cwrap('setDimers', 'number', ['number', 'number']);

    // Helper to restore dimers to WASM after reinit
    function restoreDimers(dimers) {
        if (!dimers || dimers.length === 0) return;
        // Convert to flat array: [bn, bj, wn, wj, type, ...]
        const arr = [];
        for (const d of dimers) {
            arr.push(d.bn, d.bj, d.wn, d.wj, d.t);
        }
        const dataPtr = wasm._malloc(arr.length * 4);
        for (let i = 0; i < arr.length; i++) {
            wasm.setValue(dataPtr + i * 4, arr[i], 'i32');
        }
        const ptr = setDimersWasm(dataPtr, arr.length);
        freeStringWasm(ptr);
        wasm._free(dataPtr);
    }

    // Store state for each letter
    const letterStates = [];

    // Load all letters
    for (const letter of letters) {
        const canvasId = `letter-${letter}`;
        const canvas = document.getElementById(canvasId);
        if (!canvas) continue;

        try {
            const response = await fetch(`/letters/${letter}.json`);
            if (!response.ok) continue;
            const data = await response.json();
            if (!data.triangles) continue;

            const triangles = new Map();
            const triangleArr = [];
            for (const t of data.triangles) {
                const type = t.type || t.t;
                triangles.set(`${t.n},${t.j},${type}`, { n: t.n, j: t.j, type });
                triangleArr.push(t.n, t.j, type);
            }

            // Calculate bounds
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const [, tri] of triangles) {
                let verts;
                if (tri.type === 1) {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
                } else {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j), getVertex(tri.n + 1, tri.j - 1)];
                }
                for (const v of verts) {
                    minX = Math.min(minX, v.x);
                    maxX = Math.max(maxX, v.x);
                    minY = Math.min(minY, v.y);
                    maxY = Math.max(maxY, v.y);
                }
            }

            letterStates.push({
                letter,
                canvas,
                ctx: canvas.getContext('2d'),
                triangles,
                triangleArr,
                dimers: [],
                bounds: { minX, maxX, minY, maxY }
            });
        } catch (e) {
            // Skip failed letters
        }
    }

    // Initialize each letter and get initial dimers
    for (const state of letterStates) {
        const dataPtr = wasm._malloc(state.triangleArr.length * 4);
        for (let i = 0; i < state.triangleArr.length; i++) {
            wasm.setValue(dataPtr + i * 4, state.triangleArr[i], 'i32');
        }
        const ptr = initFromTrianglesWasm(dataPtr, state.triangleArr.length);
        const jsonStr = wasm.UTF8ToString(ptr);
        freeStringWasm(ptr);
        wasm._free(dataPtr);

        const result = JSON.parse(jsonStr);
        if (result.status === 'valid') {
            setUseRandomSweepsWasm(1);
            const dPtr = exportDimersWasm();
            const dimerStr = wasm.UTF8ToString(dPtr);
            freeStringWasm(dPtr);
            const dimerResult = JSON.parse(dimerStr);
            state.dimers = Array.isArray(dimerResult) ? dimerResult : (dimerResult.dimers || []);
        }
    }

    // Draw function for a letter
    function drawLetter(state) {
        const { canvas, ctx, bounds, dimers } = state;
        const { minX, maxX, minY, maxY } = bounds;

        // Use fixed dimensions to prevent zoom issues
        const displayWidth = 200;
        const displayHeight = 260;
        const dpr = window.devicePixelRatio || 1;
        if (canvas.width !== displayWidth * dpr) {
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
        }
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        const regionWidth = maxX - minX;
        const regionHeight = maxY - minY;
        // Scale by HEIGHT only so all letters have same lozenge height (K aligns with others)
        const scale = (displayHeight / regionHeight) * 0.85;
        const centerX = displayWidth / 2 - ((minX + maxX) / 2) * scale;
        const centerY = displayHeight / 2 + ((minY + maxY) / 2) * scale;

        // Draw lozenges
        for (const d of dimers) {
            const bn = d.bn, bj = d.bj, t = d.t;
            let verts;
            if (t === 0) {
                verts = [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            } else if (t === 1) {
                verts = [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
            } else {
                verts = [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            }

            ctx.beginPath();
            const p0 = [centerX + verts[0].x * scale, centerY - verts[0].y * scale];
            ctx.moveTo(p0[0], p0[1]);
            for (let i = 1; i < 4; i++) {
                const p = [centerX + verts[i].x * scale, centerY - verts[i].y * scale];
                ctx.lineTo(p[0], p[1]);
            }
            ctx.closePath();
            ctx.fillStyle = colors[t];
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }

    // Initial draw
    for (const state of letterStates) {
        drawLetter(state);
    }

    // Animation: cycle through letters, updating one per frame
    // With isolated WASM instance, no need to reinit - just run Glauber on current state!
    let currentLetterIdx = 0;
    let isRunning = false;
    let animationId = null;

    function animate() {
        if (!isRunning) return;

        // Update current letter
        const state = letterStates[currentLetterIdx];
        if (state) {
            // Re-init WASM with this letter's triangles (still needed since we cycle through letters)
            const dataPtr = wasm._malloc(state.triangleArr.length * 4);
            for (let i = 0; i < state.triangleArr.length; i++) {
                wasm.setValue(dataPtr + i * 4, state.triangleArr[i], 'i32');
            }
            const ptr = initFromTrianglesWasm(dataPtr, state.triangleArr.length);
            freeStringWasm(ptr);
            wasm._free(dataPtr);

            // Restore previous dimers so Glauber continues from current state
            restoreDimers(state.dimers);

            setUseRandomSweepsWasm(1);

            // Run Glauber steps
            const stepPtr = performGlauberStepsWasm(10);
            freeStringWasm(stepPtr);

            // Export new dimers
            const dPtr = exportDimersWasm();
            const dimerStr = wasm.UTF8ToString(dPtr);
            freeStringWasm(dPtr);
            const dimerResult = JSON.parse(dimerStr);
            state.dimers = Array.isArray(dimerResult) ? dimerResult : (dimerResult.dimers || []);

            drawLetter(state);
        }

        currentLetterIdx = (currentLetterIdx + 1) % letterStates.length;
        animationId = requestAnimationFrame(animate);
    }

    function start() {
        if (isRunning) return;
        isRunning = true;
        animate();
    }

    function pause() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    // Register with slide engine - auto-start when slide is shown
    function waitForSlideEngine() {
        if (window.slideEngine) {
            window.slideEngine.registerSimulation('thankyou', {
                start,
                pause,
                onSlideEnter() {
                    for (const state of letterStates) {
                        drawLetter(state);
                    }
                    start();
                }
            }, 0);
        } else {
            setTimeout(waitForSlideEngine, 50);
        }
    }
    waitForSlideEngine();
})();
</script>

<!-- Global: Escape/Enter key blurs input fields for slide navigation -->
<script>
document.addEventListener('keydown', (e) => {
    if ((e.key === 'Escape' || e.key === 'Enter') && document.activeElement &&
        (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) {
        document.activeElement.blur();
        e.preventDefault();
    }
});
</script>
