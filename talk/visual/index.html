---
layout: slides
title: "Random Surfaces from Stacking Cubes: A Visual Journey"
description: "Interactive talk on random lozenge tilings and their limit shapes"
---

<!-- ==================== Slide 1: Title ==================== -->
<section class="slide slide-center" id="title" data-title="Title" style="display: flex; flex-direction: column;">
    <h1 style="font-size: clamp(2.5rem, 3.5vw, 4rem); line-height: 1.2;">Random Surfaces from Stacking Cubes:<br><span style="font-style: italic;">A Visual Journey</span></h1>

    <p class="author" style="margin-top: 1vh; font-size: clamp(1.5rem, 2.5vw, 2.2rem);">Leonid Petrov</p>
    <p style="font-size: clamp(1.2rem, 2vw, 1.8rem); color: var(--slide-muted);">University of Virginia</p>

    <div style="flex: 1; display: flex; align-items: center; justify-content: center; min-height: 0;">
        <canvas id="title-canvas" width="1600" height="1200" style="cursor: pointer; height: 55vh; width: auto;"></canvas>
    </div>
</section>

<!-- Load simulation dependencies (colorschemes.js already loaded by slides layout) -->
<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>

<!-- Dynamic WASM loader: use threaded version if SharedArrayBuffer is available -->
<script>
window.VISUAL_THREADED = typeof SharedArrayBuffer !== 'undefined';
window.VISUAL_WEBGPU = !!navigator.gpu;

// Load WASM module dynamically (no document.write)
function loadScript(src) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

const wasmSrc = '/talk/visual/sim/visual-lozenge' + (window.VISUAL_THREADED ? '-threaded' : '') + '.js';
loadScript(wasmSrc).then(() => {
    window.dispatchEvent(new Event('wasm-loaded'));
});
</script>

<script>
window.addEventListener('wasm-loaded', async function() {
    // Wait for LozengeModule factory to be available
    if (typeof LozengeModule === 'undefined') {
        console.error('LozengeModule not loaded');
        return;
    }

    // Create isolated WASM instance for Title slide
    const wasm = await LozengeModule();

    // Triangular lattice constants (for equilateral triangles)
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) {
        return { x: n, y: slope * n + j * deltaC };
    }

    // WASM interface (using our isolated instance)
    const initFromTrianglesWasm = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const performGlauberStepsWasm = wasm.cwrap('performGlauberSteps', 'number', ['number']);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeStringWasm = wasm.cwrap('freeString', null, ['number']);
    const setUseRandomSweepsWasm = wasm.cwrap('setUseRandomSweeps', null, ['number']);

    // Color palette (UVA)
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    // Simulation state
    let activeTriangles = new Map();
    let dimers = [];
    let isValid = false;

    // Load Rotunda preset
    try {
        const response = await fetch('/letters/Rotunda.json');
        if (response.ok) {
            const data = await response.json();
            if (data.triangles) {
                for (const t of data.triangles) {
                    const type = t.type || t.t;
                    activeTriangles.set(`${t.n},${t.j},${type}`, { n: t.n, j: t.j, type });
                }

                // Initialize WASM region
                const arr = [];
                for (const [key, tri] of activeTriangles) {
                    arr.push(tri.n, tri.j, tri.type);
                }

                if (arr.length > 0) {
                    const dataPtr = wasm._malloc(arr.length * 4);
                    for (let i = 0; i < arr.length; i++) {
                        wasm.setValue(dataPtr + i * 4, arr[i], 'i32');
                    }

                    const ptr = initFromTrianglesWasm(dataPtr, arr.length);
                    const jsonStr = wasm.UTF8ToString(ptr);
                    freeStringWasm(ptr);
                    wasm._free(dataPtr);

                    const result = JSON.parse(jsonStr);
                    isValid = result.status === 'valid';

                    if (isValid) {
                        setUseRandomSweepsWasm(1);
                        // Export initial dimers so we can show lozenges on load
                        const dPtr = exportDimersWasm();
                        const jsonStr = wasm.UTF8ToString(dPtr);
                        freeStringWasm(dPtr);
                        const result = JSON.parse(jsonStr);
                        const dimerArr = Array.isArray(result) ? result : (result.dimers || []);
                        dimers.push(...dimerArr);
                    }
                }
            }
        }
    } catch (e) {
        // Failed to load preset
    }

    // High-DPI canvas for crisp rendering (2x resolution for 1920x1080 projector)
    const canvas = document.getElementById('title-canvas');
    const ctx = canvas.getContext('2d');
    const displayWidth = 800, displayHeight = 600;  // 55vh at 1080p ≈ 600px
    const dpr = 2; // 2x for retina/crisp rendering

    // Simulation state
    let isRunning = false;
    let animationId = null;

    // Pre-calculate transform (bounds don't change)
    let scale, centerX, centerY;
    function calcTransform() {
        if (!activeTriangles || activeTriangles.size === 0) return;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const [, tri] of activeTriangles) {
            let verts;
            if (tri.type === 1) {
                verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
            } else {
                verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j), getVertex(tri.n + 1, tri.j - 1)];
            }
            for (const v of verts) {
                minX = Math.min(minX, v.x);
                maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y);
                maxY = Math.max(maxY, v.y);
            }
        }
        const regionWidth = maxX - minX;
        const regionHeight = maxY - minY;
        scale = Math.min(displayWidth / regionWidth, displayHeight / regionHeight) * 0.85;
        centerX = displayWidth / 2 - ((minX + maxX) / 2) * scale;
        centerY = displayHeight / 2 + ((minY + maxY) / 2) * scale;
    }
    calcTransform();

    function draw() {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        if (!activeTriangles || activeTriangles.size === 0) return;

        // Draw lozenges
        if (Array.isArray(dimers) && dimers.length > 0) {
            for (const d of dimers) {
                const bn = d.bn, bj = d.bj, t = d.t;
                let verts;
                if (t === 0) {
                    verts = [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                } else if (t === 1) {
                    verts = [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
                } else {
                    verts = [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                }

                ctx.beginPath();
                ctx.moveTo(centerX + verts[0].x * scale, centerY - verts[0].y * scale);
                for (let i = 1; i < 4; i++) {
                    ctx.lineTo(centerX + verts[i].x * scale, centerY - verts[i].y * scale);
                }
                ctx.closePath();
                ctx.fillStyle = colors[t];
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
        } else {
            // Draw triangles (shape outline)
            for (const [, tri] of activeTriangles) {
                const n = tri.n, j = tri.j, type = tri.type;
                let verts;
                if (type === 1) {
                    verts = [getVertex(n, j), getVertex(n, j - 1), getVertex(n + 1, j - 1)];
                } else {
                    verts = [getVertex(n, j), getVertex(n + 1, j), getVertex(n + 1, j - 1)];
                }

                ctx.beginPath();
                ctx.moveTo(centerX + verts[0].x * scale, centerY - verts[0].y * scale);
                for (let i = 1; i < 3; i++) {
                    ctx.lineTo(centerX + verts[i].x * scale, centerY - verts[i].y * scale);
                }
                ctx.closePath();
                ctx.fillStyle = type === 1 ? '#232D4B' : '#F9DCBF';
                ctx.fill();
            }
        }
    }

    function animate() {
        if (!isValid || !isRunning) return;

        // Run Glauber steps
        const ptr = performGlauberStepsWasm(10000);
        freeStringWasm(ptr);

        // Refresh dimers
        const dPtr = exportDimersWasm();
        const jsonStr = wasm.UTF8ToString(dPtr);
        freeStringWasm(dPtr);
        const result = JSON.parse(jsonStr);
        dimers = Array.isArray(result) ? result : (result.dimers || []);

        draw();
        animationId = requestAnimationFrame(animate);
    }

    function startSim() {
        if (!isRunning) {
            isRunning = true;
            animate();
        }
    }

    function pauseSim() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    // Click to toggle
    canvas.addEventListener('click', () => {
        if (isRunning) pauseSim();
        else startSim();
    });

    // Initial draw
    draw();

    // Register with slide engine for step control
    window.slideEngine.registerSimulation('title', {
        start: startSim,
        pause: pauseSim
    }, 1);
});
</script>

<!-- ==================== PART 0: How Nature Creates Shape ==================== -->

<section class="slide slide-top" id="nature-builds" data-title="How Nature Makes Shape">
    <h2 class="slide-title">How Nature Makes Shape?</h2>

    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: clamp(1rem, 3vw, 4rem); margin-top: 2vh; align-items: start;">
        <!-- Left column: Salt crystal images -->
        <div>
            <p style="text-align: left; margin-bottom: 2vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Salt — same substance with cubic crystal structure, at different scales and growth conditions</p>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: clamp(0.5rem, 1vw, 1rem);">
                <figure style="margin: 0;">
                    <img src="images/salt-micro-public-domain.jpg" alt="Salt crystals microscopic" style="width: 100%; height: 28vh; object-fit: cover; border-radius: 4px;">
                    <figcaption><strong style="color: var(--slide-navy);">Microscopic</strong> · Public domain</figcaption>
                </figure>
                <figure style="margin: 0;">
                    <img src="images/salt-halite-doronenko-cc-by-3.jpg" alt="Hopper salt crystal" style="width: 100%; height: 28vh; object-fit: cover; border-radius: 4px;">
                    <figcaption><strong style="color: var(--slide-navy);">Mesoscopic</strong> · Doronenko, CC BY 3.0</figcaption>
                </figure>
                <figure style="margin: 0;">
                    <img src="images/salt-halite-lavinsky-irocks-cc-by-sa-3.jpg" alt="Halite crystal" style="width: 100%; height: 28vh; object-fit: cover; border-radius: 4px;">
                    <figcaption><strong style="color: var(--slide-navy);">Mesoscopic</strong> · Lavinsky, CC BY-SA 3.0</figcaption>
                </figure>
                <figure style="margin: 0;">
                    <div style="overflow: hidden; border-radius: 4px; height: 28vh;">
                        <img src="images/salt-smooth-deadsea-xta11-cc-by-sa-4.jpg" alt="Smooth salt formation" style="width: 100%; height: 100%; object-fit: cover; transform: scale(1.5); transform-origin: right bottom;">
                    </div>
                    <figcaption><strong style="color: var(--slide-navy);">Macroscopic</strong> · xta11, CC BY-SA 4.0</figcaption>
                </figure>
            </div>
        </div>

        <!-- Right column: Crystal growth simulation -->
        <div>
            <p style="text-align: left; margin-bottom: 2vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Mathematical (random) crystal growth<br><span style="visibility: hidden;">phantom</span></p>
            <div style="position: relative; display: inline-block; width: 100%;">
                <canvas id="crystal-growth-canvas" style="width: 100%; height: 62vh; border-radius: 8px;"></canvas>
                <button id="crystal-play-btn" style="position: absolute; bottom: 12px; right: 12px; width: 44px; height: 44px; border-radius: 50%; border: none; background: rgba(35, 45, 75, 0.8); color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: opacity 0.3s;">▶</button>
            </div>
        </div>
    </div>

    <p id="nature-builds-question" style="font-size: clamp(1.5rem, 2.8vw, 2.2rem); margin-top: 3vh; text-align: center; font-style: italic; color: var(--slide-navy); opacity: 0; transition: opacity 0.3s;">When can a random pile of cubes become smooth?</p>
</section>

<script>
// 3D Hexagon Glauber simulation - Complete JS port of ultimate-lozenge.cpp
(function initCrystalSim() {
    if (!window.slideEngine) {
        setTimeout(initCrystalSim, 50);
        return;
    }
    const canvas = document.getElementById('crystal-growth-canvas');
    if (!canvas) return;

    // ===== LOZENGE TILING ENGINE (ported from C++) =====
    const hexSide = 100;

    // Triangular lattice constants
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    // Dimer grid and bounds
    let dimerGrid = [];
    let gridMinN, gridMaxN, gridMinJ, gridMaxJ, gridStrideJ;

    // Triangle storage
    const blackTriangles = [];
    const whiteTriangles = [];
    const blackMap = new Map();
    const whiteMap = new Map();
    const triangularVertices = [];

    // Helpers
    function makeKey(n, j) { return `${n},${j}`; }
    function getGridIdx(n, j) { return (n - gridMinN) * gridStrideJ + (j - gridMinJ); }
    function getVertex(n, j) { return { x: n, y: slope * n + j * deltaC }; }

    function getRightTriangleCentroid(n, j) {
        const v1 = getVertex(n, j), v2 = getVertex(n, j - 1), v3 = getVertex(n + 1, j - 1);
        return { x: (v1.x + v2.x + v3.x) / 3, y: (v1.y + v2.y + v3.y) / 3 };
    }
    function getLeftTriangleCentroid(n, j) {
        const v1 = getVertex(n, j), v2 = getVertex(n + 1, j), v3 = getVertex(n + 1, j - 1);
        return { x: (v1.x + v2.x + v3.x) / 3, y: (v1.y + v2.y + v3.y) / 3 };
    }

    function getDimerType(blackN, blackJ, whiteN, whiteJ) {
        const dn = whiteN - blackN, dj = whiteJ - blackJ;
        if (dn === 0 && dj === 0) return 0;
        if (dn === 0 && dj === -1) return 1;
        if (dn === -1 && dj === 0) return 2;
        return -1;
    }

    function getWhiteFromType(blackN, blackJ, type) {
        if (type === 0) return [blackN, blackJ];
        if (type === 1) return [blackN, blackJ - 1];
        if (type === 2) return [blackN - 1, blackJ];
        return [blackN, blackJ];
    }

    function pointInPolygon(x, y, polygon) {
        if (polygon.length < 3) return false;
        let inside = false;
        for (let i = 0, pj = polygon.length - 1; i < polygon.length; pj = i++) {
            const xi = polygon[i].x, yi = polygon[i].y;
            const xj = polygon[pj].x, yj = polygon[pj].y;
            if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    }

    // ===== DINIC'S MAX-FLOW (ported from C++) =====
    let flowAdj = [];
    let level = [];
    let ptr = [];

    function addFlowEdge(from, to, cap) {
        flowAdj[from].push({ to, cap, flow: 0, rev: flowAdj[to].length });
        flowAdj[to].push({ to: from, cap: 0, flow: 0, rev: flowAdj[from].length - 1 });
    }

    function bfsFlow(s, t) {
        level.fill(-1);
        level[s] = 0;
        const q = [s];
        let head = 0;
        while (head < q.length) {
            const v = q[head++];
            for (const edge of flowAdj[v]) {
                if (edge.cap - edge.flow > 0 && level[edge.to] === -1) {
                    level[edge.to] = level[v] + 1;
                    q.push(edge.to);
                }
            }
        }
        return level[t] !== -1;
    }

    function dfsFlow(v, t, pushed) {
        if (pushed === 0) return 0;
        if (v === t) return pushed;
        for (; ptr[v] < flowAdj[v].length; ptr[v]++) {
            const edge = flowAdj[v][ptr[v]];
            if (level[v] + 1 !== level[edge.to] || edge.cap - edge.flow === 0) continue;
            const push = dfsFlow(edge.to, t, Math.min(pushed, edge.cap - edge.flow));
            if (push === 0) continue;
            edge.flow += push;
            flowAdj[edge.to][edge.rev].flow -= push;
            return push;
        }
        return 0;
    }

    function dinic(s, t) {
        let flow = 0;
        while (bfsFlow(s, t)) {
            ptr.fill(0);
            let pushed;
            while ((pushed = dfsFlow(s, t, Infinity)) > 0) {
                flow += pushed;
            }
        }
        return flow;
    }

    // ===== HEX EDGES FOR GLAUBER =====
    function getHexEdgesAroundVertex(n, j) {
        return [
            { blackN: n, blackJ: j+1, whiteN: n, whiteJ: j, type: 1 },
            { blackN: n, blackJ: j, whiteN: n, whiteJ: j, type: 0 },
            { blackN: n, blackJ: j, whiteN: n-1, whiteJ: j, type: 2 },
            { blackN: n-1, blackJ: j+1, whiteN: n-1, whiteJ: j, type: 1 },
            { blackN: n-1, blackJ: j+1, whiteN: n-1, whiteJ: j+1, type: 0 },
            { blackN: n, blackJ: j+1, whiteN: n-1, whiteJ: j+1, type: 2 }
        ];
    }

    function dimerExists(blackN, blackJ, whiteN, whiteJ) {
        if (blackN < gridMinN || blackN > gridMaxN || blackJ < gridMinJ || blackJ > gridMaxJ) return false;
        const idx = getGridIdx(blackN, blackJ);
        if (idx < 0 || idx >= dimerGrid.length) return false;
        const typeInGrid = dimerGrid[idx];
        if (typeInGrid === -1) return false;
        return typeInGrid === getDimerType(blackN, blackJ, whiteN, whiteJ);
    }

    const qParam = 0;  // q=0 means pure removal, never add cubes

    function tryRotation(n, j, execute) {
        const edges = getHexEdgesAroundVertex(n, j);
        const coveredIdx = [], uncoveredIdx = [];

        for (let i = 0; i < 6; i++) {
            const e = edges[i];
            if (dimerExists(e.blackN, e.blackJ, e.whiteN, e.whiteJ)) {
                if (coveredIdx.length < 3) coveredIdx.push(i);
                else return 0;
            } else {
                if (uncoveredIdx.length < 3) uncoveredIdx.push(i);
                else return 0;
            }
        }

        if (coveredIdx.length !== 3 || uncoveredIdx.length !== 3) return 0;

        if (!execute) return 1;

        // q-weighted acceptance: covered sum 6 = {0,2,4}, sum 9 = {1,3,5}
        // Going from sum=9 to sum=6 adds cube, sum=6 to sum=9 removes
        const coveredSum = coveredIdx[0] + coveredIdx[1] + coveredIdx[2];
        const addingCube = (coveredSum === 9);  // {1,3,5} -> {0,2,4}
        if (addingCube && Math.random() > qParam) return 0;  // reject add with prob 1 - q
        if (!addingCube && qParam > 0 && Math.random() > 1 / qParam) return 0;  // reject remove with prob 1 - 1/q

        for (const idx of coveredIdx) {
            const e = edges[idx];
            if (e.blackN >= gridMinN && e.blackN <= gridMaxN && e.blackJ >= gridMinJ && e.blackJ <= gridMaxJ) {
                const gridIdx = getGridIdx(e.blackN, e.blackJ);
                if (gridIdx >= 0 && gridIdx < dimerGrid.length) dimerGrid[gridIdx] = -1;
            }
        }
        for (const idx of uncoveredIdx) {
            const e = edges[idx];
            if (e.blackN < gridMinN || e.blackN > gridMaxN || e.blackJ < gridMinJ || e.blackJ > gridMaxJ) continue;
            if (blackMap.has(makeKey(e.blackN, e.blackJ)) && whiteMap.has(makeKey(e.whiteN, e.whiteJ))) {
                const gridIdx = getGridIdx(e.blackN, e.blackJ);
                if (gridIdx >= 0 && gridIdx < dimerGrid.length) dimerGrid[gridIdx] = e.type;
            }
        }
        return 1;
    }

    // ===== INITIALIZATION WITH MAX-FLOW =====
    function initHexagon() {
        blackTriangles.length = 0;
        whiteTriangles.length = 0;
        blackMap.clear();
        whiteMap.clear();
        triangularVertices.length = 0;

        const N = hexSide;

        // Generate hexagon boundary
        const directions = [[1, -1], [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1]];
        const boundary = [];
        let bn = 0, bj = 0;
        for (let dir = 0; dir < 6; dir++) {
            for (let step = 0; step < N; step++) {
                boundary.push(getVertex(bn, bj));
                bn += directions[dir][0];
                bj += directions[dir][1];
            }
        }

        // Bounding box
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const v of boundary) {
            minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
            minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
        }
        const searchMinN = Math.floor(minX) - 2;
        const searchMaxN = Math.ceil(maxX) + 2;
        const nRange = searchMaxN - searchMinN;
        const searchMinJ = Math.floor(minY / deltaC) - nRange - 5;
        const searchMaxJ = Math.ceil(maxY / deltaC) + nRange + 5;

        // Generate triangles
        for (let n = searchMinN; n <= searchMaxN; n++) {
            for (let j = searchMinJ; j <= searchMaxJ; j++) {
                const rc = getRightTriangleCentroid(n, j);
                if (pointInPolygon(rc.x, rc.y, boundary)) {
                    blackMap.set(makeKey(n, j), blackTriangles.length);
                    blackTriangles.push({ n, j });
                }
                const lc = getLeftTriangleCentroid(n, j);
                if (pointInPolygon(lc.x, lc.y, boundary)) {
                    whiteMap.set(makeKey(n, j), whiteTriangles.length);
                    whiteTriangles.push({ n, j });
                }
            }
        }

        // Grid setup
        gridMinN = searchMinN - 2; gridMaxN = searchMaxN + 2;
        gridMinJ = searchMinJ - 2; gridMaxJ = searchMaxJ + 2;
        gridStrideJ = gridMaxJ - gridMinJ + 1;
        dimerGrid = new Array((gridMaxN - gridMinN + 1) * gridStrideJ).fill(-1);

        // ===== DINIC'S MAX-FLOW FOR PERFECT MATCHING =====
        const numBlack = blackTriangles.length;
        const numWhite = whiteTriangles.length;
        const S = numBlack + numWhite;  // Source
        const T = S + 1;                 // Sink

        flowAdj = Array.from({ length: T + 1 }, () => []);
        level = new Array(T + 1).fill(-1);
        ptr = new Array(T + 1).fill(0);

        // Source -> black triangles
        for (let i = 0; i < numBlack; i++) {
            addFlowEdge(S, i, 1);
        }

        // White triangles -> sink
        for (let i = 0; i < numWhite; i++) {
            addFlowEdge(numBlack + i, T, 1);
        }

        // Black -> white neighbors (3 possible neighbors per black)
        for (let i = 0; i < numBlack; i++) {
            const bt = blackTriangles[i];
            const neighbors = [
                [bt.n, bt.j],        // Type 0
                [bt.n, bt.j - 1],    // Type 1
                [bt.n - 1, bt.j]     // Type 2
            ];
            for (const [wn, wj] of neighbors) {
                const wKey = makeKey(wn, wj);
                if (whiteMap.has(wKey)) {
                    addFlowEdge(i, numBlack + whiteMap.get(wKey), 1);
                }
            }
        }

        // Run Dinic's algorithm
        const maxFlow = dinic(S, T);

        // Extract matching from flow
        for (let i = 0; i < numBlack; i++) {
            for (const edge of flowAdj[i]) {
                if (edge.to >= numBlack && edge.to < S && edge.flow === 1) {
                    const wIdx = edge.to - numBlack;
                    const bt = blackTriangles[i];
                    const wt = whiteTriangles[wIdx];
                    const type = getDimerType(bt.n, bt.j, wt.n, wt.j);
                    const gridIdx = getGridIdx(bt.n, bt.j);
                    if (gridIdx >= 0 && gridIdx < dimerGrid.length) {
                        dimerGrid[gridIdx] = type;
                    }
                    break;
                }
            }
        }

        // Build triangular vertices
        const vertexSet = new Set();
        for (const bt of blackTriangles) {
            vertexSet.add(makeKey(bt.n, bt.j));
            vertexSet.add(makeKey(bt.n, bt.j - 1));
            vertexSet.add(makeKey(bt.n + 1, bt.j - 1));
        }
        for (const wt of whiteTriangles) {
            vertexSet.add(makeKey(wt.n, wt.j));
            vertexSet.add(makeKey(wt.n + 1, wt.j));
            vertexSet.add(makeKey(wt.n + 1, wt.j - 1));
        }
        for (const key of vertexSet) {
            const [n, j] = key.split(',').map(Number);
            triangularVertices.push({ n, j });
        }

    }

    function glauberSteps(count) {
        const N = triangularVertices.length;
        if (N === 0) return;
        for (let s = 0; s < count; s++) {
            const idx = Math.floor(Math.random() * N);
            const v = triangularVertices[idx];
            tryRotation(v.n, v.j, true);
        }
    }

    function exportDimers() {
        const dimers = [];
        for (const bt of blackTriangles) {
            const gridIdx = getGridIdx(bt.n, bt.j);
            if (gridIdx >= 0 && gridIdx < dimerGrid.length) {
                const type = dimerGrid[gridIdx];
                if (type !== -1) {
                    const [wn, wj] = getWhiteFromType(bt.n, bt.j, type);
                    dimers.push({ bn: bt.n, bj: bt.j, wn, wj, t: type });
                }
            }
        }
        return dimers;
    }

    // ===== THREE.JS RENDERING =====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    let aspect = canvas.clientWidth / canvas.clientHeight;
    const camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 5000);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = false;
    controls.enablePan = true;
    controls.enableZoom = true;

    function resize() {
        const w = canvas.clientWidth, h = canvas.clientHeight;
        if (w === 0 || h === 0) return;
        renderer.setSize(w, h, false);
        aspect = w / h;
        camera.aspect = aspect;
        camera.updateProjectionMatrix();
    }
    resize();
    window.addEventListener('resize', resize);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const hemi = new THREE.HemisphereLight(0x6666aa, 0x222244, 0.25);
    hemi.position.set(0, 20, 0);
    scene.add(hemi);
    const directional = new THREE.DirectionalLight(0xffffff, 1.2);
    directional.position.set(15, 20, 5);
    scene.add(directional);
    const fill = new THREE.DirectionalLight(0xffffff, 0.3);
    fill.position.set(-10, 5, -5);
    scene.add(fill);

    const meshGroup = new THREE.Group();
    scene.add(meshGroup);

    camera.position.set(10.2, -110.4, -10.8);
    controls.target.set(-13.4, -89.2, 12.4);
    controls.update();

    const colors = ['#FFFFFF', '#FFFFFF', '#FFFFFF'];
    let isRunning = false;
    let animationId = null;

    // Vertex keys for each dimer type (same as before)
    function getVertexKeys(dimer) {
        const { bn, bj, t } = dimer;
        if (t === 0) return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
        if (t === 1) return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
        return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
    }

    function getHeightPattern(t) {
        if (t === 0) return [0, 0, 0, 0];
        if (t === 1) return [1, 0, 0, 1];
        return [1, 1, 0, 0];
    }

    function to3D(n, j, h) {
        return { x: h, y: -n - h, z: j - h };
    }

    function buildGeometry() {
        while (meshGroup.children.length > 0) {
            const child = meshGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
            meshGroup.remove(child);
        }

        const dimers = exportDimers();
        if (dimers.length === 0) return;

        // Build vertex-to-dimer map and calculate heights via BFS
        const vertexToDimers = new Map();
        for (const dimer of dimers) {
            for (const [n, j] of getVertexKeys(dimer)) {
                const key = `${n},${j}`;
                if (!vertexToDimers.has(key)) vertexToDimers.set(key, []);
                vertexToDimers.get(key).push(dimer);
            }
        }

        const heights = new Map();
        const firstVerts = getVertexKeys(dimers[0]);
        const startKey = `${firstVerts[0][0]},${firstVerts[0][1]}`;
        heights.set(startKey, 0);

        const queue = [startKey];
        const visited = new Set();

        while (queue.length > 0) {
            const currentKey = queue.shift();
            if (visited.has(currentKey)) continue;
            visited.add(currentKey);

            const currentH = heights.get(currentKey);
            const [cn, cj] = currentKey.split(',').map(Number);

            for (const dimer of vertexToDimers.get(currentKey) || []) {
                const verts = getVertexKeys(dimer);
                const pattern = getHeightPattern(dimer.t);
                const myIdx = verts.findIndex(([vn, vj]) => vn === cn && vj === cj);
                if (myIdx >= 0) {
                    for (let i = 0; i < 4; i++) {
                        const vkey = `${verts[i][0]},${verts[i][1]}`;
                        if (!heights.has(vkey)) {
                            heights.set(vkey, currentH + (pattern[i] - pattern[myIdx]));
                            queue.push(vkey);
                        }
                    }
                }
            }
        }

        const geometry = new THREE.BufferGeometry();
        const vertices = [], normals = [], vertexColors = [], indices = [];

        function addQuad(v1, v2, v3, v4, color) {
            const baseIndex = vertices.length / 3;
            vertices.push(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z, v4.x, v4.y, v4.z);
            const edge1 = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
            const edge2 = { x: v4.x - v1.x, y: v4.y - v1.y, z: v4.z - v1.z };
            const nx = edge1.y * edge2.z - edge1.z * edge2.y;
            const ny = edge1.z * edge2.x - edge1.x * edge2.z;
            const nz = edge1.x * edge2.y - edge1.y * edge2.x;
            const len = Math.sqrt(nx*nx + ny*ny + nz*nz) || 1;
            for (let i = 0; i < 4; i++) normals.push(nx/len, ny/len, nz/len);
            const c = new THREE.Color(color);
            for (let i = 0; i < 4; i++) vertexColors.push(c.r, c.g, c.b);
            indices.push(baseIndex, baseIndex+1, baseIndex+2, baseIndex, baseIndex+2, baseIndex+3);
        }

        for (const dimer of dimers) {
            const verts = getVertexKeys(dimer);
            const v3d = verts.map(([n, j]) => to3D(n, j, heights.get(`${n},${j}`) || 0));
            addQuad(v3d[0], v3d[1], v3d[2], v3d[3], colors[dimer.t]);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
        geometry.setIndex(indices);

        const material = new THREE.MeshStandardMaterial({
            vertexColors: true, side: THREE.DoubleSide, flatShading: true, roughness: 0.3, metalness: 0.5
        });
        meshGroup.add(new THREE.Mesh(geometry, material));

        if (!isRunning) {
            const edgesGeometry = new THREE.EdgesGeometry(geometry, 10);
            meshGroup.add(new THREE.LineSegments(edgesGeometry, new THREE.LineBasicMaterial({ color: 0x222222, opacity: 0.6, transparent: true })));
        }
    }

    // Initialize
    initHexagon();
    buildGeometry();
    renderer.render(scene, camera);

    function animate() {
        if (!isRunning) return;
        glauberSteps(15000);
        buildGeometry();
        controls.update();
        renderer.render(scene, camera);
        animationId = requestAnimationFrame(animate);
    }

    const playBtn = document.getElementById('crystal-play-btn');

    function updatePlayBtn() {
        playBtn.textContent = isRunning ? '⏸' : '▶';
    }

    function start() {
        if (!isRunning) { isRunning = true; updatePlayBtn(); animate(); }
    }

    function pause() {
        isRunning = false;
        if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
        updatePlayBtn();
        buildGeometry();
        renderer.render(scene, camera);
    }

    function toggle() {
        if (isRunning) pause(); else start();
    }

    playBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggle();
    });

    controls.addEventListener('change', () => {
        if (!isRunning && !isCameraAnimating) renderer.render(scene, camera);
    });

    // Camera animation (end is 2x farther from target)
    const cameraStart = { x: 10.2, y: -110.4, z: -10.8 };
    const cameraEnd = { x: 39.6, y: -140.4, z: 39.6 };
    let isCameraAnimating = false;
    let cameraAnimationId = null;

    function animateCamera(duration = 3000) {
        const startTime = performance.now();
        const startPos = { ...cameraStart };
        isCameraAnimating = true;

        function tick() {
            const elapsed = performance.now() - startTime;
            const t = Math.min(elapsed / duration, 1);
            // Smooth easing (ease-in-out)
            const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

            camera.position.x = startPos.x + (cameraEnd.x - startPos.x) * ease;
            camera.position.y = startPos.y + (cameraEnd.y - startPos.y) * ease;
            camera.position.z = startPos.z + (cameraEnd.z - startPos.z) * ease;
            controls.update();
            renderer.render(scene, camera);

            if (t < 1) {
                cameraAnimationId = requestAnimationFrame(tick);
            } else {
                isCameraAnimating = false;
            }
        }
        tick();
    }

    function resetCamera() {
        if (cameraAnimationId) cancelAnimationFrame(cameraAnimationId);
        isCameraAnimating = false;
        camera.position.set(cameraStart.x, cameraStart.y, cameraStart.z);
        controls.update();
        renderer.render(scene, camera);
    }

    const questionEl = document.getElementById('nature-builds-question');

    // 4 steps: 1=start, 2=stop, 3=camera transition, 4=text
    window.slideEngine.registerSimulation('nature-builds', {
        start, pause, steps: 4,
        onSlideEnter() {
            setTimeout(() => {
                resize();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
                buildGeometry();
                controls.update();
                renderer.render(scene, camera);
                requestAnimationFrame(() => { resize(); renderer.render(scene, camera); });
            }, 50);
        },
        onStep(step) {
            if (step === 1) { start(); }
            else if (step === 2) { pause(); }
            else if (step === 3) { animateCamera(3000); }
            else if (step === 4) { questionEl.style.opacity = '1'; }
        },
        onStepBack(step) {
            if (step === 0) { pause(); initHexagon(); buildGeometry(); resetCamera(); questionEl.style.opacity = '0'; }
            else if (step === 1) { start(); questionEl.style.opacity = '0'; }
            else if (step === 2) { resetCamera(); questionEl.style.opacity = '0'; }
            else if (step === 3) { questionEl.style.opacity = '0'; }
        }
    }, 1);
})();
</script>

<!-- ==================== PART 1: The 2D Warm-Up ==================== -->

<section class="slide slide-center" id="part1-intro" data-title="Part 1: 2D">
    <h2 style="font-size: clamp(3rem, 5vw, 5.5rem);">Part I</h2>
    <h3 style="font-size: clamp(3rem, 5vw, 5.5rem); color: var(--slide-muted); text-transform: uppercase; letter-spacing: 0.05em;">The 2D Warm-Up</h3>
</section>

<section class="slide" id="grid-paths" data-title="Grid Paths">
    <h2 class="slide-title">Paths on a Grid</h2>
    <div style="display: grid; grid-template-columns: 1fr 1.5fr; gap: 3vw; align-items: start; margin-top: 2vh;">
        <!-- Left column: grid visual, text and formula -->
        <div>
            <canvas id="grid-demo-canvas" width="400" height="400" style="width: 30vw; height: 30vw; max-width: 350px; max-height: 350px; margin-bottom: 2vh;"></canvas>
            <p style="font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Start at (0, 0), end at (a, b)</p>
            <p style="font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Move only right (R) or up (U)</p>
            <p style="margin-top: 2vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">How many paths exist?</p>
            <div id="grid-paths-answer" style="margin-top: 3vh; opacity: 0; transition: opacity 0.3s;">
                <p style="font-size: clamp(1.5rem, 2.5vw, 2rem); color: var(--uva-orange);">
                    \(\displaystyle\binom{a+b}{a} = \frac{(a+b)!}{a!\, b!}\)
                </p>
                <p style="font-size: clamp(1rem, 1.8vw, 1.4rem); color: var(--slide-muted); margin-top: 1vh;">
                    \(n! = n \times (n-1) \times \cdots \times 2 \times 1\)
                </p>
            </div>
        </div>
        <!-- Right column: simulation -->
        <div id="grid-paths-sim" style="opacity: 0; transition: opacity 0.3s;">
            <div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 1vh;">
                <label style="font-size: clamp(0.9rem, 1.5vw, 1.1rem);">a = <input type="number" id="path-a" value="2" min="1" max="7" style="width: 3rem; font-size: 1rem;"></label>
                <label style="font-size: clamp(0.9rem, 1.5vw, 1.1rem);">b = <input type="number" id="path-b" value="2" min="1" max="7" style="width: 3rem; font-size: 1rem;"></label>
                <span id="path-count" style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); color: var(--uva-orange); margin-left: 1rem;"></span>
            </div>
            <canvas id="paths-canvas" width="700" height="500" style="border: 1px solid #ccc; border-radius: 8px; width: 100%; height: auto;"></canvas>
        </div>
    </div>
</section>

<script>
(function() {
    const canvas = document.getElementById('paths-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const inputA = document.getElementById('path-a');
    const inputB = document.getElementById('path-b');
    const countSpan = document.getElementById('path-count');
    const simDiv = document.getElementById('grid-paths-sim');
    const answerDiv = document.getElementById('grid-paths-answer');

    // Draw grid demo in left column
    const gridCanvas = document.getElementById('grid-demo-canvas');
    const gridCtx = gridCanvas.getContext('2d');
    function drawGridDemo() {
        const w = gridCanvas.width, h = gridCanvas.height;
        const padding = 30;
        const gridSize = 4;
        const stepX = (w - 2 * padding) / gridSize;
        const stepY = (h - 2 * padding) / gridSize;

        gridCtx.fillStyle = '#fff';
        gridCtx.fillRect(0, 0, w, h);

        // Draw grid lines
        gridCtx.strokeStyle = '#999';
        gridCtx.lineWidth = 2;
        for (let i = 0; i <= gridSize; i++) {
            gridCtx.beginPath();
            gridCtx.moveTo(padding + i * stepX, padding);
            gridCtx.lineTo(padding + i * stepX, h - padding);
            gridCtx.stroke();
            gridCtx.beginPath();
            gridCtx.moveTo(padding, padding + i * stepY);
            gridCtx.lineTo(w - padding, padding + i * stepY);
            gridCtx.stroke();
        }

        // Draw dots
        gridCtx.fillStyle = '#232D4B';
        for (let i = 0; i <= gridSize; i++) {
            for (let j = 0; j <= gridSize; j++) {
                gridCtx.beginPath();
                gridCtx.arc(padding + i * stepX, h - padding - j * stepY, 4, 0, Math.PI * 2);
                gridCtx.fill();
            }
        }

        // Draw sample path: UURURRUR
        // (0,0) -> U(0,1) -> U(0,2) -> R(1,2) -> U(1,3) -> R(2,3) -> R(3,3) -> U(3,4) -> R(4,4)
        gridCtx.strokeStyle = '#E57200';
        gridCtx.lineWidth = 8;
        gridCtx.lineCap = 'round';
        gridCtx.lineJoin = 'round';
        gridCtx.beginPath();
        gridCtx.moveTo(padding, h - padding);                           // (0,0)
        gridCtx.lineTo(padding, h - padding - stepY);                   // U -> (0,1)
        gridCtx.lineTo(padding, h - padding - 2 * stepY);               // U -> (0,2)
        gridCtx.lineTo(padding + stepX, h - padding - 2 * stepY);       // R -> (1,2)
        gridCtx.lineTo(padding + stepX, h - padding - 3 * stepY);       // U -> (1,3)
        gridCtx.lineTo(padding + 2 * stepX, h - padding - 3 * stepY);   // R -> (2,3)
        gridCtx.lineTo(padding + 3 * stepX, h - padding - 3 * stepY);   // R -> (3,3)
        gridCtx.lineTo(padding + 3 * stepX, h - padding - 4 * stepY);   // U -> (3,4)
        gridCtx.lineTo(padding + 4 * stepX, h - padding - 4 * stepY);   // R -> (4,4)
        gridCtx.stroke();

        // Labels
        gridCtx.fillStyle = '#232D4B';
        gridCtx.font = '16px sans-serif';
        gridCtx.fillText('(0,0)', padding - 10, h - padding + 20);
        gridCtx.fillText('(a,b)', w - padding - 5, padding - 10);
    }
    drawGridDemo();

    function generatePaths(a, b) {
        const paths = [];
        function generate(x, y, path) {
            if (x === a && y === b) {
                paths.push([...path]);
                return;
            }
            if (x < a) {
                path.push('R');
                generate(x + 1, y, path);
                path.pop();
            }
            if (y < b) {
                path.push('U');
                generate(x, y + 1, path);
                path.pop();
            }
        }
        generate(0, 0, []);
        return paths;
    }

    function drawPaths() {
        const a = Math.min(7, Math.max(1, parseInt(inputA.value) || 2));
        const b = Math.min(7, Math.max(1, parseInt(inputB.value) || 2));
        inputA.value = a;
        inputB.value = b;

        const paths = generatePaths(a, b);
        const numPaths = paths.length;
        countSpan.textContent = `${numPaths} paths`;

        // Calculate grid layout
        const cols = Math.ceil(Math.sqrt(numPaths * 1.5));
        const rows = Math.ceil(numPaths / cols);

        const cellW = canvas.width / cols;
        const cellH = canvas.height / rows;
        const padding = Math.min(cellW, cellH) * 0.1;
        const gridW = cellW - 2 * padding;
        const gridH = cellH - 2 * padding;
        const stepX = gridW / a;
        const stepY = gridH / b;

        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        paths.forEach((path, idx) => {
            const col = idx % cols;
            const row = Math.floor(idx / cols);
            const baseX = col * cellW + padding;
            const baseY = row * cellH + padding;

            // Draw grid lines
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            for (let i = 0; i <= a; i++) {
                ctx.beginPath();
                ctx.moveTo(baseX + i * stepX, baseY);
                ctx.lineTo(baseX + i * stepX, baseY + gridH);
                ctx.stroke();
            }
            for (let j = 0; j <= b; j++) {
                ctx.beginPath();
                ctx.moveTo(baseX, baseY + gridH - j * stepY);
                ctx.lineTo(baseX + gridW, baseY + gridH - j * stepY);
                ctx.stroke();
            }

            // Draw grid dots
            ctx.fillStyle = '#232D4B';
            for (let i = 0; i <= a; i++) {
                for (let j = 0; j <= b; j++) {
                    ctx.beginPath();
                    ctx.arc(baseX + i * stepX, baseY + gridH - j * stepY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw path
            ctx.strokeStyle = '#E57200';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            let x = 0, y = 0;
            ctx.moveTo(baseX + x * stepX, baseY + gridH - y * stepY);
            for (const move of path) {
                if (move === 'R') x++;
                else y++;
                ctx.lineTo(baseX + x * stepX, baseY + gridH - y * stepY);
            }
            ctx.stroke();
        });
    }

    inputA.addEventListener('change', drawPaths);
    inputB.addEventListener('change', drawPaths);
    inputA.addEventListener('input', drawPaths);
    inputB.addEventListener('input', drawPaths);

    // Initial draw
    drawPaths();

    // Register with slideEngine for step-based reveal
    function waitForSlideEngine() {
        if (!window.slideEngine) {
            setTimeout(waitForSlideEngine, 50);
            return;
        }
        window.slideEngine.registerSimulation('grid-paths', {
            start() {},
            pause() {},
            steps: 3,
            onStep(step) {
                if (step === 1) {
                    // Show simulation with a=2, b=2
                    inputA.value = 2;
                    inputB.value = 2;
                    simDiv.style.opacity = '1';
                    drawPaths();
                } else if (step === 2) {
                    // Change to a=4, b=3
                    inputA.value = 4;
                    inputB.value = 3;
                    drawPaths();
                } else if (step === 3) {
                    answerDiv.style.opacity = '1';
                    if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([answerDiv]);
                }
            },
            onStepBack(step) {
                if (step === 0) {
                    simDiv.style.opacity = '0';
                    answerDiv.style.opacity = '0';
                } else if (step === 1) {
                    // Back to a=2, b=2
                    inputA.value = 2;
                    inputB.value = 2;
                    drawPaths();
                    answerDiv.style.opacity = '0';
                } else if (step === 2) {
                    answerDiv.style.opacity = '0';
                }
            },
            onSlideEnter() {
                inputA.value = 2;
                inputB.value = 2;
                drawPaths();
            }
        }, 1);
    }
    waitForSlideEngine();
})();
</script>

<section class="slide slide-center" id="random-path" data-title="Random Path">
    <h2 class="slide-title">Pick one path at random</h2>

    <p id="random-path-text1" style="opacity: 0; transition: opacity 0.3s; font-size: clamp(1.2rem, 2.2vw, 1.8rem); margin-top: 2vh;">
        Pick one path at random from \(\displaystyle\binom{a+b}{a}\) possible ones
    </p>

    <p id="random-path-question" style="opacity: 0; transition: opacity 0.3s; font-size: clamp(1.5rem, 2.8vw, 2.2rem); margin-top: 2vh; color: var(--slide-accent);">
        How does it look like?
    </p>

    <div id="random-path-sim" style="opacity: 0; transition: opacity 0.3s; margin-top: 2vh; display: flex; flex-direction: column; align-items: center;">
        <div style="font-size: clamp(1.2rem, 2.2vw, 1.8rem); margin-bottom: 1vh;">
            <span style="font-weight: 600;">a = <span id="random-a-display">4</span>, b = <span id="random-b-display">3</span></span>
            <span style="margin-left: 2vw;"><span id="random-count" style="font-weight: bold; color: var(--slide-accent);">35</span> paths</span>
        </div>
        <canvas id="random-path-canvas" width="1200" height="900" style="height: 45vh; width: auto; border: 1px solid #ccc; border-radius: 8px;"></canvas>
    </div>
</section>
<script>
(function() {
    const text1 = document.getElementById('random-path-text1');
    const question = document.getElementById('random-path-question');
    const simDiv = document.getElementById('random-path-sim');
    const canvas = document.getElementById('random-path-canvas');
    const ctx = canvas.getContext('2d');
    const aDisplay = document.getElementById('random-a-display');
    const bDisplay = document.getElementById('random-b-display');
    const countSpan = document.getElementById('random-count');

    let currentA = 4;
    let currentB = 3;
    let currentPath = null;
    let showPath = true;

    function binomial(n, k) {
        if (k > n) return 0;
        if (k === 0 || k === n) return 1;
        let result = 1;
        for (let i = 0; i < k; i++) {
            result = result * (n - i) / (i + 1);
        }
        return Math.round(result);
    }

    function generateRandomPath(a, b) {
        // Generate a random path: a R's and b U's
        const moves = [];
        let remainingR = a;
        let remainingU = b;
        while (remainingR + remainingU > 0) {
            if (remainingR === 0) {
                moves.push('U');
                remainingU--;
            } else if (remainingU === 0) {
                moves.push('R');
                remainingR--;
            } else {
                // Choose R with probability remainingR / (remainingR + remainingU)
                if (Math.random() < remainingR / (remainingR + remainingU)) {
                    moves.push('R');
                    remainingR--;
                } else {
                    moves.push('U');
                    remainingU--;
                }
            }
        }
        return moves;
    }

    function updateDisplay() {
        aDisplay.textContent = currentA;
        bDisplay.textContent = currentB;
        const count = binomial(currentA + currentB, currentA);
        countSpan.textContent = count.toLocaleString();
    }

    function drawPath() {
        const a = currentA;
        const b = currentB;

        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (!showPath) {
            // For large a,b, just show the number without the path
            ctx.fillStyle = '#232D4B';
            ctx.font = 'bold 60px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const count = binomial(a + b, a);
            ctx.fillText(count.toLocaleString() + ' paths', canvas.width / 2, canvas.height / 2);
            ctx.font = '36px sans-serif';
            ctx.fillText('(too many to draw!)', canvas.width / 2, canvas.height / 2 + 70);
            return;
        }

        // Generate random path if needed
        if (!currentPath || currentPath.length !== a + b) {
            currentPath = generateRandomPath(a, b);
        }

        const padding = 80;
        const gridW = canvas.width - 2 * padding;
        const gridH = canvas.height - 2 * padding;
        const stepX = gridW / a;
        const stepY = gridH / b;
        const baseX = padding;
        const baseY = padding;

        // Draw grid lines
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 2;
        for (let i = 0; i <= a; i++) {
            ctx.beginPath();
            ctx.moveTo(baseX + i * stepX, baseY);
            ctx.lineTo(baseX + i * stepX, baseY + gridH);
            ctx.stroke();
        }
        for (let j = 0; j <= b; j++) {
            ctx.beginPath();
            ctx.moveTo(baseX, baseY + gridH - j * stepY);
            ctx.lineTo(baseX + gridW, baseY + gridH - j * stepY);
            ctx.stroke();
        }

        // Draw grid dots
        ctx.fillStyle = '#232D4B';
        for (let i = 0; i <= a; i++) {
            for (let j = 0; j <= b; j++) {
                ctx.beginPath();
                ctx.arc(baseX + i * stepX, baseY + gridH - j * stepY, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw path
        ctx.strokeStyle = '#E57200';
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        let x = 0, y = 0;
        ctx.moveTo(baseX + x * stepX, baseY + gridH - y * stepY);
        for (const move of currentPath) {
            if (move === 'R') x++;
            else y++;
            ctx.lineTo(baseX + x * stepX, baseY + gridH - y * stepY);
        }
        ctx.stroke();

        // Label endpoints
        ctx.fillStyle = '#232D4B';
        ctx.font = 'bold 28px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('(0,0)', baseX, baseY + gridH + 10);
        ctx.textBaseline = 'bottom';
        ctx.fillText('(' + a + ',' + b + ')', baseX + gridW, baseY - 10);
    }

    function setParams(a, b, draw = true) {
        currentA = a;
        currentB = b;
        showPath = (a <= 15 && b <= 15);
        currentPath = null;
        updateDisplay();
        if (draw) drawPath();
    }

    // Click to resample
    canvas.addEventListener('click', () => {
        if (showPath) {
            currentPath = generateRandomPath(currentA, currentB);
            drawPath();
        }
    });

    // Register with slideEngine for step-based reveal
    function waitForSlideEngine() {
        if (!window.slideEngine) {
            setTimeout(waitForSlideEngine, 50);
            return;
        }
        window.slideEngine.registerSimulation('random-path', {
            start() {},
            pause() {},
            steps: 5,
            onStep(step) {
                if (step === 1) {
                    text1.style.opacity = '1';
                    if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([text1]);
                } else if (step === 2) {
                    question.style.opacity = '1';
                } else if (step === 3) {
                    simDiv.style.opacity = '1';
                    setParams(4, 3);
                } else if (step === 4) {
                    setParams(12, 9);
                } else if (step === 5) {
                    setParams(120, 90);
                }
            },
            onStepBack(step) {
                if (step === 0) {
                    text1.style.opacity = '0';
                    question.style.opacity = '0';
                    simDiv.style.opacity = '0';
                } else if (step === 1) {
                    question.style.opacity = '0';
                    simDiv.style.opacity = '0';
                } else if (step === 2) {
                    simDiv.style.opacity = '0';
                } else if (step === 3) {
                    setParams(4, 3);
                } else if (step === 4) {
                    setParams(12, 9);
                }
            },
            onSlideEnter() {
                // Reset to initial state
                text1.style.opacity = '0';
                question.style.opacity = '0';
                simDiv.style.opacity = '0';
            }
        }, 1);
    }
    waitForSlideEngine();
})();
</script>

<section class="slide slide-center" id="limit-shape-2d" data-title="Limit Shape (2D)">
    <h2 class="slide-title">The Limit Shape</h2>
    <p class="fragment" style="margin-top: 1.5rem;">Scale up to n = 100, 1000, ...</p>
    <p class="fragment" style="margin-top: 1rem;">[Simulation: Random path for large n]</p>
    <p class="fragment" style="font-size: 1.3rem; margin-top: 2rem;">It looks like a straight diagonal line!</p>
    <p class="fragment" style="color: var(--slide-muted);">This is the <strong>Law of Large Numbers</strong>.</p>
</section>

<section class="slide slide-center" id="q-deformation" data-title="q-Deformation">
    <h2 class="slide-title">The q-Deformation</h2>
    <p class="fragment" style="margin-top: 1.5rem;">Imagine the <strong>area under the path</strong> represents "energy" or "cost".</p>
    <p class="fragment" style="margin-top: 1rem;">Weight each path by \(q^{\text{area}}\)</p>
    <p class="fragment" style="margin-top: 2rem; font-size: 1.2rem;">The parameter q acts like inverse temperature.</p>
</section>

<section class="slide slide-center" id="q-slider" data-title="The q-Slider">
    <h2 class="slide-title">Bending the Curve</h2>
    <p style="margin-top: 1rem;">[Interactive: q-slider simulation]</p>
    <ul style="margin-top: 2rem; text-align: left; display: inline-block;">
        <li class="fragment"><strong>q = 1:</strong> Uniform randomness (straight diagonal)</li>
        <li class="fragment"><strong>q &lt; 1:</strong> Path hugs the axes (minimizing area)</li>
        <li class="fragment"><strong>q &gt; 1:</strong> Path bulges out (maximizing area)</li>
    </ul>
</section>

<section class="slide slide-center" id="lesson-2d" data-title="The Lesson">
    <h2 class="slide-title">The Lesson</h2>
    <p class="fragment" style="font-size: 1.5rem; margin-top: 2rem;">"By changing one parameter, we bend the curve."</p>
    <p class="fragment" style="margin-top: 2rem; color: var(--slide-muted);">This foreshadows the limit shapes in 3D...</p>
</section>

<!-- ==================== PART 2: The 3D Main Event ==================== -->

<section class="slide slide-center" id="part2-intro" data-title="Part 2: 3D">
    <h2 style="font-size: clamp(3rem, 5vw, 5.5rem);">Part II</h2>
    <h3 style="font-size: clamp(3rem, 5vw, 5.5rem); color: var(--slide-muted); text-transform: uppercase; letter-spacing: 0.05em;">One dimension up</h3>
</section>

<section class="slide slide-center" id="geometric-bridge" data-title="Geometric Bridge">
    <h2 class="slide-title">Three Views, One Object</h2>
    <ul style="margin-top: 2rem; text-align: left; display: inline-block; font-size: 1.2rem;">
        <li class="fragment">Lozenge Tiling</li>
        <li class="fragment">Stepped Surface</li>
        <li class="fragment">Stack of Cubes in a Corner (Plane Partition)</li>
    </ul>
    <p class="fragment" style="margin-top: 2rem;">[Visual: Show equivalence]</p>
</section>

<section class="slide slide-center" id="hexagon-cube" data-title="Hexagon = Cube">
    <h2 class="slide-title">The Visual Trick</h2>
    <p class="fragment" style="margin-top: 1.5rem;">A single hexagon...</p>
    <p class="fragment">...tiled by 3 rhombi...</p>
    <p class="fragment">...looks exactly like a cube!</p>
    <p class="fragment" style="margin-top: 2rem;">[Image: Hexagon with 3 lozenges = cube]</p>
</section>

<section class="slide slide-center" id="slices" data-title="Slices = Paths">
    <h2 class="slide-title">Connecting to Part 1</h2>
    <p class="fragment" style="margin-top: 1.5rem;">Take a "slice" of the 3D stack...</p>
    <p class="fragment" style="margin-top: 1rem;">It is exactly an up-right path!</p>
    <p class="fragment" style="margin-top: 2rem; font-size: 1.2rem;">The 3D object is just many 2D paths <strong>interlacing</strong>.</p>
</section>

<section class="slide slide-center" id="growth-sim" data-title="Growth Simulation">
    <h2 class="slide-title">The Growth Simulation</h2>
    <p style="margin-top: 1rem;">[Interactive: Start with empty room, pour cubes in, watch them settle]</p>
    <p class="fragment" style="margin-top: 2rem;">Cubes stack randomly...</p>
    <p class="fragment">...but a definite <strong>shape</strong> emerges.</p>
</section>

<section class="slide slide-center" id="arctic-circle" data-title="Arctic Circle">
    <h2 class="slide-title">The Arctic Circle</h2>
    <p style="margin-top: 1rem;">[Simulation: Large hexagon tiling with arctic circle]</p>
    <p class="fragment" style="margin-top: 2rem;">A sharp boundary appears!</p>
</section>

<section class="slide slide-center" id="phase-transition" data-title="Phase Transition">
    <h2 class="slide-title">Phase Transition</h2>
    <ul style="margin-top: 2rem; text-align: left; display: inline-block; font-size: 1.2rem;">
        <li class="fragment"><strong>Frozen Region:</strong> Brickwork pattern (Deterministic) - The solid crystal</li>
        <li class="fragment"><strong>Liquid Region:</strong> Chaotic disorder (Random) - The melted solution</li>
        <li class="fragment"><strong>The Boundary:</strong> An algebraic curve</li>
    </ul>
</section>

<section class="slide slide-center" id="gff" data-title="Gaussian Free Field">
    <h2 class="slide-title">The Gaussian Free Field</h2>
    <p class="fragment" style="margin-top: 1.5rem; font-style: italic;">"If the limit shape is the smooth terrain of a hill,<br>the GFF describes the rough grass and rocks on top."</p>
    <p class="fragment" style="margin-top: 2rem;">[Heatmap: Height fluctuations]</p>
    <p class="fragment" style="margin-top: 1rem; color: var(--slide-muted);">This noise is <strong>universal</strong>.</p>
</section>

<!-- ==================== PART 3: Algorithmic Magic ==================== -->

<section class="slide slide-center" id="part3-intro" data-title="Part 3: Algorithms">
    <h2 style="font-size: clamp(3rem, 5vw, 5.5rem);">Part III</h2>
    <h3 style="font-size: clamp(3rem, 5vw, 5.5rem); color: var(--slide-muted); text-transform: uppercase; letter-spacing: 0.05em;">How to draw pictures</h3>
</section>

<section class="slide slide-center" id="glauber-naive" data-title="Glauber Dynamics">
    <h2 class="slide-title">The "Naive" Approach: Glauber Dynamics</h2>
    <p class="fragment" style="margin-top: 1.5rem;"><strong>Algorithm:</strong></p>
    <ol style="margin-top: 1rem; text-align: left; display: inline-block;">
        <li class="fragment">Pick a random spot</li>
        <li class="fragment">If you can add/remove a cube, do it with probability 1/2</li>
        <li class="fragment">Repeat</li>
    </ol>
    <p class="fragment" style="margin-top: 2rem;">[Simulation: Slow Glauber dynamics]</p>
</section>

<section class="slide slide-center" id="glauber-slow" data-title="Glauber is Slow">
    <h2 class="slide-title">The Problem</h2>
    <p class="fragment" style="font-size: 1.3rem; margin-top: 2rem;">Local updates take forever to mix.</p>
    <p class="fragment" style="margin-top: 1rem; color: var(--slide-muted);">Mixing time is polynomial (or worse).</p>
    <p class="fragment" style="margin-top: 2rem;">[Visual: Surface trying to evolve but getting stuck]</p>
</section>

<section class="slide slide-center" id="smart-approach" data-title="Smart Sampling">
    <h2 class="slide-title">The "Smart" Approach</h2>
    <p class="fragment" style="margin-top: 1.5rem;">CFTP / Domino Shuffling / RSK</p>
    <p class="fragment" style="margin-top: 2rem; font-style: italic;">"Instead of moving one cube at a time, use the deep mathematical structure to sample the entire system at once."</p>
</section>

<section class="slide slide-center" id="instant-sample" data-title="Instant Sampling">
    <h2 class="slide-title">Instant Sampling</h2>
    <div style="display: grid; grid-template-columns: 1fr auto; gap: 4vw; align-items: center; margin-top: 2vh;">
        <div>
            <p>[Button: Generate n=100 sample instantly]</p>
            <p class="fragment" style="margin-top: 2vh;">Contrast: Glauber would take hours.</p>
            <p class="fragment">This takes milliseconds.</p>
        </div>
        <div class="fragment" style="text-align: center;">
            <div id="qr-placeholder" style="width: 18vh; height: 18vh; border: 3px dashed var(--slide-navy); border-radius: 8px; display: flex; align-items: center; justify-content: center; background: rgba(35, 45, 75, 0.05);">
                <span style="font-size: clamp(1rem, 1.4vw, 1.2rem); color: var(--slide-muted);">QR</span>
            </div>
            <p style="font-size: clamp(1rem, 1.6vw, 1.4rem); color: var(--slide-navy); margin-top: 1vh;">Try it yourself!</p>
        </div>
    </div>
</section>

<section class="slide slide-center" id="takeaway" data-title="The Takeaway">
    <h2 class="slide-title">The Takeaway</h2>
    <p class="fragment" style="font-size: 1.8rem; margin-top: 2rem; color: var(--uva-orange);">Good math leads to fast algorithms.</p>
</section>

<!-- ==================== Slide: Thank You ==================== -->
<section class="slide slide-center" id="thankyou" data-title="Thank You">
    <div style="display: flex; flex-direction: column; gap: clamp(1rem, 3vh, 3rem); align-items: center; justify-content: center;">
        <div style="display: flex; gap: clamp(0.5rem, 1.5vw, 1.5rem); justify-content: center;">
            <canvas id="letter-T" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
            <canvas id="letter-H" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
            <canvas id="letter-A" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
            <canvas id="letter-N" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
            <canvas id="letter-K" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
        </div>
        <div style="display: flex; gap: clamp(0.5rem, 1.5vw, 1.5rem); justify-content: center;">
            <canvas id="letter-Y" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
            <canvas id="letter-O" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
            <canvas id="letter-U" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
        </div>
    </div>
</section>

<script>
window.addEventListener('wasm-loaded', async function() {
    // Wait for LozengeModule factory to be available
    if (typeof LozengeModule === 'undefined') {
        console.error('LozengeModule not loaded');
        return;
    }

    // Create isolated WASM instance for Thank You slide - completely separate from Title!
    const wasm = await LozengeModule();

    const letters = ['T', 'H', 'A', 'N', 'K', 'Y', 'O', 'U'];
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) {
        return { x: n, y: slope * n + j * deltaC };
    }

    // WASM interface (using our isolated instance)
    const initFromTrianglesWasm = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const performGlauberStepsWasm = wasm.cwrap('performGlauberSteps', 'number', ['number']);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeStringWasm = wasm.cwrap('freeString', null, ['number']);
    const setUseRandomSweepsWasm = wasm.cwrap('setUseRandomSweeps', null, ['number']);

    // Store state for each letter
    const letterStates = [];

    // Load all letters
    for (const letter of letters) {
        const canvasId = `letter-${letter}`;
        const canvas = document.getElementById(canvasId);
        if (!canvas) continue;

        try {
            const response = await fetch(`/letters/${letter}.json`);
            if (!response.ok) continue;
            const data = await response.json();
            if (!data.triangles) continue;

            const triangles = new Map();
            const triangleArr = [];
            for (const t of data.triangles) {
                const type = t.type || t.t;
                triangles.set(`${t.n},${t.j},${type}`, { n: t.n, j: t.j, type });
                triangleArr.push(t.n, t.j, type);
            }

            // Calculate bounds
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const [, tri] of triangles) {
                let verts;
                if (tri.type === 1) {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
                } else {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j), getVertex(tri.n + 1, tri.j - 1)];
                }
                for (const v of verts) {
                    minX = Math.min(minX, v.x);
                    maxX = Math.max(maxX, v.x);
                    minY = Math.min(minY, v.y);
                    maxY = Math.max(maxY, v.y);
                }
            }

            letterStates.push({
                letter,
                canvas,
                ctx: canvas.getContext('2d'),
                triangles,
                triangleArr,
                dimers: [],
                bounds: { minX, maxX, minY, maxY }
            });
        } catch (e) {
            // Skip failed letters
        }
    }

    // Initialize each letter and get initial dimers
    for (const state of letterStates) {
        const dataPtr = wasm._malloc(state.triangleArr.length * 4);
        for (let i = 0; i < state.triangleArr.length; i++) {
            wasm.setValue(dataPtr + i * 4, state.triangleArr[i], 'i32');
        }
        const ptr = initFromTrianglesWasm(dataPtr, state.triangleArr.length);
        const jsonStr = wasm.UTF8ToString(ptr);
        freeStringWasm(ptr);
        wasm._free(dataPtr);

        const result = JSON.parse(jsonStr);
        if (result.status === 'valid') {
            setUseRandomSweepsWasm(1);
            const dPtr = exportDimersWasm();
            const dimerStr = wasm.UTF8ToString(dPtr);
            freeStringWasm(dPtr);
            const dimerResult = JSON.parse(dimerStr);
            state.dimers = Array.isArray(dimerResult) ? dimerResult : (dimerResult.dimers || []);
        }
    }

    // Draw function for a letter
    function drawLetter(state) {
        const { canvas, ctx, bounds, dimers } = state;
        const { minX, maxX, minY, maxY } = bounds;

        // Use fixed dimensions to prevent zoom issues
        const displayWidth = 100;
        const displayHeight = 130;
        const dpr = window.devicePixelRatio || 1;
        if (canvas.width !== displayWidth * dpr) {
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
        }
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        const regionWidth = maxX - minX;
        const regionHeight = maxY - minY;
        const scale = Math.min(displayWidth / regionWidth, displayHeight / regionHeight) * 0.85;
        const centerX = displayWidth / 2 - ((minX + maxX) / 2) * scale;
        const centerY = displayHeight / 2 + ((minY + maxY) / 2) * scale;

        // Draw lozenges
        for (const d of dimers) {
            const bn = d.bn, bj = d.bj, t = d.t;
            let verts;
            if (t === 0) {
                verts = [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            } else if (t === 1) {
                verts = [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
            } else {
                verts = [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            }

            ctx.beginPath();
            const p0 = [centerX + verts[0].x * scale, centerY - verts[0].y * scale];
            ctx.moveTo(p0[0], p0[1]);
            for (let i = 1; i < 4; i++) {
                const p = [centerX + verts[i].x * scale, centerY - verts[i].y * scale];
                ctx.lineTo(p[0], p[1]);
            }
            ctx.closePath();
            ctx.fillStyle = colors[t];
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }

    // Initial draw
    for (const state of letterStates) {
        drawLetter(state);
    }

    // Animation: cycle through letters, updating one per frame
    // With isolated WASM instance, no need to reinit - just run Glauber on current state!
    let currentLetterIdx = 0;
    let isRunning = false;
    let animationId = null;

    function animate() {
        if (!isRunning) return;

        // Update current letter
        const state = letterStates[currentLetterIdx];
        if (state) {
            // Re-init WASM with this letter's triangles (still needed since we cycle through letters)
            const dataPtr = wasm._malloc(state.triangleArr.length * 4);
            for (let i = 0; i < state.triangleArr.length; i++) {
                wasm.setValue(dataPtr + i * 4, state.triangleArr[i], 'i32');
            }
            const ptr = initFromTrianglesWasm(dataPtr, state.triangleArr.length);
            freeStringWasm(ptr);
            wasm._free(dataPtr);

            setUseRandomSweepsWasm(1);

            // Run Glauber steps
            const stepPtr = performGlauberStepsWasm(50);
            freeStringWasm(stepPtr);

            // Export new dimers
            const dPtr = exportDimersWasm();
            const dimerStr = wasm.UTF8ToString(dPtr);
            freeStringWasm(dPtr);
            const dimerResult = JSON.parse(dimerStr);
            state.dimers = Array.isArray(dimerResult) ? dimerResult : (dimerResult.dimers || []);

            drawLetter(state);
        }

        currentLetterIdx = (currentLetterIdx + 1) % letterStates.length;
        animationId = requestAnimationFrame(animate);
    }

    function start() {
        if (isRunning) return;
        isRunning = true;
        animate();
    }

    function pause() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    // Register with slide engine - auto-start when slide is shown
    // No onSlideEnter/onSlideLeave needed - isolated WASM instance means no state conflicts!
    if (window.slideEngine) {
        window.slideEngine.registerSimulation('thankyou', {
            start,
            pause
        }, 0);
    }
});
</script>

<!-- Global: Escape key blurs input fields for slide navigation -->
<script>
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && document.activeElement &&
        (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) {
        document.activeElement.blur();
    }
});
</script>
