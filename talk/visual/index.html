---
layout: slides
title: "Random Surfaces from Stacking Cubes: A Visual Journey"
description: "Interactive talk on random lozenge tilings and their limit shapes"
---

<!-- ==================== Slide 1: Title ==================== -->
<section class="slide slide-center" id="title" data-title="Title" style="display: flex; flex-direction: column;">
    <h1 style="font-size: clamp(2.5rem, 3.5vw, 4rem); line-height: 1.2;">Random Surfaces from Stacking Cubes:<br><span style="font-style: italic;">A Visual Journey</span></h1>

    <p class="author" style="margin-top: 1vh; font-size: clamp(1.5rem, 2.5vw, 2.2rem);">Leonid Petrov</p>
    <p style="font-size: clamp(1.2rem, 2vw, 1.8rem); color: var(--slide-muted);">University of Virginia</p>

    <div style="flex: 1; display: flex; align-items: center; justify-content: center; min-height: 0;">
        <canvas id="title-canvas" width="1600" height="1200" style="cursor: pointer; height: 55vh; width: auto;"></canvas>
    </div>
</section>

<!-- Load simulation dependencies (colorschemes.js already loaded by slides layout) -->
<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>

<!-- Dynamic WASM loader: use threaded version if SharedArrayBuffer is available -->
<script>
window.VISUAL_THREADED = typeof SharedArrayBuffer !== 'undefined';
window.VISUAL_WEBGPU = !!navigator.gpu;

// Load WASM module dynamically (no document.write)
function loadScript(src) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

const wasmSrc = '/talk/visual/sim/visual-lozenge' + (window.VISUAL_THREADED ? '-threaded' : '') + '.js';
loadScript(wasmSrc).then(() => {
    window.dispatchEvent(new Event('wasm-loaded'));
});
</script>

<script>
window.addEventListener('wasm-loaded', async function() {
    // Wait for LozengeModule factory to be available
    if (typeof LozengeModule === 'undefined') {
        console.error('LozengeModule not loaded');
        return;
    }

    // Create isolated WASM instance for Title slide
    const wasm = await LozengeModule();

    // Triangular lattice constants (for equilateral triangles)
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) {
        return { x: n, y: slope * n + j * deltaC };
    }

    // WASM interface (using our isolated instance)
    const initFromTrianglesWasm = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const performGlauberStepsWasm = wasm.cwrap('performGlauberSteps', 'number', ['number']);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeStringWasm = wasm.cwrap('freeString', null, ['number']);
    const setUseRandomSweepsWasm = wasm.cwrap('setUseRandomSweeps', null, ['number']);

    // Color palette (UVA)
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    // Simulation state
    let activeTriangles = new Map();
    let dimers = [];
    let isValid = false;

    // Load Rotunda preset
    try {
        const response = await fetch('/letters/Rotunda.json');
        if (response.ok) {
            const data = await response.json();
            if (data.triangles) {
                for (const t of data.triangles) {
                    const type = t.type || t.t;
                    activeTriangles.set(`${t.n},${t.j},${type}`, { n: t.n, j: t.j, type });
                }

                // Initialize WASM region
                const arr = [];
                for (const [key, tri] of activeTriangles) {
                    arr.push(tri.n, tri.j, tri.type);
                }

                if (arr.length > 0) {
                    const dataPtr = wasm._malloc(arr.length * 4);
                    for (let i = 0; i < arr.length; i++) {
                        wasm.setValue(dataPtr + i * 4, arr[i], 'i32');
                    }

                    const ptr = initFromTrianglesWasm(dataPtr, arr.length);
                    const jsonStr = wasm.UTF8ToString(ptr);
                    freeStringWasm(ptr);
                    wasm._free(dataPtr);

                    const result = JSON.parse(jsonStr);
                    isValid = result.status === 'valid';

                    if (isValid) {
                        setUseRandomSweepsWasm(1);
                        // Export initial dimers so we can show lozenges on load
                        const dPtr = exportDimersWasm();
                        const jsonStr = wasm.UTF8ToString(dPtr);
                        freeStringWasm(dPtr);
                        const result = JSON.parse(jsonStr);
                        const dimerArr = Array.isArray(result) ? result : (result.dimers || []);
                        dimers.push(...dimerArr);
                    }
                }
            }
        }
    } catch (e) {
        // Failed to load preset
    }

    // High-DPI canvas for crisp rendering (2x resolution for 1920x1080 projector)
    const canvas = document.getElementById('title-canvas');
    const ctx = canvas.getContext('2d');
    const displayWidth = 800, displayHeight = 600;  // 55vh at 1080p ≈ 600px
    const dpr = 2; // 2x for retina/crisp rendering

    // Simulation state
    let isRunning = false;
    let animationId = null;

    // Pre-calculate transform (bounds don't change)
    let scale, centerX, centerY;
    function calcTransform() {
        if (!activeTriangles || activeTriangles.size === 0) return;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const [, tri] of activeTriangles) {
            let verts;
            if (tri.type === 1) {
                verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
            } else {
                verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j), getVertex(tri.n + 1, tri.j - 1)];
            }
            for (const v of verts) {
                minX = Math.min(minX, v.x);
                maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y);
                maxY = Math.max(maxY, v.y);
            }
        }
        const regionWidth = maxX - minX;
        const regionHeight = maxY - minY;
        scale = Math.min(displayWidth / regionWidth, displayHeight / regionHeight) * 0.85;
        centerX = displayWidth / 2 - ((minX + maxX) / 2) * scale;
        centerY = displayHeight / 2 + ((minY + maxY) / 2) * scale;
    }
    calcTransform();

    function draw() {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        if (!activeTriangles || activeTriangles.size === 0) return;

        // Draw lozenges
        if (Array.isArray(dimers) && dimers.length > 0) {
            for (const d of dimers) {
                const bn = d.bn, bj = d.bj, t = d.t;
                let verts;
                if (t === 0) {
                    verts = [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                } else if (t === 1) {
                    verts = [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
                } else {
                    verts = [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                }

                ctx.beginPath();
                ctx.moveTo(centerX + verts[0].x * scale, centerY - verts[0].y * scale);
                for (let i = 1; i < 4; i++) {
                    ctx.lineTo(centerX + verts[i].x * scale, centerY - verts[i].y * scale);
                }
                ctx.closePath();
                ctx.fillStyle = colors[t];
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
        } else {
            // Draw triangles (shape outline)
            for (const [, tri] of activeTriangles) {
                const n = tri.n, j = tri.j, type = tri.type;
                let verts;
                if (type === 1) {
                    verts = [getVertex(n, j), getVertex(n, j - 1), getVertex(n + 1, j - 1)];
                } else {
                    verts = [getVertex(n, j), getVertex(n + 1, j), getVertex(n + 1, j - 1)];
                }

                ctx.beginPath();
                ctx.moveTo(centerX + verts[0].x * scale, centerY - verts[0].y * scale);
                for (let i = 1; i < 3; i++) {
                    ctx.lineTo(centerX + verts[i].x * scale, centerY - verts[i].y * scale);
                }
                ctx.closePath();
                ctx.fillStyle = type === 1 ? '#232D4B' : '#F9DCBF';
                ctx.fill();
            }
        }
    }

    function animate() {
        if (!isValid || !isRunning) return;

        // Run Glauber steps
        const ptr = performGlauberStepsWasm(10000);
        freeStringWasm(ptr);

        // Refresh dimers
        const dPtr = exportDimersWasm();
        const jsonStr = wasm.UTF8ToString(dPtr);
        freeStringWasm(dPtr);
        const result = JSON.parse(jsonStr);
        dimers = Array.isArray(result) ? result : (result.dimers || []);

        draw();
        animationId = requestAnimationFrame(animate);
    }

    function startSim() {
        if (!isRunning) {
            isRunning = true;
            animate();
        }
    }

    function pauseSim() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    // Click to toggle
    canvas.addEventListener('click', () => {
        if (isRunning) pauseSim();
        else startSim();
    });

    // Initial draw
    draw();

    // Register with slide engine for step control
    window.slideEngine.registerSimulation('title', {
        start: startSim,
        pause: pauseSim
    }, 1);
});
</script>

<!-- ==================== PART 0: How Nature Creates Shape ==================== -->

<section class="slide slide-top" id="nature-builds" data-title="How Nature Makes Shape">
    <h2 class="slide-title">How Nature Makes Shape</h2>

    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: clamp(1rem, 3vw, 4rem); margin-top: 2vh; align-items: start;">
        <!-- Left column: Salt crystal images -->
        <div>
            <p style="text-align: center; margin-bottom: 2vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Salt crystals — same substance, different growth regimes and scales</p>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: clamp(0.5rem, 1vw, 1rem);">
                <figure style="margin: 0;">
                    <img src="images/salt-halite-doronenko-cc-by-3.jpg" alt="Hopper salt crystal" style="width: 100%; height: 22vh; object-fit: cover; border-radius: 4px;">
                    <figcaption>Doronenko, CC BY 3.0</figcaption>
                </figure>
                <figure style="margin: 0;">
                    <img src="images/salt-halite-lavinsky-irocks-cc-by-sa-3.jpg" alt="Halite crystal" style="width: 100%; height: 22vh; object-fit: cover; border-radius: 4px;">
                    <figcaption>Rob Lavinsky/iRocks, CC BY-SA 3.0</figcaption>
                </figure>
                <figure style="margin: 0;">
                    <img src="images/salt-smooth-deadsea-xta11-cc-by-sa-4.jpg" alt="Smooth salt formation" style="width: 100%; height: 22vh; object-fit: cover; border-radius: 4px;">
                    <figcaption>xta11, CC BY-SA 4.0</figcaption>
                </figure>
                <figure style="margin: 0;">
                    <img src="images/salt-micro-public-domain.jpg" alt="Salt crystals microscopic" style="width: 100%; height: 22vh; object-fit: cover; border-radius: 4px;">
                    <figcaption>Public domain</figcaption>
                </figure>
            </div>
        </div>

        <!-- Right column: Crystal growth simulation -->
        <div style="text-align: center;">
            <p style="margin-bottom: 2vh; font-size: clamp(1.2rem, 2.2vw, 1.8rem);">Random crystal growth</p>
            <canvas id="crystal-growth-canvas" style="width: 35vh; height: 45vh; border: 2px solid var(--slide-navy); border-radius: 8px; background: #fff;"></canvas>
            <p style="font-size: clamp(1rem, 1.4vw, 1.3rem); color: var(--slide-muted); margin-top: 1vh;">[Simulation placeholder]</p>
        </div>
    </div>

    <p class="fragment" style="font-size: clamp(1.5rem, 2.8vw, 2.2rem); margin-top: 3vh; text-align: center; font-style: italic; color: var(--slide-navy);">Why does a random pile of cubes become smooth?</p>
</section>

<!-- ==================== PART 1: The 2D Warm-Up ==================== -->

<section class="slide slide-center" id="part1-intro" data-title="Part 1: 2D">
    <h2>Part 1</h2>
    <h3 style="color: var(--slide-muted); text-transform: uppercase; letter-spacing: 0.05em;">The 2D Warm-Up</h3>
    <p style="margin-top: 2rem; font-size: 1.2rem;">The Bridge from Counting to Statistical Mechanics</p>
</section>

<section class="slide slide-center" id="grid-paths" data-title="Grid Paths">
    <h2 class="slide-title">Paths on a Grid</h2>
    <p class="fragment" style="margin-top: 1.5rem;">Start at (0, 0), end at (n, n)</p>
    <p class="fragment">Move only right (R) or up (U)</p>
    <p class="fragment" style="margin-top: 1rem; font-size: 1.3rem;">How many paths exist?</p>
    <p class="fragment" style="font-size: 2rem; color: var(--uva-orange); margin-top: 1rem;">
        \(\binom{2n}{n}\)
    </p>
</section>

<section class="slide slide-center" id="count-paths" data-title="Counting Paths">
    <h2 class="slide-title">Small Example: n = 3</h2>
    <p style="margin-top: 1.5rem;">[Interactive: Show all 20 paths for n=3]</p>
    <p class="fragment" style="margin-top: 2rem;">Each path is equally likely under uniform measure.</p>
</section>

<section class="slide slide-center" id="limit-shape-2d" data-title="Limit Shape (2D)">
    <h2 class="slide-title">The Limit Shape</h2>
    <p class="fragment" style="margin-top: 1.5rem;">Scale up to n = 100, 1000, ...</p>
    <p class="fragment" style="margin-top: 1rem;">[Simulation: Random path for large n]</p>
    <p class="fragment" style="font-size: 1.3rem; margin-top: 2rem;">It looks like a straight diagonal line!</p>
    <p class="fragment" style="color: var(--slide-muted);">This is the <strong>Law of Large Numbers</strong>.</p>
</section>

<section class="slide slide-center" id="q-deformation" data-title="q-Deformation">
    <h2 class="slide-title">The q-Deformation</h2>
    <p class="fragment" style="margin-top: 1.5rem;">Imagine the <strong>area under the path</strong> represents "energy" or "cost".</p>
    <p class="fragment" style="margin-top: 1rem;">Weight each path by \(q^{\text{area}}\)</p>
    <p class="fragment" style="margin-top: 2rem; font-size: 1.2rem;">The parameter q acts like inverse temperature.</p>
</section>

<section class="slide slide-center" id="q-slider" data-title="The q-Slider">
    <h2 class="slide-title">Bending the Curve</h2>
    <p style="margin-top: 1rem;">[Interactive: q-slider simulation]</p>
    <ul style="margin-top: 2rem; text-align: left; display: inline-block;">
        <li class="fragment"><strong>q = 1:</strong> Uniform randomness (straight diagonal)</li>
        <li class="fragment"><strong>q &lt; 1:</strong> Path hugs the axes (minimizing area)</li>
        <li class="fragment"><strong>q &gt; 1:</strong> Path bulges out (maximizing area)</li>
    </ul>
</section>

<section class="slide slide-center" id="lesson-2d" data-title="The Lesson">
    <h2 class="slide-title">The Lesson</h2>
    <p class="fragment" style="font-size: 1.5rem; margin-top: 2rem;">"By changing one parameter, we bend the curve."</p>
    <p class="fragment" style="margin-top: 2rem; color: var(--slide-muted);">This foreshadows the limit shapes in 3D...</p>
</section>

<!-- ==================== PART 2: The 3D Main Event ==================== -->

<section class="slide slide-center" id="part2-intro" data-title="Part 2: 3D">
    <h2>Part 2</h2>
    <h3 style="color: var(--slide-muted); text-transform: uppercase; letter-spacing: 0.05em;">The 3D Main Event</h3>
    <p style="margin-top: 2rem; font-size: 1.2rem;">From Discrete Cubes to Algebraic Curves</p>
</section>

<section class="slide slide-center" id="geometric-bridge" data-title="Geometric Bridge">
    <h2 class="slide-title">Three Views, One Object</h2>
    <ul style="margin-top: 2rem; text-align: left; display: inline-block; font-size: 1.2rem;">
        <li class="fragment">Lozenge Tiling</li>
        <li class="fragment">Stepped Surface</li>
        <li class="fragment">Stack of Cubes in a Corner (Plane Partition)</li>
    </ul>
    <p class="fragment" style="margin-top: 2rem;">[Visual: Show equivalence]</p>
</section>

<section class="slide slide-center" id="hexagon-cube" data-title="Hexagon = Cube">
    <h2 class="slide-title">The Visual Trick</h2>
    <p class="fragment" style="margin-top: 1.5rem;">A single hexagon...</p>
    <p class="fragment">...tiled by 3 rhombi...</p>
    <p class="fragment">...looks exactly like a cube!</p>
    <p class="fragment" style="margin-top: 2rem;">[Image: Hexagon with 3 lozenges = cube]</p>
</section>

<section class="slide slide-center" id="slices" data-title="Slices = Paths">
    <h2 class="slide-title">Connecting to Part 1</h2>
    <p class="fragment" style="margin-top: 1.5rem;">Take a "slice" of the 3D stack...</p>
    <p class="fragment" style="margin-top: 1rem;">It is exactly an up-right path!</p>
    <p class="fragment" style="margin-top: 2rem; font-size: 1.2rem;">The 3D object is just many 2D paths <strong>interlacing</strong>.</p>
</section>

<section class="slide slide-center" id="growth-sim" data-title="Growth Simulation">
    <h2 class="slide-title">The Growth Simulation</h2>
    <p style="margin-top: 1rem;">[Interactive: Start with empty room, pour cubes in, watch them settle]</p>
    <p class="fragment" style="margin-top: 2rem;">Cubes stack randomly...</p>
    <p class="fragment">...but a definite <strong>shape</strong> emerges.</p>
</section>

<section class="slide slide-center" id="arctic-circle" data-title="Arctic Circle">
    <h2 class="slide-title">The Arctic Circle</h2>
    <p style="margin-top: 1rem;">[Simulation: Large hexagon tiling with arctic circle]</p>
    <p class="fragment" style="margin-top: 2rem;">A sharp boundary appears!</p>
</section>

<section class="slide slide-center" id="phase-transition" data-title="Phase Transition">
    <h2 class="slide-title">Phase Transition</h2>
    <ul style="margin-top: 2rem; text-align: left; display: inline-block; font-size: 1.2rem;">
        <li class="fragment"><strong>Frozen Region:</strong> Brickwork pattern (Deterministic) - The solid crystal</li>
        <li class="fragment"><strong>Liquid Region:</strong> Chaotic disorder (Random) - The melted solution</li>
        <li class="fragment"><strong>The Boundary:</strong> An algebraic curve</li>
    </ul>
</section>

<section class="slide slide-center" id="gff" data-title="Gaussian Free Field">
    <h2 class="slide-title">The Gaussian Free Field</h2>
    <p class="fragment" style="margin-top: 1.5rem; font-style: italic;">"If the limit shape is the smooth terrain of a hill,<br>the GFF describes the rough grass and rocks on top."</p>
    <p class="fragment" style="margin-top: 2rem;">[Heatmap: Height fluctuations]</p>
    <p class="fragment" style="margin-top: 1rem; color: var(--slide-muted);">This noise is <strong>universal</strong>.</p>
</section>

<!-- ==================== PART 3: Algorithmic Magic ==================== -->

<section class="slide slide-center" id="part3-intro" data-title="Part 3: Algorithms">
    <h2>Part 3</h2>
    <h3 style="color: var(--slide-muted); text-transform: uppercase; letter-spacing: 0.05em;">Algorithmic Magic</h3>
    <p style="margin-top: 2rem; font-size: 1.2rem;">"How do we actually build these?"</p>
</section>

<section class="slide slide-center" id="glauber-naive" data-title="Glauber Dynamics">
    <h2 class="slide-title">The "Naive" Approach: Glauber Dynamics</h2>
    <p class="fragment" style="margin-top: 1.5rem;"><strong>Algorithm:</strong></p>
    <ol style="margin-top: 1rem; text-align: left; display: inline-block;">
        <li class="fragment">Pick a random spot</li>
        <li class="fragment">If you can add/remove a cube, do it with probability 1/2</li>
        <li class="fragment">Repeat</li>
    </ol>
    <p class="fragment" style="margin-top: 2rem;">[Simulation: Slow Glauber dynamics]</p>
</section>

<section class="slide slide-center" id="glauber-slow" data-title="Glauber is Slow">
    <h2 class="slide-title">The Problem</h2>
    <p class="fragment" style="font-size: 1.3rem; margin-top: 2rem;">Local updates take forever to mix.</p>
    <p class="fragment" style="margin-top: 1rem; color: var(--slide-muted);">Mixing time is polynomial (or worse).</p>
    <p class="fragment" style="margin-top: 2rem;">[Visual: Surface trying to evolve but getting stuck]</p>
</section>

<section class="slide slide-center" id="smart-approach" data-title="Smart Sampling">
    <h2 class="slide-title">The "Smart" Approach</h2>
    <p class="fragment" style="margin-top: 1.5rem;">CFTP / Domino Shuffling / RSK</p>
    <p class="fragment" style="margin-top: 2rem; font-style: italic;">"Instead of moving one cube at a time, use the deep mathematical structure to sample the entire system at once."</p>
</section>

<section class="slide slide-center" id="instant-sample" data-title="Instant Sampling">
    <h2 class="slide-title">Instant Sampling</h2>
    <div style="display: grid; grid-template-columns: 1fr auto; gap: 4vw; align-items: center; margin-top: 2vh;">
        <div>
            <p>[Button: Generate n=100 sample instantly]</p>
            <p class="fragment" style="margin-top: 2vh;">Contrast: Glauber would take hours.</p>
            <p class="fragment">This takes milliseconds.</p>
        </div>
        <div class="fragment" style="text-align: center;">
            <div id="qr-placeholder" style="width: 18vh; height: 18vh; border: 3px dashed var(--slide-navy); border-radius: 8px; display: flex; align-items: center; justify-content: center; background: rgba(35, 45, 75, 0.05);">
                <span style="font-size: clamp(1rem, 1.4vw, 1.2rem); color: var(--slide-muted);">QR</span>
            </div>
            <p style="font-size: clamp(1rem, 1.6vw, 1.4rem); color: var(--slide-navy); margin-top: 1vh;">Try it yourself!</p>
        </div>
    </div>
</section>

<section class="slide slide-center" id="takeaway" data-title="The Takeaway">
    <h2 class="slide-title">The Takeaway</h2>
    <p class="fragment" style="font-size: 1.8rem; margin-top: 2rem; color: var(--uva-orange);">Good math leads to fast algorithms.</p>
</section>

<!-- ==================== Slide: Thank You ==================== -->
<section class="slide slide-center" id="thankyou" data-title="Thank You">
    <div style="display: flex; flex-direction: column; gap: clamp(1rem, 3vh, 3rem); align-items: center; justify-content: center;">
        <div style="display: flex; gap: clamp(0.5rem, 1.5vw, 1.5rem); justify-content: center;">
            <canvas id="letter-T" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
            <canvas id="letter-H" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
            <canvas id="letter-A" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
            <canvas id="letter-N" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
            <canvas id="letter-K" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
        </div>
        <div style="display: flex; gap: clamp(0.5rem, 1.5vw, 1.5rem); justify-content: center;">
            <canvas id="letter-Y" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
            <canvas id="letter-O" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
            <canvas id="letter-U" width="100" height="130" style="width: 12vh; height: 15vh;"></canvas>
        </div>
    </div>
</section>

<script>
window.addEventListener('wasm-loaded', async function() {
    // Wait for LozengeModule factory to be available
    if (typeof LozengeModule === 'undefined') {
        console.error('LozengeModule not loaded');
        return;
    }

    // Create isolated WASM instance for Thank You slide - completely separate from Title!
    const wasm = await LozengeModule();

    const letters = ['T', 'H', 'A', 'N', 'K', 'Y', 'O', 'U'];
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) {
        return { x: n, y: slope * n + j * deltaC };
    }

    // WASM interface (using our isolated instance)
    const initFromTrianglesWasm = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const performGlauberStepsWasm = wasm.cwrap('performGlauberSteps', 'number', ['number']);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeStringWasm = wasm.cwrap('freeString', null, ['number']);
    const setUseRandomSweepsWasm = wasm.cwrap('setUseRandomSweeps', null, ['number']);

    // Store state for each letter
    const letterStates = [];

    // Load all letters
    for (const letter of letters) {
        const canvasId = `letter-${letter}`;
        const canvas = document.getElementById(canvasId);
        if (!canvas) continue;

        try {
            const response = await fetch(`/letters/${letter}.json`);
            if (!response.ok) continue;
            const data = await response.json();
            if (!data.triangles) continue;

            const triangles = new Map();
            const triangleArr = [];
            for (const t of data.triangles) {
                const type = t.type || t.t;
                triangles.set(`${t.n},${t.j},${type}`, { n: t.n, j: t.j, type });
                triangleArr.push(t.n, t.j, type);
            }

            // Calculate bounds
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const [, tri] of triangles) {
                let verts;
                if (tri.type === 1) {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
                } else {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j), getVertex(tri.n + 1, tri.j - 1)];
                }
                for (const v of verts) {
                    minX = Math.min(minX, v.x);
                    maxX = Math.max(maxX, v.x);
                    minY = Math.min(minY, v.y);
                    maxY = Math.max(maxY, v.y);
                }
            }

            letterStates.push({
                letter,
                canvas,
                ctx: canvas.getContext('2d'),
                triangles,
                triangleArr,
                dimers: [],
                bounds: { minX, maxX, minY, maxY }
            });
        } catch (e) {
            // Skip failed letters
        }
    }

    // Initialize each letter and get initial dimers
    for (const state of letterStates) {
        const dataPtr = wasm._malloc(state.triangleArr.length * 4);
        for (let i = 0; i < state.triangleArr.length; i++) {
            wasm.setValue(dataPtr + i * 4, state.triangleArr[i], 'i32');
        }
        const ptr = initFromTrianglesWasm(dataPtr, state.triangleArr.length);
        const jsonStr = wasm.UTF8ToString(ptr);
        freeStringWasm(ptr);
        wasm._free(dataPtr);

        const result = JSON.parse(jsonStr);
        if (result.status === 'valid') {
            setUseRandomSweepsWasm(1);
            const dPtr = exportDimersWasm();
            const dimerStr = wasm.UTF8ToString(dPtr);
            freeStringWasm(dPtr);
            const dimerResult = JSON.parse(dimerStr);
            state.dimers = Array.isArray(dimerResult) ? dimerResult : (dimerResult.dimers || []);
        }
    }

    // Draw function for a letter
    function drawLetter(state) {
        const { canvas, ctx, bounds, dimers } = state;
        const { minX, maxX, minY, maxY } = bounds;

        // Use fixed dimensions to prevent zoom issues
        const displayWidth = 100;
        const displayHeight = 130;
        const dpr = window.devicePixelRatio || 1;
        if (canvas.width !== displayWidth * dpr) {
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
        }
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        const regionWidth = maxX - minX;
        const regionHeight = maxY - minY;
        const scale = Math.min(displayWidth / regionWidth, displayHeight / regionHeight) * 0.85;
        const centerX = displayWidth / 2 - ((minX + maxX) / 2) * scale;
        const centerY = displayHeight / 2 + ((minY + maxY) / 2) * scale;

        // Draw lozenges
        for (const d of dimers) {
            const bn = d.bn, bj = d.bj, t = d.t;
            let verts;
            if (t === 0) {
                verts = [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            } else if (t === 1) {
                verts = [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
            } else {
                verts = [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            }

            ctx.beginPath();
            const p0 = [centerX + verts[0].x * scale, centerY - verts[0].y * scale];
            ctx.moveTo(p0[0], p0[1]);
            for (let i = 1; i < 4; i++) {
                const p = [centerX + verts[i].x * scale, centerY - verts[i].y * scale];
                ctx.lineTo(p[0], p[1]);
            }
            ctx.closePath();
            ctx.fillStyle = colors[t];
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }

    // Initial draw
    for (const state of letterStates) {
        drawLetter(state);
    }

    // Animation: cycle through letters, updating one per frame
    // With isolated WASM instance, no need to reinit - just run Glauber on current state!
    let currentLetterIdx = 0;
    let isRunning = false;
    let animationId = null;

    function animate() {
        if (!isRunning) return;

        // Update current letter
        const state = letterStates[currentLetterIdx];
        if (state) {
            // Re-init WASM with this letter's triangles (still needed since we cycle through letters)
            const dataPtr = wasm._malloc(state.triangleArr.length * 4);
            for (let i = 0; i < state.triangleArr.length; i++) {
                wasm.setValue(dataPtr + i * 4, state.triangleArr[i], 'i32');
            }
            const ptr = initFromTrianglesWasm(dataPtr, state.triangleArr.length);
            freeStringWasm(ptr);
            wasm._free(dataPtr);

            setUseRandomSweepsWasm(1);

            // Run Glauber steps
            const stepPtr = performGlauberStepsWasm(50);
            freeStringWasm(stepPtr);

            // Export new dimers
            const dPtr = exportDimersWasm();
            const dimerStr = wasm.UTF8ToString(dPtr);
            freeStringWasm(dPtr);
            const dimerResult = JSON.parse(dimerStr);
            state.dimers = Array.isArray(dimerResult) ? dimerResult : (dimerResult.dimers || []);

            drawLetter(state);
        }

        currentLetterIdx = (currentLetterIdx + 1) % letterStates.length;
        animationId = requestAnimationFrame(animate);
    }

    function start() {
        if (isRunning) return;
        isRunning = true;
        animate();
    }

    function pause() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    // Register with slide engine - auto-start when slide is shown
    // No onSlideEnter/onSlideLeave needed - isolated WASM instance means no state conflicts!
    if (window.slideEngine) {
        window.slideEngine.registerSimulation('thankyou', {
            start,
            pause
        }, 0);
    }
});
</script>
