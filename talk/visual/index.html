---
layout: slides
title: "Random Surfaces from Stacking Cubes: A Visual Journey"
description: "Interactive talk on random lozenge tilings and their limit shapes"
---

<!-- ==================== Slide 1: Title ==================== -->
<section class="slide slide-center" id="title" data-title="Title">
    <h1 style="font-size: 2.2rem; line-height: 1.2;">Random Surfaces from Stacking Cubes:<br><span style="font-style: italic;">A Visual Journey</span></h1>

    <p class="author" style="margin-top: 1.5rem; font-size: 1.3rem;">Leonid Petrov</p>
    <p style="font-size: 1.1rem; color: var(--slide-muted);">University of Virginia</p>

    <div style="margin-top: 1.5rem;">
        <canvas id="title-canvas" width="500" height="380" style="cursor: pointer; max-width: 100%;"></canvas>
    </div>
</section>

<!-- Load simulation dependencies (colorschemes.js already loaded by slides layout) -->
<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>

<!-- Dynamic WASM loader: use threaded version if SharedArrayBuffer is available -->
<script>
window.VISUAL_THREADED = typeof SharedArrayBuffer !== 'undefined';
window.VISUAL_WEBGPU = !!navigator.gpu;
</script>
<script>
// Load appropriate WASM module from local sim folder (now modularized - exports LozengeModule factory)
document.write('<script src="/talk/visual/sim/visual-lozenge' + (window.VISUAL_THREADED ? '-threaded' : '') + '.js"><\/script>');
</script>

<script>
document.addEventListener('DOMContentLoaded', async function() {
    // Wait for LozengeModule factory to be available
    if (typeof LozengeModule === 'undefined') {
        console.error('LozengeModule not loaded');
        return;
    }

    // Create isolated WASM instance for Title slide
    const wasm = await LozengeModule();

    // Triangular lattice constants (for equilateral triangles)
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) {
        return { x: n, y: slope * n + j * deltaC };
    }

    // WASM interface (using our isolated instance)
    const initFromTrianglesWasm = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const performGlauberStepsWasm = wasm.cwrap('performGlauberSteps', 'number', ['number']);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeStringWasm = wasm.cwrap('freeString', null, ['number']);
    const setUseRandomSweepsWasm = wasm.cwrap('setUseRandomSweeps', null, ['number']);

    // Color palette (UVA)
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    // Simulation state
    let activeTriangles = new Map();
    let dimers = [];
    let isValid = false;

    // Load Rotunda preset
    try {
        const response = await fetch('/letters/Rotunda.json');
        if (response.ok) {
            const data = await response.json();
            if (data.triangles) {
                for (const t of data.triangles) {
                    const type = t.type || t.t;
                    activeTriangles.set(`${t.n},${t.j},${type}`, { n: t.n, j: t.j, type });
                }

                // Initialize WASM region
                const arr = [];
                for (const [key, tri] of activeTriangles) {
                    arr.push(tri.n, tri.j, tri.type);
                }

                if (arr.length > 0) {
                    const dataPtr = wasm._malloc(arr.length * 4);
                    for (let i = 0; i < arr.length; i++) {
                        wasm.setValue(dataPtr + i * 4, arr[i], 'i32');
                    }

                    const ptr = initFromTrianglesWasm(dataPtr, arr.length);
                    const jsonStr = wasm.UTF8ToString(ptr);
                    freeStringWasm(ptr);
                    wasm._free(dataPtr);

                    const result = JSON.parse(jsonStr);
                    isValid = result.status === 'valid';

                    if (isValid) {
                        setUseRandomSweepsWasm(1);
                        // Export initial dimers so we can show lozenges on load
                        const dPtr = exportDimersWasm();
                        const jsonStr = wasm.UTF8ToString(dPtr);
                        freeStringWasm(dPtr);
                        const result = JSON.parse(jsonStr);
                        const dimerArr = Array.isArray(result) ? result : (result.dimers || []);
                        dimers.push(...dimerArr);
                    }
                }
            }
        }
    } catch (e) {
        // Failed to load preset
    }

    // Create simulation using SlideSimulation helper (data already loaded)
    // No more reinit needed - this slide has its own isolated WASM instance!
    const sim = SlideSimulation.create({
        canvasId: 'title-canvas',
        slideId: 'title',
        steps: 1,

        // Store state on sim object
        activeTriangles: activeTriangles,
        dimers: dimers,
        isValid: isValid,
        stepsPerFrame: 10000,
        colors: colors,

        init(ctx, canvas) {
            // Data already loaded and stored above
        },

        update(dt) {
            if (!this.isValid || !this.isRunning) return;
            // Run Glauber steps
            const ptr = performGlauberStepsWasm(this.stepsPerFrame);
            freeStringWasm(ptr);
            // Refresh dimers
            const dPtr = exportDimersWasm();
            const jsonStr = wasm.UTF8ToString(dPtr);
            freeStringWasm(dPtr);
            const result = JSON.parse(jsonStr);
            this.dimers = Array.isArray(result) ? result : (result.dimers || []);
        },

        onStep(step) {
            // Step 1: start the simulation
            if (step === 1) {
                this.start();
            }
        },

        onStepBack(step) {
            // Back to step 0: just pause
            if (step === 0) {
                this.pause();
            }
        },

        draw(ctx, canvas) {
                // Use fixed display size to prevent layout changes
                const displayWidth = 500;
                const displayHeight = 380;

                const dpr = window.devicePixelRatio || 1;
                if (canvas.width !== displayWidth * dpr) {
                    canvas.width = displayWidth * dpr;
                    canvas.height = displayHeight * dpr;
                }
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, displayWidth, displayHeight);

                if (!this.activeTriangles || this.activeTriangles.size === 0) {
                    return;
                }

                const width = displayWidth;
                const height = displayHeight;
                const colors = this.colors;

                // Calculate bounds from all triangle vertices
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                for (const [, tri] of this.activeTriangles) {
                    let verts;
                    if (tri.type === 1) {
                        verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
                    } else {
                        verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j), getVertex(tri.n + 1, tri.j - 1)];
                    }
                    for (const v of verts) {
                        minX = Math.min(minX, v.x);
                        maxX = Math.max(maxX, v.x);
                        minY = Math.min(minY, v.y);
                        maxY = Math.max(maxY, v.y);
                    }
                }

                const regionWidth = maxX - minX;
                const regionHeight = maxY - minY;
                const scale = Math.min(width / regionWidth, height / regionHeight) * 0.85;
                const centerX = width / 2 - ((minX + maxX) / 2) * scale;
                const centerY = height / 2 + ((minY + maxY) / 2) * scale;

                // If simulation running, draw lozenges; otherwise draw shape
                if (Array.isArray(this.dimers) && this.dimers.length > 0 && !this.showShape) {
                    // Draw lozenges
                    for (const d of this.dimers) {
                        const bn = d.bn, bj = d.bj, t = d.t;
                        let verts;
                        if (t === 0) {
                            verts = [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                        } else if (t === 1) {
                            verts = [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
                        } else {
                            verts = [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                        }

                        ctx.beginPath();
                        const p0 = [centerX + verts[0].x * scale, centerY - verts[0].y * scale];
                        ctx.moveTo(p0[0], p0[1]);
                        for (let i = 1; i < 4; i++) {
                            const p = [centerX + verts[i].x * scale, centerY - verts[i].y * scale];
                            ctx.lineTo(p[0], p[1]);
                        }
                        ctx.closePath();
                        ctx.fillStyle = colors[t];
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                } else {
                    // Draw triangles (shape)
                    for (const [, tri] of this.activeTriangles) {
                        const n = tri.n, j = tri.j, type = tri.type;
                        let verts;
                        if (type === 1) {
                            verts = [getVertex(n, j), getVertex(n, j - 1), getVertex(n + 1, j - 1)];
                        } else {
                            verts = [getVertex(n, j), getVertex(n + 1, j), getVertex(n + 1, j - 1)];
                        }

                        ctx.beginPath();
                        const p0 = [centerX + verts[0].x * scale, centerY - verts[0].y * scale];
                        ctx.moveTo(p0[0], p0[1]);
                        for (let i = 1; i < 3; i++) {
                            const p = [centerX + verts[i].x * scale, centerY - verts[i].y * scale];
                            ctx.lineTo(p[0], p[1]);
                        }
                        ctx.closePath();
                        ctx.fillStyle = type === 1 ? '#232D4B' : '#F9DCBF';
                        ctx.fill();
                    }
                }
            },

        });
});
</script>

<!-- ==================== Slide: Thank You ==================== -->
<section class="slide slide-center" id="thankyou" data-title="Thank You">
    <div style="display: flex; flex-direction: column; gap: 24px; align-items: center; justify-content: center;">
        <div style="display: flex; gap: 12px; justify-content: center;">
            <canvas id="letter-T" width="100" height="130"></canvas>
            <canvas id="letter-H" width="100" height="130"></canvas>
            <canvas id="letter-A" width="100" height="130"></canvas>
            <canvas id="letter-N" width="100" height="130"></canvas>
            <canvas id="letter-K" width="100" height="130"></canvas>
        </div>
        <div style="display: flex; gap: 12px; justify-content: center;">
            <canvas id="letter-Y" width="100" height="130"></canvas>
            <canvas id="letter-O" width="100" height="130"></canvas>
            <canvas id="letter-U" width="100" height="130"></canvas>
        </div>
    </div>
</section>

<script>
document.addEventListener('DOMContentLoaded', async function() {
    // Wait for LozengeModule factory to be available
    if (typeof LozengeModule === 'undefined') {
        console.error('LozengeModule not loaded');
        return;
    }

    // Create isolated WASM instance for Thank You slide - completely separate from Title!
    const wasm = await LozengeModule();

    const letters = ['T', 'H', 'A', 'N', 'K', 'Y', 'O', 'U'];
    const colors = ['#E57200', '#232D4B', '#F9DCBF'];

    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) {
        return { x: n, y: slope * n + j * deltaC };
    }

    // WASM interface (using our isolated instance)
    const initFromTrianglesWasm = wasm.cwrap('initFromTriangles', 'number', ['number', 'number']);
    const performGlauberStepsWasm = wasm.cwrap('performGlauberSteps', 'number', ['number']);
    const exportDimersWasm = wasm.cwrap('exportDimers', 'number', []);
    const freeStringWasm = wasm.cwrap('freeString', null, ['number']);
    const setUseRandomSweepsWasm = wasm.cwrap('setUseRandomSweeps', null, ['number']);

    // Store state for each letter
    const letterStates = [];

    // Load all letters
    for (const letter of letters) {
        const canvasId = `letter-${letter}`;
        const canvas = document.getElementById(canvasId);
        if (!canvas) continue;

        try {
            const response = await fetch(`/letters/${letter}.json`);
            if (!response.ok) continue;
            const data = await response.json();
            if (!data.triangles) continue;

            const triangles = new Map();
            const triangleArr = [];
            for (const t of data.triangles) {
                const type = t.type || t.t;
                triangles.set(`${t.n},${t.j},${type}`, { n: t.n, j: t.j, type });
                triangleArr.push(t.n, t.j, type);
            }

            // Calculate bounds
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const [, tri] of triangles) {
                let verts;
                if (tri.type === 1) {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
                } else {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j), getVertex(tri.n + 1, tri.j - 1)];
                }
                for (const v of verts) {
                    minX = Math.min(minX, v.x);
                    maxX = Math.max(maxX, v.x);
                    minY = Math.min(minY, v.y);
                    maxY = Math.max(maxY, v.y);
                }
            }

            letterStates.push({
                letter,
                canvas,
                ctx: canvas.getContext('2d'),
                triangles,
                triangleArr,
                dimers: [],
                bounds: { minX, maxX, minY, maxY }
            });
        } catch (e) {
            // Skip failed letters
        }
    }

    // Initialize each letter and get initial dimers
    for (const state of letterStates) {
        const dataPtr = wasm._malloc(state.triangleArr.length * 4);
        for (let i = 0; i < state.triangleArr.length; i++) {
            wasm.setValue(dataPtr + i * 4, state.triangleArr[i], 'i32');
        }
        const ptr = initFromTrianglesWasm(dataPtr, state.triangleArr.length);
        const jsonStr = wasm.UTF8ToString(ptr);
        freeStringWasm(ptr);
        wasm._free(dataPtr);

        const result = JSON.parse(jsonStr);
        if (result.status === 'valid') {
            setUseRandomSweepsWasm(1);
            const dPtr = exportDimersWasm();
            const dimerStr = wasm.UTF8ToString(dPtr);
            freeStringWasm(dPtr);
            const dimerResult = JSON.parse(dimerStr);
            state.dimers = Array.isArray(dimerResult) ? dimerResult : (dimerResult.dimers || []);
        }
    }

    // Draw function for a letter
    function drawLetter(state) {
        const { canvas, ctx, bounds, dimers } = state;
        const { minX, maxX, minY, maxY } = bounds;

        // Use fixed dimensions to prevent zoom issues
        const displayWidth = 100;
        const displayHeight = 130;
        const dpr = window.devicePixelRatio || 1;
        if (canvas.width !== displayWidth * dpr) {
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
        }
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        const regionWidth = maxX - minX;
        const regionHeight = maxY - minY;
        const scale = Math.min(displayWidth / regionWidth, displayHeight / regionHeight) * 0.85;
        const centerX = displayWidth / 2 - ((minX + maxX) / 2) * scale;
        const centerY = displayHeight / 2 + ((minY + maxY) / 2) * scale;

        // Draw lozenges
        for (const d of dimers) {
            const bn = d.bn, bj = d.bj, t = d.t;
            let verts;
            if (t === 0) {
                verts = [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            } else if (t === 1) {
                verts = [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
            } else {
                verts = [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            }

            ctx.beginPath();
            const p0 = [centerX + verts[0].x * scale, centerY - verts[0].y * scale];
            ctx.moveTo(p0[0], p0[1]);
            for (let i = 1; i < 4; i++) {
                const p = [centerX + verts[i].x * scale, centerY - verts[i].y * scale];
                ctx.lineTo(p[0], p[1]);
            }
            ctx.closePath();
            ctx.fillStyle = colors[t];
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }

    // Initial draw
    for (const state of letterStates) {
        drawLetter(state);
    }

    // Animation: cycle through letters, updating one per frame
    // With isolated WASM instance, no need to reinit - just run Glauber on current state!
    let currentLetterIdx = 0;
    let isRunning = false;
    let animationId = null;

    function animate() {
        if (!isRunning) return;

        // Update current letter
        const state = letterStates[currentLetterIdx];
        if (state) {
            // Re-init WASM with this letter's triangles (still needed since we cycle through letters)
            const dataPtr = wasm._malloc(state.triangleArr.length * 4);
            for (let i = 0; i < state.triangleArr.length; i++) {
                wasm.setValue(dataPtr + i * 4, state.triangleArr[i], 'i32');
            }
            const ptr = initFromTrianglesWasm(dataPtr, state.triangleArr.length);
            freeStringWasm(ptr);
            wasm._free(dataPtr);

            setUseRandomSweepsWasm(1);

            // Run Glauber steps
            const stepPtr = performGlauberStepsWasm(50);
            freeStringWasm(stepPtr);

            // Export new dimers
            const dPtr = exportDimersWasm();
            const dimerStr = wasm.UTF8ToString(dPtr);
            freeStringWasm(dPtr);
            const dimerResult = JSON.parse(dimerStr);
            state.dimers = Array.isArray(dimerResult) ? dimerResult : (dimerResult.dimers || []);

            drawLetter(state);
        }

        currentLetterIdx = (currentLetterIdx + 1) % letterStates.length;
        animationId = requestAnimationFrame(animate);
    }

    function start() {
        if (isRunning) return;
        isRunning = true;
        animate();
    }

    function pause() {
        isRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    // Register with slide engine - auto-start when slide is shown
    // No onSlideEnter/onSlideLeave needed - isolated WASM instance means no state conflicts!
    if (window.slideEngine) {
        window.slideEngine.registerSimulation('thankyou', {
            start,
            pause
        }, 0);
    }
});
</script>
