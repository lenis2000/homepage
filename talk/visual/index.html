---
layout: slides
title: "Random Surfaces from Stacking Cubes: A Visual Journey"
description: "Interactive talk on random lozenge tilings and their limit shapes"
---

<!-- ==================== Slide 1: Title ==================== -->
<section class="slide slide-center" id="title" data-title="Title">
    <h1 style="font-size: 2.2rem; line-height: 1.2;">Random Surfaces from Stacking Cubes:<br><span style="font-style: italic;">A Visual Journey</span></h1>

    <p class="author" style="margin-top: 1.5rem; font-size: 1.3rem;">Leonid Petrov</p>
    <p style="font-size: 1.1rem; color: var(--slide-muted);">University of Virginia</p>

    <div style="margin-top: 1.5rem;">
        <canvas id="title-canvas" width="500" height="380" style="cursor: pointer; max-width: 100%;"></canvas>
    </div>
</section>

<!-- Load simulation dependencies (colorschemes.js already loaded by slides layout) -->
<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>

<!-- Dynamic WASM loader: use threaded version if SharedArrayBuffer is available -->
<script>
window.VISUAL_THREADED = typeof SharedArrayBuffer !== 'undefined';
window.VISUAL_WEBGPU = !!navigator.gpu;
</script>
<script>
// Load appropriate WASM module from local sim folder
document.write('<script src="/talk/visual/sim/visual-lozenge' + (window.VISUAL_THREADED ? '-threaded' : '') + '.js"><\/script>');
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Wait for WASM Module to be ready
    if (typeof Module === 'undefined') {
        console.error('WASM Module not loaded');
        return;
    }

    Module.onRuntimeInitialized = Module.onRuntimeInitialized || function() {};
    const originalOnInit = Module.onRuntimeInitialized;
    Module.onRuntimeInitialized = function() {
        originalOnInit();
        initTitleSimulation();
    };

    // If already initialized
    if (Module.calledRun) {
        initTitleSimulation();
    }

    async function initTitleSimulation() {
        // Triangular lattice constants (for equilateral triangles)
        const slope = 1 / Math.sqrt(3);
        const deltaC = 2 / Math.sqrt(3);

        function getVertex(n, j) {
            return { x: n, y: slope * n + j * deltaC };
        }

        // WASM interface
        const initFromTrianglesWasm = Module.cwrap('initFromTriangles', 'number', ['number', 'number']);
        const performGlauberStepsWasm = Module.cwrap('performGlauberSteps', 'number', ['number']);
        const exportDimersWasm = Module.cwrap('exportDimers', 'number', []);
        const freeStringWasm = Module.cwrap('freeString', null, ['number']);
        const setUseRandomSweepsWasm = Module.cwrap('setUseRandomSweeps', null, ['number']);

        // Color palette (UVA)
        const colors = ['#E57200', '#232D4B', '#F9DCBF'];

        // Simulation state
        let activeTriangles = new Map();
        let dimers = [];
        let isValid = false;
        let showShape = true; // Start by showing shape only
        let stepsPerFrame = 1000;

        // Load Rotunda preset FIRST (before creating simulation)
        try {
            const response = await fetch('/letters/Rotunda.json');
            if (response.ok) {
                const data = await response.json();
                if (data.triangles) {
                    for (const t of data.triangles) {
                        const type = t.type || t.t;
                        activeTriangles.set(`${t.n},${t.j},${type}`, { n: t.n, j: t.j, type });
                    }

                    // Initialize WASM region
                    const arr = [];
                    for (const [key, tri] of activeTriangles) {
                        arr.push(tri.n, tri.j, tri.type);
                    }

                    if (arr.length > 0) {
                        const dataPtr = Module._malloc(arr.length * 4);
                        for (let i = 0; i < arr.length; i++) {
                            Module.setValue(dataPtr + i * 4, arr[i], 'i32');
                        }

                        const ptr = initFromTrianglesWasm(dataPtr, arr.length);
                        const jsonStr = Module.UTF8ToString(ptr);
                        freeStringWasm(ptr);
                        Module._free(dataPtr);

                        const result = JSON.parse(jsonStr);
                        isValid = result.status === 'valid';

                        if (isValid) {
                            setUseRandomSweepsWasm(1);
                            // Export initial dimers so we can show lozenges on load
                            const dPtr = exportDimersWasm();
                            const jsonStr = Module.UTF8ToString(dPtr);
                            freeStringWasm(dPtr);
                            const result = JSON.parse(jsonStr);
                            const dimerArr = Array.isArray(result) ? result : (result.dimers || []);
                            dimers.push(...dimerArr);
                        }
                    }
                }
            }
        } catch (e) {
            // Failed to load preset
        }

        // Create simulation using SlideSimulation helper (data already loaded)
        const sim = SlideSimulation.create({
            canvasId: 'title-canvas',
            slideId: 'title',
            step: 1, // Start on first arrow press

            // Store state on sim object
            activeTriangles: activeTriangles,
            dimers: dimers,
            isValid: isValid,
            showShape: false,
            stepsPerFrame: 5000,
            colors: colors,

            init(ctx, canvas) {
                // Data already loaded and stored above
            },

            update(dt) {
                if (!this.isValid) return;
                // Run Glauber steps
                const ptr = performGlauberStepsWasm(this.stepsPerFrame);
                freeStringWasm(ptr);
                // Refresh dimers
                const dPtr = exportDimersWasm();
                const jsonStr = Module.UTF8ToString(dPtr);
                freeStringWasm(dPtr);
                const result = JSON.parse(jsonStr);
                this.dimers = Array.isArray(result) ? result : (result.dimers || []);
            },

            draw(ctx, canvas) {
                const displayWidth = canvas.clientWidth || 500;
                const displayHeight = canvas.clientHeight || 380;

                const dpr = window.devicePixelRatio || 1;
                canvas.width = displayWidth * dpr;
                canvas.height = displayHeight * dpr;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, displayWidth, displayHeight);

                if (!this.activeTriangles || this.activeTriangles.size === 0) {
                    return;
                }

                const width = displayWidth;
                const height = displayHeight;
                const colors = this.colors;

                // Calculate bounds from all triangle vertices
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                for (const [, tri] of this.activeTriangles) {
                    let verts;
                    if (tri.type === 1) {
                        verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
                    } else {
                        verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j), getVertex(tri.n + 1, tri.j - 1)];
                    }
                    for (const v of verts) {
                        minX = Math.min(minX, v.x);
                        maxX = Math.max(maxX, v.x);
                        minY = Math.min(minY, v.y);
                        maxY = Math.max(maxY, v.y);
                    }
                }

                const regionWidth = maxX - minX;
                const regionHeight = maxY - minY;
                const scale = Math.min(width / regionWidth, height / regionHeight) * 0.85;
                const centerX = width / 2 - ((minX + maxX) / 2) * scale;
                const centerY = height / 2 + ((minY + maxY) / 2) * scale;

                // If simulation running, draw lozenges; otherwise draw shape
                if (Array.isArray(this.dimers) && this.dimers.length > 0 && !this.showShape) {
                    // Draw lozenges
                    for (const d of this.dimers) {
                        const bn = d.bn, bj = d.bj, t = d.t;
                        let verts;
                        if (t === 0) {
                            verts = [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                        } else if (t === 1) {
                            verts = [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
                        } else {
                            verts = [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                        }

                        ctx.beginPath();
                        const p0 = [centerX + verts[0].x * scale, centerY - verts[0].y * scale];
                        ctx.moveTo(p0[0], p0[1]);
                        for (let i = 1; i < 4; i++) {
                            const p = [centerX + verts[i].x * scale, centerY - verts[i].y * scale];
                            ctx.lineTo(p[0], p[1]);
                        }
                        ctx.closePath();
                        ctx.fillStyle = colors[t];
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                } else {
                    // Draw triangles (shape)
                    for (const [, tri] of this.activeTriangles) {
                        const n = tri.n, j = tri.j, type = tri.type;
                        let verts;
                        if (type === 1) {
                            verts = [getVertex(n, j), getVertex(n, j - 1), getVertex(n + 1, j - 1)];
                        } else {
                            verts = [getVertex(n, j), getVertex(n + 1, j), getVertex(n + 1, j - 1)];
                        }

                        ctx.beginPath();
                        const p0 = [centerX + verts[0].x * scale, centerY - verts[0].y * scale];
                        ctx.moveTo(p0[0], p0[1]);
                        for (let i = 1; i < 3; i++) {
                            const p = [centerX + verts[i].x * scale, centerY - verts[i].y * scale];
                            ctx.lineTo(p[0], p[1]);
                        }
                        ctx.closePath();
                        ctx.fillStyle = type === 1 ? '#232D4B' : '#F9DCBF';
                        ctx.fill();
                    }
                }
            },

            onStart() {
                // Dimers already loaded, just ensure we're showing lozenges
                this.showShape = false;
            },

            onPause() {
                // Keep showing lozenges when paused
            }
        });
    }
});
</script>
