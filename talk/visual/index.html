---
layout: slides
title: "Random Surfaces from Stacking Cubes: A Visual Journey"
description: "Interactive talk on random lozenge tilings and their limit shapes"
---

<!-- ==================== Slide 1: Title ==================== -->
<section class="slide slide-center" id="title" data-title="Title">
    <h1 style="font-size: 2.2rem; line-height: 1.2;">Random Surfaces from Stacking Cubes:<br><span style="font-style: italic;">A Visual Journey</span></h1>

    <p class="author" style="margin-top: 1.5rem; font-size: 1.3rem;">Leonid Petrov</p>
    <p style="font-size: 1.1rem; color: var(--slide-muted);">University of Virginia</p>

    <div style="margin-top: 1.5rem;">
        <canvas id="title-canvas" width="500" height="380" style="cursor: pointer; max-width: 100%;"></canvas>
    </div>
</section>

<!-- Load simulation dependencies (colorschemes.js already loaded by slides layout) -->
<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>

<!-- Dynamic WASM loader: use threaded version if SharedArrayBuffer is available -->
<script>
window.VISUAL_THREADED = typeof SharedArrayBuffer !== 'undefined';
window.VISUAL_WEBGPU = !!navigator.gpu;
</script>
<script>
// Load appropriate WASM module from local sim folder
document.write('<script src="/talk/visual/sim/visual-lozenge' + (window.VISUAL_THREADED ? '-threaded' : '') + '.js"><\/script>');
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Wait for WASM Module to be ready
    if (typeof Module === 'undefined') {
        console.error('WASM Module not loaded');
        return;
    }

    Module.onRuntimeInitialized = Module.onRuntimeInitialized || function() {};
    const originalOnInit = Module.onRuntimeInitialized;
    Module.onRuntimeInitialized = function() {
        originalOnInit();
        initTitleSimulation();
    };

    // If already initialized
    if (Module.calledRun) {
        initTitleSimulation();
    }

    function initTitleSimulation() {
        const canvas = document.getElementById('title-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        // Triangular lattice constants (for equilateral triangles)
        const slope = 1 / Math.sqrt(3);
        const deltaC = 2 / Math.sqrt(3);

        function getVertex(n, j) {
            return { x: n, y: slope * n + j * deltaC };
        }

        // WASM interface
        const initFromTrianglesWasm = Module.cwrap('initFromTriangles', 'number', ['number', 'number']);
        const runCFTPWasm = Module.cwrap('runCFTP', 'number', []);
        const exportDimersWasm = Module.cwrap('exportDimers', 'number', []);
        const freeStringWasm = Module.cwrap('freeString', null, ['number']);

        let activeTriangles = new Map();
        let dimers = [];
        let isValid = false;
        let isRunningCFTP = false;

        // Color palette (UVA)
        const colors = ['#E57200', '#232D4B', '#F9DCBF'];

        // Load Rotunda preset
        async function loadRotunda() {
            try {
                const response = await fetch('/letters/Rotunda.json');
                if (!response.ok) return;
                const data = await response.json();
                if (!data.triangles) return;

                activeTriangles = new Map();
                for (const t of data.triangles) {
                    const type = t.type || t.t;
                    activeTriangles.set(`${t.n},${t.j},${type}`, { n: t.n, j: t.j, type });
                }
                // Draw shape first (before WASM processes)
                draw();
                // Then initialize WASM
                initFromTriangles();
            } catch (e) {
                console.error('Failed to load Rotunda:', e);
            }
        }

        function initFromTriangles() {
            const arr = [];
            for (const [key, tri] of activeTriangles) {
                arr.push(tri.n, tri.j, tri.type);
            }
            if (arr.length === 0) return;

            const dataPtr = Module._malloc(arr.length * 4);
            for (let i = 0; i < arr.length; i++) {
                Module.setValue(dataPtr + i * 4, arr[i], 'i32');
            }

            const ptr = initFromTrianglesWasm(dataPtr, arr.length);
            const jsonStr = Module.UTF8ToString(ptr);
            freeStringWasm(ptr);
            Module._free(dataPtr);

            const result = JSON.parse(jsonStr);
            isValid = result.status === 'valid';
            if (isValid) {
                refreshDimers();
                draw();
            }
        }

        function refreshDimers() {
            const ptr = exportDimersWasm();
            const jsonStr = Module.UTF8ToString(ptr);
            freeStringWasm(ptr);
            const result = JSON.parse(jsonStr);
            // Handle both array and object with dimers property
            dimers = Array.isArray(result) ? result : (result.dimers || []);
        }

        async function runCFTP() {
            if (isRunningCFTP || !isValid) return;
            isRunningCFTP = true;
            canvas.style.cursor = 'wait';

            // Run CFTP (blocking, but fast for small regions)
            await new Promise(resolve => setTimeout(resolve, 10)); // Let UI update
            const ptr = runCFTPWasm();
            const jsonStr = Module.UTF8ToString(ptr);
            freeStringWasm(ptr);
            const result = JSON.parse(jsonStr);

            refreshDimers();
            draw();

            isRunningCFTP = false;
            canvas.style.cursor = 'pointer';
        }

        function draw() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvas.clientWidth * dpr;
            canvas.height = canvas.clientHeight * dpr;
            ctx.scale(dpr, dpr);

            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);

            if (activeTriangles.size === 0) return;

            // Calculate bounds from all triangle vertices
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const [, tri] of activeTriangles) {
                let verts;
                if (tri.type === 1) {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
                } else {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j - 1), getVertex(tri.n + 1, tri.j)];
                }
                for (const v of verts) {
                    minX = Math.min(minX, v.x);
                    maxX = Math.max(maxX, v.x);
                    minY = Math.min(minY, v.y);
                    maxY = Math.max(maxY, v.y);
                }
            }

            const regionWidth = maxX - minX;
            const regionHeight = maxY - minY;
            const scale = Math.min(width / regionWidth, height / regionHeight) * 0.85;
            const centerX = width / 2 - ((minX + maxX) / 2) * scale;
            const centerY = height / 2 + ((minY + maxY) / 2) * scale; // Flipped for y-axis

            function toCanvas(x, y) {
                // Flip y-axis (canvas has y increasing downward)
                return [centerX + x * scale, centerY - y * scale];
            }

            // If we have dimers, draw lozenges; otherwise draw the triangular shape
            if (Array.isArray(dimers) && dimers.length > 0) {
                // Draw lozenges
                for (const d of dimers) {
                    drawLozenge(d.bn, d.bj, d.t);
                }
            } else {
                // Draw just the triangles to show the shape
                for (const [, tri] of activeTriangles) {
                    drawTriangle(tri.n, tri.j, tri.type);
                }
            }

            function drawTriangle(n, j, type) {
                let verts;
                if (type === 1) {
                    // Black (right-facing): (n,j), (n,j-1), (n+1,j-1)
                    verts = [getVertex(n, j), getVertex(n, j - 1), getVertex(n + 1, j - 1)];
                } else {
                    // White (left-facing): (n,j), (n+1,j-1), (n+1,j)
                    verts = [getVertex(n, j), getVertex(n + 1, j - 1), getVertex(n + 1, j)];
                }

                ctx.beginPath();
                const [x0, y0] = toCanvas(verts[0].x, verts[0].y);
                ctx.moveTo(x0, y0);
                for (let i = 1; i < 3; i++) {
                    const [xi, yi] = toCanvas(verts[i].x, verts[i].y);
                    ctx.lineTo(xi, yi);
                }
                ctx.closePath();
                ctx.fillStyle = type === 1 ? '#232D4B' : '#F9DCBF';
                ctx.fill();
            }

            function drawLozenge(bn, bj, type) {
                let verts;
                if (type === 0) {
                    verts = [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
                } else if (type === 1) {
                    verts = [getVertex(bn, bj), getVertex(bn, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn + 1, bj - 1)];
                } else {
                    verts = [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
                }

                ctx.beginPath();
                const [x0, y0] = toCanvas(verts[0].x, verts[0].y);
                ctx.moveTo(x0, y0);
                for (let i = 1; i < 4; i++) {
                    const [xi, yi] = toCanvas(verts[i].x, verts[i].y);
                    ctx.lineTo(xi, yi);
                }
                ctx.closePath();
                ctx.fillStyle = colors[type];
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 0.3;
                ctx.stroke();
            }
        }

        // Click to run CFTP
        canvas.addEventListener('click', runCFTP);

        // Load Rotunda on start
        loadRotunda();
    }
});
</script>
