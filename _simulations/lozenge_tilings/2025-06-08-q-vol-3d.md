---
title: 3D q-volume and q-Racah lozenge tilings visualization
model: lozenge-tilings
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/lozenge_tilings/2025-06-08-q-vol-3d.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/lozenge_tilings/2025-06-08-q-vol-3d.cpp'
    txt: 'C++ code for the simulation'
permalink: /lozenge/
---

<style>
  /* ========================================================================
     Phase 1: Two-Column Desktop Layout (matching lozenge-draw)
     ======================================================================== */
  .simulation-layout {
    display: flex;
    flex-direction: column;
    max-width: 1400px;
    margin: 0 auto;
    padding: 8px;
    gap: 16px;
  }

  @media (min-width: 992px) {
    .simulation-layout {
      display: grid;
      grid-template-columns: 340px 1fr;
      grid-template-rows: auto;
      gap: 16px;
      align-items: start;
    }
    .controls-panel {
      grid-column: 1;
      grid-row: 1;
    }
    .visualization-panel {
      grid-column: 2;
      grid-row: 1;
    }
  }

  @media (min-width: 1200px) {
    .simulation-layout {
      grid-template-columns: 380px 1fr;
    }
  }

  .controls-panel {
    flex: 0 0 auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
    overflow: visible;
  }

  @media (min-width: 992px) {
    .controls-panel {
      padding-right: 16px;
      border-right: 2px solid var(--border-color, #d0d0d0);
      box-shadow: 4px 0 12px rgba(0, 0, 0, 0.06);
      overflow: visible;
    }
    [data-theme="dark"] .controls-panel {
      border-right-color: var(--border-color, #555);
      box-shadow: 4px 0 12px rgba(0, 0, 0, 0.3);
    }
    .controls-panel-inner {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
      overflow: visible;
    }
  }

  .visualization-panel {
    flex: 1 1 auto;
    min-width: 0;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  /* ========================================================================
     Canvas Styling
     ======================================================================== */
  #lozenge-canvas {
    width: 100%;
    max-width: 900px;
    height: 600px;
    border: 1px solid #ccc;
    display: block;
    margin: 0 auto;
    background: #ffffff;
    border-radius: 6px;
    touch-action: none;
  }

  #three-container {
    width: 100%;
    max-width: 900px;
    height: 600px;
    margin: 0 auto;
    border: 1px solid #ccc;
    display: block;
    background: #ffffff;
    border-radius: 6px;
    touch-action: none;
  }

  #three-container canvas {
    width: 100% !important;
    height: 100% !important;
    display: block;
  }

  [data-theme="dark"] #three-container {
    background: #1a1a1a;
    border-color: #444;
  }

  [data-theme="dark"] #lozenge-canvas {
    background: #1a1a1a;
    border-color: #444;
  }

  [data-theme="dark"] canvas {
    border-color: #555;
  }

  @media (min-width: 992px) {
    .visualization-panel #lozenge-canvas,
    .visualization-panel #three-container {
      width: 100%;
      max-width: none;
      height: 70vh;
      max-height: 800px;
      margin: 0;
    }
  }

  /* ========================================================================
     Phase 2: Collapsible Accordion Sections
     ======================================================================== */
  details.control-section {
    display: block;
    width: 100%;
    max-width: none;
    box-sizing: border-box;
    border: 1px solid var(--border-color, #e0e0e0);
    border-radius: 8px;
    background: var(--bg-secondary, #f5f5f5);
    overflow: visible;
    margin: 0;
  }

  div.control-section {
    display: block;
    width: 100%;
    box-sizing: border-box;
    border: 1px solid var(--border-color, #e0e0e0);
    border-radius: 8px;
    background: var(--bg-secondary, #f5f5f5);
  }

  .control-section summary {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    font-family: "franklingothic-demi", Arial, sans-serif;
    font-size: 15px;
    font-weight: 600;
    text-transform: none;
    letter-spacing: 0.3px;
    color: var(--text-primary, #333);
    cursor: pointer;
    user-select: none;
    list-style: none;
    background: var(--bg-secondary, #f5f5f5);
    transition: background 0.15s;
  }

  .control-section summary::-webkit-details-marker {
    display: none;
  }

  .control-section summary::after {
    content: '';
    width: 8px;
    height: 8px;
    border-right: 2px solid currentColor;
    border-bottom: 2px solid currentColor;
    transform: rotate(-45deg);
    transition: transform 0.2s;
    opacity: 0.6;
  }

  .control-section[open] summary::after {
    transform: rotate(45deg);
  }

  .control-section summary:hover {
    background: rgba(229, 114, 0, 0.08);
  }

  .control-section-content {
    padding: 12px;
    border-top: 1px solid var(--border-color, #e0e0e0);
    display: flex;
    flex-direction: column;
    gap: 12px;
    overflow-x: visible;
  }

  .control-section .control-row {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
    width: 100%;
    box-sizing: border-box;
  }

  .control-section label,
  .control-section .param-label {
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary, #555);
  }

  [data-theme="dark"] .control-section label,
  [data-theme="dark"] .control-section .param-label {
    color: var(--text-secondary, #aaa);
  }

  [data-theme="dark"] details.control-section,
  [data-theme="dark"] div.control-section {
    background: var(--bg-secondary, #2d2d2d);
    border-color: var(--border-color, #444);
  }

  [data-theme="dark"] .control-section summary {
    background: var(--bg-secondary, #2d2d2d);
    color: var(--text-primary, #e8e8e8);
  }

  [data-theme="dark"] .control-section summary:hover {
    background: rgba(255, 153, 51, 0.1);
  }

  [data-theme="dark"] .control-section-content {
    border-color: var(--border-color, #444);
  }

  /* ========================================================================
     Parameter Inputs
     ======================================================================== */
  .param-input {
    width: 60px;
    height: 30px;
    text-align: center;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
    font-family: 'SF Mono', Monaco, monospace;
    box-sizing: border-box;
  }

  .param-input:focus {
    outline: none;
    border-color: #E57200;
    box-shadow: 0 0 0 2px rgba(229, 114, 0, 0.2);
  }

  .param-label {
    font-size: 13px;
    color: #555;
    margin-right: 4px;
    font-weight: 500;
  }

  .param-group {
    display: inline-flex;
    align-items: center;
    margin-right: 12px;
  }

  .parameters-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: 12px;
    margin-bottom: 12px;
  }

  .param-item {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .param-item label {
    font-weight: 500;
    min-width: 20px;
  }

  .param-item input {
    flex: 1;
    min-width: 50px;
  }

  /* ========================================================================
     Button Hierarchy
     ======================================================================== */
  .control-section button {
    height: 30px;
    padding: 0 14px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    background: white;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
  }

  .control-section button:hover {
    background: #f5f5f5;
    border-color: #999;
  }

  .control-section button:disabled {
    background: #e0e0e0;
    border-color: #ccc;
    color: #999;
    cursor: not-allowed;
  }

  .control-section button:disabled:hover {
    background: #e0e0e0;
    border-color: #ccc;
  }

  /* Primary action - Orange gradient */
  .btn-action {
    background: linear-gradient(135deg, #E57200, #f08c30) !important;
    color: white !important;
    border-color: #E57200 !important;
    font-weight: 600;
    box-shadow: 0 2px 4px rgba(229, 114, 0, 0.3);
  }

  .btn-action:hover:not(:disabled) {
    background: linear-gradient(135deg, #d16610, #E57200) !important;
    box-shadow: 0 3px 8px rgba(229, 114, 0, 0.4);
    transform: translateY(-1px);
  }

  .btn-action:disabled {
    background: #ccc !important;
    border-color: #ccc !important;
    box-shadow: none;
  }

  /* Secondary action - Navy */
  .btn-secondary-action {
    background: linear-gradient(135deg, #232D4B, #3a4a6b) !important;
    color: white !important;
    border-color: #232D4B !important;
    font-weight: 500;
  }

  .btn-secondary-action:hover:not(:disabled) {
    background: linear-gradient(135deg, #1a2238, #232D4B) !important;
  }

  .btn-secondary-action:disabled {
    background: #8a9ab8 !important;
    border-color: #8a9ab8 !important;
  }

  /* Utility - Neutral */
  .btn-utility {
    background: var(--bg-primary, white) !important;
    color: var(--text-primary, #333) !important;
    border: 1px solid var(--border-color, #d0d0d0) !important;
  }

  .btn-utility:hover:not(:disabled) {
    background: var(--bg-secondary, #f5f5f5) !important;
    border-color: #999 !important;
  }

  /* Legacy primary class mapped to btn-action */
  button.primary {
    background: linear-gradient(135deg, #E57200, #f08c30);
    color: white;
    border-color: #E57200;
    font-weight: 600;
  }

  button.primary:hover {
    background: linear-gradient(135deg, #d16610, #E57200);
  }

  button.primary:disabled {
    background: #ccc;
    border-color: #ccc;
    cursor: not-allowed;
  }

  .button-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  /* ========================================================================
     View Toggle (Segmented Controls)
     ======================================================================== */
  .view-toggle {
    display: inline-flex;
    border: 2px solid #232D4B;
    border-radius: 6px;
    overflow: hidden;
  }

  .view-toggle button {
    border: none;
    border-radius: 0;
    height: 32px;
    padding: 0 16px;
    font-weight: 500;
    background: white;
    color: #232D4B;
  }

  .view-toggle button.active {
    background: #232D4B;
    color: white;
  }

  .view-toggle button:hover:not(.active) {
    background: #F9DCBF;
  }

  [data-theme="dark"] .view-toggle {
    border-color: #4dabf7;
  }

  [data-theme="dark"] .view-toggle button {
    background: #2d2d2d;
    color: #4dabf7;
  }

  [data-theme="dark"] .view-toggle button.active {
    background: #4dabf7;
    color: #1a1a1a;
  }

  [data-theme="dark"] .view-toggle button:hover:not(.active) {
    background: #3d3d3d;
  }

  /* ========================================================================
     Stats Bar
     ======================================================================== */
  .stats-inline {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    font-size: 12px;
  }

  .stats-inline .stat {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .stats-inline .stat-label {
    color: #888;
    text-transform: uppercase;
    font-size: 10px;
  }

  .stats-inline .stat-value {
    color: #232D4B;
    font-weight: 600;
    font-family: 'SF Mono', Monaco, monospace;
  }

  [data-theme="dark"] .stat-value {
    color: #d0d0d0;
  }

  [data-theme="dark"] .stat-label {
    color: #aaa;
  }

  /* ========================================================================
     Color Legend Inline
     ======================================================================== */
  .legend-items {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 12px;
    color: var(--text-primary, #555);
  }

  .color-box {
    width: 12px;
    height: 12px;
    border-radius: 2px;
    border: 1px solid rgba(0,0,0,0.1);
  }

  /* ========================================================================
     Palette Picker Grid
     ======================================================================== */
  .palette-picker {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(44px, 1fr));
    gap: 6px;
    max-height: 140px;
    overflow-y: auto;
    padding: 4px;
    margin-top: 8px;
  }

  .palette-item {
    display: flex;
    flex-wrap: wrap;
    width: 44px;
    height: 28px;
    border: 2px solid var(--border-color, #d0d0d0);
    border-radius: 4px;
    overflow: hidden;
    cursor: pointer;
    transition: border-color 0.15s, transform 0.1s;
  }

  .palette-item:hover {
    transform: scale(1.08);
    z-index: 1;
  }

  .palette-item.active {
    border-color: var(--accent-color, #e57200);
    box-shadow: 0 0 0 2px rgba(229, 114, 0, 0.3);
  }

  .palette-item .swatch {
    width: 33.33%;
    height: 100%;
  }

  [data-theme="dark"] .palette-item {
    border-color: #555;
  }

  [data-theme="dark"] .palette-item.active {
    border-color: var(--accent-color, #ff9933);
  }

  /* ========================================================================
     Custom Colors Panel
     ======================================================================== */
  .custom-colors-panel {
    display: none;
    margin-top: 10px;
    padding: 15px;
    background-color: #f8f9fa;
    border-radius: 4px;
    border: 1px solid #ccc;
  }

  .color-palette {
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .color-palette label {
    width: 120px;
    font-weight: bold;
  }

  .color-palette input[type="color"] {
    width: 40px;
    height: 30px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }

  .color-palette input[type="text"] {
    width: 70px;
    height: 26px;
    font-family: monospace;
    font-size: 12px;
    text-align: center;
    border: 1px solid #ccc;
    border-radius: 4px;
  }

  /* ========================================================================
     Export Section Groups
     ======================================================================== */
  .export-group {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 0;
    flex-wrap: wrap;
  }

  .export-group-label {
    font-size: 11px;
    font-weight: 600;
    color: #666;
    text-transform: uppercase;
    min-width: 50px;
  }

  [data-theme="dark"] .export-group-label {
    color: #aaa;
  }

  .export-divider {
    width: 100%;
    height: 1px;
    background: var(--border-color, #e0e0e0);
    margin: 4px 0;
  }

  /* ========================================================================
     Export Modal
     ======================================================================== */
  .export-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
  }

  .export-modal-content {
    background-color: var(--bg-primary, white);
    margin: 5% auto;
    padding: 20px;
    border-radius: 12px;
    width: 80%;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  }

  .export-textarea {
    width: 100%;
    height: 300px;
    font-family: monospace;
    font-size: 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 10px;
    margin: 10px 0;
    resize: vertical;
  }

  .export-buttons {
    display: flex;
    gap: 10px;
    margin-top: 10px;
  }

  .export-buttons button {
    padding: 8px 16px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #f8f9fa;
    cursor: pointer;
  }

  .export-buttons button:hover {
    background-color: #e9ecef;
  }

  .close-modal {
    float: right;
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
    color: #aaa;
  }

  .close-modal:hover {
    color: #000;
  }

  /* ========================================================================
     View Overlay (Floating Controls on Canvas)
     ======================================================================== */
  #view-overlay {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 6px 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.12);
    border: 1px solid rgba(0,0,0,0.08);
  }

  [data-theme="dark"] #view-overlay {
    background: rgba(35, 35, 35, 0.95);
    border-color: rgba(255,255,255,0.1);
  }

  #view-overlay .view-toggle {
    background: transparent;
    border: none;
    padding: 0;
    gap: 2px;
  }

  #view-overlay button {
    min-width: 32px;
    height: 32px;
    padding: 0 8px;
    border: 1px solid var(--border-color, #ddd);
    font-size: 13px;
    position: relative;
  }

  #view-overlay button[title]::after {
    content: attr(title);
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-top: 6px;
    padding: 4px 8px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    font-size: 11px;
    border-radius: 4px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.15s;
    z-index: 1000;
  }

  #view-overlay button[title]:hover::after {
    opacity: 1;
  }

  .help-circle-btn {
    width: 28px;
    height: 28px;
    border: 1px solid var(--border-color, #888);
    border-radius: 50%;
    background: var(--bg-primary, white);
    color: #666;
    font-size: 14px;
    cursor: pointer;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .help-circle-btn:hover {
    border-color: #E57200;
    color: #E57200;
  }

  /* ========================================================================
     Keyboard Shortcuts Help Modal
     ======================================================================== */
  .keyboard-help-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.6);
    z-index: 2000;
    align-items: center;
    justify-content: center;
  }

  .keyboard-help-modal.visible {
    display: flex;
  }

  .keyboard-help-content {
    background: var(--bg-primary, white);
    border-radius: 12px;
    padding: 24px;
    max-width: 400px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  }

  .keyboard-help-content h3 {
    margin: 0 0 16px 0;
    font-family: "franklingothic-demi", Arial, sans-serif;
    font-size: 16px;
    color: var(--text-primary, #333);
  }

  .keyboard-help-content table {
    width: 100%;
    border-collapse: collapse;
  }

  .keyboard-help-content td {
    padding: 8px 4px;
    border-bottom: 1px solid var(--border-color, #e0e0e0);
    font-size: 13px;
  }

  .keyboard-help-content kbd {
    display: inline-block;
    background: #e8e8e8;
    border: 1px solid #bbb;
    border-radius: 4px;
    padding: 2px 8px;
    font-family: 'SF Mono', Monaco, monospace;
    font-size: 12px;
    min-width: 24px;
    text-align: center;
    color: #333;
    box-shadow: 0 1px 0 #999;
  }

  [data-theme="dark"] .keyboard-help-content kbd {
    background: #444;
    border-color: #666;
    color: #e8e8e8;
    box-shadow: 0 1px 0 #222;
  }

  .keyboard-help-content .close-btn {
    margin-top: 16px;
    width: 100%;
    padding: 10px;
    background: var(--bg-secondary, #f5f5f5);
    border: 1px solid var(--border-color, #d0d0d0);
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
  }

  [data-theme="dark"] .keyboard-help-content {
    background: var(--bg-primary, #1a1a1a);
  }

  /* ========================================================================
     Mobile Bottom Sheet Drawer
     ======================================================================== */
  @media (max-width: 991px) {
    .controls-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--bg-primary, #fff);
      border-top: 1px solid var(--border-color, #e0e0e0);
      border-radius: 16px 16px 0 0;
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
      z-index: 900;
      max-height: 70vh;
      transform: translateY(calc(100% - 60px));
      transition: transform 0.3s ease-out;
      padding: 0;
      overflow: hidden;
    }

    .controls-panel.expanded {
      transform: translateY(0);
    }

    .controls-panel-inner {
      max-height: calc(70vh - 60px);
      overflow-y: auto;
      padding: 0 12px 20px;
    }

    .drawer-handle {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 60px;
      cursor: grab;
      flex-shrink: 0;
    }

    .drawer-handle:active {
      cursor: grabbing;
    }

    .drawer-handle-bar {
      width: 40px;
      height: 4px;
      background: var(--border-color, #ccc);
      border-radius: 2px;
    }

    .drawer-handle-hint {
      position: absolute;
      font-size: 11px;
      color: #888;
      margin-top: 24px;
    }

    .controls-panel.expanded .drawer-handle-hint {
      display: none;
    }

    [data-theme="dark"] .controls-panel {
      background: var(--bg-primary, #1a1a1a);
      border-color: var(--border-color, #444);
    }

    .visualization-panel {
      padding-bottom: 70px;
    }

    .visualization-panel #lozenge-canvas,
    .visualization-panel #three-container {
      height: 400px;
    }
  }

  @media (min-width: 992px) {
    .drawer-handle {
      display: none;
    }
  }

  /* ========================================================================
     Floating Action Button (Mobile)
     ======================================================================== */
  .sample-fab {
    display: none;
    position: fixed;
    bottom: 80px;
    right: 16px;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: linear-gradient(135deg, #E57200, #f08c30);
    color: white;
    border: none;
    font-size: 24px;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(229, 114, 0, 0.4);
    z-index: 1000;
    transition: transform 0.15s, box-shadow 0.15s;
    align-items: center;
    justify-content: center;
  }

  .sample-fab:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(229, 114, 0, 0.5);
  }

  .sample-fab:disabled {
    background: #ccc;
    box-shadow: none;
    cursor: not-allowed;
  }

  .sample-fab::before {
    content: attr(data-tooltip);
    position: absolute;
    right: 64px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
  }

  .sample-fab:hover::before {
    opacity: 1;
  }

  @media (max-width: 991px) {
    .sample-fab { display: flex; }
  }

  /* ========================================================================
     Input / Select Styling
     ======================================================================== */
  input[type="number"],
  input[type="text"],
  select {
    height: 30px;
    padding: 0 8px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    font-size: 13px;
    background: white;
    transition: border-color 0.2s;
  }

  input[type="number"]:focus,
  input[type="text"]:focus,
  select:focus {
    outline: none;
    border-color: #E57200;
    box-shadow: 0 0 0 2px rgba(229, 114, 0, 0.2);
  }

  input[type="range"] {
    height: 4px;
    border-radius: 2px;
    background: #d0d0d0;
    appearance: none;
    outline: none;
  }

  input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: linear-gradient(135deg, #E57200, #f08c30);
    cursor: pointer;
  }

  input[type="checkbox"] {
    accent-color: #E57200;
  }

  /* ========================================================================
     Dark Mode
     ======================================================================== */
  [data-theme="dark"] label {
    color: #bbb;
  }

  [data-theme="dark"] input[type="number"],
  [data-theme="dark"] input[type="text"],
  [data-theme="dark"] select {
    background-color: #3a3a3a;
    border-color: #555;
    color: #ddd;
  }

  [data-theme="dark"] .control-section button {
    background-color: #3a3a3a;
    border-color: #555;
    color: #ddd;
  }

  [data-theme="dark"] .control-section button:hover {
    background-color: #4a4a4a;
    border-color: #666;
  }

  [data-theme="dark"] .control-section button:disabled {
    background-color: #2a2a2a;
    border-color: #444;
    color: #666;
  }

  [data-theme="dark"] .export-modal-content {
    background-color: #1a1a1a;
    color: #ddd;
  }

  [data-theme="dark"] .custom-colors-panel {
    background-color: #2d2d2d;
    border-color: #444;
  }

  [data-theme="dark"] #loading {
    background-color: rgba(0, 0, 0, 0.9);
    color: #ddd;
  }

  /* ========================================================================
     About Section (top of page)
     ======================================================================== */
  #about-simulation-details {
    max-width: 1400px;
    margin: 0 auto 16px auto;
    border: 1px solid var(--border-color, #e0e0e0);
    border-radius: 8px;
    background: var(--bg-secondary, #f8f9fa);
  }

  #about-simulation-details summary {
    padding: 12px 16px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    background: var(--bg-secondary, #f5f5f5);
    border-radius: 8px;
  }

  #about-simulation-details[open] summary {
    border-radius: 8px 8px 0 0;
    border-bottom: 1px solid var(--border-color, #e0e0e0);
  }

  #about-simulation-details .content {
    padding: 16px;
    background: var(--bg-primary, white);
    border-radius: 0 0 8px 8px;
    font-size: 13px;
    line-height: 1.5;
  }

  [data-theme="dark"] #about-simulation-details {
    background: var(--bg-secondary, #2d2d2d);
    border-color: var(--border-color, #444);
  }

  [data-theme="dark"] #about-simulation-details summary {
    background: var(--bg-secondary, #2d2d2d);
  }

  [data-theme="dark"] #about-simulation-details .content {
    background: var(--bg-primary, #1a1a1a);
  }

  /* Canvas footer strip (config + legend at bottom of canvas) */
  .canvas-footer {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 4px 24px;
    padding: 6px 10px;
    background: var(--bg-secondary, #f5f5f5);
    border: 1px solid var(--border-color, #e0e0e0);
    border-top: none;
    border-radius: 0 0 8px 8px;
    font-size: 12px;
  }

  .canvas-footer-row {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 4px 12px;
  }

  /* Separator between config and legend on same line */
  .canvas-footer-row + .canvas-footer-row::before {
    content: '';
    width: 1px;
    height: 14px;
    background: var(--border-color, #ccc);
    margin-right: 4px;
  }

  [data-theme="dark"] .canvas-footer {
    background: var(--bg-secondary, #2d2d2d);
    border-color: var(--border-color, #444);
  }

  /* Config item (used by JS for config display) */
  .config-item {
    font-family: 'SF Mono', Monaco, monospace;
    color: #232D4B;
    font-size: 12px;
  }

  [data-theme="dark"] .config-item {
    color: #d0d0d0;
  }

  /* ========================================================================
     Accessibility
     ======================================================================== */
  .skip-link {
    position: absolute;
    left: -9999px;
    top: auto;
    width: 1px;
    height: 1px;
    overflow: hidden;
    z-index: 1000;
    background: #E57200;
    color: white;
    padding: 8px 16px;
    text-decoration: none;
    border-radius: 4px;
  }

  .skip-link:focus {
    position: fixed;
    top: 10px;
    left: 10px;
    width: auto;
    height: auto;
    overflow: visible;
  }

  button:focus, input:focus, select:focus {
    outline: 3px solid #E57200;
    outline-offset: 2px;
  }

  .view-toggle button:focus {
    outline: 3px solid #232D4B;
    outline-offset: 2px;
  }

  button.loading {
    opacity: 0.7;
    cursor: wait;
  }

  button:disabled,
  input:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  @media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
      animation-duration: 0.01ms !important;
      transition-duration: 0.01ms !important;
    }
  }

  @media (prefers-contrast: high) {
    .control-section { border-width: 2px; }
    button { border-width: 2px; }
    .view-toggle { border-width: 3px; }
  }

  /* ========================================================================
     Mobile Responsiveness
     ======================================================================== */
  @media (max-width: 767px) {
    .simulation-layout {
      padding: 4px;
    }

    .control-section summary {
      padding: 14px 16px;
      min-height: 48px;
      font-size: 13px;
    }

    .control-section-content {
      padding: 12px;
    }

    .control-row {
      gap: 8px;
    }

    .param-input {
      width: 50px;
      height: 36px;
      font-size: 14px;
    }

    .parameters-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .button-row {
      gap: 6px;
    }

    .param-item {
      gap: 2px;
    }

    .param-item label {
      font-size: 14px;
      min-width: 16px;
    }

    .control-section button {
      min-width: 44px;
      min-height: 44px;
      padding: 0 12px;
      font-size: 13px;
    }

    .view-toggle button {
      min-width: 44px;
      min-height: 44px;
      padding: 0 12px;
      font-size: 12px;
    }

    #view-overlay {
      top: 6px;
      right: 6px;
      gap: 6px;
    }
  }

  @media (max-width: 480px) {
    .control-section summary {
      padding: 12px 14px;
      min-height: 44px;
      font-size: 12px;
    }

    .control-section-content {
      padding: 10px;
      gap: 10px;
    }

    .btn-action,
    .btn-secondary-action {
      padding: 10px 14px;
      font-size: 13px;
      width: 100%;
    }

    .control-row {
      flex-wrap: wrap;
    }
  }
</style>

<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>
<script src="/js/colorschemes.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="/js/2025-06-08-q-vol-3d.js"></script>

<a href="#three-container" class="skip-link">Skip to simulation</a>

<details id="about-simulation-details">
<summary>About this simulation</summary>
<div class="content">

This simulation demonstrates <strong>3D lozenge tilings</strong> using a WASM/JS port of a program by <a href="https://www.stat.berkeley.edu/~vadicgor/research.html">Vadim Gorin</a>.
The simulation generates lozenge tilings of a hexagon with sides $N$, $S$, and $T-S$ under the $q^{-volume}$ measure, including support for the <strong>imaginary q-Racah</strong> case introduced by <a href="https://arxiv.org/abs/0905.0679">Borodin, Gorin, and Rains (2009)</a>.
<br><br>
The sampler works entirely in your browser using WebAssembly. This version provides both 2D and 3D visualization modes with full S→S±1 operator functionality for all supported polynomial families.

</div>
</details>

---

<div class="simulation-layout">

<!-- Left: Controls Panel (sidebar) -->
<aside class="controls-panel" id="controlsPanel">
  <!-- Mobile drawer handle -->
  <div class="drawer-handle" id="drawerHandle">
    <div class="drawer-handle-bar"></div>
    <span class="drawer-handle-hint">Swipe up for controls</span>
  </div>

  <div class="controls-panel-inner">

    <!-- Stats Bar -->
    <div class="control-section" style="padding: 10px 14px;">
      <div class="stats-inline" role="status" aria-live="polite">
        <div class="stat"><span class="stat-label">N</span><span class="stat-value" id="stat-N">40</span></div>
        <div class="stat"><span class="stat-label">T</span><span class="stat-value" id="stat-T">80</span></div>
        <div class="stat"><span class="stat-label">S</span><span class="stat-value" id="stat-S">0</span></div>
        <div class="stat"><span class="stat-label">q</span><span class="stat-value" id="stat-q">1</span></div>
      </div>
      <!-- Color legend inline -->
      <div class="legend-items" style="margin-top: 8px;">
        <span class="legend-item">
          <span class="color-box" id="swatch-gray1" style="background-color: #E57200;"></span>
          Up
        </span>
        <span class="legend-item">
          <span class="color-box" id="swatch-gray2" style="background-color: #232D4B;"></span>
          Down
        </span>
        <span class="legend-item">
          <span class="color-box" id="swatch-gray3" style="background-color: #F9DCBF;"></span>
          Horizontal
        </span>
        <span class="legend-item">
          <span class="color-box" id="swatch-border" style="background-color: #666666; border: 1px solid #333;"></span>
          Border
        </span>
        <span class="legend-item">
          <span style="font-weight: 600;" id="palette-info">UVA</span>
        </span>
      </div>
    </div>

    <!-- Section 1: Parameters (open by default) -->
    <details class="control-section" open>
      <summary>Parameters</summary>
      <div class="control-section-content">
        <div class="control-row">
          <span class="param-group">
            <label for="N" class="param-label">N</label>
            <input type="number" class="param-input" id="N" value="40" min="1" max="200">
          </span>
          <span class="param-group">
            <label for="T" class="param-label">T</label>
            <input type="number" class="param-input" id="T" value="80" min="1" max="500">
          </span>
          <span class="param-group">
            <label for="S" class="param-label">S</label>
            <input type="number" class="param-input" id="S" value="0" min="0">
          </span>
          <span class="param-group" id="regular-q-param">
            <label for="q" class="param-label">q</label>
            <input type="number" class="param-input" id="q" value="1" step="0.02" style="width: 80px;">
          </span>
        </div>
        <div class="control-row">
          <label style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;">
            <input type="checkbox" id="imaginary-q-racah"> Imaginary q-Racah
          </label>
          <div id="kappa-param" style="display: none; align-items: center; gap: 16px;">
            <span class="param-group">
              <label for="imaginary-q" class="param-label">q</label>
              <input type="number" class="param-input" id="imaginary-q" value="0.5" step="0.01" min="0.01" max="1" style="width: 70px;">
            </span>
            <span class="param-group">
              <label for="kappa-i" class="param-label">κ/i</label>
              <input type="number" class="param-input" id="kappa-i" value="3" step="0.01" min="0.01" style="width: 70px;">
            </span>
          </div>
        </div>
        <div class="control-row">
          <button id="initialize" class="btn-action" aria-label="Initialize tiling">Initialize</button>
          <button id="set-parameters" class="btn-secondary-action" aria-label="Set parameters">Set Parameters</button>
        </div>
      </div>
    </details>

    <!-- Section 2: Animation Controls (open by default) -->
    <details class="control-section" id="animation-controls-details" open>
      <summary>Animation Controls</summary>
      <div class="control-section-content">
        <div class="control-row">
          <label for="steps" style="font-style: italic; font-size: 13px;">r =</label>
          <input id="steps" type="number" class="param-input" value="1" min="1" max="9999" style="width: 60px;">
        </div>
        <div class="control-row">
          <button id="step-plus" class="btn-utility" aria-label="Step S to S plus r">S → S+r</button>
          <button id="step-minus" class="btn-utility" aria-label="Step S to S minus r">S → S-r</button>
        </div>
        <div class="control-row">
          <button id="step-plus-back" class="btn-utility" aria-label="Step S to S plus r then back">S → S+r → S</button>
          <button id="step-minus-forward" class="btn-utility" aria-label="Step S to S minus r then forward">S → S-r → S</button>
        </div>
      </div>
    </details>

    <!-- Section 3: View Controls -->
    <details class="control-section">
      <summary>View Controls</summary>
      <div class="control-section-content">
        <div class="control-row">
          <button id="toggle-view" class="btn-utility" aria-label="Toggle 2D/3D view">Toggle 2D/3D</button>
          <button id="toggle-ortho" class="btn-utility" title="Toggle perspective/orthographic projection" aria-label="Toggle projection mode">Perspective</button>
        </div>
        <div class="control-row">
          <button id="zoom-in" class="btn-utility" aria-label="Zoom in">Zoom In</button>
          <button id="zoom-out" class="btn-utility" aria-label="Zoom out">Zoom Out</button>
          <button id="zoom-reset" class="btn-utility" aria-label="Reset zoom">Reset</button>
        </div>
        <div class="control-row" style="margin-top: 4px;">
          <span class="param-group">
            <label class="param-label">X</label>
            <input type="number" class="param-input" id="cam-x" value="0" step="1">
          </span>
          <span class="param-group">
            <label class="param-label">Y</label>
            <input type="number" class="param-input" id="cam-y" value="0" step="1">
          </span>
          <span class="param-group">
            <label class="param-label">Z</label>
            <input type="number" class="param-input" id="cam-z" value="0" step="1">
          </span>
          <span class="param-group">
            <label class="param-label">Dist</label>
            <input type="number" class="param-input" id="cam-distance" value="50" min="1" max="2000" step="5" style="width: 60px;">
          </span>
        </div>
        <div class="control-row">
          <button id="apply-camera" class="btn-utility" aria-label="Apply camera settings">Apply Camera</button>
          <button id="reset-camera" class="btn-utility" aria-label="Reset camera">Reset Camera</button>
        </div>
        <div class="control-row">
          <label style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;">
            <input type="checkbox" id="demo-mode"> Demo Mode (Auto-rotate)
          </label>
        </div>
        <div style="font-size: 11px; color: #888; font-family: 'SF Mono', Monaco, monospace;">
          <div id="camera-info">Camera: (0, 0, 0) | Target: (0, 0, 0) | Distance: 0</div>
        </div>
      </div>
    </details>

    <!-- Section 4: Styling -->
    <details class="control-section" id="styling-controls-details">
      <summary>Styling</summary>
      <div class="control-section-content">
        <div class="control-row">
          <label for="style" class="param-label">Style</label>
          <select id="style">
            <option value="1" selected>Lozenges</option>
            <option value="5">Z² paths</option>
          </select>
        </div>
        <div class="control-row">
          <label class="param-label">Border</label>
          <input id="border-width" type="number" class="param-input" value="0.01" step="0.001" min="0" max="0.2" style="width: 80px;">
          <button id="border-thin" class="btn-utility" style="font-size: 11px;">Thin</button>
          <button id="border-medium" class="btn-utility" style="font-size: 11px;">Med</button>
          <button id="border-thick" class="btn-utility" style="font-size: 11px;">Thick</button>
          <button id="border-ultra-thick" class="btn-utility" style="font-size: 11px;">Ultra</button>
        </div>
        <div class="control-row">
          <button id="prev-palette" class="btn-utility" style="padding: 0 10px;" aria-label="Previous palette">◀</button>
          <select id="palette-select" style="flex: 1; min-width: 80px;" aria-label="Select color palette">
            <!-- Populated dynamically from ColorSchemes -->
          </select>
          <button id="next-palette" class="btn-utility" style="padding: 0 10px;" aria-label="Next palette">▶</button>
          <button id="permute-colors" class="btn-utility" aria-label="Permute colors">Permute</button>
        </div>
        <!-- Visual Palette Picker Grid -->
        <div id="palettePickerGrid" class="palette-picker" role="listbox" aria-label="Color palette visual selection"></div>
        <div class="control-row">
          <button id="custom-colors" class="btn-utility" aria-label="Toggle custom color pickers">Custom Colors</button>
        </div>
      </div>
      <div id="custom-colors-panel" class="custom-colors-panel">
        <h4>Custom Color Palettes</h4>

        <div class="color-palette">
          <label>Up Rhombi:</label>
          <input type="color" id="color-gray1" value="#E57200">
          <input type="text" id="hex-gray1" value="#E57200" placeholder="#RRGGBB">
        </div>

        <div class="color-palette">
          <label>Down Rhombi:</label>
          <input type="color" id="color-gray2" value="#232D4B">
          <input type="text" id="hex-gray2" value="#232D4B" placeholder="#RRGGBB">
        </div>

        <div class="color-palette">
          <label>Horizontal:</label>
          <input type="color" id="color-gray3" value="#F9DCBF">
          <input type="text" id="hex-gray3" value="#F9DCBF" placeholder="#RRGGBB">
        </div>

        <div class="color-palette">
          <label>Border:</label>
          <input type="color" id="color-border" value="#666666">
          <input type="text" id="hex-border" value="#666666" placeholder="#RRGGBB">
        </div>

        <div style="margin-top: 15px;">
          <button id="reset-default-colors">Reset to Default</button>
          <button id="close-custom-colors" style="margin-left: 10px;">Close</button>
        </div>
      </div>
    </details>

    <!-- Section 5: Export/Import -->
    <details class="control-section">
      <summary>Export / Import</summary>
      <div class="control-section-content">
        <div class="export-group">
          <span class="export-group-label">Images</span>
          <button id="export-pdf" class="btn-utility" style="font-size: 11px;">PDF</button>
          <button id="export-png" class="btn-utility" style="font-size: 11px;">PNG</button>
          <button id="export-tikz" class="btn-utility" style="font-size: 11px;">TikZ</button>
        </div>
        <div class="export-divider"></div>
        <div class="export-group">
          <span class="export-group-label">3D</span>
          <button id="export-stl" class="btn-utility" style="font-size: 11px;">STL Solid</button>
          <button id="export-stl-layer" class="btn-utility" style="font-size: 11px;">STL Layer</button>
          <button id="export-obj" class="btn-utility" style="font-size: 11px;">OBJ Solid</button>
          <button id="export-obj-layer" class="btn-utility" style="font-size: 11px;">OBJ Layer</button>
        </div>
        <div class="export-divider"></div>
        <div class="export-group">
          <span class="export-group-label">Data</span>
          <button id="export-json" class="btn-utility" style="font-size: 11px;">JSON</button>
          <button id="import-json" class="btn-utility" style="font-size: 11px;">Import JSON</button>
        </div>
        <div class="export-divider"></div>
        <div class="control-row">
          <label for="png-quality" style="font-size: 11px; color: #888;">PNG quality:</label>
          <input type="range" id="png-quality" min="0" max="100" value="85" style="width: 80px;">
          <span id="png-quality-value" style="font-family: 'SF Mono', Monaco, monospace; font-size: 11px;">85</span>
        </div>
        <div class="control-row">
          <label for="layer-thickness" style="font-size: 11px; color: #888;">Layer thickness:</label>
          <input type="range" id="layer-thickness" min="1" max="20" step="1" value="5" style="width: 80px;">
          <span id="layer-thickness-value" style="font-family: 'SF Mono', Monaco, monospace; font-size: 11px;">5</span>
        </div>
        <input type="file" id="json-file-input" accept=".json" style="display: none;">
        <div id="tikz-export-display" style="display: none; margin-top: 12px;">
          <div style="margin-bottom: 8px; font-weight: 600; color: #666;">TikZ Code:</div>
          <textarea id="tikz-export-textarea" readonly style="width: 100%; height: 300px; font-family: monospace; font-size: 11px; border: 1px solid #ccc; border-radius: 4px; padding: 10px; resize: vertical; background: #f8f9fa;"></textarea>
          <div style="margin-top: 8px; display: flex; gap: 8px;">
            <button id="copy-tikz-clipboard">Copy TikZ to Clipboard</button>
            <button id="download-tikz-file">Download TikZ File</button>
            <button id="hide-tikz-export">Hide</button>
          </div>
        </div>
      </div>
    </details>

  </div><!-- end controls-panel-inner -->
</aside>

<!-- Right: Visualization Panel -->
<main class="visualization-panel">
  <div id="canvas-container" style="position: relative;">
    <!-- View Toggle overlay -->
    <div id="view-overlay" style="position: absolute; top: 8px; right: 8px; z-index: 100; display: flex; align-items: center; gap: 6px;">
      <div class="view-toggle">
        <button id="toggle-view-overlay" title="Toggle 2D/3D (V)">3D</button>
      </div>
      <div class="view-toggle">
        <button id="toggle-ortho-overlay" class="active" title="Perspective">Pers</button>
        <button id="toggle-ortho-overlay-alt" title="Orthographic">Ortho</button>
      </div>
      <button id="helpBtn" class="help-circle-btn" title="Keyboard shortcuts (?)" aria-label="Show keyboard shortcuts">?</button>
    </div>

    <!-- 2D Visualization (hidden) -->
    <canvas id="lozenge-canvas" style="display: none;"></canvas>

    <!-- 3D Visualization (default) -->
    <div id="three-container">
      <canvas id="three-canvas"></canvas>
    </div>

    <!-- Config + Legend footer strip -->
    <div class="canvas-footer" id="config-details" data-always-open="true">
      <div class="canvas-footer-row" id="info">
        <span class="config-item">N = <strong>40</strong></span>
        <span class="config-item">T = <strong>80</strong></span>
        <span class="config-item">S = <strong>10</strong></span>
        <span class="config-item">q = <strong>1</strong></span>
      </div>
      <div class="canvas-footer-row" id="legend-details" data-always-open="true">
        <span class="legend-item">
          <span class="color-box" style="background-color: #E57200;"></span>
          Up
        </span>
        <span class="legend-item">
          <span class="color-box" style="background-color: #232D4B;"></span>
          Down
        </span>
        <span class="legend-item">
          <span class="color-box" style="background-color: #F9DCBF;"></span>
          Horizontal
        </span>
        <span class="legend-item">
          <span class="color-box" style="background-color: #666666; border: 1px solid #333;"></span>
          Border
        </span>
      </div>
    </div>
  </div>
</main>

</div><!-- end simulation-layout -->

<!-- Mobile FAB -->
<button id="sampleFab" class="sample-fab" aria-label="Initialize" data-tooltip="Initialize (I)">▶</button>

<!-- Export Modal -->
<div id="export-modal" class="export-modal">
  <div class="export-modal-content">
    <span class="close-modal">&times;</span>
    <h3>Export Plane Partition</h3>
    <p>Matrix representation of the plane partition:</p>
    <textarea id="export-textarea" class="export-textarea" readonly></textarea>
    <div class="export-buttons">
      <button id="copy-to-clipboard">Copy to Clipboard</button>
      <button id="download-file">Download File</button>
      <button id="close-export">Close</button>
    </div>
  </div>
</div>

<!-- Keyboard Shortcuts Help Modal -->
<div id="keyboardHelpModal" class="keyboard-help-modal" role="dialog" aria-labelledby="keyboard-help-title" aria-modal="true">
  <div class="keyboard-help-content">
    <h3 id="keyboard-help-title">Keyboard Shortcuts</h3>
    <h4 style="margin: 12px 0 8px 0; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: #666;">Animation</h4>
    <table>
      <tr><td><kbd>A</kbd></td><td>S → S+r</td></tr>
      <tr><td><kbd>Z</kbd></td><td>S → S-r</td></tr>
      <tr><td><kbd>S</kbd></td><td>S → S+r → S-r</td></tr>
      <tr><td><kbd>X</kbd></td><td>S → S-r → S+r</td></tr>
    </table>
    <h4 style="margin: 16px 0 8px 0; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: #666;">View</h4>
    <table>
      <tr><td><kbd>V</kbd></td><td>Toggle 2D/3D view</td></tr>
      <tr><td><kbd>R</kbd></td><td>Reset camera (3D only)</td></tr>
      <tr><td><kbd>Shift</kbd>+Drag</td><td>Pan camera (3D only)</td></tr>
    </table>
    <h4 style="margin: 16px 0 8px 0; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: #666;">Colors</h4>
    <table>
      <tr><td><kbd>C</kbd></td><td>Next color palette</td></tr>
      <tr><td><kbd>Shift</kbd>+<kbd>C</kbd></td><td>Previous color palette</td></tr>
      <tr><td><kbd>P</kbd></td><td>Permute colors</td></tr>
      <tr><td><kbd>B</kbd></td><td>Cycle border style</td></tr>
    </table>
    <button class="close-btn" id="closeKeyboardHelp">Close</button>
  </div>
</div>

<!-- Hidden details for JS compatibility -->
<details id="keyboard-info-details" style="display: none;"></details>

<!-- New UI JavaScript: Drawer, Help Modal, FAB, Overlay buttons, Palette Grid -->
<script>
(function() {
  // ========================================================================
  // Mobile Bottom Sheet Drawer
  // ========================================================================
  const drawerHandle = document.getElementById('drawerHandle');
  const controlsPanel = document.getElementById('controlsPanel');

  if (drawerHandle && controlsPanel) {
    let drawerStartY = 0;
    let drawerStartTranslateY = 0;
    let isDragging = false;

    drawerHandle.addEventListener('touchstart', (e) => {
      if (window.innerWidth >= 992) return;
      isDragging = true;
      drawerStartY = e.touches[0].clientY;
      drawerStartTranslateY = controlsPanel.classList.contains('expanded') ? 0 : controlsPanel.offsetHeight - 60;
      controlsPanel.style.transition = 'none';
    }, { passive: true });

    drawerHandle.addEventListener('touchmove', (e) => {
      if (!isDragging || window.innerWidth >= 992) return;
      const deltaY = e.touches[0].clientY - drawerStartY;
      const newTranslateY = Math.max(0, Math.min(controlsPanel.offsetHeight - 60, drawerStartTranslateY + deltaY));
      controlsPanel.style.transform = `translateY(${newTranslateY}px)`;
    }, { passive: true });

    const endDrag = () => {
      if (!isDragging) return;
      isDragging = false;
      controlsPanel.style.transition = '';
      const transform = controlsPanel.style.transform;
      let currentTranslateY = 0;
      if (transform) {
        const match = transform.match(/translateY\(([^)]+)\)/);
        if (match) currentTranslateY = parseFloat(match[1]) || 0;
      }
      const threshold = controlsPanel.offsetHeight * 0.3;
      if (currentTranslateY < threshold) {
        controlsPanel.classList.add('expanded');
      } else {
        controlsPanel.classList.remove('expanded');
      }
      controlsPanel.style.transform = '';
    };

    drawerHandle.addEventListener('touchend', endDrag, { passive: true });
    drawerHandle.addEventListener('touchcancel', endDrag, { passive: true });

    drawerHandle.addEventListener('click', () => {
      if (window.innerWidth >= 992) return;
      controlsPanel.classList.toggle('expanded');
    });
  }

  // ========================================================================
  // Keyboard Shortcuts Help Modal
  // ========================================================================
  const keyboardHelpModal = document.getElementById('keyboardHelpModal');
  const closeKeyboardHelp = document.getElementById('closeKeyboardHelp');
  const helpBtn = document.getElementById('helpBtn');

  function showKeyboardHelp() {
    if (keyboardHelpModal) keyboardHelpModal.classList.add('visible');
  }

  function hideKeyboardHelp() {
    if (keyboardHelpModal) keyboardHelpModal.classList.remove('visible');
  }

  if (closeKeyboardHelp) closeKeyboardHelp.addEventListener('click', hideKeyboardHelp);
  if (keyboardHelpModal) keyboardHelpModal.addEventListener('click', (e) => {
    if (e.target === keyboardHelpModal) hideKeyboardHelp();
  });
  if (helpBtn) helpBtn.addEventListener('click', showKeyboardHelp);

  // '?' key opens help, Escape closes it
  document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
    if (e.key === '?' || (e.shiftKey && e.key === '/')) {
      e.preventDefault();
      showKeyboardHelp();
    }
    if (e.key === 'Escape') {
      hideKeyboardHelp();
    }
  });

  // ========================================================================
  // View Overlay Buttons (wire to existing sidebar buttons)
  // ========================================================================
  const toggleViewOverlay = document.getElementById('toggle-view-overlay');
  const toggleOrthoOverlay = document.getElementById('toggle-ortho-overlay');
  const toggleOrthoOverlayAlt = document.getElementById('toggle-ortho-overlay-alt');

  if (toggleViewOverlay) {
    toggleViewOverlay.addEventListener('click', () => {
      const sidebarBtn = document.getElementById('toggle-view');
      if (sidebarBtn) sidebarBtn.click();
    });
  }

  if (toggleOrthoOverlay) {
    toggleOrthoOverlay.addEventListener('click', () => {
      const sidebarBtn = document.getElementById('toggle-ortho');
      if (sidebarBtn) sidebarBtn.click();
    });
  }

  if (toggleOrthoOverlayAlt) {
    toggleOrthoOverlayAlt.addEventListener('click', () => {
      const sidebarBtn = document.getElementById('toggle-ortho');
      if (sidebarBtn) sidebarBtn.click();
    });
  }

  // ========================================================================
  // Mobile FAB (triggers Initialize)
  // ========================================================================
  const sampleFab = document.getElementById('sampleFab');
  if (sampleFab) {
    sampleFab.addEventListener('click', () => {
      const initBtn = document.getElementById('initialize');
      if (initBtn) initBtn.click();
    });
  }

  // ========================================================================
  // Palette Picker Grid
  // ========================================================================
  function buildPaletteGrid() {
    const grid = document.getElementById('palettePickerGrid');
    if (!grid || typeof window.ColorSchemes === 'undefined') return;

    grid.innerHTML = '';
    window.ColorSchemes.forEach((scheme, index) => {
      const item = document.createElement('div');
      item.className = 'palette-item' + (index === 0 ? ' active' : '');
      item.setAttribute('role', 'option');
      item.setAttribute('aria-label', scheme.name);
      item.title = scheme.name;

      const colors = scheme.colors || [];
      for (let i = 0; i < 3; i++) {
        const swatch = document.createElement('div');
        swatch.className = 'swatch';
        swatch.style.backgroundColor = colors[i] || '#ccc';
        item.appendChild(swatch);
      }

      item.addEventListener('click', () => {
        // Update palette-select
        const select = document.getElementById('palette-select');
        if (select) {
          select.value = index;
          select.dispatchEvent(new Event('change'));
        }
        // Update active state
        grid.querySelectorAll('.palette-item').forEach(p => p.classList.remove('active'));
        item.classList.add('active');
      });

      grid.appendChild(item);
    });
  }

  // Build grid when ColorSchemes is available
  if (typeof window.ColorSchemes !== 'undefined') {
    buildPaletteGrid();
  } else {
    // Wait a bit for scripts to load
    const checkInterval = setInterval(() => {
      if (typeof window.ColorSchemes !== 'undefined') {
        clearInterval(checkInterval);
        buildPaletteGrid();
      }
    }, 200);
    // Stop checking after 5s
    setTimeout(() => clearInterval(checkInterval), 5000);
  }

  // Update grid when palette changes
  const paletteSelect = document.getElementById('palette-select');
  if (paletteSelect) {
    paletteSelect.addEventListener('change', () => {
      const grid = document.getElementById('palettePickerGrid');
      if (!grid) return;
      const items = grid.querySelectorAll('.palette-item');
      items.forEach((item, i) => {
        item.classList.toggle('active', i === parseInt(paletteSelect.value));
      });
    });
  }

  // ========================================================================
  // Ensure "About this Simulation" is always closed by default
  // ========================================================================
  const aboutDetails = document.getElementById('about-simulation-details');
  if (aboutDetails) aboutDetails.removeAttribute('open');
})();
</script>

<script>
// Check if Module is defined before setting onRuntimeInitialized
if (typeof Module === 'undefined') {
    window.Module = { onRuntimeInitialized: function() {} };
}

Module.onRuntimeInitialized = async function() {
    // WASM Interface Class
    class WASMInterface {
        constructor() {
            this.ready = false;
            this.N_param = 40;
            this.T_param = 80;
            this.S_param = 0;
            this.mode_param = 5;
            this.q_param = 1.0;
            this.paths = [];
        }

        async initialize() {
            if (typeof Module === 'undefined') {
                throw new Error('Module is not defined. WASM JavaScript file may not be loaded.');
            }
            if (typeof Module.cwrap !== 'function') {
                throw new Error('Module.cwrap is not a function. WASM module may not be properly initialized.');
            }

            // Wrap exported functions
            this.initializeTiling = Module.cwrap('initializeTiling', 'number', ['number', 'number', 'number', 'number', 'number'], {async: true});
            this.performSOperator = Module.cwrap('performSOperator', 'number', [], {async: true});
            this.performSMinusOperator = Module.cwrap('performSMinusOperator', 'number', [], {async: true});
            this.exportPaths = Module.cwrap('exportPaths', 'number', [], {async: true});
            this.updateParameters = Module.cwrap('updateParameters', 'number', ['number', 'number'], {async: true});
            this.setImaginaryQ = Module.cwrap('setImaginaryQ', null, ['number']);
            this.freeString = Module.cwrap('freeString', null, ['number']);
            this.getProgress = Module.cwrap('getProgress', 'number', []);

            this.ready = true;
        }

        async initializeTilingWasm(params) {
            if (!this.ready) throw new Error('WASM not ready');

            this.N_param = params.N;
            this.T_param = params.T;
            this.S_param = params.S;
            this.mode_param = params.mode;
            this.q_param = params.q;

            try {
                const ptr = await this.initializeTiling(params.N, params.T, params.S, params.mode, params.q);
                if (!ptr) {
                    throw new Error('initializeTiling returned null pointer');
                }
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`Initialization failed: ${error.message}`);
            }
        }

        async stepForward() {
            if (!this.ready) throw new Error('WASM not ready');
            if (this.S_param >= this.T_param) throw new Error('Cannot perform S→S+1: already at maximum');

            try {
                const ptr = await this.performSOperator();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                this.S_param = result.s;
                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`S operator failed: ${error.message}`);
            }
        }

        async stepBackward() {
            if (!this.ready) throw new Error('WASM not ready');
            if (this.S_param <= 0) throw new Error('Cannot perform S→S-1: already at minimum');

            try {
                const ptr = await this.performSMinusOperator();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                this.S_param = result.s;
                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`S- operator failed: ${error.message}`);
            }
        }

        async refreshPaths() {
            try {
                const ptr = await this.exportPaths();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (!result.error) {
                    this.paths = result.paths;
                }
            } catch (error) {
                // silently ignore
            }
        }

        getPaths() {
            return this.paths;
        }

        getParameters() {
            return {
                N: this.N_param,
                T: this.T_param,
                S: this.S_param,
                mode: this.mode_param,
                q: this.q_param
            };
        }

        async updateParametersWasm(params) {
            if (!this.ready) throw new Error('WASM not ready');

            try {
                const ptr = await this.updateParameters(params.mode, params.q);

                // Check if ptr is a valid pointer or an error code
                if (!ptr || ptr < 1000) {
                    throw new Error(`WASM function returned error code: ${ptr}`);
                }

                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                // Check if we got a valid JSON string
                if (!jsonStr || jsonStr.trim() === '') {
                    throw new Error('WASM function returned empty response');
                }

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                this.mode_param = params.mode;
                this.q_param = params.q;
                return result;
            } catch (error) {
                const errorMessage = error?.message || error?.toString() || 'Unknown error';
                throw new Error(`Parameter update failed: ${errorMessage}`);
            }
        }
    }

    // 2D Tiling Visualizer Class (full-featured)
    class TilingVisualizer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.style = 1; // Default: lozenges
            this.borderWidth = 0.01; // Default border width

            this.colors = {
                gray1: '#E57200', // UVA Orange (up rhombi)
                gray2: '#232D4B', // UVA Blue (down rhombi)
                gray3: '#F9DCBF', // UVA Orange 25% (horizontal rhombi)
                border: '#666666', // Default border color
                black: '#000000',
                white: '#FFFFFF'
            };
            this.customBorderColor = null; // Track if user has set custom border color

            this.currentPalette = 'UVA Colors';
            this.currentPaletteIndex = 0;

            // Color permutation state (0-5 for 6 possible permutations)
            this.currentPermutation = 0;

            // Zoom and pan for 2D
            this.zoomLevel = 1.0;
            this.panX = 0;
            this.panY = 0;
        }

        // Color palette management
        setPalette(paletteIndex) {
            if (typeof window.ColorSchemes === 'undefined') {
                return;
            }

            this.currentPaletteIndex = paletteIndex;
            const palette = window.ColorSchemes[paletteIndex];
            if (palette && palette.colors) {
                this.colors.gray1 = palette.colors[0];
                this.colors.gray2 = palette.colors[1];
                this.colors.gray3 = palette.colors[2];

                // Only update border color if it hasn't been customized
                if (!this.customBorderColor) {
                    this.colors.border = '#666666'; // Default border color
                }

                this.currentPalette = palette.name;
                this.updateColorSwatches();
            }
        }

        cyclePalette(direction = 1) {
            if (typeof window.ColorSchemes === 'undefined') return;

            const newIndex = (this.currentPaletteIndex + direction + window.ColorSchemes.length) % window.ColorSchemes.length;
            this.setPalette(newIndex);

            // Update the select element
            const paletteSelect = document.getElementById('palette-select');
            if (paletteSelect) {
                paletteSelect.value = newIndex;
            }
        }

        permuteColors() {
            // Cycle through 6 permutations of the 3 main colors
            this.currentPermutation = (this.currentPermutation + 1) % 6;

            const baseColors = [this.colors.gray1, this.colors.gray2, this.colors.gray3];
            const permutations = [
                [0, 1, 2], // Original
                [0, 2, 1], // Swap gray2 and gray3
                [1, 0, 2], // Swap gray1 and gray2
                [1, 2, 0], // Rotate left
                [2, 0, 1], // Rotate right
                [2, 1, 0]  // Reverse
            ];

            const perm = permutations[this.currentPermutation];
            this.colors.gray1 = baseColors[perm[0]];
            this.colors.gray2 = baseColors[perm[1]];
            this.colors.gray3 = baseColors[perm[2]];

            this.updateColorSwatches();
        }

        updateColorSwatches() {
            const swatches = {
                'swatch-gray1': this.colors.gray1,
                'swatch-gray2': this.colors.gray2,
                'swatch-gray3': this.colors.gray3,
                'swatch-border': this.colors.border
            };

            for (const [id, color] of Object.entries(swatches)) {
                const element = document.getElementById(id);
                if (element) {
                    element.style.backgroundColor = color;
                }
            }

            // Update palette info
            const paletteInfo = document.getElementById('palette-info');
            if (paletteInfo) {
                paletteInfo.textContent = this.currentPalette;
            }
        }

        setCustomColor(colorType, color) {
            this.colors[colorType] = color;
            if (colorType === 'border') {
                this.customBorderColor = color;
            }
            this.currentPalette = 'Custom';
            this.updateColorSwatches();
        }

        setBorderWidth(width) {
            this.borderWidth = Math.max(0, Math.min(0.2, width));
        }

        cycleBorderWidth() {
            const widths = [0.001, 0.01, 0.03, 0.06]; // thin, medium, thick, ultra thick
            const currentIndex = widths.findIndex(w => Math.abs(w - this.borderWidth) < 0.001) || 0;
            const nextIndex = (currentIndex + 1) % widths.length;
            this.setBorderWidth(widths[nextIndex]);

            // Update the input element
            const borderInput = document.getElementById('border-width');
            if (borderInput) {
                borderInput.value = this.borderWidth;
            }
        }

        zoom(factor) {
            this.zoomLevel *= factor;
            this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
        }

        resetZoom() {
            this.zoomLevel = 1.0;
            this.panX = 0;
            this.panY = 0;
        }

        setStyle(styleValue) {
            this.style = styleValue;
        }

        updateCanvasDimensions(N, T, S) {
            const sqrt3 = Math.sqrt(3);

            // Calculate the bounding box of the hexagon
            const minX = 0;
            const maxX = T * 0.5 * sqrt3;
            const minY = -(T - S) * 0.5;
            const maxY = N + Math.max(S * 0.5, (2 * S - T) * 0.5);

            const hexWidth = maxX - minX;
            const hexHeight = maxY - minY;

            // Calculate appropriate scale to fit the hexagon nicely
            const maxCanvasWidth = Math.min(1200, window.innerWidth * 0.9);
            const maxCanvasHeight = Math.min(800, window.innerHeight * 0.8);

            const scaleX = maxCanvasWidth / hexWidth;
            const scaleY = maxCanvasHeight / hexHeight;
            const scale = Math.min(scaleX, scaleY) * 0.8; // Use 80% of max scale for padding

            const canvasWidth = Math.max(400, hexWidth * scale);
            const canvasHeight = Math.max(300, hexHeight * scale);

            // Set canvas size accounting for device pixel ratio
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = canvasWidth * dpr;
            this.canvas.height = canvasHeight * dpr;
            this.canvas.style.width = canvasWidth + 'px';
            this.canvas.style.height = canvasHeight + 'px';

            // Scale context for high DPI displays
            this.ctx.scale(dpr, dpr);
        }

        draw(paths, N, T, S) {
            // Update canvas dimensions to fit hexagon exactly
            this.updateCanvasDimensions(N, T, S);

            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = this.colors.white;
            ctx.fillRect(0, 0, width, height);

            if (this.style === 5) {
                this.drawLatticePathsStyle(paths, N, T, S);
            } else {
                this.drawHexagonStyle(paths, N, T, S);
            }
        }

        drawHexagonStyle(paths, N, T, S) {
            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            const sqrt3 = Math.sqrt(3);

            // Calculate the bounding box of the hexagon
            const minX = 0;
            const maxX = T * 0.5 * sqrt3;
            const minY = -(T - S) * 0.5;
            const maxY = N + Math.max(S * 0.5, (2 * S - T) * 0.5);

            const hexWidth = maxX - minX;
            const hexHeight = maxY - minY;
            const hexCenterX = (minX + maxX) / 2;
            const hexCenterY = (minY + maxY) / 2;

            const margin = 0; // No margin - fit hexagon exactly
            const scale = Math.min(
                (width - 2 * margin) / hexWidth,
                (height - 2 * margin) / hexHeight
            ) * this.zoomLevel;

            ctx.save();
            ctx.translate(this.panX, this.panY);
            ctx.translate(width / 2, height / 2);
            ctx.scale(-scale, scale);  // Flip horizontally with negative x scale
            // Center the hexagon
            ctx.translate(-hexCenterX, -hexCenterY);

            this.drawBackgroundHexagon(N, T, S);

            for (let i = 0; i < T; i++) {
                for (let j = 0; j < N; j++) {
                    const currentHeight = paths[j][i];
                    const nextHeight = paths[j][i + 1];
                    this.drawRhombus(i, j, currentHeight, nextHeight);
                }
            }

            // Draw paths on top of the tiling
            this.drawPathsOverlay(paths, N, T, S);

            ctx.restore();
        }

        drawBackgroundHexagon(N, T, S) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            // First, clip to the hexagon shape
            const vertices = [
                {x: 0, y: 0},
                {x: 0, y: N},
                {x: S * 0.5 * sqrt3, y: N + S * 0.5},
                {x: T * 0.5 * sqrt3, y: N + (2 * S - T) * 0.5},
                {x: T * 0.5 * sqrt3, y: (2 * S - T) * 0.5},
                {x: (T - S) * 0.5 * sqrt3, y: -(T - S) * 0.5}
            ];

            ctx.save();

            // Create clipping path
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < 6; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.clip();

            // Draw background rhombi with borders aligned to lozenge grid
            for (let timeIdx = -1; timeIdx <= T; timeIdx++) {
                for (let height = -(T - S + 2); height <= N + S + 2; height++) {
                    // Use the same coordinate system as the actual rhombi
                    const x1 = timeIdx * 0.5 * sqrt3;
                    const y1 = height - timeIdx * 0.5;

                    // Calculate rhombus center for bounds checking
                    const centerX = x1 + 0.25 * sqrt3;
                    const centerY = y1 + 0.5;

                    // Check if rhombus center is roughly within bounds
                    if (centerX >= -0.5 * sqrt3 && centerX <= (T + 1) * 0.5 * sqrt3 &&
                        centerY >= -(T - S + 2) * 0.5 && centerY <= N + S + 1) {

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x1+0.5 * sqrt3, y1 + 0.5);
                        ctx.lineTo(x1 + sqrt3, y1);
                        ctx.lineTo(x1 + 0.5 * sqrt3, y1 - 0.5);
                        ctx.closePath();

                        ctx.fillStyle = this.colors.gray3;
                        ctx.fill();

                        ctx.strokeStyle = this.colors.border;
                        ctx.lineWidth = this.borderWidth;
                        ctx.stroke();
                    }
                }
            }

            ctx.restore();
        }

        drawRhombus(timeIdx, particleIdx, height, nextHeight) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            const x1 = timeIdx * 0.5 * sqrt3;
            const y1 = height - timeIdx * 0.5;
            const x2 = x1;
            const y2 = y1 + 1;

            let x3, y3, x4, y4;
            let fillColor;

            if (nextHeight === height) {
                // Down rhombus
                x3 = x2 + 0.5 * sqrt3;
                y3 = y2 - 0.5;
                x4 = x1 + 0.5 * sqrt3;
                y4 = y1 - 0.5;
                fillColor = this.colors.gray1;
            } else {
                // Up rhombus
                x3 = x2 + 0.5 * sqrt3;
                y3 = y2 + 0.5;
                x4 = x1 + 0.5 * sqrt3;
                y4 = y1 + 0.5;
                fillColor = this.colors.gray2;
            }

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.lineTo(x4, y4);
            ctx.closePath();

            ctx.fillStyle = fillColor;
            ctx.fill();

            // Add consistent thin borders to all rhombi
            ctx.strokeStyle = this.colors.border;
            ctx.lineWidth = this.borderWidth;
            ctx.stroke();
        }

        drawPathsOverlay(paths, N, T, S) {
            // Only draw paths for lattice paths style (style 5), not for lozenges
            if (this.style !== 5) return;

            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            // Draw paths as lines overlaid on the hexagon tiling
            ctx.save();

            // Draw each path
            for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
                const path = paths[pathIdx];

                ctx.beginPath();
                ctx.strokeStyle = '#FF0000';  // Red color for paths
                ctx.lineWidth = 0.05;
                ctx.fillStyle = '#FF0000';

                for (let timeIdx = 0; timeIdx < path.length; timeIdx++) {
                    const height = path[timeIdx];

                    // Convert to hexagon coordinates (same as rhombus coordinates)
                    const x = timeIdx * 0.5 * sqrt3;
                    const y = height - timeIdx * 0.5;

                    if (timeIdx === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    // Draw a small circle at each point
                    ctx.fillRect(x - 0.03, y - 0.03, 0.06, 0.06);
                }

                ctx.stroke();
            }

            ctx.restore();
        }

        drawLatticePathsStyle(paths, N, T, S) {
            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            const margin = 20; // Smaller margin for lattice paths
            const scaleX = (width - 2 * margin) / (T + 5);
            const scaleY = (height - 2 * margin) / (N + S + 5);
            const scale = Math.min(scaleX, scaleY) * this.zoomLevel;

            const maxY = N + S - 1;

            ctx.save();
            ctx.translate(this.panX + margin, this.panY + height - margin);
            ctx.scale(scale, -scale);

            ctx.fillStyle = this.colors.gray3;
            for (let i = 0; i <= T; i++) {
                for (let j = 0; j <= maxY; j++) {
                    ctx.fillRect(i - 0.1, j - 0.1, 0.2, 0.2);
                }
            }

            ctx.strokeStyle = this.colors.black;
            ctx.lineWidth = this.borderWidth;
            ctx.fillStyle = this.colors.black;

            for (let j = 0; j < N; j++) {
                ctx.beginPath();

                for (let i = 0; i <= T; i++) {
                    const x = i;
                    const y = paths[j][i];

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    ctx.fillRect(x - 0.05, y - 0.05, 0.1, 0.1);
                }

                ctx.stroke();
            }

            ctx.restore();
        }
    }

    // 3D Tiling Visualizer Class (enhanced with color palette support)
    class Tiling3DVisualizer {
        constructor(container) {
            this.container = container;
            this.colors = {
                gray1: '#E57200', // UVA Orange (up rhombi)
                gray2: '#232D4B', // UVA Blue (down rhombi)
                gray3: '#F9DCBF', // UVA Orange 25% (horizontal rhombi)
                border: '#666666' // Default border color
            };
            this.cameraInitialized = false;
            this.demoMode = false;
            this.rotationSpeed = 0.05;

            // Three.js setup
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0xffffff);

            // Camera (start with perspective)
            this.isPerspective = true;
            this.camera = new THREE.PerspectiveCamera(
                45,
                container.clientWidth / container.clientHeight,
                0.1,
                10000
            );

            // Set Z-axis as up
            this.camera.up.set(0, 0, 1);

            // Renderer
            this.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('three-canvas'),
                antialias: true
            });
            this.renderer.setSize(container.clientWidth, container.clientHeight);

            // Controls
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;
            this.controls.enablePan = true;
            this.controls.panSpeed = 1.0;
            this.controls.screenSpacePanning = false; // Use object space panning

            // Set up mouse buttons - by default, left = rotate, right = pan, middle = zoom
            this.controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };

            // Enable shift-drag for panning
            this.setupShiftDragPanning();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            this.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight.position.set(10, 10, 10);
            this.scene.add(directionalLight);

            // Group for rhombi
            this.boxGroup = new THREE.Group();
            this.scene.add(this.boxGroup);

            // Handle window resize
            window.addEventListener('resize', () => this.handleResize());

            // Start animation loop
            this.animate();
        }

        setupShiftDragPanning() {
            // Track shift key state
            this.shiftPressed = false;

            // Listen for shift key press/release
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Shift' && !this.shiftPressed) {
                    this.shiftPressed = true;
                    // When shift is pressed, swap left mouse to pan
                    this.controls.mouseButtons.LEFT = THREE.MOUSE.PAN;
                }
            });

            window.addEventListener('keyup', (e) => {
                if (e.key === 'Shift' && this.shiftPressed) {
                    this.shiftPressed = false;
                    // Restore left mouse to rotate
                    this.controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
                }
            });

            // Also handle when window loses focus (to reset shift state)
            window.addEventListener('blur', () => {
                if (this.shiftPressed) {
                    this.shiftPressed = false;
                    this.controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
                }
            });
        }

        // Color palette support for 3D
        updateColors(colors) {
            this.colors = { ...colors };
            // Rebuild the geometry if it exists
            if (this.boxGroup && this.boxGroup.children.length > 0) {
                // Will be rebuilt on next pathsTo3D call
            }
        }

        handleResize() {
            const width = this.container.clientWidth;
            const height = this.container.clientHeight;

            if (this.isPerspective) {
                this.camera.aspect = width / height;
            } else {
                // Orthographic camera - maintain frustum size but update aspect
                const aspect = width / height;
                const frustumHeight = (this.camera.top - this.camera.bottom);
                this.camera.left = -frustumHeight * aspect / 2;
                this.camera.right = frustumHeight * aspect / 2;
            }
            this.camera.updateProjectionMatrix();

            this.renderer.setSize(width, height);
        }

        togglePerspective() {
            const w = this.container.clientWidth;
            const h = this.container.clientHeight;
            const oldPosition = this.camera.position.clone();
            const oldTarget = this.controls.target.clone();

            if (this.isPerspective) {
                // Switch to orthographic camera
                const frustum = 100;
                const aspect = w / h;
                this.camera = new THREE.OrthographicCamera(
                    -frustum * aspect / 2, frustum * aspect / 2,
                    frustum / 2, -frustum / 2,
                    0.1, 10000
                );
            } else {
                // Switch to perspective camera
                this.camera = new THREE.PerspectiveCamera(
                    45, w / h, 0.1, 10000
                );
            }

            // Restore camera state
            this.camera.up.set(0, 0, 1);
            this.camera.position.copy(oldPosition);

            // Update controls with new camera
            this.controls.object = this.camera;
            this.controls.target.copy(oldTarget);
            this.controls.update();

            this.isPerspective = !this.isPerspective;
            return this.isPerspective;
        }

        pathsTo3D(paths, N, T, S) {
            // Store parameters for use in horizontal lozenge calculations
            this.currentN = N;
            this.currentT = T;
            this.currentS = S;

            // Clear existing geometry
            while(this.boxGroup.children.length > 0) {
                const child = this.boxGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                this.boxGroup.remove(child);
            }

            // Convert paths to triplet format (normal WASM mode)
            const pathTriplets = [];
            for (let i = 0; i < paths.length; i++) {
                const pathCopy = paths[i].slice().reverse();
                const firstElement = pathCopy[0];
                const adjustedPath = pathCopy.map(x => firstElement - x);

                const triplets = [];
                let x = 0, y = 0;
                const z = paths.length - i; // z-coordinate is constant for each path

                // Start with initial triplet
                triplets.push([x, y, z]);

                // Process each step in the path
                for (let j = 1; j < adjustedPath.length; j++) {
                    const prev = adjustedPath[j-1];
                    const curr = adjustedPath[j];

                    if (curr === prev + 1) {
                        // Path goes up by 1, increment first coordinate
                        x++;
                    } else if (curr === prev) {
                        // Path stays the same, increment second coordinate
                        y++;
                    }
                    triplets.push([x, y, z]);
                }
                pathTriplets.push(triplets);
            }

            // Create geometry for the surface
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const colors = [];
            const indices = [];

            // Helper to add a square face
            const addSquareFace = (v1, v2, v3, v4, color) => {
                const baseIndex = vertices.length / 3;

                // Add vertices (swap X and Y)
                vertices.push(v1[1], v1[0], v1[2]);
                vertices.push(v2[1], v2[0], v2[2]);
                vertices.push(v3[1], v3[0], v3[2]);
                vertices.push(v4[1], v4[0], v4[2]);

                // Calculate normal (swap X and Y)
                const edge1 = [v2[1] - v1[1], v2[0] - v1[0], v2[2] - v1[2]];
                const edge2 = [v3[1] - v1[1], v3[0] - v1[0], v3[2] - v1[2]];
                const normal = [
                    edge1[1] * edge2[2] - edge1[2] * edge2[1],
                    edge1[2] * edge2[0] - edge1[0] * edge2[2],
                    edge1[0] * edge2[1] - edge1[1] * edge2[0]
                ];
                const len = Math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2);
                if (len > 0) {
                    normal[0] /= len;
                    normal[1] /= len;
                    normal[2] /= len;
                }

                // Add normals
                for (let i = 0; i < 4; i++) {
                    normals.push(normal[0], normal[1], normal[2]);
                }

                // Add colors
                const c = new THREE.Color(color);
                for (let i = 0; i < 4; i++) {
                    colors.push(c.r, c.g, c.b);
                }

                // Add triangles
                indices.push(
                    baseIndex, baseIndex + 1, baseIndex + 2,
                    baseIndex, baseIndex + 2, baseIndex + 3
                );
            };

            // Create strips between consecutive paths (skip path -1 for vertical lozenges)
            for (let pathIdx = 1; pathIdx < pathTriplets.length; pathIdx++) {
                const topPath = pathTriplets[pathIdx];

                // Create bottom path by lowering z by 1
                const bottomPath = topPath.map(point => [point[0], point[1], point[2] - 1]);

                // Create strips between consecutive segments
                for (let i = 0; i < topPath.length - 1; i++) {
                    const topP1 = topPath[i];
                    const topP2 = topPath[i + 1];
                    const bottomP1 = bottomPath[i];
                    const bottomP2 = bottomPath[i + 1];

                    // Determine color based on segment direction
                    let color;
                    if (topP2[0] > topP1[0] && topP2[1] === topP1[1]) {
                        // x increases, y constant -> "up" rhombus
                        color = this.colors.gray2;
                    } else if (topP2[0] === topP1[0] && topP2[1] > topP1[1]) {
                        // x constant, y increases -> "down" rhombus
                        color = this.colors.gray1;
                    } else {
                        // Shouldn't happen with valid paths
                        color = this.colors.gray3;
                    }

                    // Create strip as a quadrilateral
                    // topP1 -> topP2 -> bottomP2 -> bottomP1
                    addSquareFace(topP1, topP2, bottomP2, bottomP1, color);
                }
            }

            // Place horizontal lozenges at all height levels
            this.placeAllHorizontalLozenges(pathTriplets, addSquareFace);

            // Find the bounds of the surface for camera positioning (swap X and Y)
            let maxX = 0, maxY = 0, maxZ = 0;
            for (const path of pathTriplets) {
                for (const point of path) {
                    maxX = Math.max(maxX, point[1]);
                    maxY = Math.max(maxY, point[0]);
                    maxZ = Math.max(maxZ, point[2]);
                }
            }

            // Set geometry attributes
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);

            // Create material
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: true
            });

            const mesh = new THREE.Mesh(geometry, material);
            this.boxGroup.add(mesh);

            // Add edges
            const edgesGeometry = new THREE.EdgesGeometry(geometry, 1);
            const edgesMaterial = new THREE.LineBasicMaterial({
                color: this.colors.border,
                linewidth: 2
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            this.boxGroup.add(edges);

            // Only center camera on initial load, not on resampling
            if (!this.cameraInitialized) {
                this.centerCamera(maxX, maxY, maxZ);
                this.cameraInitialized = true;
            }
        }

        addHorizontalLozenges(pathTriplets, addSquareFace) {
            // Horizontal lozenges have constant z-component and lie in xy-planes between path levels
            // Implementation based on the Mathematica logic

            // Process consecutive path pairs
            for (let pathIdx = 0; pathIdx < pathTriplets.length - 1; pathIdx++) {
                const upperPath = pathTriplets[pathIdx];      // Higher z-level
                const lowerPath = pathTriplets[pathIdx + 1];  // Lower z-level

                // The horizontal squares lie at the z-level of the lower path
                const zLevel = lowerPath[0][2];

                // Extract xy-projections and find horizontal squares
                const horizontalSquares = this.findHorizontalSquaresBetweenPaths(upperPath, lowerPath, zLevel);

                // Add each horizontal square as a face
                for (const square of horizontalSquares) {
                    addSquareFace(square[0], square[1], square[2], square[3], this.colors.gray3);
                }
            }
        }

        findHorizontalSquaresBetweenPaths(upperPath, lowerPath, zLevel) {
            const horizontalSquares = [];

            // Extract xy-projections of the paths (ignore z-coordinate)
            const upperXY = upperPath.map(point => [point[0], point[1]]);
            const lowerXY = lowerPath.map(point => [point[0], point[1]]);

            // Implement extractLastFromIncreasing logic from Mathematica
            const extractLastFromIncreasing = (list) => {
                const result = [];
                let i = 0;
                while (i < list.length) {
                    let j = i;
                    // Find the end of increasing sequence
                    while (j + 1 < list.length && list[j] < list[j + 1]) {
                        j++;
                    }
                    result.push(list[j]); // Take the last element of the increasing sequence
                    i = j + 1;
                }
                return result;
            };

            // Extract x-coordinates for both paths
            const upperXList = upperXY.map(point => point[0]);
            const lowerXList = lowerXY.map(point => point[0]);

            // Apply extractLastFromIncreasing to both paths
            const upperXExtracted = extractLastFromIncreasing(upperXList);
            const lowerXExtracted = extractLastFromIncreasing(lowerXList);

            // Find intersection of the two lists (common x-values)
            const commonX = upperXExtracted.filter(x => lowerXExtracted.includes(x));

            // Similarly for y-coordinates
            const upperYList = upperXY.map(point => point[1]);
            const lowerYList = lowerXY.map(point => point[1]);

            const upperYExtracted = extractLastFromIncreasing(upperYList);
            const lowerYExtracted = extractLastFromIncreasing(lowerYList);

            const commonY = upperYExtracted.filter(y => lowerYExtracted.includes(y));

            // Create horizontal squares for all combinations of common x,y values
            // Each square is a 1x1 unit square in the xy-plane at the given z-level
            for (const x of commonX) {
                for (const y of commonY) {
                    // Check if this (x,y) position should have a horizontal square
                    // by verifying it's properly between the paths
                    if (this.shouldPlaceHorizontalSquare(x, y, upperXY, lowerXY)) {
                        // Create a 1x1 square at position (x,y) with z = zLevel
                        const square = [
                            [x, y, zLevel],         // bottom-left
                            [x + 1, y, zLevel],     // bottom-right
                            [x + 1, y + 1, zLevel], // top-right
                            [x, y + 1, zLevel]      // top-left
                        ];
                        horizontalSquares.push(square);
                    }
                }
            }

            return horizontalSquares;
        }

        shouldPlaceHorizontalSquare(x, y, upperPath, lowerPath) {
            // Check if a horizontal square at position (x,y) is valid
            // This is a simplified check - you may need to refine based on your specific rules

            // The square should be placed if both paths pass through or near this region
            const tolerance = 1.5; // Allow some tolerance for path proximity

            // Check if upper path passes near this region
            let upperNear = false;
            for (const point of upperPath) {
                if (Math.abs(point[0] - x) <= tolerance && Math.abs(point[1] - y) <= tolerance) {
                    upperNear = true;
                    break;
                }
            }

            // Check if lower path passes near this region
            let lowerNear = false;
            for (const point of lowerPath) {
                if (Math.abs(point[0] - x) <= tolerance && Math.abs(point[1] - y) <= tolerance) {
                    lowerNear = true;
                    break;
                }
            }

            return upperNear && lowerNear;
        }

        placeAllHorizontalLozenges(pathTriplets, addSquareFace) {
            // Algorithmic placement based on Mathematica logic
            // For each pair of consecutive paths, find horizontal lozenges between them

            const S = this.currentS;
            const T = this.currentT;
            const N = this.currentN;

            // Handle top boundary (above the first path at z=N)
            if (pathTriplets.length > 0) {
                const topZ = N;
                const firstPath = pathTriplets[0];

                // Top boundary path (extreme version of path 0 at same height)
                const topBoundary = [];
                for (let i = 0; i <= S; i++) {
                    topBoundary.push([i, 0, topZ]);
                }
                for (let i = 1; i <= T - S; i++) {
                    topBoundary.push([S, i, topZ]);
                }

                // Calculate horizontal lozenges between top boundary and first path
                const zLevel = topZ - 1;
                const horizontalMatrix = this.calculateHorizontalLozengeMatrix(topBoundary, firstPath, S, T);

                // Place squares where matrix value is 1
                for (let a = 0; a <= S; a++) {
                    for (let b = 0; b <= T - S; b++) {
                        if (a < horizontalMatrix.length && b < horizontalMatrix[a].length && horizontalMatrix[a][b] === 1) {
                            const square = [
                                [a, b, zLevel],         // bottom-left
                                [a + 1, b, zLevel],     // bottom-right
                                [a + 1, b + 1, zLevel], // top-right
                                [a, b + 1, zLevel]      // top-left
                            ];
                            addSquareFace(square[0], square[1], square[2], square[3], this.colors.gray3);
                        }
                    }
                }
            }

            // Handle middle paths (between consecutive actual paths)
            for (let pathIdx = 0; pathIdx < pathTriplets.length - 1; pathIdx++) {
                const upperPath = pathTriplets[pathIdx];      // Higher z-level path
                const lowerPath = pathTriplets[pathIdx + 1];  // Lower z-level path

                // The horizontal lozenges lie at z-level of upper path minus 1
                const zLevel = upperPath[0][2] - 1;

                // Calculate horizontal lozenges between these paths
                const horizontalMatrix = this.calculateHorizontalLozengeMatrix(upperPath, lowerPath, S, T);

                // Place squares where matrix value is 1
                for (let a = 0; a <= S; a++) {
                    for (let b = 0; b <= T - S; b++) {
                        if (a < horizontalMatrix.length && b < horizontalMatrix[a].length && horizontalMatrix[a][b] === 1) {
                            const square = [
                                [a, b, zLevel],         // bottom-left
                                [a + 1, b, zLevel],     // bottom-right
                                [a + 1, b + 1, zLevel], // top-right
                                [a, b + 1, zLevel]      // top-left
                            ];
                            addSquareFace(square[0], square[1], square[2], square[3], this.colors.gray3);
                        }
                    }
                }
            }

            // Handle bottom boundary (below the last path at z=0)
            if (pathTriplets.length > 0) {
                const lastPath = pathTriplets[pathTriplets.length - 1];

                // Bottom boundary path (extreme version of last path at height 0)
                const bottomBoundary = [];
                for (let i = 0; i <= T - S; i++) {
                    bottomBoundary.push([0, i, 0]);
                }
                for (let i = 1; i <= S; i++) {
                    bottomBoundary.push([i, T - S, 0]);
                }

                // Calculate horizontal lozenges between last path and bottom boundary
                const zLevel = 0;
                const horizontalMatrix = this.calculateHorizontalLozengeMatrix(lastPath, bottomBoundary, S, T);

                // Place squares where matrix value is 1
                for (let a = 0; a <= S; a++) {
                    for (let b = 0; b <= T - S; b++) {
                        if (a < horizontalMatrix.length && b < horizontalMatrix[a].length && horizontalMatrix[a][b] === 1) {
                            const square = [
                                [a, b, zLevel],         // bottom-left
                                [a + 1, b, zLevel],     // bottom-right
                                [a + 1, b + 1, zLevel], // top-right
                                [a, b + 1, zLevel]      // top-left
                            ];
                            addSquareFace(square[0], square[1], square[2], square[3], this.colors.gray3);
                        }
                    }
                }
            }
        }

        calculateHorizontalLozengeMatrix(upperPath, lowerPath, S, T) {
            // Implement the Mathematica logic: q[z] function and matrix calculation
            // Matrix dimensions: (S+1) rows (a=0 to S) × (T-S+1) columns (b=0 to T-S)
            const matrix = Array(S + 1).fill().map(() => Array(T - S + 1).fill(0));

            // Extract q[z] for both paths using extractLastFromIncreasing logic
            const upperQ = this.calculateQFunction(upperPath);
            const lowerQ = this.calculateQFunction(lowerPath);

            // Apply the condition: If[q[z][[b + 1]] > a >= q[z + 1][[b + 1]], 1, 0]
            for (let a = 0; a <= S; a++) {
                for (let b = 0; b <= T - S; b++) {
                    const upperVal = upperQ[b] || 0;  // q[z][[b + 1]] (1-indexed in Mathematica)
                    const lowerVal = lowerQ[b] || 0;  // q[z + 1][[b + 1]]

                    if (upperVal > a && a >= lowerVal) {
                        matrix[a][b] = 1;
                    }
                }
            }

            return matrix;
        }

        calculateQFunction(path) {
            // Implement: q[z] := Last /@ Split[Table[If[p[z][[i]][[1]] == p[z][[i]][[2]], p[z][[i]][[2]], p[z][[i]][[1]]], {i, 1, 11}], #1 < #2 &]

            // Step 1: Create the table - for each point, take x if x != y, otherwise take y
            const table = [];
            for (let i = 0; i < path.length; i++) {
                const [x, y, z] = path[i];
                if (x === y) {
                    table.push(y);
                } else {
                    table.push(x);
                }
            }

            // Step 2: Apply extractLastFromIncreasing (equivalent to Last /@ Split[..., #1 < #2 &])
            return this.extractLastFromIncreasing(table);
        }

        extractLastFromIncreasing(list) {
            const result = [];
            let i = 0;
            while (i < list.length) {
                let j = i;
                // Find the end of increasing sequence
                while (j + 1 < list.length && list[j] < list[j + 1]) {
                    j++;
                }
                result.push(list[j]); // Take the last element of the increasing sequence
                i = j + 1;
            }
            return result;
        }

        centerCamera(maxX, maxY, maxZ) {
            // Use ideal camera settings
            // Target: (34.1, 18.4, 11.4)
            // Camera: (74.3, -36.7, 58.8)
            // Distance: 83.1

            // Set controls target to the ideal position
            this.controls.target.set(25.2, 21.6, 11.4);

            // Set camera to ideal position
            this.camera.position.set(79.9, -53.4, 75.9);

            this.controls.update();

            // Add controls change listener to update UI
            this.controls.addEventListener('change', () => {
                this.updateCameraUI();
            });

            // Initial UI update
            this.updateCameraUI();
        }

        setDemoMode(enabled) {
            this.demoMode = enabled;
            // Keep controls enabled during demo mode for manual adjustment
            // The auto-rotation will pause when user interacts
        }

        animate() {
            requestAnimationFrame(() => this.animate());

            // Auto-rotate in demo mode - rotate camera around center
            if (this.demoMode) {
                const time = Date.now() * 0.001;
                const radius = Math.sqrt(
                    Math.pow(this.camera.position.x - this.controls.target.x, 2) +
                    Math.pow(this.camera.position.y - this.controls.target.y, 2)
                );
                const height = this.camera.position.z;

                // Rotate camera around the target point
                this.camera.position.x = this.controls.target.x + radius * Math.cos(time * this.rotationSpeed * 10);
                this.camera.position.y = this.controls.target.y + radius * Math.sin(time * this.rotationSpeed * 10);
                this.camera.position.z = height;

                this.camera.lookAt(this.controls.target);
            }

            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }

        getCameraInfo() {
            const dx = this.camera.position.x - this.controls.target.x;
            const dy = this.camera.position.y - this.controls.target.y;
            const dz = this.camera.position.z - this.controls.target.z;
            const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);

            return {
                position: {
                    x: this.camera.position.x,
                    y: this.camera.position.y,
                    z: this.camera.position.z
                },
                target: {
                    x: this.controls.target.x,
                    y: this.controls.target.y,
                    z: this.controls.target.z
                },
                distance: distance
            };
        }

        setCameraPosition(x, y, z, distance) {
            // Keep the same target, update camera position based on distance
            const target = this.controls.target.clone();

            // Calculate direction from target to new position
            const dx = x - target.x;
            const dy = y - target.y;
            const dz = z - target.z;
            const currentDist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            if (currentDist > 0) {
                // Normalize and scale by desired distance
                const scale = distance / currentDist;
                this.camera.position.set(
                    target.x + dx * scale,
                    target.y + dy * scale,
                    target.z + dz * scale
                );
            }

            this.controls.update();
        }

        updateCameraUI() {
            const info = this.getCameraInfo();

            // Update input fields
            document.getElementById('cam-x').value = info.position.x.toFixed(2);
            document.getElementById('cam-y').value = info.position.y.toFixed(2);
            document.getElementById('cam-z').value = info.position.z.toFixed(2);
            document.getElementById('cam-distance').value = info.distance.toFixed(2);

            // Update info text
            const infoText = `Camera: (${info.position.x.toFixed(1)}, ${info.position.y.toFixed(1)}, ${info.position.z.toFixed(1)}) | Target: (${info.target.x.toFixed(1)}, ${info.target.y.toFixed(1)}, ${info.target.z.toFixed(1)}) | Distance: ${info.distance.toFixed(1)}`;
            document.getElementById('camera-info').textContent = infoText;
        }
    }

    // Main Application
    const wasmInterface = new WASMInterface();
    let tilingVisualizer = null;
    let tiling3DVisualizer = null;
    let is3DView = true; // Default to 3D view

    // Populate palette dropdown from ColorSchemes
    function populatePaletteDropdown() {
        const select = document.getElementById('palette-select');
        if (!select || typeof window.ColorSchemes === 'undefined') return;

        select.innerHTML = '';
        window.ColorSchemes.forEach((scheme, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = scheme.name;
            select.appendChild(option);
        });
    }

    // Initialize
    async function init() {
        try {
            await wasmInterface.initialize();

            // Populate palette dropdown dynamically
            populatePaletteDropdown();

            // Initialize 2D visualizer
            const canvas = document.getElementById('lozenge-canvas');
            tilingVisualizer = new TilingVisualizer(canvas);

            // Initialize 3D visualizer
            const container = document.getElementById('three-container');
            tiling3DVisualizer = new Tiling3DVisualizer(container);

            // Initialize color swatches
            if (tilingVisualizer) {
                tilingVisualizer.updateColorSwatches();
            }

            // Initialize with default parameters
            await initializeTiling();

            // Update visualization
            updateVisualization();

            // DEBUG MODE (commented out):
            /*
            const debugPaths = [
                // p[-1] (top boundary) - at z=6
                [[0,0,6], [1,0,6], [2,0,6], [3,0,6], [4,0,6], [5,0,6], [6,0,6], [6,1,6], [6,2,6], [6,3,6], [6,4,6]],
                // p[0] - at z=5
                [[0,0,5], [1,0,5], [2,0,5], [2,1,5], [3,1,5], [3,2,5], [4,2,5], [5,2,5], [5,3,5], [6,3,5], [6,4,5]],
                // p[1] - at z=4
                [[0,0,4], [1,0,4], [2,0,4], [2,1,4], [3,1,4], [3,2,4], [3,3,4], [4,3,4], [5,3,4], [6,3,4], [6,4,4]],
                // p[2] - at z=3
                [[0,0,3], [0,1,3], [1,1,3], [2,1,3], [3,1,3], [3,2,3], [3,3,3], [4,3,3], [5,3,3], [5,4,3], [6,4,3]],
                // p[3] - at z=2
                [[0,0,2], [0,1,2], [0,2,2], [1,2,2], [2,2,2], [3,2,2], [3,3,2], [4,3,2], [4,4,2], [5,4,2], [6,4,2]],
                // p[4] (bottom) - at z=1
                [[0,0,1], [0,1,1], [0,2,1], [0,3,1], [0,4,1], [1,4,1], [2,4,1], [3,4,1], [4,4,1], [5,4,1], [6,4,1]]
            ];
            wasmInterface.N_param = 5;
            wasmInterface.T_param = 10;
            wasmInterface.S_param = 6;
            wasmInterface.q_param = 1.0;
            wasmInterface.paths = debugPaths;
            wasmInterface.ready = true;
            updateVisualization();
            */

            // Set up event listeners
            setupEventListeners();

            // Set initial details state based on screen size
            setInitialDetailsState();

            // Auto-initialize and perform 20 S→S+1 operations
            await autoInitializeAndRun();

        } catch (error) {
            alert('Failed to initialize: ' + error.message);
        }
    }

    function setInitialDetailsState() {
        // Accordion sections that should be open by default
        const alwaysOpen = ['keyboard-info-details', 'animation-controls-details'];
        alwaysOpen.forEach(id => {
            const el = document.getElementById(id);
            if (el && el.tagName === 'DETAILS') el.open = true;
        });

        // About simulation: always closed by default
        const aboutEl = document.getElementById('about-simulation-details');
        if (aboutEl) aboutEl.open = false;
    }

    async function autoInitializeAndRun() {
        try {
            // Initialize with default parameters
            await initializeTiling();

            // Perform 20 S→S+1 operations
            for (let i = 0; i < 20; i++) {
                try {
                    await wasmInterface.stepForward();
                    updateVisualization();
                    // Small delay to show progress
                    await new Promise(resolve => setTimeout(resolve, 50));
                } catch (error) {
                    break;
                }
            }
        } catch (error) {
            // silently ignore
        }
    }

    async function initializeTiling() {
        const N = parseInt(document.getElementById('N').value) || 20;
        const T = parseInt(document.getElementById('T').value) || 50;
        let S = parseInt(document.getElementById('S').value) || 0;
        let q = parseFloat(document.getElementById('q').value) || 1.0;

        // Handle Imaginary q-Racah mode
        const imaginaryMode = document.getElementById('imaginary-q-racah').checked;
        let mode = 5; // Default to Q_HAHN
        if (imaginaryMode) {
            // In imaginary q-Racah mode, we need both q and kappa parameters
            const imaginaryQ = parseFloat(document.getElementById('imaginary-q').value) || 0.5;
            const kappaI = parseFloat(document.getElementById('kappa-i').value) || 3.0;
            const kappasq = kappaI * kappaI; // kappasq = (kappa/i)^2

            // Encode kappasq as negative q (simple approach)
            q = -kappasq;
            mode = 7; // Use IMAGINARY_Q_RACAH mode

            // In imaginary q-Racah mode, always reset S to 0 for initialization
            S = 0;
            document.getElementById('S').value = 0; // Update UI to reflect reset
        }

        try {
            await wasmInterface.initializeTilingWasm({
                N: N,
                T: T,
                S: S,
                mode: mode,
                q: q
            });

            // Force refresh paths from WASM after initialization
            await wasmInterface.refreshPaths();

            // Update visualization immediately after initialization to show S=0 tiling
            updateVisualization();
        } catch (error) {
            alert('Initialization failed: ' + error.message);
        }
    }

    function updateVisualization() {
        const params = wasmInterface.getParameters();
        const paths = wasmInterface.getPaths();

        // Update the S input field to reflect current S value
        document.getElementById('S').value = params.S;

        // Update configuration display
        updateConfigDisplay(params);

        if (is3DView) {
            tiling3DVisualizer.pathsTo3D(paths, params.N, params.T, params.S);
        } else {
            tilingVisualizer.draw(paths, params.N, params.T, params.S);
        }
    }

    function updateConfigDisplay(params) {
        const infoElement = document.getElementById('info');
        if (infoElement) {
            const imaginaryMode = document.getElementById('imaginary-q-racah').checked;

            if (imaginaryMode) {
                // In imaginary q-Racah mode, display the UI values for q and κ/i
                const imaginaryQ = parseFloat(document.getElementById('imaginary-q').value) || 0.5;
                const kappaI = parseFloat(document.getElementById('kappa-i').value) || 3.0;

                infoElement.innerHTML = `
                    <span class="config-item">N = <strong>${params.N}</strong></span>
                    <span class="config-item">T = <strong>${params.T}</strong></span>
                    <span class="config-item">S = <strong>${params.S}</strong></span>
                    <span class="config-item">q = <strong>${imaginaryQ}</strong></span>
                    <span class="config-item">κ/i = <strong>${kappaI}</strong></span>
                `;
            } else {
                // Regular mode, display the regular q parameter
                infoElement.innerHTML = `
                    <span class="config-item">N = <strong>${params.N}</strong></span>
                    <span class="config-item">T = <strong>${params.T}</strong></span>
                    <span class="config-item">S = <strong>${params.S}</strong></span>
                    <span class="config-item">q = <strong>${params.q}</strong></span>
                `;
            }
        }
    }

    function generateTikZCode(paths, params, colors) {
        if (!paths || paths.length === 0) return '';

        const { N, T, S } = params;
        const sqrt3 = Math.sqrt(3);

        let tikzCode = `% TikZ code for lozenge tiling
% Parameters: N=${N}, T=${T}, S=${S}
\\begin{tikzpicture}[scale=1]

% Define colors
\\definecolor{uprhombi}{HTML}{${colors.gray1.substring(1)}}
\\definecolor{downrhombi}{HTML}{${colors.gray2.substring(1)}}
\\definecolor{horizontal}{HTML}{${colors.gray3.substring(1)}}
\\definecolor{bordercolor}{HTML}{${colors.border.substring(1)}}

`;

        // Draw the hexagon boundary
        const vertices = [
            { x: 0, y: 0 },
            { x: 0, y: N },
            { x: S * 0.5 * sqrt3, y: N + S * 0.5 },
            { x: T * 0.5 * sqrt3, y: N + (2 * S - T) * 0.5 },
            { x: T * 0.5 * sqrt3, y: (2 * S - T) * 0.5 },
            { x: (T - S) * 0.5 * sqrt3, y: -(T - S) * 0.5 }
        ];

        tikzCode += `% Hexagon boundary\n\\draw[thick] `;
        vertices.forEach((v, i) => {
            tikzCode += `(${v.x.toFixed(3)}, ${v.y.toFixed(3)})`;
            tikzCode += i < vertices.length - 1 ? ' -- ' : ' -- cycle;\n\n';
        });

        // Draw rhombi
        for (let i = 0; i < T; i++) {
            for (let j = 0; j < N; j++) {
                const currentHeight = paths[j][i];
                const nextHeight = paths[j][i + 1];

                const x1 = i * 0.5 * sqrt3;
                const y1 = currentHeight - i * 0.5;
                const x2 = x1;
                const y2 = y1 + 1;

                let x3, y3, x4, y4, fillColor;

                if (nextHeight === currentHeight) {
                    // Down rhombus
                    x3 = x2 + 0.5 * sqrt3;
                    y3 = y2 - 0.5;
                    x4 = x1 + 0.5 * sqrt3;
                    y4 = y1 - 0.5;
                    fillColor = 'uprhombi';
                } else {
                    // Up rhombus
                    x3 = x2 + 0.5 * sqrt3;
                    y3 = y2 + 0.5;
                    x4 = x1 + 0.5 * sqrt3;
                    y4 = y1 + 0.5;
                    fillColor = 'downrhombi';
                }

                tikzCode += `\\fill[${fillColor}] (${x1.toFixed(3)}, ${y1.toFixed(3)}) -- (${x2.toFixed(3)}, ${y2.toFixed(3)}) -- (${x3.toFixed(3)}, ${y3.toFixed(3)}) -- (${x4.toFixed(3)}, ${y4.toFixed(3)}) -- cycle;\n`;
                tikzCode += `\\draw[bordercolor, thin] (${x1.toFixed(3)}, ${y1.toFixed(3)}) -- (${x2.toFixed(3)}, ${y2.toFixed(3)}) -- (${x3.toFixed(3)}, ${y3.toFixed(3)}) -- (${x4.toFixed(3)}, ${y4.toFixed(3)}) -- cycle;\n`;
            }
        }

        tikzCode += `\n\\end{tikzpicture}`;
        return tikzCode;
    }

    function pointInPolygon(point, vs) {
        // ray-casting algorithm based on https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html
        const x = point[0], y = point[1];
        let inside = false;
        for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
            const xi = vs[i][0], yi = vs[i][1];
            const xj = vs[j][0], yj = vs[j][1];
            const intersect = ((yi > y) !== (yj > y))
                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    function generatePDF(paths, params, colors, borderWidth) {
        if (!paths || paths.length === 0) return;
        if (!window.jspdf) {
            alert('PDF library is not loaded. Please try again.');
            return;
        }

        const { jsPDF } = window.jspdf;
        const { N, T, S } = params;
        const sqrt3 = Math.sqrt(3);

        // 1. Define Hexagon Geometry & PDF Layout
        const hexVertices = [
            [0, 0], [0, N], [S * 0.5 * sqrt3, N + S * 0.5],
            [T * 0.5 * sqrt3, N + (2 * S - T) * 0.5], [T * 0.5 * sqrt3, (2 * S - T) * 0.5],
            [(T - S) * 0.5 * sqrt3, -(T - S) * 0.5]
        ];
        const minX = Math.min(...hexVertices.map(v => v[0]));
        const maxX = Math.max(...hexVertices.map(v => v[0]));
        const minY = Math.min(...hexVertices.map(v => v[1]));
        const maxY = Math.max(...hexVertices.map(v => v[1]));
        const hexWidth = maxX - minX;
        const hexHeight = maxY - minY;

        const pdf = new jsPDF({ orientation: hexWidth > hexHeight ? 'landscape' : 'portrait', unit: 'pt', format: 'a4' });
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const margin = 20; // in points
        const scale = Math.min((pageWidth - 2 * margin) / hexWidth, (pageHeight - 2 * margin) / hexHeight);
        const offsetX = (pageWidth - hexWidth * scale) / 2;
        const offsetY = pageHeight - (pageHeight - hexHeight * scale) / 2;

        // 2. Define Helper Functions
        const hexToRgb = hex => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [0, 0, 0];
        };

        const transform = p => [offsetX + (p[0] - minX) * scale, offsetY - (p[1] - minY) * scale];

        const drawPolygon = (vertices, fillColor) => {
            const transformed = vertices.map(transform);
            pdf.setFillColor(...hexToRgb(fillColor));
            pdf.setDrawColor(...hexToRgb(colors.border));
            pdf.setLineWidth(borderWidth * scale * 0.5);

            // Use lines method instead of polygon
            const lines = [];
            for (let i = 0; i < transformed.length; i++) {
                const current = transformed[i];
                const next = transformed[(i + 1) % transformed.length];
                lines.push([next[0] - current[0], next[1] - current[1]]);
            }
            pdf.lines(lines, transformed[0][0], transformed[0][1], [1, 1], 'FD');
        };

        // 3. Painter's Algorithm: Background -> Tiling -> Border
        // Step 3a: Draw background of horizontal lozenges inside the hexagon
        const timeStart = Math.floor(minX / (0.5 * sqrt3));
        const timeEnd = Math.ceil(maxX / (0.5 * sqrt3));
        for (let timeIdx = timeStart; timeIdx <= timeEnd; timeIdx++) {
            const hStart = Math.floor(minY + timeIdx * 0.5);
            const hEnd = Math.ceil(maxY + timeIdx * 0.5);
            for (let h = hStart; h <= hEnd; h++) {
                const x1 = timeIdx * 0.5 * sqrt3;
                const y1 = h - timeIdx * 0.5;
                const centerX = x1 + 0.5 * sqrt3;
                const centerY = y1;
                if (pointInPolygon([centerX, centerY], hexVertices)) {
                    drawPolygon([
                        [x1, y1], [x1 + 0.5 * sqrt3, y1 + 0.5],
                        [x1 + sqrt3, y1], [x1 + 0.5 * sqrt3, y1 - 0.5]
                    ], colors.gray3);
                }
            }
        }

        // Step 3b: Draw the actual up and down rhombi from the paths data
        for (let i = 0; i < T; i++) {
            for (let j = 0; j < N; j++) {
                const currentHeight = paths[j][i];
                const nextHeight = paths[j][i + 1];
                const x1 = i * 0.5 * sqrt3;
                const y1 = currentHeight - i * 0.5;
                let vertices, fillColor;
                if (nextHeight === currentHeight) { // "Down" rhombus
                    fillColor = colors.gray1;
                    vertices = [[x1, y1], [x1, y1 + 1], [x1 + 0.5 * sqrt3, y1 + 0.5], [x1 + 0.5 * sqrt3, y1 - 0.5]];
                } else { // "Up" rhombus
                    fillColor = colors.gray2;
                    vertices = [[x1, y1], [x1, y1 + 1], [x1 + 0.5 * sqrt3, y1 + 1.5], [x1 + 0.5 * sqrt3, y1 + 0.5]];
                }
                drawPolygon(vertices, fillColor);
            }
        }

        // Step 3c: Draw the final hexagon border
        pdf.setLineWidth(0.8); // Thicker final border
        pdf.setDrawColor(...hexToRgb(colors.border));

        const transformedHex = hexVertices.map(transform);
        const hexLines = [];
        for (let i = 0; i < transformedHex.length; i++) {
            const current = transformedHex[i];
            const next = transformedHex[(i + 1) % transformedHex.length];
            hexLines.push([next[0] - current[0], next[1] - current[1]]);
        }
        pdf.lines(hexLines, transformedHex[0][0], transformedHex[0][1], [1, 1], 'S'); // Stroke only

        // 4. Set Metadata and Save
        pdf.setProperties({
            title: `Lozenge Tiling N${N}_T${T}_S${S}`,
            subject: 'q-volume lozenge tiling',
            author: '3D q-volume lozenge tilings visualization',
            keywords: `lozenge tiling hexagon N=${N} T=${T} S${S} q=${params.q}`,
            creator: window.location.href
        });
        pdf.save(`lozenge_tiling_N${N}_T${T}_S${S}_q${params.q}.pdf`);
    }

    function exportPNG2D(paths, params, colors, borderWidth, quality) {
        if (!paths || paths.length === 0) return;
        if (!tilingVisualizer || !tilingVisualizer.canvas) return;

        // Calculate DPI multiplier (quality 0-100 maps to 72-600 DPI)
        const dpi = Math.max(72, Math.min(600, 72 + (quality / 100) * 528));
        const dpiMultiplier = dpi / 72; // 72 DPI is standard web resolution

        // Create a high-resolution temporary canvas
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');

        // Store original canvas dimensions
        const originalWidth = tilingVisualizer.canvas.width;
        const originalHeight = tilingVisualizer.canvas.height;
        const originalStyleWidth = tilingVisualizer.canvas.style.width;
        const originalStyleHeight = tilingVisualizer.canvas.style.height;

        // Set high-resolution dimensions
        const highResWidth = originalWidth * dpiMultiplier;
        const highResHeight = originalHeight * dpiMultiplier;

        tempCanvas.width = highResWidth;
        tempCanvas.height = highResHeight;

        // Temporarily replace the visualizer's canvas context
        const originalCanvas = tilingVisualizer.canvas;
        const originalCtx = tilingVisualizer.ctx;

        tilingVisualizer.canvas = tempCanvas;
        tilingVisualizer.ctx = tempCtx;

        // Scale context for high DPI
        tempCtx.scale(dpiMultiplier, dpiMultiplier);

        // Redraw at high resolution
        tilingVisualizer.draw(paths, params.N, params.T, params.S);

        // Export as PNG
        tempCanvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lozenge_tiling_2D_N${params.N}_T${params.T}_S${params.S}_q${params.q}_${Math.round(dpi)}dpi.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 'image/png');

        // Restore original canvas
        tilingVisualizer.canvas = originalCanvas;
        tilingVisualizer.ctx = originalCtx;
    }


    function toggleView() {
        is3DView = !is3DView;
        const canvas = document.getElementById('lozenge-canvas');
        const container = document.getElementById('three-container');

        if (is3DView) {
            canvas.style.display = 'none';
            container.style.display = 'block';
            tiling3DVisualizer.handleResize();
        } else {
            canvas.style.display = 'block';
            container.style.display = 'none';
        }

        updateVisualization();
    }

// Paste this new block before the 'function setupEventListeners()' line,
// replacing the old STL code entirely.

// v3 STL export code removed to prevent duplicate function definitions

// Old v4 layer export function removed to prevent conflicts with v5

// =======================================================================
// ================ WELDED STL EXPORT FUNCTIONALITY (FIXED) ================
// =======================================================================
// This version implements "mesh welding" to create an indexed mesh before
// generating the STL file. This eliminates redundant vertex data and
// dramatically reduces file sizes for large, complex models.

/**
 * Main function to generate and download a SOLID, WELDED STL file.
 */
function generateAndDownloadWeldedSTL() {
    const params = wasmInterface.getParameters();
    const paths = wasmInterface.getPaths();
    if (!paths || !paths.length) {
        alert("No tiling data available to export.");
        return;
    }

    const heightMap = getHeightMap(paths, params);
    const cubeSet = new Set();
    heightMap.forEach((height, key) => {
        // The key from getHeightMap is "y,x", so we parse it as [y, x]
        const [y, x] = key.split(',').map(Number);
        for (let z = 0; z < height; z++) {
            cubeSet.add(`${x},${y},${z}`);
        }
    });

    const stlString = generateWeldedSTLFromCubeSet(cubeSet, "lozenge_tiling_solid");
    downloadSTL(stlString, `lozenge_solid_welded_N${params.N}_T${params.T}_S${params.S}_q${params.q}.stl`);
}

/**
 * Main function to generate and download a hollow, WELDED STL LAYER.
 */
function generateAndDownloadWeldedSTLLayer() {
    const params = wasmInterface.getParameters();
    const paths = wasmInterface.getPaths();
    if (!paths || !paths.length) {
        alert("No tiling data available to export.");
        return;
    }

    const layerThickness = Math.max(1, parseInt(document.getElementById('layer-thickness').value) || 5);
    const { S, T } = params;

    const topHeightMap = getHeightMap(paths, params);
    const erodedBottom = erodeHeightMapDiagonal(topHeightMap, layerThickness, S, T);
    const bottomHeightMap = sealLayerPinholes(topHeightMap, erodedBottom, S, T, 1);

    const layerCubeSet = new Set();
    const Ymax = T - S;
    // Note: The height map keys are "y,x" but our iteration logic uses x,y.
    // We use HM_get and HM_set to abstract this away.
    for (let x = 0; x <= S; x++) {
        for (let y = 0; y <= Ymax; y++) {
            const top = HM_get(topHeightMap, x, y);
            const bot = HM_get(bottomHeightMap, x, y);
            for (let z = bot; z < top; z++) {
                layerCubeSet.add(`${x},${y},${z}`);
            }
        }
    }

    const stlString = generateWeldedSTLFromCubeSet(layerCubeSet, "lozenge_tiling_layer");
    downloadSTL(stlString, `lozenge_layer_welded_a${layerThickness}_N${params.N}_T${params.T}_S${params.S}_q${params.q}.stl`);
}

/**
 * Generate and download a SOLID OBJ using the same heightMap→voxels→weld pipeline.
 */
function generateAndDownloadWeldedOBJ() {
  const params = wasmInterface.getParameters();
  const paths = wasmInterface.getPaths();
  if (!paths || !paths.length) {
    alert("No tiling data available to export.");
    return;
  }

  const heightMap = getHeightMap(paths, params);
  const cubeSet = new Set();
  heightMap.forEach((height, key) => {
    const [y, x] = key.split(',').map(Number);
    for (let z = 0; z < height; z++) {
      cubeSet.add(`${x},${y},${z}`);
    }
  });

  const objString = generateWeldedOBJFromCubeSet(cubeSet, "lozenge_tiling_solid");
  downloadOBJ(objString, `lozenge_solid_welded_N${params.N}_T${params.T}_S${params.S}_q${params.q}.obj`);
}

/**
 * Generate and download a LAYER OBJ with diagonal erosion (thickness "a"),
 * identical to the STL layer logic.
 */
function generateAndDownloadWeldedOBJLayer() {
  const params = wasmInterface.getParameters();
  const paths = wasmInterface.getPaths();
  if (!paths || !paths.length) {
    alert("No tiling data available to export.");
    return;
  }
  const layerThickness = Math.max(1, parseInt(document.getElementById('layer-thickness').value) || 5);
  const { S, T } = params;

  const topHeightMap = getHeightMap(paths, params);
  const erodedBottom = erodeHeightMapDiagonal(topHeightMap, layerThickness, S, T);
  const bottomHeightMap = sealLayerPinholes(topHeightMap, erodedBottom, S, T, 1);

  const layerCubeSet = new Set();
  const Ymax = T - S;
  for (let x = 0; x <= S; x++) {
    for (let y = 0; y <= Ymax; y++) {
      const top = HM_get(topHeightMap, x, y);
      const bot = HM_get(bottomHeightMap, x, y);
      for (let z = bot; z < top; z++) {
        layerCubeSet.add(`${x},${y},${z}`);
      }
    }
  }

  const objString = generateWeldedOBJFromCubeSet(layerCubeSet, "lozenge_tiling_layer");
  downloadOBJ(objString, `lozenge_layer_welded_a${layerThickness}_N${params.N}_T${params.T}_S${params.S}_q${params.q}.obj`);
}


/**
 * Generates an optimized STL string from a set of cubes by first welding
 * vertices to create an indexed mesh.
 */
function generateWeldedSTLFromCubeSet(cubeSet, modelName) {
    const vertexMap = new Map();
    const vertices = [];
    const faces = [];

    const stringToVec = s => {
        const p = s.split(',').map(Number);
        return { x: p[0], y: p[1], z: p[2] };
    };

    const getVertexIndex = v => {
        const key = `${v.x},${v.y},${v.z}`;
        if (vertexMap.has(key)) {
            return vertexMap.get(key);
        }
        const index = vertices.length;
        vertices.push(v);
        vertexMap.set(key, index);
        return index;
    };

    // Step 1: Find unique vertices and build indexed faces
    const directions = [
        { dir: [1, 0, 0], name: '+X' }, { dir: [-1, 0, 0], name: '-X' },
        { dir: [0, 1, 0], name: '+Y' }, { dir: [0, -1, 0], name: '-Y' },
        { dir: [0, 0, 1], name: '+Z' }, { dir: [0, 0, -1], name: '-Z' }
    ];

    cubeSet.forEach(cubeKey => {
        const cubePos = stringToVec(cubeKey);
        directions.forEach(d => {
            const neighborKey = `${cubePos.x + d.dir[0]},${cubePos.y + d.dir[1]},${cubePos.z + d.dir[2]}`;
            if (!cubeSet.has(neighborKey)) { // This is an exposed face
                const faceTriangles = getCubeFace(cubePos, d.name);
                faceTriangles.forEach(tri => {
                    const faceIndices = [
                        getVertexIndex(tri[0]),
                        getVertexIndex(tri[1]),
                        getVertexIndex(tri[2])
                    ];
                    faces.push(faceIndices);
                });
            }
        });
    });

    // Step 2: Build the STL string from the welded mesh
    let stlString = `solid ${modelName}\n`;
    faces.forEach(face => {
        const v1 = vertices[face[0]];
        const v2 = vertices[face[1]];
        const v3 = vertices[face[2]];
        const n = calculateNormalV5(v1, v2, v3);

        stlString += `  facet normal ${n.x.toFixed(6)} ${n.y.toFixed(6)} ${n.z.toFixed(6)}\n`;
        stlString += '    outer loop\n';
        stlString += `      vertex ${v1.x.toFixed(6)} ${v1.y.toFixed(6)} ${v1.z.toFixed(6)}\n`;
        stlString += `      vertex ${v2.x.toFixed(6)} ${v2.y.toFixed(6)} ${v2.z.toFixed(6)}\n`;
        stlString += `      vertex ${v3.x.toFixed(6)} ${v3.y.toFixed(6)} ${v3.z.toFixed(6)}\n`;
        stlString += '    endloop\n';
        stlString += '  endfacet\n';
    });
    stlString += `endsolid ${modelName}\n`;

    return stlString;
}

// --- HELPER FUNCTIONS (Re-included for completeness) ---

function HM_get(map, x, y) { return map.get(`${y},${x}`) || 0; }
function HM_set(map, x, y, v) { map.set(`${y},${x}`, v); }

function erodeHeightMapDiagonal(heightMap, a, S, T) {
    const out = new Map();
    const Ymax = T - S;
    for (let x = 0; x <= S; x++) {
        for (let y = 0; y <= Ymax; y++) {
            let best = +Infinity;
            for (let dx = 0; dx <= a; dx++) {
                const dyMax = a - dx;
                for (let dy = 0; dy <= dyMax; dy++) {
                    const h = HM_get(heightMap, x + dx, y + dy);
                    const cand = h - (a - (dx + dy));
                    if (cand < best) best = cand;
                }
            }
            const top = HM_get(heightMap, x, y);
            const g = Math.max(0, Math.min(top, Math.floor(best)));
            HM_set(out, x, y, g);
        }
    }
    return out;
}

function sealLayerPinholes(topHM, botHM, S, T, minThick = 1) {
    const out = new Map(botHM);
    const Ymax = T - S;
    const NBR = [[1, 0], [-1, 0], [0, 1], [0, -1]];

    const hasCol = (x, y) => (HM_get(topHM, x, y) - HM_get(out, x, y)) >= minThick;

    for (let x = 0; x <= S; x++) {
        for (let y = 0; y <= Ymax; y++) {
            const top = HM_get(topHM, x, y);
            if (top > 0 && (top - HM_get(out, x, y)) < minThick) {
                HM_set(out, x, y, Math.max(0, top - minThick));
            }
        }
    }
    const toFill = [];
    for (let x = 0; x <= S; x++) {
        for (let y = 0; y <= Ymax; y++) {
            if (HM_get(topHM, x, y) > 0 && !hasCol(x, y)) {
                let cnt = 0, hasOppPair = false;
                for (let k = 0; k < 4; k++) {
                    const n1 = hasCol(x + NBR[k][0], y + NBR[k][1]);
                    const n2 = hasCol(x + NBR[(k + 2) % 4][0], y + NBR[(k + 2) % 4][1]);
                    if (n1) cnt++;
                    if (n1 && n2) hasOppPair = true;
                }
                if (cnt >= 3 || hasOppPair) toFill.push([x, y]);
            }
        }
    }
    for (const [x, y] of toFill) {
        const top = HM_get(topHM, x, y);
        HM_set(out, x, y, Math.max(0, top - minThick));
    }
    return out;
}

function getHeightMap(paths, { N, T, S }) {
    const heightMap = new Map();
    const allPathsXY = paths.map(path => {
        const pathCopy = path.slice().reverse();
        const firstElement = pathCopy[0];
        const adjustedPath = pathCopy.map(val => firstElement - val);
        let x = 0, y = 0;
        const pathPoints = [{ x, y }];
        for (let j = 1; j < adjustedPath.length; j++) {
            if (adjustedPath[j] === adjustedPath[j - 1] + 1) x++; else y++;
            pathPoints.push({ x, y });
        }
        return pathPoints;
    });
    const pathYLUT = allPathsXY.map(path => {
        const lut = new Array(S + 1);
        let currentY = 0, pathIdx = 0;
        for (let x = 0; x <= S; x++) {
            while (pathIdx < path.length && path[pathIdx].x <= x) {
                if (path[pathIdx].x === x) currentY = path[pathIdx].y;
                pathIdx++;
            }
            lut[x] = currentY;
        }
        return lut;
    });
    for (let x_p = 0; x_p <= S; x_p++) {
        for (let y_p = 0; y_p <= T - S; y_p++) {
            let height = pathYLUT.reduce((h, lut) => h + (y_p <= lut[x_p] ? 1 : 0), 0);
            if (height > 0) heightMap.set(`${y_p},${x_p}`, height);
        }
    }
    return heightMap;
}

function downloadOBJ(objString, fileName) {
  const blob = new Blob([objString], { type: 'model/obj' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = fileName;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(link.href);
}


function downloadSTL(stlString, fileName) {
    const blob = new Blob([stlString], { type: 'application/sla' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
}

function getCubeFace(pos, faceName) {
    const v = [
        { x: pos.x, y: pos.y, z: pos.z }, { x: pos.x + 1, y: pos.y, z: pos.z },
        { x: pos.x + 1, y: pos.y + 1, z: pos.z }, { x: pos.x, y: pos.y + 1, z: pos.z },
        { x: pos.x, y: pos.y, z: pos.z + 1 }, { x: pos.x + 1, y: pos.y, z: pos.z + 1 },
        { x: pos.x + 1, y: pos.y + 1, z: pos.z + 1 }, { x: pos.x, y: pos.y + 1, z: pos.z + 1 }
    ];
    switch (faceName) {
        case '+X': return [[v[1], v[5], v[6]], [v[1], v[6], v[2]]];
        case '-X': return [[v[0], v[3], v[7]], [v[0], v[7], v[4]]];
        case '+Y': return [[v[2], v[6], v[7]], [v[2], v[7], v[3]]];
        case '-Y': return [[v[0], v[4], v[5]], [v[0], v[5], v[1]]];
        case '+Z': return [[v[4], v[7], v[6]], [v[4], v[6], v[5]]];
        case '-Z': return [[v[0], v[1], v[2]], [v[0], v[2], v[3]]];
        default: return [];
    }
}

const calculateNormalV5 = (v1, v2, v3) => {
    const dx1 = v2.x - v1.x, dy1 = v2.y - v1.y, dz1 = v2.z - v1.z;
    const dx2 = v3.x - v1.x, dy2 = v3.y - v1.y, dz2 = v3.z - v1.z;
    const nx = dy1 * dz2 - dz1 * dy2;
    const ny = dz1 * dx2 - dx1 * dz2;
    const nz = dx1 * dy2 - dy1 * dx2;
    const l = Math.sqrt(nx * nx + ny * ny + nz * nz);
    return l > 0 ? { x: nx / l, y: ny / l, z: nz / l } : { x: 0, y: 0, z: 0 };
};

// ================= END OF WELDED STL EXPORT CODE =================


/**
 * Generates an optimized OBJ string from a set of cubes by first welding
 * vertices to create an indexed mesh. Logic mirrors generateWeldedSTLFromCubeSet.
 */
function generateWeldedOBJFromCubeSet(cubeSet, modelName) {
  const vertexMap = new Map();
  const vertices = [];
  const faces = [];

  const stringToVec = s => {
    const p = s.split(',').map(Number);
    return { x: p[0], y: p[1], z: p[2] };
  };

  const getVertexIndex = v => {
    const key = `${v.x},${v.y},${v.z}`;
    if (vertexMap.has(key)) return vertexMap.get(key);
    const index = vertices.length;
    vertices.push(v);
    vertexMap.set(key, index);
    return index;
  };

  const directions = [
    { dir: [ 1,  0,  0], name: '+X' },
    { dir: [-1,  0,  0], name: '-X' },
    { dir: [ 0,  1,  0], name: '+Y' },
    { dir: [ 0, -1,  0], name: '-Y' },
    { dir: [ 0,  0,  1], name: '+Z' },
    { dir: [ 0,  0, -1], name: '-Z' }
  ];

  // Build welded indexed mesh (exactly as we do for STL)
  cubeSet.forEach(cubeKey => {
    const cubePos = stringToVec(cubeKey);
    directions.forEach(d => {
      const neighborKey = `${cubePos.x + d.dir[0]},${cubePos.y + d.dir[1]},${cubePos.z + d.dir[2]}`;
      if (!cubeSet.has(neighborKey)) {
        const faceTriangles = getCubeFace(cubePos, d.name);
        faceTriangles.forEach(tri => {
          const a = getVertexIndex(tri[0]);
          const b = getVertexIndex(tri[1]);
          const c = getVertexIndex(tri[2]);
          faces.push([a, b, c]); // 0-based for now
        });
      }
    });
  });

  // Serialize to Wavefront OBJ
  // We disable smoothing so apps use flat shading across welded edges.
  const lines = [];
  lines.push(`# Wavefront OBJ exported by 3D q-volume lozenge tilings visualization`);
  lines.push(`o ${modelName}`);
  lines.push(`s off`);

  // Vertices: 1-based indexing in OBJ is handled when writing faces
  for (let i = 0; i < vertices.length; i++) {
    const v = vertices[i];
    lines.push(`v ${v.x.toFixed(6)} ${v.y.toFixed(6)} ${v.z.toFixed(6)}`);
  }

  // Faces (triangles) referencing vertex indices (+1)
  for (let i = 0; i < faces.length; i++) {
    const f = faces[i];
    lines.push(`f ${f[0] + 1} ${f[1] + 1} ${f[2] + 1}`);
  }

  return lines.join('\n') + '\n';
}



    // Helper function to update default layer thickness based on current N value
    function updateDefaultLayerThickness() {
        const N = parseInt(document.getElementById('N').value) || 20;
        const defaultThickness = Math.max(1, Math.round(Math.max(5, N / 10)));
        const layerThicknessInput = document.getElementById('layer-thickness');
        if (layerThicknessInput && layerThicknessInput.value == layerThicknessInput.defaultValue) {
            // Only update if user hasn't manually changed the value
            layerThicknessInput.value = defaultThickness;
            layerThicknessInput.defaultValue = defaultThickness;

            // Update the display value as well
            const valueSpan = document.getElementById('layer-thickness-value');
            if (valueSpan) {
                valueSpan.textContent = defaultThickness;
            }
        }
    }

    function setupEventListeners() {
        // Initialize button
        document.getElementById('initialize').addEventListener('click', async () => {
            // Check if we're in imaginary mode and reset S properly
            const imaginaryMode = document.getElementById('imaginary-q-racah').checked;
            if (imaginaryMode) {
                // Force S to 0 and update the S field
                document.getElementById('S').value = 0;
            }

            await initializeTiling();
            updateVisualization();
            updateDefaultLayerThickness(); // Update layer thickness after initialization
        });

        // Update layer thickness when N changes
        document.getElementById('N')?.addEventListener('input', () => {
            updateDefaultLayerThickness();
        });

        // Update layer thickness display value as slider moves
        document.getElementById('layer-thickness')?.addEventListener('input', (e) => {
            const valueSpan = document.getElementById('layer-thickness-value');
            if (valueSpan) {
                valueSpan.textContent = e.target.value;
            }
        });

        // Set parameters button
        document.getElementById('set-parameters')?.addEventListener('click', async () => {
            try {
                // Get current UI values
                const N = parseInt(document.getElementById('N').value) || 20;
                const T = parseInt(document.getElementById('T').value) || 50;
                const S = parseInt(document.getElementById('S').value) || 0;
                let q = parseFloat(document.getElementById('q').value) || 1.0;
                const visualStyle = parseInt(document.getElementById('style').value) || 1;

                // Handle Imaginary q-Racah mode
                const imaginaryMode = document.getElementById('imaginary-q-racah').checked;
                let mode = 5; // Default to Q_HAHN
                if (imaginaryMode) {
                    // In imaginary q-Racah mode, we need both q and kappa parameters
                    const imaginaryQ = parseFloat(document.getElementById('imaginary-q').value) || 0.5;
                    const kappaI = parseFloat(document.getElementById('kappa-i').value) || 3.0;
                    const kappasq = kappaI * kappaI; // kappasq = (kappa/i)^2

                    // Validate imaginary q-Racah parameters
                    if (imaginaryQ <= 0 || imaginaryQ >= 1) {
                        throw new Error('q must be strictly between 0 and 1 for imaginary q-Racah mode');
                    }
                    if (kappaI <= 0) {
                        throw new Error('κ/i must be positive for imaginary q-Racah mode');
                    }

                    // Set the imaginary q parameter separately, encode kappasq as negative q
                    if (wasmInterface.ready) {
                        wasmInterface.setImaginaryQ(imaginaryQ);
                    }
                    q = -kappasq;
                    mode = 7; // Use IMAGINARY_Q_RACAH mode
                } else {
                    // Validate regular q parameter
                    if (q <= 0) {
                        throw new Error('q must be positive for regular q-Hahn mode');
                    }
                }

                const currentParams = wasmInterface.getParameters();

                // Check if N, T, or S changed - these require reinitialization
                if (N !== currentParams.N || T !== currentParams.T || S !== currentParams.S) {
                    alert('Cannot change N, T, or S without creating a new tiling. Use "Initialize" instead.');
                    return;
                }

                // Update style directly in visualizer (no WASM call needed)
                if (tilingVisualizer) {
                    tilingVisualizer.setStyle(visualStyle);
                }

                // Update q parameter via WASM if it changed
                if (Math.abs(currentParams.q - q) > 0.001 || mode !== currentParams.mode) {
                    try {
                        await wasmInterface.updateParametersWasm({ mode, q });
                    } catch (error) {
                        // If WASM update fails, try updating locally as fallback
                        wasmInterface.mode_param = mode;
                        wasmInterface.q_param = q;
                    }
                }

                // Update the visualization
                updateVisualization();
            } catch (error) {
                const errorMessage = error?.message || error?.toString() || 'Unknown error';
                alert('Invalid parameters: ' + errorMessage);
            }
        });

        // Animation controls
        document.getElementById('step-plus')?.addEventListener('click', async () => {
            const steps = parseInt(document.getElementById('steps').value) || 1;
            for (let i = 0; i < steps; i++) {
                try {
                    await wasmInterface.stepForward();
                } catch (error) {
                    break;
                }
            }
            updateVisualization();
        });

        document.getElementById('step-minus')?.addEventListener('click', async () => {
            const steps = parseInt(document.getElementById('steps').value) || 1;
            for (let i = 0; i < steps; i++) {
                try {
                    await wasmInterface.stepBackward();
                } catch (error) {
                    break;
                }
            }
            updateVisualization();
        });

        document.getElementById('step-plus-back')?.addEventListener('click', async () => {
            const steps = parseInt(document.getElementById('steps').value) || 1;
            for (let i = 0; i < steps; i++) {
                try {
                    await wasmInterface.stepForward();
                } catch (error) {
                    break;
                }
            }
            for (let i = 0; i < steps; i++) {
                try {
                    await wasmInterface.stepBackward();
                } catch (error) {
                    break;
                }
            }
            updateVisualization();
        });

        document.getElementById('step-minus-forward')?.addEventListener('click', async () => {
            const steps = parseInt(document.getElementById('steps').value) || 1;
            for (let i = 0; i < steps; i++) {
                try {
                    await wasmInterface.stepBackward();
                } catch (error) {
                    break;
                }
            }
            for (let i = 0; i < steps; i++) {
                try {
                    await wasmInterface.stepForward();
                } catch (error) {
                    break;
                }
            }
            updateVisualization();
        });

        // View controls
        document.getElementById('toggle-view')?.addEventListener('click', toggleView);
        document.getElementById('toggle-ortho')?.addEventListener('click', () => {
            if (tiling3DVisualizer) {
                const isPerspective = tiling3DVisualizer.togglePerspective();
                const btn = document.getElementById('toggle-ortho');
                btn.textContent = isPerspective ? '🎯 Perspective' : '📐 Orthographic';
                btn.title = isPerspective ? 'Click for orthographic projection' : 'Click for perspective projection';
            }
        });
        document.getElementById('zoom-in')?.addEventListener('click', () => {
            if (!is3DView && tilingVisualizer) {
                tilingVisualizer.zoom(1.2);
                updateVisualization();
            }
        });
        document.getElementById('zoom-out')?.addEventListener('click', () => {
            if (!is3DView && tilingVisualizer) {
                tilingVisualizer.zoom(0.8);
                updateVisualization();
            }
        });
        document.getElementById('zoom-reset')?.addEventListener('click', () => {
            if (!is3DView && tilingVisualizer) {
                tilingVisualizer.resetZoom();
                updateVisualization();
            }
        });

        // Camera controls for 3D view
        document.getElementById('apply-camera')?.addEventListener('click', () => {
            if (is3DView && tiling3DVisualizer) {
                const x = parseFloat(document.getElementById('cam-x').value) || 0;
                const y = parseFloat(document.getElementById('cam-y').value) || 0;
                const z = parseFloat(document.getElementById('cam-z').value) || 0;
                const distance = parseFloat(document.getElementById('cam-distance').value) || 50;

                tiling3DVisualizer.setCameraPosition(x, y, z, distance);
            }
        });

        document.getElementById('reset-camera')?.addEventListener('click', () => {
            if (is3DView && tiling3DVisualizer) {
                // Get current bounds to reset camera
                const params = wasmInterface.getParameters();
                const maxDim = Math.max(params.N, params.T);
                tiling3DVisualizer.centerCamera(maxDim/2, maxDim/2, maxDim/2);
            }
        });

        // Demo mode checkbox control
        document.getElementById('demo-mode')?.addEventListener('change', (e) => {
            if (is3DView && tiling3DVisualizer) {
                tiling3DVisualizer.setDemoMode(e.target.checked);
            }
        });

        // Imaginary q-Racah checkbox control
        document.getElementById('imaginary-q-racah')?.addEventListener('change', (e) => {
            const kappaParam = document.getElementById('kappa-param');
            const regularQParam = document.getElementById('regular-q-param');
            const stepMinusBtn = document.getElementById('step-minus');
            const stepMinusForwardBtn = document.getElementById('step-minus-forward');
            const qInput = document.getElementById('q');

            if (e.target.checked) {
                // Show imaginary q-Racah parameters, hide regular q parameter
                kappaParam.style.display = 'flex';
                regularQParam.style.display = 'none';
            } else {
                // Hide imaginary q-Racah parameters, show regular q parameter
                kappaParam.style.display = 'none';
                regularQParam.style.display = 'flex';
                // In normal mode, q parameter must be positive
                qInput.setAttribute('min', '0.01');
            }
        });

        // Style controls
        document.getElementById('style')?.addEventListener('change', (e) => {
            const style = parseInt(e.target.value);
            if (tilingVisualizer) {
                tilingVisualizer.setStyle(style);
                updateVisualization();
            }
        });

        // Border width controls
        document.getElementById('border-width')?.addEventListener('input', (e) => {
            const width = parseFloat(e.target.value);
            if (tilingVisualizer) {
                tilingVisualizer.setBorderWidth(width);
                updateVisualization();
            }
        });

        document.getElementById('border-thin')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.setBorderWidth(0.001);
                document.getElementById('border-width').value = 0.001;
                updateVisualization();
            }
        });

        document.getElementById('border-medium')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.setBorderWidth(0.01);
                document.getElementById('border-width').value = 0.01;
                updateVisualization();
            }
        });

        document.getElementById('border-thick')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.setBorderWidth(0.03);
                document.getElementById('border-width').value = 0.03;
                updateVisualization();
            }
        });

        document.getElementById('border-ultra-thick')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.setBorderWidth(0.06);
                document.getElementById('border-width').value = 0.06;
                updateVisualization();
            }
        });

        // Palette controls
        document.getElementById('palette-select')?.addEventListener('change', (e) => {
            const paletteIndex = parseInt(e.target.value);
            if (tilingVisualizer) {
                tilingVisualizer.setPalette(paletteIndex);
                if (tiling3DVisualizer) {
                    tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                }
                updateVisualization();
            }
        });

        document.getElementById('prev-palette')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.cyclePalette(-1);
                if (tiling3DVisualizer) {
                    tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                }
                updateVisualization();
            }
        });

        document.getElementById('next-palette')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.cyclePalette(1);
                if (tiling3DVisualizer) {
                    tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                }
                updateVisualization();
            }
        });

        document.getElementById('permute-colors')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.permuteColors();
                if (tiling3DVisualizer) {
                    tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                }
                updateVisualization();
            }
        });

        // Custom colors
        document.getElementById('custom-colors')?.addEventListener('click', () => {
            const panel = document.getElementById('custom-colors-panel');
            if (panel) {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        });

        document.getElementById('close-custom-colors')?.addEventListener('click', () => {
            const panel = document.getElementById('custom-colors-panel');
            if (panel) {
                panel.style.display = 'none';
            }
        });

        // Custom color inputs
        const colorInputs = ['gray1', 'gray2', 'gray3', 'border'];
        colorInputs.forEach(colorType => {
            document.getElementById(`color-${colorType}`)?.addEventListener('input', (e) => {
                const color = e.target.value;
                document.getElementById(`hex-${colorType}`).value = color;
                if (tilingVisualizer) {
                    tilingVisualizer.setCustomColor(colorType, color);
                    if (tiling3DVisualizer) {
                        tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                    }
                    updateVisualization();
                }
            });

            document.getElementById(`hex-${colorType}`)?.addEventListener('input', (e) => {
                const color = e.target.value;
                if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                    document.getElementById(`color-${colorType}`).value = color;
                    if (tilingVisualizer) {
                        tilingVisualizer.setCustomColor(colorType, color);
                        if (tiling3DVisualizer) {
                            tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                        }
                        updateVisualization();
                    }
                }
            });
        });

        document.getElementById('reset-default-colors')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.setPalette(0); // Reset to UVA colors
                if (tiling3DVisualizer) {
                    tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                }
                updateVisualization();
                // Update custom color inputs
                document.getElementById('color-gray1').value = tilingVisualizer.colors.gray1;
                document.getElementById('hex-gray1').value = tilingVisualizer.colors.gray1;
                document.getElementById('color-gray2').value = tilingVisualizer.colors.gray2;
                document.getElementById('hex-gray2').value = tilingVisualizer.colors.gray2;
                document.getElementById('color-gray3').value = tilingVisualizer.colors.gray3;
                document.getElementById('hex-gray3').value = tilingVisualizer.colors.gray3;
                document.getElementById('color-border').value = tilingVisualizer.colors.border;
                document.getElementById('hex-border').value = tilingVisualizer.colors.border;
            }
        });

document.getElementById('export-stl')?.addEventListener('click', generateAndDownloadWeldedSTL);
document.getElementById('export-stl-layer')?.addEventListener('click', generateAndDownloadWeldedSTLLayer);
document.getElementById('export-obj')?.addEventListener('click', generateAndDownloadWeldedOBJ);
document.getElementById('export-obj-layer')?.addEventListener('click', generateAndDownloadWeldedOBJLayer);



        // TikZ Export
        document.getElementById('export-tikz')?.addEventListener('click', () => {
            if (!tilingVisualizer) return;

            const paths = wasmInterface.getPaths();
            const params = wasmInterface.getParameters();

            if (!paths || paths.length === 0) {
                alert('No tiling data to export. Please initialize first.');
                return;
            }

            const tikzCode = generateTikZCode(paths, params, tilingVisualizer.colors);
            document.getElementById('tikz-export-textarea').value = tikzCode;
            document.getElementById('tikz-export-display').style.display = 'block';
        });

        document.getElementById('copy-tikz-clipboard')?.addEventListener('click', () => {
            const textarea = document.getElementById('tikz-export-textarea');
            textarea.select();
            document.execCommand('copy');
            alert('TikZ code copied to clipboard!');
        });

        document.getElementById('download-tikz-file')?.addEventListener('click', () => {
            const tikzCode = document.getElementById('tikz-export-textarea').value;
            const blob = new Blob([tikzCode], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'lozenge_tiling.tex';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        document.getElementById('hide-tikz-export')?.addEventListener('click', () => {
            document.getElementById('tikz-export-display').style.display = 'none';
        });

        // PDF Export
        document.getElementById('export-pdf')?.addEventListener('click', () => {
            if (!tilingVisualizer) return;

            const paths = wasmInterface.getPaths();
            const params = wasmInterface.getParameters();

            if (!paths || paths.length === 0) {
                alert('No tiling data to export. Please initialize first.');
                return;
            }

            generatePDF(paths, params, tilingVisualizer.colors, tilingVisualizer.borderWidth);
        });

        // PNG Quality Slider
        document.getElementById('png-quality')?.addEventListener('input', (e) => {
            const quality = parseInt(e.target.value);
            document.getElementById('png-quality-value').textContent = quality;
        });

        // PNG Export
        document.getElementById('export-png')?.addEventListener('click', () => {
            if (is3DView) {
                alert('PNG export is only available in 2D view. Please switch to 2D view first.');
                return;
            }

            const paths = wasmInterface.getPaths();
            const params = wasmInterface.getParameters();

            if (!paths || paths.length === 0) {
                alert('No tiling data to export. Please initialize first.');
                return;
            }

            if (!tilingVisualizer) return;

            const quality = parseInt(document.getElementById('png-quality').value) || 85;
            exportPNG2D(paths, params, tilingVisualizer.colors, tilingVisualizer.borderWidth, quality);
        });

        // JSON Export
        document.getElementById('export-json')?.addEventListener('click', () => {
            if (!tilingVisualizer) return;

            const paths = wasmInterface.getPaths();
            const params = wasmInterface.getParameters();

            if (!paths || paths.length === 0) {
                alert('No tiling data to export. Please initialize first.');
                return;
            }

            const lozengeData = {
                version: "1.0",
                timestamp: new Date().toISOString(),
                parameters: params,
                paths: paths,
                colors: tilingVisualizer.colors,
                metadata: {
                    generator: "3D q-volume lozenge tilings visualization",
                    url: window.location.href
                }
            };

            const jsonString = JSON.stringify(lozengeData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lozenge_tiling_N${params.N}_T${params.T}_S${params.S}_q${params.q}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // JSON Import
        document.getElementById('import-json')?.addEventListener('click', () => {
            document.getElementById('json-file-input').click();
        });

        document.getElementById('json-file-input')?.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const lozengeData = JSON.parse(e.target.result);

                    // Validate the JSON structure
                    if (!lozengeData.parameters || !lozengeData.paths) {
                        throw new Error('Invalid lozenge data format. Missing parameters or paths.');
                    }

                    // Update parameters in UI
                    const params = lozengeData.parameters;
                    document.getElementById('N').value = params.N || 40;
                    document.getElementById('T').value = params.T || 80;
                    document.getElementById('S').value = params.S || 10;
                    document.getElementById('q').value = params.q || 1.0;

                    // Update WASM interface with the imported data
                    wasmInterface.N_param = params.N;
                    wasmInterface.T_param = params.T;
                    wasmInterface.S_param = params.S;
                    wasmInterface.q_param = params.q;
                    wasmInterface.mode_param = params.mode || 5;
                    wasmInterface.paths = lozengeData.paths;

                    // Update colors if available
                    if (lozengeData.colors && tilingVisualizer) {
                        tilingVisualizer.colors = { ...tilingVisualizer.colors, ...lozengeData.colors };
                        tilingVisualizer.updateColorSwatches();
                        if (tiling3DVisualizer) {
                            tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                        }
                    }

                    // Update visualization
                    updateVisualization();

                    alert(`Successfully imported lozenge tiling data:\nN=${params.N}, T=${params.T}, S=${params.S}, q=${params.q}`);

                } catch (error) {
                    alert('Error importing JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);

            // Reset the file input so the same file can be imported again if needed
            event.target.value = '';
        });

        // Enhanced keyboard shortcuts
        document.addEventListener('keydown', async (e) => {
            // Don't handle shortcuts if user is typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            try {
                const steps = parseInt(document.getElementById('steps')?.value) || 1;

                switch(e.key.toLowerCase()) {
                    case 'a':
                        for (let i = 0; i < steps; i++) {
                            try {
                                await wasmInterface.stepForward();
                            } catch (error) {
                                break;
                            }
                        }
                        updateVisualization();
                        break;
                    case 'z':
                        for (let i = 0; i < steps; i++) {
                            try {
                                await wasmInterface.stepBackward();
                            } catch (error) {
                                break;
                            }
                        }
                        updateVisualization();
                        break;
                    case 's':
                        for (let i = 0; i < steps; i++) {
                            try {
                                await wasmInterface.stepForward();
                            } catch (error) {
                                break;
                            }
                        }
                        for (let i = 0; i < steps; i++) {
                            try {
                                await wasmInterface.stepBackward();
                            } catch (error) {
                                break;
                            }
                        }
                        updateVisualization();
                        break;
                    case 'x':
                        for (let i = 0; i < steps; i++) {
                            try {
                                await wasmInterface.stepBackward();
                            } catch (error) {
                                break;
                            }
                        }
                        for (let i = 0; i < steps; i++) {
                            try {
                                await wasmInterface.stepForward();
                            } catch (error) {
                                break;
                            }
                        }
                        updateVisualization();
                        break;
                    case 'v':
                        toggleView();
                        break;
                    case 'c':
                        if (tilingVisualizer) {
                            tilingVisualizer.cyclePalette(e.shiftKey ? -1 : 1);
                            if (tiling3DVisualizer) {
                                tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                            }
                            updateVisualization();
                        }
                        break;
                    case 'p':
                        if (tilingVisualizer) {
                            tilingVisualizer.permuteColors();
                            if (tiling3DVisualizer) {
                                tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                            }
                            updateVisualization();
                        }
                        break;
                    case 'b':
                        if (tilingVisualizer) {
                            tilingVisualizer.cycleBorderWidth();
                            updateVisualization();
                        }
                        break;
                    case 'r':
                        if (is3DView && tiling3DVisualizer) {
                            // Reset camera to center view
                            const params = wasmInterface.getParameters();
                            const maxDim = Math.max(params.N, params.T);
                            tiling3DVisualizer.centerCamera(maxDim/2, maxDim/2, maxDim/2);
                        }
                        break;
                }
            } catch (error) {
                // silently ignore
            }
        });
    }

    // Start the application
    init();
};
</script>
