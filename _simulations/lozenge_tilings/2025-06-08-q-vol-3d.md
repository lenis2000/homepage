---
title: Minimal q-volume lozenge tilings visualization
model: lozenge-tilings
author: 'Vadim Gorin (original code); Leonid Petrov (porting)'
---

<style>
  /* Minimal styling */
  .interface-container {
    max-width: 1000px;
    margin: 0 auto;
    padding: 16px;
  }
  
  .control-group {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
  }

  .parameters-grid {
    display: flex;
    gap: 16px;
    margin-bottom: 12px;
  }

  #lozenge-canvas, #three-canvas {
    width: 100%;
    max-width: 800px;
    height: 600px;
    border: 1px solid #ccc;
    display: block;
    margin: 0 auto;
  }

  #three-container {
    width: 100%;
    max-width: 800px;
    height: 600px;
    margin: 0 auto;
    border: 1px solid #ccc;
    display: none; /* Hidden by default, 2D is default */
  }

  .keyboard-info {
    margin-top: 20px;
    padding: 10px;
    background: #f0f0f0;
    border-radius: 4px;
  }

  .export-section {
    margin-top: 20px;
    padding: 10px;
    background: #f5f5f5;
    border-radius: 4px;
    border: 1px solid #e0e0e0;
  }

  #paths-export, #plane-partition-export {
    width: 100%;
    max-width: 800px;
    height: 150px;
    font-family: monospace;
    font-size: 12px;
    margin: 10px auto;
    display: block;
    resize: vertical;
  }
</style>

<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>
<script src="/js/2025-06-08-q-vol-3d.js"></script>

<div class="interface-container">
  <!-- Parameters Only -->
  <div class="control-group">
    <div class="parameters-grid">
      <div>
        <label for="N">N:</label>
        <input type="number" id="N" value="2" min="1" max="200" style="width: 60px;">
      </div>
      <div>
        <label for="T">T:</label>
        <input type="number" id="T" value="5" min="1" max="500" style="width: 60px;">
      </div>
      <div>
        <label for="S">S:</label>
        <input type="number" id="S" value="3" min="0" style="width: 60px;">
      </div>
      <div>
        <label for="q">q:</label>
        <input type="number" id="q" value="1" step="0.02" min="0.01" style="width: 80px;">
      </div>
      <button id="initialize">Initialize</button>
    </div>
  </div>
</div>

<!-- 2D Visualization (default) -->
<canvas id="lozenge-canvas"></canvas>

<!-- 3D Visualization (hidden) -->
<div id="three-container">
  <canvas id="three-canvas"></canvas>
</div>

<div class="keyboard-info">
  <strong>Keyboard shortcuts:</strong><br>
  A: S → S+1 | Z: S → S-1 | S: S → S+1 → S-1 | X: S → S-1 → S+1 | V: Toggle 2D/3D view
</div>

<div class="export-section">
  <strong>Raw Paths Data:</strong><br>
  <textarea id="paths-export" readonly placeholder="Paths representation will appear here"></textarea>
  <br><br>
  <strong>Plane Partition:</strong><br>
  <textarea id="plane-partition-export" readonly placeholder="Plane partition representation will appear here"></textarea>
</div>

<script>
// Minimal UVA color scheme only
const UVA_COLORS = {
    gray1: '#E57200', // Orange - Up rhombi
    gray2: '#232D4B', // Navy - Down rhombi  
    gray3: '#F9DCBF', // Beige - Horizontal
    border: '#666666'
};

Module.onRuntimeInitialized = async function() {
    // WASM Interface Class
    class WASMInterface {
        constructor() {
            this.ready = false;
            this.N_param = 4;
            this.T_param = 10;
            this.S_param = 3;
            this.mode_param = 5;
            this.q_param = 1.0;
            this.paths = [];
        }

        async initialize() {
            if (typeof Module === 'undefined') {
                throw new Error('Module is not defined. WASM JavaScript file may not be loaded.');
            }
            if (typeof Module.cwrap !== 'function') {
                throw new Error('Module.cwrap is not a function. WASM module may not be properly initialized.');
            }

            // Wrap exported functions
            this.initializeTiling = Module.cwrap('initializeTiling', 'number', ['number', 'number', 'number', 'number', 'number'], {async: true});
            this.performSOperator = Module.cwrap('performSOperator', 'number', [], {async: true});
            this.performSMinusOperator = Module.cwrap('performSMinusOperator', 'number', [], {async: true});
            this.exportPaths = Module.cwrap('exportPaths', 'number', [], {async: true});
            this.updateParameters = Module.cwrap('updateParameters', 'number', ['number', 'number'], {async: true});
            this.freeString = Module.cwrap('freeString', null, ['number']);

            this.ready = true;
            console.log('WASM module loaded successfully');
        }

        async initializeTilingWasm(params) {
            if (!this.ready) throw new Error('WASM not ready');

            this.N_param = params.N;
            this.T_param = params.T;
            this.S_param = params.S;
            this.mode_param = params.mode;
            this.q_param = params.q;

            try {
                const ptr = await this.initializeTiling(params.N, params.T, params.S, params.mode, params.q);
                if (!ptr) {
                    throw new Error('initializeTiling returned null pointer');
                }
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`Initialization failed: ${error.message}`);
            }
        }

        async stepForward() {
            if (!this.ready) throw new Error('WASM not ready');
            if (this.S_param >= this.T_param) throw new Error('Cannot perform S→S+1: already at maximum');

            try {
                const ptr = await this.performSOperator();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                this.S_param = result.s;
                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`S operator failed: ${error.message}`);
            }
        }

        async stepBackward() {
            if (!this.ready) throw new Error('WASM not ready');
            if (this.S_param <= 0) throw new Error('Cannot perform S→S-1: already at minimum');

            try {
                const ptr = await this.performSMinusOperator();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                this.S_param = result.s;
                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`S- operator failed: ${error.message}`);
            }
        }

        async refreshPaths() {
            try {
                const ptr = await this.exportPaths();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (!result.error) {
                    this.paths = result.paths;
                }
            } catch (error) {
                console.error('Failed to refresh paths:', error);
            }
        }

        getPaths() {
            return this.paths;
        }

        getParameters() {
            return {
                N: this.N_param,
                T: this.T_param,
                S: this.S_param,
                mode: this.mode_param,
                q: this.q_param
            };
        }
    }

    // 2D Tiling Visualizer Class (using original drawing logic)
    class TilingVisualizer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.colors = { 
                ...UVA_COLORS,
                white: '#FFFFFF',
                black: '#000000'
            };
            this.borderWidth = 0.01;
            this.style = 1; // Lozenges
            this.zoomLevel = 1.0;
            this.panX = 0;
            this.panY = 0;
        }

        updateCanvasDimensions(N, T, S) {
            const sqrt3 = Math.sqrt(3);
            
            // Calculate the bounding box of the hexagon
            const minX = 0;
            const maxX = T * 0.5 * sqrt3;
            const minY = -(T - S) * 0.5;
            const maxY = N + Math.max(S * 0.5, (2 * S - T) * 0.5);

            const hexWidth = maxX - minX;
            const hexHeight = maxY - minY;

            // Set canvas size with some padding
            const padding = 50;
            const canvasWidth = Math.min(hexWidth * 100 + padding * 2, window.innerWidth * 0.9);
            const canvasHeight = Math.min(hexHeight * 100 + padding * 2, window.innerHeight * 0.8);
            
            // Set canvas size accounting for device pixel ratio
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = canvasWidth * dpr;
            this.canvas.height = canvasHeight * dpr;
            this.canvas.style.width = canvasWidth + 'px';
            this.canvas.style.height = canvasHeight + 'px';
            
            // Scale context for high DPI displays
            this.ctx.scale(dpr, dpr);
        }

        draw(paths, N, T, S) {
            // Update canvas dimensions to fit hexagon exactly
            this.updateCanvasDimensions(N, T, S);

            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = this.colors.white;
            ctx.fillRect(0, 0, width, height);

            if (this.style === 5) {
                this.drawLatticePathsStyle(paths, N, T, S);
            } else {
                this.drawHexagonStyle(paths, N, T, S);
            }
        }

        drawHexagonStyle(paths, N, T, S) {
            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            const sqrt3 = Math.sqrt(3);

            // Calculate the bounding box of the hexagon
            const minX = 0;
            const maxX = T * 0.5 * sqrt3;
            const minY = -(T - S) * 0.5;
            const maxY = N + Math.max(S * 0.5, (2 * S - T) * 0.5);

            const hexWidth = maxX - minX;
            const hexHeight = maxY - minY;
            const hexCenterX = (minX + maxX) / 2;
            const hexCenterY = (minY + maxY) / 2;

            const margin = 0; // No margin - fit hexagon exactly
            const scale = Math.min(
                (width - 2 * margin) / hexWidth,
                (height - 2 * margin) / hexHeight
            ) * this.zoomLevel;

            ctx.save();
            ctx.translate(this.panX, this.panY);
            ctx.translate(width / 2, height / 2);
            ctx.scale(-scale, scale);  // Flip horizontally with negative x scale
            // Center the hexagon
            ctx.translate(-hexCenterX, -hexCenterY);

            this.drawBackgroundHexagon(N, T, S);

            for (let i = 0; i < T; i++) {
                for (let j = 0; j < N; j++) {
                    const currentHeight = paths[j][i];
                    const nextHeight = paths[j][i + 1];
                    this.drawRhombus(i, j, currentHeight, nextHeight);
                }
            }

            // Draw paths on top of the tiling
            this.drawPathsOverlay(paths, N, T, S);

            ctx.restore();
        }

        drawBackgroundHexagon(N, T, S) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            // First, clip to the hexagon shape
            const vertices = [
                {x: 0, y: 0},
                {x: 0, y: N},
                {x: S * 0.5 * sqrt3, y: N + S * 0.5},
                {x: T * 0.5 * sqrt3, y: N + (2 * S - T) * 0.5},
                {x: T * 0.5 * sqrt3, y: (2 * S - T) * 0.5},
                {x: (T - S) * 0.5 * sqrt3, y: -(T - S) * 0.5}
            ];

            ctx.save();

            // Create clipping path
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < 6; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.clip();

            // Draw background rhombi with borders aligned to lozenge grid
            for (let timeIdx = -1; timeIdx <= T; timeIdx++) {
                for (let height = -(T - S + 2); height <= N + S + 2; height++) {
                    // Use the same coordinate system as the actual rhombi
                    const x1 = timeIdx * 0.5 * sqrt3;
                    const y1 = height - timeIdx * 0.5;

                    // Calculate rhombus center for bounds checking
                    const centerX = x1 + 0.25 * sqrt3;
                    const centerY = y1 + 0.5;

                    // Check if rhombus center is roughly within bounds
                    if (centerX >= -0.5 * sqrt3 && centerX <= (T + 1) * 0.5 * sqrt3 &&
                        centerY >= -(T - S + 2) * 0.5 && centerY <= N + S + 1) {

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x1+0.5 * sqrt3, y1 + 0.5);
                        ctx.lineTo(x1 + sqrt3, y1);
                        ctx.lineTo(x1 + 0.5 * sqrt3, y1 - 0.5);
                        ctx.closePath();

                        ctx.fillStyle = this.colors.gray3;
                        ctx.fill();

                        ctx.strokeStyle = this.colors.border;
                        ctx.lineWidth = this.borderWidth;
                        ctx.stroke();
                    }
                }
            }

            ctx.restore();
        }

        drawRhombus(timeIdx, particleIdx, height, nextHeight) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            const x1 = timeIdx * 0.5 * sqrt3;
            const y1 = height - timeIdx * 0.5;
            const x2 = x1;
            const y2 = y1 + 1;

            let x3, y3, x4, y4;
            let fillColor;

            if (nextHeight === height) {
                // Down rhombus
                x3 = x2 + 0.5 * sqrt3;
                y3 = y2 - 0.5;
                x4 = x1 + 0.5 * sqrt3;
                y4 = y1 - 0.5;
                fillColor = this.colors.gray1;
            } else {
                // Up rhombus
                x3 = x2 + 0.5 * sqrt3;
                y3 = y2 + 0.5;
                x4 = x1 + 0.5 * sqrt3;
                y4 = y1 + 0.5;
                fillColor = this.colors.gray2;
            }

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.lineTo(x4, y4);
            ctx.closePath();

            ctx.fillStyle = fillColor;
            ctx.fill();

            // Add consistent thin borders to all rhombi
            ctx.strokeStyle = this.colors.border;
            ctx.lineWidth = this.borderWidth;
            ctx.stroke();
        }

        drawPathsOverlay(paths, N, T, S) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            // Draw paths as lines overlaid on the hexagon tiling
            ctx.save();

            // Draw each path
            for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
                const path = paths[pathIdx];
                
                ctx.beginPath();
                ctx.strokeStyle = '#FF0000';  // Red color for paths
                ctx.lineWidth = 0.05;
                ctx.fillStyle = '#FF0000';

                for (let timeIdx = 0; timeIdx < path.length; timeIdx++) {
                    const height = path[timeIdx];
                    
                    // Convert to hexagon coordinates (same as rhombus coordinates)
                    const x = timeIdx * 0.5 * sqrt3;
                    const y = height - timeIdx * 0.5;

                    if (timeIdx === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    // Draw a small circle at each point
                    ctx.fillRect(x - 0.03, y - 0.03, 0.06, 0.06);
                }

                ctx.stroke();
            }

            ctx.restore();
        }

        drawLatticePathsStyle(paths, N, T, S) {
            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            const margin = 20; // Smaller margin for lattice paths
            const scaleX = (width - 2 * margin) / (T + 5);
            const scaleY = (height - 2 * margin) / (N + S + 5);
            const scale = Math.min(scaleX, scaleY) * this.zoomLevel;

            const maxY = N + S - 1;

            ctx.save();
            ctx.translate(this.panX + margin, this.panY + height - margin);
            ctx.scale(scale, -scale);

            ctx.fillStyle = this.colors.gray3;
            for (let i = 0; i <= T; i++) {
                for (let j = 0; j <= maxY; j++) {
                    ctx.fillRect(i - 0.1, j - 0.1, 0.2, 0.2);
                }
            }

            ctx.strokeStyle = this.colors.black;
            ctx.lineWidth = this.borderWidth;
            ctx.fillStyle = this.colors.black;

            for (let j = 0; j < N; j++) {
                ctx.beginPath();

                for (let i = 0; i <= T; i++) {
                    const x = i;
                    const y = paths[j][i];

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    ctx.fillRect(x - 0.05, y - 0.05, 0.1, 0.1);
                }

                ctx.stroke();
            }

            ctx.restore();
        }
    }

    // 3D Tiling Visualizer Class (minimal version with fixed pathsTo3D)
    class Tiling3DVisualizer {
        constructor(container) {
            this.container = container;
            this.colors = { ...UVA_COLORS };
            
            // Three.js setup
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0xffffff);
            
            // Camera
            this.camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            
            // Renderer
            this.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('three-canvas'),
                antialias: true
            });
            this.renderer.setSize(container.clientWidth, container.clientHeight);
            
            // Controls
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 10, 10);
            this.scene.add(directionalLight);
            
            // Group for rhombi
            this.boxGroup = new THREE.Group();
            this.scene.add(this.boxGroup);
            
            // Handle window resize
            window.addEventListener('resize', () => this.handleResize());
            
            // Start animation loop
            this.animate();
        }

        handleResize() {
            const width = this.container.clientWidth;
            const height = this.container.clientHeight;
            
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();
            
            this.renderer.setSize(width, height);
        }

        pathsTo3D(paths, N, T, S) {
            // Clear existing geometry
            while(this.boxGroup.children.length > 0) {
                const child = this.boxGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                this.boxGroup.remove(child);
            }
            
            // The paths encode the lozenge tiling via particle positions
            // We need to reconstruct which lozenges are present from the paths
            
            const sqrt3 = Math.sqrt(3);
            
            // We'll create a single mesh for all faces
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const colors = [];
            const indices = [];
            let vertexIndex = 0;
            
            // Helper to add a quad face
            const addQuadFace = (v1, v2, v3, v4, color) => {
                const baseIndex = vertices.length / 3;
                
                // Add vertices
                vertices.push(v1[0], v1[1], v1[2]);
                vertices.push(v2[0], v2[1], v2[2]);
                vertices.push(v3[0], v3[1], v3[2]);
                vertices.push(v4[0], v4[1], v4[2]);
                
                // Calculate normal
                const edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
                const edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
                const normal = [
                    edge1[1] * edge2[2] - edge1[2] * edge2[1],
                    edge1[2] * edge2[0] - edge1[0] * edge2[2],
                    edge1[0] * edge2[1] - edge1[1] * edge2[0]
                ];
                const len = Math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2);
                if (len > 0) {
                    normal[0] /= len;
                    normal[1] /= len;
                    normal[2] /= len;
                }
                
                // Add normals for all 4 vertices
                for (let i = 0; i < 4; i++) {
                    normals.push(normal[0], normal[1], normal[2]);
                }
                
                // Add colors
                const c = new THREE.Color(color);
                for (let i = 0; i < 4; i++) {
                    colors.push(c.r, c.g, c.b);
                }
                
                // Add triangles (2 triangles make a quad)
                indices.push(
                    baseIndex, baseIndex + 1, baseIndex + 2,
                    baseIndex, baseIndex + 2, baseIndex + 3
                );
            };
            
            // The key insight: each rhombus in the 2D tiling corresponds to a face in 3D
            // We iterate through the same rhombi as in the 2D drawing code
            
            // Process each rhombus from the paths (matching 2D drawing logic)
            for (let timeIdx = 0; timeIdx < T; timeIdx++) {
                for (let particleIdx = 0; particleIdx < N; particleIdx++) {
                    if (particleIdx < paths.length && timeIdx < paths[particleIdx].length - 1) {
                        const currentHeight = paths[particleIdx][timeIdx];
                        const nextHeight = paths[particleIdx][timeIdx + 1];
                        
                        // Map from 2D rhombus to 3D face
                        // The 2D position (timeIdx, currentHeight) maps to 3D
                        
                        if (nextHeight === currentHeight) {
                            // Down rhombus in 2D → face in 3D
                            // This face is visible when looking along (1,1,1)
                            
                            // Calculate 3D coordinates using the projection
                            // 2D point (x,y) comes from 3D point (X,Y,Z) via:
                            // x = X - Z, y = Y - Z (when viewing along (1,1,1))
                            
                            // For this rhombus at 2D position
                            const x2d = timeIdx * 0.5 * sqrt3;
                            const y2d = currentHeight - timeIdx * 0.5;
                            
                            // Map to 3D: this is a YZ-face (perpendicular to X)
                            const X = timeIdx;
                            const Y = particleIdx;
                            const Z = currentHeight - particleIdx;
                            
                            // Create the face
                            const v1 = [X, Y, Z];
                            const v2 = [X, Y + 1, Z];
                            const v3 = [X, Y + 1, Z + 1];
                            const v4 = [X, Y, Z + 1];
                            
                            addQuadFace(v1, v2, v3, v4, this.colors.gray1);
                            
                        } else {
                            // Up rhombus in 2D → different face in 3D
                            
                            const X = timeIdx;
                            const Y = particleIdx;
                            const Z = currentHeight - particleIdx;
                            
                            // This is an XZ-face (perpendicular to Y)
                            const v1 = [X, Y, Z];
                            const v2 = [X + 1, Y, Z];
                            const v3 = [X + 1, Y, Z + 1];
                            const v4 = [X, Y, Z + 1];
                            
                            addQuadFace(v1, v2, v3, v4, this.colors.gray2);
                        }
                    }
                }
            }
            
            // Add horizontal rhombi (background faces)
            // These fill the hexagon base and other horizontal surfaces
            // We need to identify where these appear by checking gaps in the vertical faces
            
            // For the base of the surface, add horizontal faces
            for (let x = 0; x < T; x++) {
                for (let y = 0; y < N; y++) {
                    // Check if we need a horizontal face here
                    // This is complex - for now, add base plane
                    const z = 0;
                    
                    // Only add if within the hexagon bounds
                    if (x >= 0 && x < T && y >= 0 && y < N) {
                        const v1 = [x, y, z];
                        const v2 = [x + 1, y, z];
                        const v3 = [x + 1, y + 1, z];
                        const v4 = [x, y + 1, z];
                        
                        // Check if this face should be visible
                        // (not covered by other rhombi)
                        let covered = false;
                        
                        // Simple check: if no vertical faces above this position
                        for (let p = 0; p < paths.length && p < N; p++) {
                            if (x < paths[p].length - 1) {
                                const h = paths[p][x];
                                if (p === y && h > z) {
                                    covered = true;
                                    break;
                                }
                            }
                        }
                        
                        if (!covered) {
                            addQuadFace(v1, v2, v3, v4, this.colors.gray3);
                        }
                    }
                }
            }
            
            // Set geometry attributes
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            
            // Create material
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: true
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            this.boxGroup.add(mesh);
            
            // Add edges
            const edgesGeometry = new THREE.EdgesGeometry(geometry, 1);
            const edgesMaterial = new THREE.LineBasicMaterial({ 
                color: this.colors.border,
                linewidth: 2
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            this.boxGroup.add(edges);
            
            // Center camera
            this.centerCamera(N, T, S);
        }

        centerCamera(N, T, S) {
            // Calculate actual bounds of the surface
            const centerX = T / 2;
            const centerY = N / 2;
            const centerZ = 0;
            
            // Set controls target
            this.controls.target.set(centerX, centerY, centerZ);
            
            // Position camera for good view
            const distance = Math.max(N, T, S) * 1.5;
            this.camera.position.set(
                centerX + distance,
                centerY + distance * 0.8,
                centerZ + distance * 0.6
            );
            
            this.controls.update();
        }

        animate() {
            requestAnimationFrame(() => this.animate());
            
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }
    }

    // Main Application
    const wasmInterface = new WASMInterface();
    let tilingVisualizer = null;
    let tiling3DVisualizer = null;
    let is3DView = false;

    // Initialize
    async function init() {
        try {
            await wasmInterface.initialize();
            
            // Initialize 2D visualizer
            const canvas = document.getElementById('lozenge-canvas');
            tilingVisualizer = new TilingVisualizer(canvas);
            
            // Initialize 3D visualizer
            const container = document.getElementById('three-container');
            tiling3DVisualizer = new Tiling3DVisualizer(container);
            
            // Initialize with default parameters
            await initializeTiling();
            
            // Set up event listeners
            setupEventListeners();
            
        } catch (error) {
            console.error('Initialization error:', error);
            alert('Failed to initialize: ' + error.message);
        }
    }

    async function initializeTiling() {
        const N = parseInt(document.getElementById('N').value) || 4;
        const T = parseInt(document.getElementById('T').value) || 10;
        const S = parseInt(document.getElementById('S').value) || 3;
        const q = parseFloat(document.getElementById('q').value) || 1.0;

        try {
            await wasmInterface.initializeTilingWasm({
                N: N,
                T: T,
                S: S,
                mode: 5,
                q: q
            });
            
            updateVisualization();
        } catch (error) {
            console.error('Initialization failed:', error);
            alert('Initialization failed: ' + error.message);
        }
    }

    function updateVisualization() {
        const params = wasmInterface.getParameters();
        const paths = wasmInterface.getPaths();
        
        if (is3DView) {
            tiling3DVisualizer.pathsTo3D(paths, params.N, params.T, params.S);
        } else {
            tilingVisualizer.draw(paths, params.N, params.T, params.S);
        }
        
        // Automatically update both exports
        exportPathsData();
        exportPlanePartition();
    }

    function toggleView() {
        is3DView = !is3DView;
        const canvas = document.getElementById('lozenge-canvas');
        const container = document.getElementById('three-container');
        
        if (is3DView) {
            canvas.style.display = 'none';
            container.style.display = 'block';
            tiling3DVisualizer.handleResize();
        } else {
            canvas.style.display = 'block';
            container.style.display = 'none';
        }
        
        updateVisualization();
    }

    function exportPathsData() {
        const paths = wasmInterface.getPaths();
        const params = wasmInterface.getParameters();
        
        if (!paths || paths.length === 0) {
            document.getElementById('paths-export').value = 'No paths data available';
            return;
        }
        
        const N = params.N;
        const T = params.T;
        const sqrt3 = Math.sqrt(3);
        
        // Format paths as simple text matrix
        let output = `Paths Data (N=${N}, T=${T}, S=${params.S}, q=${params.q}):\n\n`;
        output += 'Each row represents one particle path, columns are time steps:\n\n';
        
        for (let i = 0; i < paths.length; i++) {
            output += `Path ${i}: [${paths[i].join(', ')}]\n`;
        }
        
        document.getElementById('paths-export').value = output;
    }

    function exportPlanePartition() {
        const paths = wasmInterface.getPaths();
        const params = wasmInterface.getParameters();
        
        if (!paths || paths.length === 0) {
            alert('No tiling data available to export');
            return;
        }
        
        // Convert paths to plane partition
        // The paths represent a lozenge tiling where paths[i][j] is the height of particle i at time j
        // For a plane partition, we need to extract the 3D box configuration
        
        const N = params.N;
        const T = params.T;
        const S = params.S;
        
        // Create a 2D array to store the plane partition
        // The plane partition should be S × (T-S) based on the Fortran code
        const planePartition = [];
        
        // Initialize the plane partition array - size is S × (T-S)
        for (let i = 0; i < S; i++) {
            planePartition[i] = [];
            for (let j = 0; j < T - S; j++) {
                planePartition[i][j] = 0;
            }
        }
        
        // Fill the plane partition based on the paths using the Fortran algorithm
        // Phase 1: Process columns from j=0 to T-S-1 (0-indexed)
        for (let j = 0; j < T - S; j++) {
            let h = 0;  // height counter
            let k = 0;  // path index (0-indexed)
            let i = S - 1;  // plane partition row index (0-indexed)
            
            let r = 0;  // position counter
            while (r <= S + N - 1 && r <= j + N) {
                if (k < N && k < paths.length && j < paths[k].length && paths[k][j] === r) {
                    k++;
                    h++;  // increment height when path crosses
                } else {
                    // Store height in plane partition if within bounds
                    const col = j + (i - (S - 1));
                    if (i >= 0 && i < S && col >= 0 && col < T - S) {
                        planePartition[i][col] = h;
                    }
                    i--;
                }
                r++;
            }
        }
        
        // Phase 2: Process remaining positions when S > 1
        let i = S - 2;  // 0-indexed
        while (i >= 0) {
            let h = 0;
            let k = 0;
            let j = T - S - 1;  // 0-indexed
            
            let r = S - 1 - i;
            while (r <= S + N - 1 && r <= T - 1 - i + N - 1) {
                const timeIdx = T - 1 - i;  // 0-indexed
                if (k < N && k < paths.length && timeIdx < paths[k].length && paths[k][timeIdx] === r) {
                    k++;
                    h++;
                } else {
                    // Store height in plane partition if within bounds
                    const row = i + (j - (T - S - 1));
                    if (row >= 0 && row < S && j >= 0 && j < T - S) {
                        planePartition[row][j] = h;
                    }
                    j--;
                }
                r++;
            }
            i--;
        }
        
        // Format the plane partition as text
        let output = `Plane Partition (N=${N}, T=${T}, S=${S}, q=${params.q}):\n\n`;
        
        // Output in standard plane partition format
        // The Fortran code outputs as transpose, so we need to transpose and flip
        // Output dimensions: (T-S) rows × S columns
        for (let j = 0; j < T - S; j++) {
            let row = '';
            for (let i = S - 1; i >= 0; i--) {
                row += planePartition[i][j].toString().padStart(3, ' ');
            }
            output += row + '\n';
        }
        
        // Also add a compact notation showing non-zero entries
        output += '\nCompact notation (row,col,height):\n';
        const nonZeroEntries = [];
        // Iterate through the transposed output format
        for (let j = 0; j < T - S; j++) {
            for (let i = 0; i < S; i++) {
                if (planePartition[i][j] > 0) {
                    // Output in transposed coordinates
                    nonZeroEntries.push(`(${j},${S - 1 - i},${planePartition[i][j]})`);
                }
            }
        }
        output += nonZeroEntries.join(' ');
        
        // Set the output in the textarea
        document.getElementById('plane-partition-export').value = output;
    }

    function setupEventListeners() {
        // Initialize button
        document.getElementById('initialize').addEventListener('click', initializeTiling);
        
        // Keyboard shortcuts
        document.addEventListener('keydown', async (e) => {
            try {
                switch(e.key.toLowerCase()) {
                    case 'a':
                        await wasmInterface.stepForward();
                        updateVisualization();
                        break;
                    case 'z':
                        await wasmInterface.stepBackward();
                        updateVisualization();
                        break;
                    case 's':
                        await wasmInterface.stepForward();
                        await wasmInterface.stepBackward();
                        updateVisualization();
                        break;
                    case 'x':
                        await wasmInterface.stepBackward();
                        await wasmInterface.stepForward();
                        updateVisualization();
                        break;
                    case 'v':
                        toggleView();
                        break;
                }
            } catch (error) {
                console.error('Operation failed:', error);
            }
        });
    }

    // Start the application
    init();
};
</script>