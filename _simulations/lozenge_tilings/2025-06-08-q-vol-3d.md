---
title: 3D q-volume and q-Racah lozenge tilings visualization
model: lozenge-tilings
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/lozenge_tilings/2025-06-08-q-vol-3d.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/lozenge_tilings/2025-06-08-q-vol-3d.cpp'
    txt: 'C++ code for the simulation'
permalink: /lozenge/
---

<style>
  /* Interface container and responsive layout */
  .interface-container {
    display: grid;
    gap: 16px;
    padding: 16px;
    max-width: 1200px;
    margin: 0 auto;
  }

  /* Desktop layout */
  @media (min-width: 768px) {
    .interface-container {
      grid-template-columns: repeat(2, 1fr);
    }

    .control-group.full-width,
    .full-width {
      grid-column: 1 / -1;
    }
  }

  /* Mobile layout */
  @media (max-width: 767px) {
    .interface-container {
      grid-template-columns: 1fr;
    }
  }

  /* Visual grouping */
  .control-group {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
  }

  .control-group-title {
    font-size: 12px;
    font-weight: 600;
    color: #666;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  /* Basic styling for the canvas */
  #lozenge-canvas {
    width: 100%;
    max-width: 1200px;
    height: 400px; /* Default height, will be calculated dynamically */
    border: 1px solid #ccc;
    display: block;
    margin: 0 auto;
  }

  #three-container {
    width: 100%;
    max-width: 1200px;
    height: 600px;
    margin: 0 auto;
    border: 1px solid #ccc;
    display: block; /* Shown by default, 3D is default */
  }

  /* Parameter grid layout */
  .parameters-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: 12px;
    margin-bottom: 12px;
  }

  .param-item {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .param-item label {
    font-weight: 500;
    min-width: 20px;
  }

  .param-item input {
    flex: 1;
    min-width: 50px;
  }

  .button-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  /* Consistent input styling */
  input[type="number"],
  input[type="text"],
  select {
    height: 36px;
    padding: 0 12px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    font-size: 14px;
    transition: border-color 0.2s;
  }

  input[type="number"]:focus,
  input[type="text"]:focus,
  select:focus {
    outline: none;
    border-color: #4CAF50;
  }

  /* Button improvements */
  button {
    height: 36px;
    padding: 0 16px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    background: white;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }

  button:hover {
    background: #f5f5f5;
    border-color: #999;
  }

  button:active {
    background: #e0e0e0;
  }

  /* Primary action buttons */
  button.primary {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
  }

  button.primary:hover {
    background: #45a049;
  }

  /* Current configuration display */
  .config-display {
    background: #e8f5e9;
    border: 1px solid #4CAF50;
    border-radius: 8px;
    padding: 16px;
    margin-top: 16px;
  }

  .config-display h3 {
    margin: 0 0 8px 0;
    font-size: 16px;
    color: #2e7d32;
  }

  .config-values {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
  }

  .config-item {
    font-family: 'SF Mono', Monaco, monospace;
    color: #1976d2;
  }

  /* Color legend */
  .color-legend {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    background: #fafafa;
    border-radius: 8px;
    flex-wrap: wrap;
  }

  .legend-title {
    font-weight: 600;
    color: #666;
  }

  .legend-items {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 14px;
  }

  .color-box {
    width: 20px;
    height: 20px;
    border-radius: 4px;
    border: 1px solid rgba(0,0,0,0.1);
  }

  /* Mobile touch targets and accessibility */
  @media (max-width: 767px) {
    .interface-container {
      padding: 8px;
      gap: 8px;
    }

    .control-group {
      padding: 8px;
      margin-bottom: 8px;
    }

    .control-group-title {
      font-size: 11px;
      margin-bottom: 6px;
    }

    button {
      min-height: 44px;
      min-width: 44px;
      padding: 0 12px;
      font-size: 13px;
    }

    input[type="number"],
    input[type="text"],
    select {
      height: 40px;
      font-size: 14px;
      padding: 0 6px;
    }

    .parameters-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .button-row {
      gap: 6px;
    }

    .param-item {
      gap: 2px;
    }

    .param-item label {
      font-size: 14px;
      min-width: 16px;
    }

    #lozenge-canvas {
      max-width: 100%;
      height: 400px;
      min-height: 400px;
    }

    #three-container {
      max-width: 100%;
      height: 400px;
    }

    .config-display {
      padding: 12px;
      margin-top: 8px;
    }

    .config-display h3 {
      font-size: 14px;
      margin-bottom: 6px;
    }

    .config-values {
      gap: 12px;
    }

    .config-item {
      font-size: 12px;
    }

    .color-legend {
      padding: 8px;
      gap: 8px;
    }

    .legend-items {
      gap: 12px;
    }

    .legend-item {
      font-size: 12px;
      gap: 4px;
    }

    .color-box {
      width: 16px;
      height: 16px;
    }
  }

  /* Focus states for accessibility */
  *:focus-visible {
    outline: 2px solid #4CAF50;
    outline-offset: 2px;
  }

  /* Loading and disabled states */
  button.loading {
    opacity: 0.7;
    cursor: wait;
  }

  button:disabled,
  input:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* --- General Styling for ALL details elements --- */
  details {
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 16px;
  }
  details:last-of-type {
    margin-bottom: 20px;
  }

  details > summary {
    padding: 12px 16px;
    background: #f5f5f5;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
    list-style-position: inside;
  }

  details[open] > summary {
    border-bottom: 1px solid #e0e0e0;
  }

  /* Content wrapper div directly inside details */
  details > .content {
    padding: 16px;
    background: white;
  }
  details > .content.control-group-content {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-top: none;
    border-radius: 0 0 8px 8px;
    margin: -1px;
    margin-top: 0;
    padding: 12px;
  }

  /* Title styling when inside summary */
  details > summary > .control-group-title {
    display: inline;
    font-size: 12px;
    font-weight: 600;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 0;
  }

  /* --- Styling for the MAIN "More Options" details (#more-options-details) --- */
  details#more-options-details {
    border: none;
    background: transparent;
    margin-bottom: 0;
    padding: 0;
  }
  details#more-options-details > .content {
    padding: 0;
    background: transparent;
  }

  @media (max-width: 767px) {
    details#more-options-details > .content {
      padding: 8px;
    }
  }

  /* --- Styling for NESTED details elements within "More Options" --- */
  details.nested-control-group {
    margin-bottom: 10px;
    border: 1px solid #e8e8e8;
    border-radius: 6px;
  }
  details.nested-control-group:last-child {
    margin-bottom: 0;
  }
  details.nested-control-group > summary {
    background: #f9f9f9;
    padding: 10px 14px;
    font-size: 0.95em;
    border-bottom: none;
  }
  details.nested-control-group[open] > summary {
    border-bottom: 1px solid #e0e0e0;
  }
  details.nested-control-group > .content {
    padding: 12px;
  }

  /* Custom colors panel */
  .custom-colors-panel {
    display: none;
    margin-top: 10px;
    padding: 15px;
    background-color: #f8f9fa;
    border-radius: 4px;
    border: 1px solid #ccc;
  }

  .color-palette {
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .color-palette label {
    width: 120px;
    font-weight: bold;
  }

  .color-palette input[type="color"] {
    width: 40px;
    height: 30px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }

  .color-palette input[type="text"] {
    width: 70px;
    height: 26px;
    font-family: monospace;
    font-size: 12px;
    text-align: center;
    border: 1px solid #ccc;
    border-radius: 4px;
  }

  /* Export modal styles */
  .export-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
  }

  .export-modal-content {
    background-color: white;
    margin: 5% auto;
    padding: 20px;
    border-radius: 8px;
    width: 80%;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
  }

  .export-textarea {
    width: 100%;
    height: 300px;
    font-family: monospace;
    font-size: 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 10px;
    margin: 10px 0;
    resize: vertical;
  }

  .export-buttons {
    display: flex;
    gap: 10px;
    margin-top: 10px;
  }

  .export-buttons button {
    padding: 8px 16px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #f8f9fa;
    cursor: pointer;
  }

  .export-buttons button:hover {
    background-color: #e9ecef;
  }

  .close-modal {
    float: right;
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
    color: #aaa;
  }

  .close-modal:hover {
    color: #000;
  }

  .keyboard-info {
    margin-top: 10px;
    padding: 10px;
    background-color: #f8f9fa;
    border-radius: 4px;
    font-size: 12px;
  }

  /* Dark theme styles */
  [data-theme="dark"] .control-group {
    background-color: #2d2d2d;
    border-color: #444;
  }

  [data-theme="dark"] .control-group-title {
    color: #bbb;
  }

  [data-theme="dark"] label {
    color: #bbb;
  }

  [data-theme="dark"] input[type="number"],
  [data-theme="dark"] input[type="text"],
  [data-theme="dark"] select {
    background-color: #3a3a3a;
    border-color: #555;
    color: #ddd;
  }

  [data-theme="dark"] button {
    background-color: #3a3a3a;
    border-color: #555;
    color: #ddd;
  }

  [data-theme="dark"] button:hover {
    background-color: #4a4a4a;
    border-color: #666;
  }

  [data-theme="dark"] .config-display {
    background-color: #1e3a1e;
    border-color: #4CAF50;
    color: #bbb;
  }

  [data-theme="dark"] canvas {
    border-color: #555;
  }

  [data-theme="dark"] #loading {
    background-color: rgba(0, 0, 0, 0.9);
    color: #ddd;
  }

</style>

<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>
<script src="/js/colorschemes.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="/js/2025-06-08-q-vol-3d.js"></script>

<details id="about-simulation-details">
<summary>About this simulation</summary>
<div class="content">

This simulation demonstrates <strong>3D lozenge tilings</strong> using a WASM/JS port of a program by <a href="https://www.stat.berkeley.edu/~vadicgor/research.html">Vadim Gorin</a>.
The simulation generates lozenge tilings of a hexagon with sides $N$, $S$, and $T-S$ under the $q^{-volume}$ measure, including support for the <strong>imaginary q-Racah</strong> case introduced by <a href="https://arxiv.org/abs/0905.0679">Borodin, Gorin, and Rains (2009)</a>.
<br><br>
The sampler works entirely in your browser using WebAssembly. This version provides both 2D and 3D visualization modes with full S→S±1 operator functionality for all supported polynomial families.

</div>
</details>

---

<!-- Controls for the simulation -->
<div class="interface-container">
<!-- Parameters Group -->
<div class="control-group full-width">
  <div class="control-group-title">Parameters</div>
  <div class="parameters-grid">
    <div class="param-item">
      <label for="N">N:</label>
      <input type="number" id="N" value="40" min="1" max="200" style="width: 60px;">
    </div>
    <div class="param-item">
      <label for="T">T:</label>
      <input type="number" id="T" value="80" min="1" max="500" style="width: 60px;">
    </div>
    <div class="param-item">
      <label for="S">S:</label>
      <input type="number" id="S" value="0" min="0" style="width: 60px;">
    </div>
    <div class="param-item" id="regular-q-param">
      <label for="q">q:</label>
      <input type="number" id="q" value="1" step="0.02" style="width: 80px;">
    </div>
  </div>
  <div style="margin-top: 8px; display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
    <div style="display: flex; align-items: center; gap: 6px;">
      <input type="checkbox" id="imaginary-q-racah">
      <label for="imaginary-q-racah">Imaginary q-Racah</label>
    </div>
    <div id="kappa-param" style="display: none; align-items: center; gap: 16px;">
      <div style="display: flex; align-items: center; gap: 6px;">
        <label for="imaginary-q">q:</label>
        <input type="number" id="imaginary-q" value="0.5" step="0.01" min="0.01" max="1" style="width: 80px;">
      </div>
      <div style="display: flex; align-items: center; gap: 6px;">
        <label for="kappa-i">κ/i:</label>
        <input type="number" id="kappa-i" value="3" step="0.01" min="0.01" style="width: 80px;">
      </div>
    </div>
  </div>
  <div class="button-row">
    <button id="initialize" class="primary">Initialize</button>
    <button id="set-parameters">Set Parameters</button>
  </div>
</div>

<!-- Animation Controls -->
<details id="animation-controls-details" class="full-width">
  <summary><div class="control-group-title">Animation Controls</div></summary>
  <div class="content control-group-content">
    <div class="button-row">
      <label for="steps" style="font-style: italic;">r =</label>
      <input id="steps" type="number" value="1" min="1" max="9999" style="width: 60px;">
      <button id="step-plus">S → S+r</button>
      <button id="step-minus">S → S-r</button>
      <button id="step-plus-back">S → S+r → S</button>
      <button id="step-minus-forward">S → S-r → S</button>
    </div>
  </div>
</details>

<!-- More Options (Mobile Collapsible) -->
<details class="control-group full-width" id="more-options-details">
  <summary>More Options</summary>
  <div class="content">
    <!-- View Controls -->
    <details class="nested-control-group">
      <summary><div class="control-group-title">View Controls</div></summary>
      <div class="content">
        <div class="button-row">
          <button id="toggle-view">Toggle 2D/3D</button>
          <button id="zoom-in">Zoom In</button>
          <button id="zoom-out">Zoom Out</button>
          <button id="zoom-reset">Reset Zoom</button>
        </div>
        <div class="parameters-grid" style="margin-top: 12px;">
          <div class="param-item">
            <label>Cam X:</label>
            <input type="number" id="cam-x" value="0" step="1" style="width: 60px;">
          </div>
          <div class="param-item">
            <label>Cam Y:</label>
            <input type="number" id="cam-y" value="0" step="1" style="width: 60px;">
          </div>
          <div class="param-item">
            <label>Cam Z:</label>
            <input type="number" id="cam-z" value="0" step="1" style="width: 60px;">
          </div>
          <div class="param-item">
            <label>Distance:</label>
            <input type="number" id="cam-distance" value="50" min="1" max="2000" step="5" style="width: 60px;">
          </div>
        </div>
        <div class="button-row" style="margin-top: 8px;">
          <button id="apply-camera">Apply Camera Settings</button>
          <button id="reset-camera">Reset Camera</button>
        </div>
        <div style="margin-top: 8px; font-size: 12px; color: #666;">
          <div id="camera-info">Camera: (0, 0, 0) | Target: (0, 0, 0) | Distance: 0</div>
        </div>
      </div>
    </details>

    <!-- Styling Controls -->
    <details class="nested-control-group" id="styling-controls-details">
      <summary><div class="control-group-title">Styling Controls</div></summary>
      <div class="content">
        <div class="button-row">
          <label for="style">Style:</label>
          <select id="style">
            <option value="1" selected>Lozenges</option>
            <option value="5">Z² paths</option>
          </select>
        </div>
        <div class="button-row">
          <label>Border Width:</label>
          <input id="border-width" type="number" value="0.01" step="0.001" min="0" max="0.2" style="width: 100px;">
          <button id="border-thin">Thin</button>
          <button id="border-medium">Medium</button>
          <button id="border-thick">Thick</button>
          <button id="border-ultra-thick">Ultra Thick</button>
        </div>
        <div class="button-row">
          <label for="palette-select">Palette:</label>
          <button id="prev-palette">◀</button>
          <select id="palette-select">
            <option value="0">UVA</option>
            <option value="1">Albina</option>
            <option value="2">No Colors</option>
            <option value="3">Ocean Breeze</option>
            <option value="4">Forest Calm</option>
            <option value="5">Sunset Glow</option>
            <option value="6">Royal Purple</option>
            <option value="7">Arctic Frost</option>
            <option value="8">Cherry Blossom</option>
            <option value="9">Tropical</option>
            <option value="10">Emerald Dream</option>
            <option value="11">Cosmic Blue</option>
            <option value="12">Autumn Leaves</option>
            <option value="13">Lavender Fields</option>
            <option value="14">Desert Sand</option>
            <option value="15">Coral Reef</option>
            <option value="16">Midnight Sky</option>
            <option value="17">Rose Garden</option>
            <option value="18">Sage Green</option>
            <option value="19">Amber Glow</option>
            <option value="20">Steel Blue</option>
            <option value="21">Italy</option>
            <option value="22">France</option>
            <option value="23">United Kingdom</option>
            <option value="24">Jamaica</option>
            <option value="25">Belgium</option>
            <option value="26">Colombia</option>
            <option value="27">South Korea</option>
            <option value="28">Brazil</option>
            <option value="29">Argentina</option>
            <option value="30">Ukraine</option>
            <option value="31">Dracula</option>
            <option value="32">Monokai</option>
            <option value="33">Solarized Dark</option>
            <option value="34">One Dark</option>
            <option value="35">Material</option>
            <option value="36">Nord</option>
            <option value="37">Gruvbox Dark</option>
            <option value="38">Atom One Light</option>
            <option value="39">Harvard</option>
            <option value="40">MIT</option>
            <option value="41">Stanford</option>
            <option value="42">Yale</option>
            <option value="43">Princeton</option>
            <option value="44">Columbia</option>
            <option value="45">Berkeley</option>
            <option value="46">Michigan</option>
            <option value="47">Cornell</option>
            <option value="48">Northwestern</option>
            <option value="49">Northeastern</option>
            <option value="50">Duke</option>
            <option value="51">Notre Dame</option>
          </select>
          <button id="next-palette">▶</button>
          <button id="permute-colors">Permute Colors</button>
          <button id="custom-colors">Custom Colors</button>
        </div>
      </div>
      <div id="custom-colors-panel" class="custom-colors-panel">
        <h4>Custom Color Palettes</h4>

        <div class="color-palette">
          <label>Up Rhombi:</label>
          <input type="color" id="color-gray1" value="#E57200">
          <input type="text" id="hex-gray1" value="#E57200" placeholder="#RRGGBB">
        </div>

        <div class="color-palette">
          <label>Down Rhombi:</label>
          <input type="color" id="color-gray2" value="#232D4B">
          <input type="text" id="hex-gray2" value="#232D4B" placeholder="#RRGGBB">
        </div>

        <div class="color-palette">
          <label>Horizontal:</label>
          <input type="color" id="color-gray3" value="#F9DCBF">
          <input type="text" id="hex-gray3" value="#F9DCBF" placeholder="#RRGGBB">
        </div>

        <div class="color-palette">
          <label>Border:</label>
          <input type="color" id="color-border" value="#666666">
          <input type="text" id="hex-border" value="#666666" placeholder="#RRGGBB">
        </div>

        <div style="margin-top: 15px;">
          <button id="reset-default-colors">Reset to Default</button>
          <button id="close-custom-colors" style="margin-left: 10px;">Close</button>
        </div>
      </div>
    </details>

    <!-- Export/Import Controls -->
    <details class="nested-control-group">
      <summary><div class="control-group-title">Export/Import</div></summary>
      <div class="content">
        <div class="button-row">
          <button id="export-tikz">Export TikZ</button>
          <button id="export-pdf">Export PDF</button>
          <button id="export-png">Export PNG</button>
          <button id="export-stl">Export STL (Solid)</button>
          <button id="export-stl-layer">Export STL (Layer)</button>
          <button id="export-json">Export JSON</button>
          <button id="import-json">Import JSON</button>
        </div>
        <div class="button-row" style="margin-top: 8px;">
          <label for="png-quality">PNG quality:</label>
          <input type="range" id="png-quality" min="0" max="100" value="85" style="width: 100px;">
          <span id="png-quality-value">85</span>
        </div>
        <input type="file" id="json-file-input" accept=".json" style="display: none;">
        <div id="tikz-export-display" style="display: none; margin-top: 12px;">
          <div style="margin-bottom: 8px; font-weight: 600; color: #666;">TikZ Code:</div>
          <textarea id="tikz-export-textarea" readonly style="width: 100%; height: 300px; font-family: monospace; font-size: 11px; border: 1px solid #ccc; border-radius: 4px; padding: 10px; resize: vertical; background: #f8f9fa;"></textarea>
          <div style="margin-top: 8px; display: flex; gap: 8px;">
            <button id="copy-tikz-clipboard">Copy TikZ to Clipboard</button>
            <button id="download-tikz-file">Download TikZ File</button>
            <button id="hide-tikz-export">Hide</button>
          </div>
        </div>
      </div>
    </details>
  </div>
</details>

</div> <!-- End interface-container -->

<!-- 2D Visualization (hidden) -->
<canvas id="lozenge-canvas" style="display: none;"></canvas>

<!-- 3D Visualization (default) -->
<div id="three-container">
  <canvas id="three-canvas"></canvas>
</div>

<!-- Current Configuration -->
<details class="info-section-details" id="config-details">
  <summary>Current Configuration</summary>
  <div class="content">
    <div class="config-values" id="info">
      <span class="config-item">N = <strong>40</strong></span>
      <span class="config-item">T = <strong>80</strong></span>
      <span class="config-item">S = <strong>10</strong></span>
      <span class="config-item">q = <strong>1</strong></span>
    </div>
  </div>
</details>

<!-- Color Legend -->
<details class="info-section-details" id="legend-details">
  <summary>Color Legend</summary>
  <div class="content">
    <div class="legend-items">
      <span class="legend-item">
        <span class="color-box" id="swatch-gray1" style="background-color: #E57200;"></span>
        Up
      </span>
      <span class="legend-item">
        <span class="color-box" id="swatch-gray2" style="background-color: #232D4B;"></span>
        Down
      </span>
      <span class="legend-item">
        <span class="color-box" id="swatch-gray3" style="background-color: #F9DCBF;"></span>
        Horizontal
      </span>
      <span class="legend-item">
        <span class="color-box" id="swatch-border" style="background-color: #666666; border: 1px solid #333;"></span>
        Border
      </span>
      <span class="legend-item">
        <span style="font-weight: 600;" id="palette-info">UVA</span>
      </span>
    </div>
  </div>
</details>

<!-- Export Modal -->
<div id="export-modal" class="export-modal">
  <div class="export-modal-content">
    <span class="close-modal">&times;</span>
    <h3>Export Plane Partition</h3>
    <p>Matrix representation of the plane partition:</p>
    <textarea id="export-textarea" class="export-textarea" readonly></textarea>
    <div class="export-buttons">
      <button id="copy-to-clipboard">Copy to Clipboard</button>
      <button id="download-file">Download File</button>
      <button id="close-export">Close</button>
    </div>
  </div>
</div>

<details id="keyboard-info-details">
  <summary>Keyboard Shortcuts</summary>
  <div class="keyboard-info">
    <strong>Keyboard shortcuts:</strong><br>
    A: S → S+r<br>
    Z: S → S-r<br>
    S: S → S+r → S-r<br>
    X: S → S-r → S+r<br>
    V: Toggle 2D/3D view<br>
    C: Next color palette<br>
    Shift+C: Previous color palette<br>
    P: Permute colors (cycle through 6 permutations)<br>
    B: Change border style (thin/medium/thick/ultra thick)<br>
    R: Reset camera (3D view only)
  </div>
</details>


<script>
// Check if Module is defined before setting onRuntimeInitialized
if (typeof Module === 'undefined') {
    console.error('Module is not defined. Make sure the WASM JavaScript file is loaded correctly.');
    window.Module = { onRuntimeInitialized: function() {} };
}

Module.onRuntimeInitialized = async function() {
    // WASM Interface Class
    class WASMInterface {
        constructor() {
            this.ready = false;
            this.N_param = 40;
            this.T_param = 80;
            this.S_param = 0;
            this.mode_param = 5;
            this.q_param = 1.0;
            this.paths = [];
        }

        async initialize() {
            if (typeof Module === 'undefined') {
                throw new Error('Module is not defined. WASM JavaScript file may not be loaded.');
            }
            if (typeof Module.cwrap !== 'function') {
                throw new Error('Module.cwrap is not a function. WASM module may not be properly initialized.');
            }

            // Wrap exported functions
            this.initializeTiling = Module.cwrap('initializeTiling', 'number', ['number', 'number', 'number', 'number', 'number'], {async: true});
            this.performSOperator = Module.cwrap('performSOperator', 'number', [], {async: true});
            this.performSMinusOperator = Module.cwrap('performSMinusOperator', 'number', [], {async: true});
            this.exportPaths = Module.cwrap('exportPaths', 'number', [], {async: true});
            this.updateParameters = Module.cwrap('updateParameters', 'number', ['number', 'number'], {async: true});
            this.setImaginaryQ = Module.cwrap('setImaginaryQ', null, ['number']);
            this.freeString = Module.cwrap('freeString', null, ['number']);
            this.getProgress = Module.cwrap('getProgress', 'number', []);

            this.ready = true;
        }

        async initializeTilingWasm(params) {
            if (!this.ready) throw new Error('WASM not ready');

            this.N_param = params.N;
            this.T_param = params.T;
            this.S_param = params.S;
            this.mode_param = params.mode;
            this.q_param = params.q;

            try {
                const ptr = await this.initializeTiling(params.N, params.T, params.S, params.mode, params.q);
                if (!ptr) {
                    throw new Error('initializeTiling returned null pointer');
                }
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`Initialization failed: ${error.message}`);
            }
        }

        async stepForward() {
            if (!this.ready) throw new Error('WASM not ready');
            if (this.S_param >= this.T_param) throw new Error('Cannot perform S→S+1: already at maximum');

            try {
                const ptr = await this.performSOperator();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                this.S_param = result.s;
                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`S operator failed: ${error.message}`);
            }
        }

        async stepBackward() {
            if (!this.ready) throw new Error('WASM not ready');
            if (this.S_param <= 0) throw new Error('Cannot perform S→S-1: already at minimum');

            try {
                const ptr = await this.performSMinusOperator();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                this.S_param = result.s;
                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`S- operator failed: ${error.message}`);
            }
        }

        async refreshPaths() {
            try {
                const ptr = await this.exportPaths();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (!result.error) {
                    this.paths = result.paths;
                }
            } catch (error) {
                console.error('Failed to refresh paths:', error);
            }
        }

        getPaths() {
            return this.paths;
        }

        getParameters() {
            return {
                N: this.N_param,
                T: this.T_param,
                S: this.S_param,
                mode: this.mode_param,
                q: this.q_param
            };
        }

        async updateParametersWasm(params) {
            if (!this.ready) throw new Error('WASM not ready');

            try {
                console.log('Calling updateParameters with mode:', params.mode, 'q:', params.q);
                const ptr = await this.updateParameters(params.mode, params.q);
                console.log('updateParameters returned ptr:', ptr);

                // Check if ptr is a valid pointer or an error code
                if (!ptr || ptr < 1000) {
                    throw new Error(`WASM function returned error code: ${ptr}`);
                }

                const jsonStr = Module.UTF8ToString(ptr);
                console.log('JSON response:', jsonStr);
                this.freeString(ptr);

                // Check if we got a valid JSON string
                if (!jsonStr || jsonStr.trim() === '') {
                    throw new Error('WASM function returned empty response');
                }

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                this.mode_param = params.mode;
                this.q_param = params.q;
                console.log('Successfully updated parameters');
                return result;
            } catch (error) {
                const errorMessage = error?.message || error?.toString() || 'Unknown error';
                throw new Error(`Parameter update failed: ${errorMessage}`);
            }
        }
    }

    // 2D Tiling Visualizer Class (full-featured)
    class TilingVisualizer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.style = 1; // Default: lozenges
            this.borderWidth = 0.01; // Default border width

            this.colors = {
                gray1: '#E57200', // UVA Orange (up rhombi)
                gray2: '#232D4B', // UVA Blue (down rhombi)
                gray3: '#F9DCBF', // UVA Orange 25% (horizontal rhombi)
                border: '#666666', // Default border color
                black: '#000000',
                white: '#FFFFFF'
            };
            this.customBorderColor = null; // Track if user has set custom border color

            this.currentPalette = 'UVA Colors';
            this.currentPaletteIndex = 0;

            // Color permutation state (0-5 for 6 possible permutations)
            this.currentPermutation = 0;

            // Zoom and pan for 2D
            this.zoomLevel = 1.0;
            this.panX = 0;
            this.panY = 0;
        }

        // Color palette management
        setPalette(paletteIndex) {
            if (typeof window.ColorSchemes === 'undefined') {
                console.warn('Color palettes not loaded');
                return;
            }

            this.currentPaletteIndex = paletteIndex;
            const palette = window.ColorSchemes[paletteIndex];
            if (palette && palette.colors) {
                this.colors.gray1 = palette.colors[0];
                this.colors.gray2 = palette.colors[1];
                this.colors.gray3 = palette.colors[2];

                // Only update border color if it hasn't been customized
                if (!this.customBorderColor) {
                    this.colors.border = '#666666'; // Default border color
                }

                this.currentPalette = palette.name;
                this.updateColorSwatches();
            }
        }

        cyclePalette(direction = 1) {
            if (typeof window.ColorSchemes === 'undefined') return;

            const newIndex = (this.currentPaletteIndex + direction + window.ColorSchemes.length) % window.ColorSchemes.length;
            this.setPalette(newIndex);

            // Update the select element
            const paletteSelect = document.getElementById('palette-select');
            if (paletteSelect) {
                paletteSelect.value = newIndex;
            }
        }

        permuteColors() {
            // Cycle through 6 permutations of the 3 main colors
            this.currentPermutation = (this.currentPermutation + 1) % 6;

            const baseColors = [this.colors.gray1, this.colors.gray2, this.colors.gray3];
            const permutations = [
                [0, 1, 2], // Original
                [0, 2, 1], // Swap gray2 and gray3
                [1, 0, 2], // Swap gray1 and gray2
                [1, 2, 0], // Rotate left
                [2, 0, 1], // Rotate right
                [2, 1, 0]  // Reverse
            ];

            const perm = permutations[this.currentPermutation];
            this.colors.gray1 = baseColors[perm[0]];
            this.colors.gray2 = baseColors[perm[1]];
            this.colors.gray3 = baseColors[perm[2]];

            this.updateColorSwatches();
        }

        updateColorSwatches() {
            const swatches = {
                'swatch-gray1': this.colors.gray1,
                'swatch-gray2': this.colors.gray2,
                'swatch-gray3': this.colors.gray3,
                'swatch-border': this.colors.border
            };

            for (const [id, color] of Object.entries(swatches)) {
                const element = document.getElementById(id);
                if (element) {
                    element.style.backgroundColor = color;
                }
            }

            // Update palette info
            const paletteInfo = document.getElementById('palette-info');
            if (paletteInfo) {
                paletteInfo.textContent = this.currentPalette;
            }
        }

        setCustomColor(colorType, color) {
            this.colors[colorType] = color;
            if (colorType === 'border') {
                this.customBorderColor = color;
            }
            this.currentPalette = 'Custom';
            this.updateColorSwatches();
        }

        setBorderWidth(width) {
            this.borderWidth = Math.max(0, Math.min(0.2, width));
        }

        cycleBorderWidth() {
            const widths = [0.001, 0.01, 0.03, 0.06]; // thin, medium, thick, ultra thick
            const currentIndex = widths.findIndex(w => Math.abs(w - this.borderWidth) < 0.001) || 0;
            const nextIndex = (currentIndex + 1) % widths.length;
            this.setBorderWidth(widths[nextIndex]);

            // Update the input element
            const borderInput = document.getElementById('border-width');
            if (borderInput) {
                borderInput.value = this.borderWidth;
            }
        }

        zoom(factor) {
            this.zoomLevel *= factor;
            this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
        }

        resetZoom() {
            this.zoomLevel = 1.0;
            this.panX = 0;
            this.panY = 0;
        }

        setStyle(styleValue) {
            this.style = styleValue;
        }

        updateCanvasDimensions(N, T, S) {
            const sqrt3 = Math.sqrt(3);

            // Calculate the bounding box of the hexagon
            const minX = 0;
            const maxX = T * 0.5 * sqrt3;
            const minY = -(T - S) * 0.5;
            const maxY = N + Math.max(S * 0.5, (2 * S - T) * 0.5);

            const hexWidth = maxX - minX;
            const hexHeight = maxY - minY;

            // Calculate appropriate scale to fit the hexagon nicely
            const maxCanvasWidth = Math.min(1200, window.innerWidth * 0.9);
            const maxCanvasHeight = Math.min(800, window.innerHeight * 0.8);

            const scaleX = maxCanvasWidth / hexWidth;
            const scaleY = maxCanvasHeight / hexHeight;
            const scale = Math.min(scaleX, scaleY) * 0.8; // Use 80% of max scale for padding

            const canvasWidth = Math.max(400, hexWidth * scale);
            const canvasHeight = Math.max(300, hexHeight * scale);

            // Set canvas size accounting for device pixel ratio
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = canvasWidth * dpr;
            this.canvas.height = canvasHeight * dpr;
            this.canvas.style.width = canvasWidth + 'px';
            this.canvas.style.height = canvasHeight + 'px';

            // Scale context for high DPI displays
            this.ctx.scale(dpr, dpr);
        }

        draw(paths, N, T, S) {
            // Update canvas dimensions to fit hexagon exactly
            this.updateCanvasDimensions(N, T, S);

            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = this.colors.white;
            ctx.fillRect(0, 0, width, height);

            if (this.style === 5) {
                this.drawLatticePathsStyle(paths, N, T, S);
            } else {
                this.drawHexagonStyle(paths, N, T, S);
            }
        }

        drawHexagonStyle(paths, N, T, S) {
            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            const sqrt3 = Math.sqrt(3);

            // Calculate the bounding box of the hexagon
            const minX = 0;
            const maxX = T * 0.5 * sqrt3;
            const minY = -(T - S) * 0.5;
            const maxY = N + Math.max(S * 0.5, (2 * S - T) * 0.5);

            const hexWidth = maxX - minX;
            const hexHeight = maxY - minY;
            const hexCenterX = (minX + maxX) / 2;
            const hexCenterY = (minY + maxY) / 2;

            const margin = 0; // No margin - fit hexagon exactly
            const scale = Math.min(
                (width - 2 * margin) / hexWidth,
                (height - 2 * margin) / hexHeight
            ) * this.zoomLevel;

            ctx.save();
            ctx.translate(this.panX, this.panY);
            ctx.translate(width / 2, height / 2);
            ctx.scale(-scale, scale);  // Flip horizontally with negative x scale
            // Center the hexagon
            ctx.translate(-hexCenterX, -hexCenterY);

            this.drawBackgroundHexagon(N, T, S);

            for (let i = 0; i < T; i++) {
                for (let j = 0; j < N; j++) {
                    const currentHeight = paths[j][i];
                    const nextHeight = paths[j][i + 1];
                    this.drawRhombus(i, j, currentHeight, nextHeight);
                }
            }

            // Draw paths on top of the tiling
            this.drawPathsOverlay(paths, N, T, S);

            ctx.restore();
        }

        drawBackgroundHexagon(N, T, S) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            // First, clip to the hexagon shape
            const vertices = [
                {x: 0, y: 0},
                {x: 0, y: N},
                {x: S * 0.5 * sqrt3, y: N + S * 0.5},
                {x: T * 0.5 * sqrt3, y: N + (2 * S - T) * 0.5},
                {x: T * 0.5 * sqrt3, y: (2 * S - T) * 0.5},
                {x: (T - S) * 0.5 * sqrt3, y: -(T - S) * 0.5}
            ];

            ctx.save();

            // Create clipping path
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < 6; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.clip();

            // Draw background rhombi with borders aligned to lozenge grid
            for (let timeIdx = -1; timeIdx <= T; timeIdx++) {
                for (let height = -(T - S + 2); height <= N + S + 2; height++) {
                    // Use the same coordinate system as the actual rhombi
                    const x1 = timeIdx * 0.5 * sqrt3;
                    const y1 = height - timeIdx * 0.5;

                    // Calculate rhombus center for bounds checking
                    const centerX = x1 + 0.25 * sqrt3;
                    const centerY = y1 + 0.5;

                    // Check if rhombus center is roughly within bounds
                    if (centerX >= -0.5 * sqrt3 && centerX <= (T + 1) * 0.5 * sqrt3 &&
                        centerY >= -(T - S + 2) * 0.5 && centerY <= N + S + 1) {

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x1+0.5 * sqrt3, y1 + 0.5);
                        ctx.lineTo(x1 + sqrt3, y1);
                        ctx.lineTo(x1 + 0.5 * sqrt3, y1 - 0.5);
                        ctx.closePath();

                        ctx.fillStyle = this.colors.gray3;
                        ctx.fill();

                        ctx.strokeStyle = this.colors.border;
                        ctx.lineWidth = this.borderWidth;
                        ctx.stroke();
                    }
                }
            }

            ctx.restore();
        }

        drawRhombus(timeIdx, particleIdx, height, nextHeight) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            const x1 = timeIdx * 0.5 * sqrt3;
            const y1 = height - timeIdx * 0.5;
            const x2 = x1;
            const y2 = y1 + 1;

            let x3, y3, x4, y4;
            let fillColor;

            if (nextHeight === height) {
                // Down rhombus
                x3 = x2 + 0.5 * sqrt3;
                y3 = y2 - 0.5;
                x4 = x1 + 0.5 * sqrt3;
                y4 = y1 - 0.5;
                fillColor = this.colors.gray1;
            } else {
                // Up rhombus
                x3 = x2 + 0.5 * sqrt3;
                y3 = y2 + 0.5;
                x4 = x1 + 0.5 * sqrt3;
                y4 = y1 + 0.5;
                fillColor = this.colors.gray2;
            }

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.lineTo(x4, y4);
            ctx.closePath();

            ctx.fillStyle = fillColor;
            ctx.fill();

            // Add consistent thin borders to all rhombi
            ctx.strokeStyle = this.colors.border;
            ctx.lineWidth = this.borderWidth;
            ctx.stroke();
        }

        drawPathsOverlay(paths, N, T, S) {
            // Only draw paths for lattice paths style (style 5), not for lozenges
            if (this.style !== 5) return;

            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            // Draw paths as lines overlaid on the hexagon tiling
            ctx.save();

            // Draw each path
            for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
                const path = paths[pathIdx];

                ctx.beginPath();
                ctx.strokeStyle = '#FF0000';  // Red color for paths
                ctx.lineWidth = 0.05;
                ctx.fillStyle = '#FF0000';

                for (let timeIdx = 0; timeIdx < path.length; timeIdx++) {
                    const height = path[timeIdx];

                    // Convert to hexagon coordinates (same as rhombus coordinates)
                    const x = timeIdx * 0.5 * sqrt3;
                    const y = height - timeIdx * 0.5;

                    if (timeIdx === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    // Draw a small circle at each point
                    ctx.fillRect(x - 0.03, y - 0.03, 0.06, 0.06);
                }

                ctx.stroke();
            }

            ctx.restore();
        }

        drawLatticePathsStyle(paths, N, T, S) {
            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            const margin = 20; // Smaller margin for lattice paths
            const scaleX = (width - 2 * margin) / (T + 5);
            const scaleY = (height - 2 * margin) / (N + S + 5);
            const scale = Math.min(scaleX, scaleY) * this.zoomLevel;

            const maxY = N + S - 1;

            ctx.save();
            ctx.translate(this.panX + margin, this.panY + height - margin);
            ctx.scale(scale, -scale);

            ctx.fillStyle = this.colors.gray3;
            for (let i = 0; i <= T; i++) {
                for (let j = 0; j <= maxY; j++) {
                    ctx.fillRect(i - 0.1, j - 0.1, 0.2, 0.2);
                }
            }

            ctx.strokeStyle = this.colors.black;
            ctx.lineWidth = this.borderWidth;
            ctx.fillStyle = this.colors.black;

            for (let j = 0; j < N; j++) {
                ctx.beginPath();

                for (let i = 0; i <= T; i++) {
                    const x = i;
                    const y = paths[j][i];

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    ctx.fillRect(x - 0.05, y - 0.05, 0.1, 0.1);
                }

                ctx.stroke();
            }

            ctx.restore();
        }
    }

    // 3D Tiling Visualizer Class (enhanced with color palette support)
    class Tiling3DVisualizer {
        constructor(container) {
            this.container = container;
            this.colors = {
                gray1: '#E57200', // UVA Orange (up rhombi)
                gray2: '#232D4B', // UVA Blue (down rhombi)
                gray3: '#F9DCBF', // UVA Orange 25% (horizontal rhombi)
                border: '#666666' // Default border color
            };
            this.cameraInitialized = false;

            // Three.js setup
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0xffffff);

            // Camera
            this.camera = new THREE.PerspectiveCamera(
                45,
                container.clientWidth / container.clientHeight,
                0.1,
                10000
            );

            // Set Z-axis as up
            this.camera.up.set(0, 0, 1);

            // Renderer
            this.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('three-canvas'),
                antialias: true
            });
            this.renderer.setSize(container.clientWidth, container.clientHeight);

            // Controls
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            this.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight.position.set(10, 10, 10);
            this.scene.add(directionalLight);

            // Group for rhombi
            this.boxGroup = new THREE.Group();
            this.scene.add(this.boxGroup);

            // Handle window resize
            window.addEventListener('resize', () => this.handleResize());

            // Start animation loop
            this.animate();
        }

        // Color palette support for 3D
        updateColors(colors) {
            this.colors = { ...colors };
            // Rebuild the geometry if it exists
            if (this.boxGroup && this.boxGroup.children.length > 0) {
                // Will be rebuilt on next pathsTo3D call
            }
        }

        handleResize() {
            const width = this.container.clientWidth;
            const height = this.container.clientHeight;

            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();

            this.renderer.setSize(width, height);
        }

        pathsTo3D(paths, N, T, S) {
            // Store parameters for use in horizontal lozenge calculations
            this.currentN = N;
            this.currentT = T;
            this.currentS = S;

            // Clear existing geometry
            while(this.boxGroup.children.length > 0) {
                const child = this.boxGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                this.boxGroup.remove(child);
            }

            // Convert paths to triplet format (normal WASM mode)
            const pathTriplets = [];
            for (let i = 0; i < paths.length; i++) {
                const pathCopy = paths[i].slice().reverse();
                const firstElement = pathCopy[0];
                const adjustedPath = pathCopy.map(x => firstElement - x);

                const triplets = [];
                let x = 0, y = 0;
                const z = paths.length - i; // z-coordinate is constant for each path

                // Start with initial triplet
                triplets.push([x, y, z]);

                // Process each step in the path
                for (let j = 1; j < adjustedPath.length; j++) {
                    const prev = adjustedPath[j-1];
                    const curr = adjustedPath[j];

                    if (curr === prev + 1) {
                        // Path goes up by 1, increment first coordinate
                        x++;
                    } else if (curr === prev) {
                        // Path stays the same, increment second coordinate
                        y++;
                    }
                    triplets.push([x, y, z]);
                }
                pathTriplets.push(triplets);
            }

            // Create geometry for the surface
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const colors = [];
            const indices = [];

            // Helper to add a square face
            const addSquareFace = (v1, v2, v3, v4, color) => {
                const baseIndex = vertices.length / 3;

                // Add vertices (swap X and Y)
                vertices.push(v1[1], v1[0], v1[2]);
                vertices.push(v2[1], v2[0], v2[2]);
                vertices.push(v3[1], v3[0], v3[2]);
                vertices.push(v4[1], v4[0], v4[2]);

                // Calculate normal (swap X and Y)
                const edge1 = [v2[1] - v1[1], v2[0] - v1[0], v2[2] - v1[2]];
                const edge2 = [v3[1] - v1[1], v3[0] - v1[0], v3[2] - v1[2]];
                const normal = [
                    edge1[1] * edge2[2] - edge1[2] * edge2[1],
                    edge1[2] * edge2[0] - edge1[0] * edge2[2],
                    edge1[0] * edge2[1] - edge1[1] * edge2[0]
                ];
                const len = Math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2);
                if (len > 0) {
                    normal[0] /= len;
                    normal[1] /= len;
                    normal[2] /= len;
                }

                // Add normals
                for (let i = 0; i < 4; i++) {
                    normals.push(normal[0], normal[1], normal[2]);
                }

                // Add colors
                const c = new THREE.Color(color);
                for (let i = 0; i < 4; i++) {
                    colors.push(c.r, c.g, c.b);
                }

                // Add triangles
                indices.push(
                    baseIndex, baseIndex + 1, baseIndex + 2,
                    baseIndex, baseIndex + 2, baseIndex + 3
                );
            };

            // Create strips between consecutive paths (skip path -1 for vertical lozenges)
            for (let pathIdx = 1; pathIdx < pathTriplets.length; pathIdx++) {
                const topPath = pathTriplets[pathIdx];

                // Create bottom path by lowering z by 1
                const bottomPath = topPath.map(point => [point[0], point[1], point[2] - 1]);

                // Create strips between consecutive segments
                for (let i = 0; i < topPath.length - 1; i++) {
                    const topP1 = topPath[i];
                    const topP2 = topPath[i + 1];
                    const bottomP1 = bottomPath[i];
                    const bottomP2 = bottomPath[i + 1];

                    // Determine color based on segment direction
                    let color;
                    if (topP2[0] > topP1[0] && topP2[1] === topP1[1]) {
                        // x increases, y constant -> "up" rhombus
                        color = this.colors.gray2;
                    } else if (topP2[0] === topP1[0] && topP2[1] > topP1[1]) {
                        // x constant, y increases -> "down" rhombus
                        color = this.colors.gray1;
                    } else {
                        // Shouldn't happen with valid paths
                        color = this.colors.gray3;
                    }

                    // Create strip as a quadrilateral
                    // topP1 -> topP2 -> bottomP2 -> bottomP1
                    addSquareFace(topP1, topP2, bottomP2, bottomP1, color);
                }
            }

            // Place horizontal lozenges at all height levels
            this.placeAllHorizontalLozenges(pathTriplets, addSquareFace);

            // Find the bounds of the surface for camera positioning (swap X and Y)
            let maxX = 0, maxY = 0, maxZ = 0;
            for (const path of pathTriplets) {
                for (const point of path) {
                    maxX = Math.max(maxX, point[1]);
                    maxY = Math.max(maxY, point[0]);
                    maxZ = Math.max(maxZ, point[2]);
                }
            }

            // Set geometry attributes
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);

            // Create material
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: true
            });

            const mesh = new THREE.Mesh(geometry, material);
            this.boxGroup.add(mesh);

            // Add edges
            const edgesGeometry = new THREE.EdgesGeometry(geometry, 1);
            const edgesMaterial = new THREE.LineBasicMaterial({
                color: this.colors.border,
                linewidth: 2
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            this.boxGroup.add(edges);

            // Only center camera on initial load, not on resampling
            if (!this.cameraInitialized) {
                this.centerCamera(maxX, maxY, maxZ);
                this.cameraInitialized = true;
            }
        }

        addHorizontalLozenges(pathTriplets, addSquareFace) {
            // Horizontal lozenges have constant z-component and lie in xy-planes between path levels
            // Implementation based on the Mathematica logic

            // Process consecutive path pairs
            for (let pathIdx = 0; pathIdx < pathTriplets.length - 1; pathIdx++) {
                const upperPath = pathTriplets[pathIdx];      // Higher z-level
                const lowerPath = pathTriplets[pathIdx + 1];  // Lower z-level

                // The horizontal squares lie at the z-level of the lower path
                const zLevel = lowerPath[0][2];

                // Extract xy-projections and find horizontal squares
                const horizontalSquares = this.findHorizontalSquaresBetweenPaths(upperPath, lowerPath, zLevel);

                // Add each horizontal square as a face
                for (const square of horizontalSquares) {
                    addSquareFace(square[0], square[1], square[2], square[3], this.colors.gray3);
                }
            }
        }

        findHorizontalSquaresBetweenPaths(upperPath, lowerPath, zLevel) {
            const horizontalSquares = [];

            // Extract xy-projections of the paths (ignore z-coordinate)
            const upperXY = upperPath.map(point => [point[0], point[1]]);
            const lowerXY = lowerPath.map(point => [point[0], point[1]]);

            // Implement extractLastFromIncreasing logic from Mathematica
            const extractLastFromIncreasing = (list) => {
                const result = [];
                let i = 0;
                while (i < list.length) {
                    let j = i;
                    // Find the end of increasing sequence
                    while (j + 1 < list.length && list[j] < list[j + 1]) {
                        j++;
                    }
                    result.push(list[j]); // Take the last element of the increasing sequence
                    i = j + 1;
                }
                return result;
            };

            // Extract x-coordinates for both paths
            const upperXList = upperXY.map(point => point[0]);
            const lowerXList = lowerXY.map(point => point[0]);

            // Apply extractLastFromIncreasing to both paths
            const upperXExtracted = extractLastFromIncreasing(upperXList);
            const lowerXExtracted = extractLastFromIncreasing(lowerXList);

            // Find intersection of the two lists (common x-values)
            const commonX = upperXExtracted.filter(x => lowerXExtracted.includes(x));

            // Similarly for y-coordinates
            const upperYList = upperXY.map(point => point[1]);
            const lowerYList = lowerXY.map(point => point[1]);

            const upperYExtracted = extractLastFromIncreasing(upperYList);
            const lowerYExtracted = extractLastFromIncreasing(lowerYList);

            const commonY = upperYExtracted.filter(y => lowerYExtracted.includes(y));

            // Create horizontal squares for all combinations of common x,y values
            // Each square is a 1x1 unit square in the xy-plane at the given z-level
            for (const x of commonX) {
                for (const y of commonY) {
                    // Check if this (x,y) position should have a horizontal square
                    // by verifying it's properly between the paths
                    if (this.shouldPlaceHorizontalSquare(x, y, upperXY, lowerXY)) {
                        // Create a 1x1 square at position (x,y) with z = zLevel
                        const square = [
                            [x, y, zLevel],         // bottom-left
                            [x + 1, y, zLevel],     // bottom-right
                            [x + 1, y + 1, zLevel], // top-right
                            [x, y + 1, zLevel]      // top-left
                        ];
                        horizontalSquares.push(square);
                    }
                }
            }

            return horizontalSquares;
        }

        shouldPlaceHorizontalSquare(x, y, upperPath, lowerPath) {
            // Check if a horizontal square at position (x,y) is valid
            // This is a simplified check - you may need to refine based on your specific rules

            // The square should be placed if both paths pass through or near this region
            const tolerance = 1.5; // Allow some tolerance for path proximity

            // Check if upper path passes near this region
            let upperNear = false;
            for (const point of upperPath) {
                if (Math.abs(point[0] - x) <= tolerance && Math.abs(point[1] - y) <= tolerance) {
                    upperNear = true;
                    break;
                }
            }

            // Check if lower path passes near this region
            let lowerNear = false;
            for (const point of lowerPath) {
                if (Math.abs(point[0] - x) <= tolerance && Math.abs(point[1] - y) <= tolerance) {
                    lowerNear = true;
                    break;
                }
            }

            return upperNear && lowerNear;
        }

        placeAllHorizontalLozenges(pathTriplets, addSquareFace) {
            // Algorithmic placement based on Mathematica logic
            // For each pair of consecutive paths, find horizontal lozenges between them

            const S = this.currentS;
            const T = this.currentT;
            const N = this.currentN;

            // Handle top boundary (above the first path at z=N)
            if (pathTriplets.length > 0) {
                const topZ = N;
                const firstPath = pathTriplets[0];

                // Top boundary path (extreme version of path 0 at same height)
                const topBoundary = [];
                for (let i = 0; i <= S; i++) {
                    topBoundary.push([i, 0, topZ]);
                }
                for (let i = 1; i <= T - S; i++) {
                    topBoundary.push([S, i, topZ]);
                }

                // Calculate horizontal lozenges between top boundary and first path
                const zLevel = topZ - 1;
                const horizontalMatrix = this.calculateHorizontalLozengeMatrix(topBoundary, firstPath, S, T);

                // Place squares where matrix value is 1
                for (let a = 0; a <= S; a++) {
                    for (let b = 0; b <= T - S; b++) {
                        if (a < horizontalMatrix.length && b < horizontalMatrix[a].length && horizontalMatrix[a][b] === 1) {
                            const square = [
                                [a, b, zLevel],         // bottom-left
                                [a + 1, b, zLevel],     // bottom-right
                                [a + 1, b + 1, zLevel], // top-right
                                [a, b + 1, zLevel]      // top-left
                            ];
                            addSquareFace(square[0], square[1], square[2], square[3], this.colors.gray3);
                        }
                    }
                }
            }

            // Handle middle paths (between consecutive actual paths)
            for (let pathIdx = 0; pathIdx < pathTriplets.length - 1; pathIdx++) {
                const upperPath = pathTriplets[pathIdx];      // Higher z-level path
                const lowerPath = pathTriplets[pathIdx + 1];  // Lower z-level path

                // The horizontal lozenges lie at z-level of upper path minus 1
                const zLevel = upperPath[0][2] - 1;

                // Calculate horizontal lozenges between these paths
                const horizontalMatrix = this.calculateHorizontalLozengeMatrix(upperPath, lowerPath, S, T);

                // Place squares where matrix value is 1
                for (let a = 0; a <= S; a++) {
                    for (let b = 0; b <= T - S; b++) {
                        if (a < horizontalMatrix.length && b < horizontalMatrix[a].length && horizontalMatrix[a][b] === 1) {
                            const square = [
                                [a, b, zLevel],         // bottom-left
                                [a + 1, b, zLevel],     // bottom-right
                                [a + 1, b + 1, zLevel], // top-right
                                [a, b + 1, zLevel]      // top-left
                            ];
                            addSquareFace(square[0], square[1], square[2], square[3], this.colors.gray3);
                        }
                    }
                }
            }

            // Handle bottom boundary (below the last path at z=0)
            if (pathTriplets.length > 0) {
                const lastPath = pathTriplets[pathTriplets.length - 1];

                // Bottom boundary path (extreme version of last path at height 0)
                const bottomBoundary = [];
                for (let i = 0; i <= T - S; i++) {
                    bottomBoundary.push([0, i, 0]);
                }
                for (let i = 1; i <= S; i++) {
                    bottomBoundary.push([i, T - S, 0]);
                }

                // Calculate horizontal lozenges between last path and bottom boundary
                const zLevel = 0;
                const horizontalMatrix = this.calculateHorizontalLozengeMatrix(lastPath, bottomBoundary, S, T);

                // Place squares where matrix value is 1
                for (let a = 0; a <= S; a++) {
                    for (let b = 0; b <= T - S; b++) {
                        if (a < horizontalMatrix.length && b < horizontalMatrix[a].length && horizontalMatrix[a][b] === 1) {
                            const square = [
                                [a, b, zLevel],         // bottom-left
                                [a + 1, b, zLevel],     // bottom-right
                                [a + 1, b + 1, zLevel], // top-right
                                [a, b + 1, zLevel]      // top-left
                            ];
                            addSquareFace(square[0], square[1], square[2], square[3], this.colors.gray3);
                        }
                    }
                }
            }
        }

        calculateHorizontalLozengeMatrix(upperPath, lowerPath, S, T) {
            // Implement the Mathematica logic: q[z] function and matrix calculation
            // Matrix dimensions: (S+1) rows (a=0 to S) × (T-S+1) columns (b=0 to T-S)
            const matrix = Array(S + 1).fill().map(() => Array(T - S + 1).fill(0));

            // Extract q[z] for both paths using extractLastFromIncreasing logic
            const upperQ = this.calculateQFunction(upperPath);
            const lowerQ = this.calculateQFunction(lowerPath);

            // Apply the condition: If[q[z][[b + 1]] > a >= q[z + 1][[b + 1]], 1, 0]
            for (let a = 0; a <= S; a++) {
                for (let b = 0; b <= T - S; b++) {
                    const upperVal = upperQ[b] || 0;  // q[z][[b + 1]] (1-indexed in Mathematica)
                    const lowerVal = lowerQ[b] || 0;  // q[z + 1][[b + 1]]

                    if (upperVal > a && a >= lowerVal) {
                        matrix[a][b] = 1;
                    }
                }
            }

            return matrix;
        }

        calculateQFunction(path) {
            // Implement: q[z] := Last /@ Split[Table[If[p[z][[i]][[1]] == p[z][[i]][[2]], p[z][[i]][[2]], p[z][[i]][[1]]], {i, 1, 11}], #1 < #2 &]

            // Step 1: Create the table - for each point, take x if x != y, otherwise take y
            const table = [];
            for (let i = 0; i < path.length; i++) {
                const [x, y, z] = path[i];
                if (x === y) {
                    table.push(y);
                } else {
                    table.push(x);
                }
            }

            // Step 2: Apply extractLastFromIncreasing (equivalent to Last /@ Split[..., #1 < #2 &])
            return this.extractLastFromIncreasing(table);
        }

        extractLastFromIncreasing(list) {
            const result = [];
            let i = 0;
            while (i < list.length) {
                let j = i;
                // Find the end of increasing sequence
                while (j + 1 < list.length && list[j] < list[j + 1]) {
                    j++;
                }
                result.push(list[j]); // Take the last element of the increasing sequence
                i = j + 1;
            }
            return result;
        }

        centerCamera(maxX, maxY, maxZ) {
            // Use ideal camera settings
            // Target: (34.1, 18.4, 11.4)
            // Camera: (74.3, -36.7, 58.8)
            // Distance: 83.1

            // Set controls target to the ideal position
            this.controls.target.set(34.1, 18.4, 11.4);

            // Set camera to ideal position
            this.camera.position.set(74.3, -36.7, 58.8);

            this.controls.update();

            // Add controls change listener to update UI
            this.controls.addEventListener('change', () => {
                this.updateCameraUI();
            });

            // Initial UI update
            this.updateCameraUI();
        }

        animate() {
            requestAnimationFrame(() => this.animate());

            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }

        getCameraInfo() {
            const dx = this.camera.position.x - this.controls.target.x;
            const dy = this.camera.position.y - this.controls.target.y;
            const dz = this.camera.position.z - this.controls.target.z;
            const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);

            return {
                position: {
                    x: this.camera.position.x,
                    y: this.camera.position.y,
                    z: this.camera.position.z
                },
                target: {
                    x: this.controls.target.x,
                    y: this.controls.target.y,
                    z: this.controls.target.z
                },
                distance: distance
            };
        }

        setCameraPosition(x, y, z, distance) {
            // Keep the same target, update camera position based on distance
            const target = this.controls.target.clone();

            // Calculate direction from target to new position
            const dx = x - target.x;
            const dy = y - target.y;
            const dz = z - target.z;
            const currentDist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            if (currentDist > 0) {
                // Normalize and scale by desired distance
                const scale = distance / currentDist;
                this.camera.position.set(
                    target.x + dx * scale,
                    target.y + dy * scale,
                    target.z + dz * scale
                );
            }

            this.controls.update();
        }

        updateCameraUI() {
            const info = this.getCameraInfo();

            // Update input fields
            document.getElementById('cam-x').value = info.position.x.toFixed(2);
            document.getElementById('cam-y').value = info.position.y.toFixed(2);
            document.getElementById('cam-z').value = info.position.z.toFixed(2);
            document.getElementById('cam-distance').value = info.distance.toFixed(2);

            // Update info text
            const infoText = `Camera: (${info.position.x.toFixed(1)}, ${info.position.y.toFixed(1)}, ${info.position.z.toFixed(1)}) | Target: (${info.target.x.toFixed(1)}, ${info.target.y.toFixed(1)}, ${info.target.z.toFixed(1)}) | Distance: ${info.distance.toFixed(1)}`;
            document.getElementById('camera-info').textContent = infoText;
        }
    }

    // Main Application
    const wasmInterface = new WASMInterface();
    let tilingVisualizer = null;
    let tiling3DVisualizer = null;
    let is3DView = true; // Default to 3D view

    // Initialize
    async function init() {
        try {
            await wasmInterface.initialize();

            // Initialize 2D visualizer
            const canvas = document.getElementById('lozenge-canvas');
            tilingVisualizer = new TilingVisualizer(canvas);

            // Initialize 3D visualizer
            const container = document.getElementById('three-container');
            tiling3DVisualizer = new Tiling3DVisualizer(container);

            // Initialize color swatches
            if (tilingVisualizer) {
                tilingVisualizer.updateColorSwatches();
            }

            // Initialize with default parameters
            await initializeTiling();

            // Update visualization
            updateVisualization();

            // DEBUG MODE (commented out):
            /*
            const debugPaths = [
                // p[-1] (top boundary) - at z=6
                [[0,0,6], [1,0,6], [2,0,6], [3,0,6], [4,0,6], [5,0,6], [6,0,6], [6,1,6], [6,2,6], [6,3,6], [6,4,6]],
                // p[0] - at z=5
                [[0,0,5], [1,0,5], [2,0,5], [2,1,5], [3,1,5], [3,2,5], [4,2,5], [5,2,5], [5,3,5], [6,3,5], [6,4,5]],
                // p[1] - at z=4
                [[0,0,4], [1,0,4], [2,0,4], [2,1,4], [3,1,4], [3,2,4], [3,3,4], [4,3,4], [5,3,4], [6,3,4], [6,4,4]],
                // p[2] - at z=3
                [[0,0,3], [0,1,3], [1,1,3], [2,1,3], [3,1,3], [3,2,3], [3,3,3], [4,3,3], [5,3,3], [5,4,3], [6,4,3]],
                // p[3] - at z=2
                [[0,0,2], [0,1,2], [0,2,2], [1,2,2], [2,2,2], [3,2,2], [3,3,2], [4,3,2], [4,4,2], [5,4,2], [6,4,2]],
                // p[4] (bottom) - at z=1
                [[0,0,1], [0,1,1], [0,2,1], [0,3,1], [0,4,1], [1,4,1], [2,4,1], [3,4,1], [4,4,1], [5,4,1], [6,4,1]]
            ];
            wasmInterface.N_param = 5;
            wasmInterface.T_param = 10;
            wasmInterface.S_param = 6;
            wasmInterface.q_param = 1.0;
            wasmInterface.paths = debugPaths;
            wasmInterface.ready = true;
            updateVisualization();
            */

            // Set up event listeners
            setupEventListeners();

            // Set initial details state based on screen size
            setInitialDetailsState();

            // Auto-initialize and perform 20 S→S+1 operations
            await autoInitializeAndRun();

        } catch (error) {
            console.error('Initialization error:', error);
            alert('Failed to initialize: ' + error.message);
        }
    }

    function setInitialDetailsState() {
        const isMobile = window.innerWidth <= 767;

        // These are always open on load (but still foldable)
        document.getElementById('config-details').open = true;
        document.getElementById('legend-details').open = true;
        document.getElementById('keyboard-info-details').open = true;
        document.getElementById('animation-controls-details').open = true;

        if (isMobile) {
            // On mobile: about section closed
            document.getElementById('about-simulation-details').open = false;
        } else {
            // On PC: about section also open
            document.getElementById('about-simulation-details').open = true;
        }
    }

    async function autoInitializeAndRun() {
        try {
            // Initialize with default parameters
            await initializeTiling();

            // Perform 20 S→S+1 operations
            for (let i = 0; i < 20; i++) {
                try {
                    await wasmInterface.stepForward();
                    updateVisualization();
                    // Small delay to show progress
                    await new Promise(resolve => setTimeout(resolve, 50));
                } catch (error) {
                    console.log(`Stopped at operation ${i + 1}: ${error.message}`);
                    break;
                }
            }
        } catch (error) {
            console.error('Auto-initialization error:', error);
        }
    }

    async function initializeTiling() {
        const N = parseInt(document.getElementById('N').value) || 20;
        const T = parseInt(document.getElementById('T').value) || 50;
        let S = parseInt(document.getElementById('S').value) || 0;
        let q = parseFloat(document.getElementById('q').value) || 1.0;

        // Handle Imaginary q-Racah mode
        const imaginaryMode = document.getElementById('imaginary-q-racah').checked;
        let mode = 5; // Default to Q_HAHN
        if (imaginaryMode) {
            // In imaginary q-Racah mode, we need both q and kappa parameters
            const imaginaryQ = parseFloat(document.getElementById('imaginary-q').value) || 0.5;
            const kappaI = parseFloat(document.getElementById('kappa-i').value) || 3.0;
            const kappasq = kappaI * kappaI; // kappasq = (kappa/i)^2

            // Encode kappasq as negative q (simple approach)
            q = -kappasq;
            mode = 7; // Use IMAGINARY_Q_RACAH mode

            // In imaginary q-Racah mode, always reset S to 0 for initialization
            S = 0;
            document.getElementById('S').value = 0; // Update UI to reflect reset
        }

        try {
            console.log(`Initializing tiling: N=${N}, T=${T}, S=${S}, mode=${mode}, q=${q}`);
            await wasmInterface.initializeTilingWasm({
                N: N,
                T: T,
                S: S,
                mode: mode,
                q: q
            });

            // Force refresh paths from WASM after initialization
            await wasmInterface.refreshPaths();
            console.log('Paths after initialization:', wasmInterface.getPaths());

            // Update visualization immediately after initialization to show S=0 tiling
            updateVisualization();
        } catch (error) {
            console.error('Initialization failed:', error);
            alert('Initialization failed: ' + error.message);
        }
    }

    function updateVisualization() {
        const params = wasmInterface.getParameters();
        const paths = wasmInterface.getPaths();

        console.log('updateVisualization called with params:', params);
        console.log('Paths length:', paths.length);
        console.log('First few paths:', paths.slice(0, 3));

        // Update the S input field to reflect current S value
        document.getElementById('S').value = params.S;

        // Update configuration display
        updateConfigDisplay(params);

        if (is3DView) {
            console.log('Updating 3D visualization');
            tiling3DVisualizer.pathsTo3D(paths, params.N, params.T, params.S);
        } else {
            console.log('Updating 2D visualization');
            tilingVisualizer.draw(paths, params.N, params.T, params.S);
        }
    }

    function updateConfigDisplay(params) {
        const infoElement = document.getElementById('info');
        if (infoElement) {
            const imaginaryMode = document.getElementById('imaginary-q-racah').checked;

            if (imaginaryMode) {
                // In imaginary q-Racah mode, display the UI values for q and κ/i
                const imaginaryQ = parseFloat(document.getElementById('imaginary-q').value) || 0.5;
                const kappaI = parseFloat(document.getElementById('kappa-i').value) || 3.0;

                infoElement.innerHTML = `
                    <span class="config-item">N = <strong>${params.N}</strong></span>
                    <span class="config-item">T = <strong>${params.T}</strong></span>
                    <span class="config-item">S = <strong>${params.S}</strong></span>
                    <span class="config-item">q = <strong>${imaginaryQ}</strong></span>
                    <span class="config-item">κ/i = <strong>${kappaI}</strong></span>
                `;
            } else {
                // Regular mode, display the regular q parameter
                infoElement.innerHTML = `
                    <span class="config-item">N = <strong>${params.N}</strong></span>
                    <span class="config-item">T = <strong>${params.T}</strong></span>
                    <span class="config-item">S = <strong>${params.S}</strong></span>
                    <span class="config-item">q = <strong>${params.q}</strong></span>
                `;
            }
        }
    }

    function generateTikZCode(paths, params, colors) {
        if (!paths || paths.length === 0) return '';

        const { N, T, S } = params;
        const sqrt3 = Math.sqrt(3);

        let tikzCode = `% TikZ code for lozenge tiling
% Parameters: N=${N}, T=${T}, S=${S}
\\begin{tikzpicture}[scale=1]

% Define colors
\\definecolor{uprhombi}{HTML}{${colors.gray1.substring(1)}}
\\definecolor{downrhombi}{HTML}{${colors.gray2.substring(1)}}
\\definecolor{horizontal}{HTML}{${colors.gray3.substring(1)}}
\\definecolor{bordercolor}{HTML}{${colors.border.substring(1)}}

`;

        // Draw the hexagon boundary
        const vertices = [
            { x: 0, y: 0 },
            { x: 0, y: N },
            { x: S * 0.5 * sqrt3, y: N + S * 0.5 },
            { x: T * 0.5 * sqrt3, y: N + (2 * S - T) * 0.5 },
            { x: T * 0.5 * sqrt3, y: (2 * S - T) * 0.5 },
            { x: (T - S) * 0.5 * sqrt3, y: -(T - S) * 0.5 }
        ];

        tikzCode += `% Hexagon boundary\n\\draw[thick] `;
        vertices.forEach((v, i) => {
            tikzCode += `(${v.x.toFixed(3)}, ${v.y.toFixed(3)})`;
            tikzCode += i < vertices.length - 1 ? ' -- ' : ' -- cycle;\n\n';
        });

        // Draw rhombi
        for (let i = 0; i < T; i++) {
            for (let j = 0; j < N; j++) {
                const currentHeight = paths[j][i];
                const nextHeight = paths[j][i + 1];

                const x1 = i * 0.5 * sqrt3;
                const y1 = currentHeight - i * 0.5;
                const x2 = x1;
                const y2 = y1 + 1;

                let x3, y3, x4, y4, fillColor;

                if (nextHeight === currentHeight) {
                    // Down rhombus
                    x3 = x2 + 0.5 * sqrt3;
                    y3 = y2 - 0.5;
                    x4 = x1 + 0.5 * sqrt3;
                    y4 = y1 - 0.5;
                    fillColor = 'uprhombi';
                } else {
                    // Up rhombus
                    x3 = x2 + 0.5 * sqrt3;
                    y3 = y2 + 0.5;
                    x4 = x1 + 0.5 * sqrt3;
                    y4 = y1 + 0.5;
                    fillColor = 'downrhombi';
                }

                tikzCode += `\\fill[${fillColor}] (${x1.toFixed(3)}, ${y1.toFixed(3)}) -- (${x2.toFixed(3)}, ${y2.toFixed(3)}) -- (${x3.toFixed(3)}, ${y3.toFixed(3)}) -- (${x4.toFixed(3)}, ${y4.toFixed(3)}) -- cycle;\n`;
                tikzCode += `\\draw[bordercolor, thin] (${x1.toFixed(3)}, ${y1.toFixed(3)}) -- (${x2.toFixed(3)}, ${y2.toFixed(3)}) -- (${x3.toFixed(3)}, ${y3.toFixed(3)}) -- (${x4.toFixed(3)}, ${y4.toFixed(3)}) -- cycle;\n`;
            }
        }

        tikzCode += `\n\\end{tikzpicture}`;
        return tikzCode;
    }

    function pointInPolygon(point, vs) {
        // ray-casting algorithm based on https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html
        const x = point[0], y = point[1];
        let inside = false;
        for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
            const xi = vs[i][0], yi = vs[i][1];
            const xj = vs[j][0], yj = vs[j][1];
            const intersect = ((yi > y) !== (yj > y))
                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    function generatePDF(paths, params, colors, borderWidth) {
        if (!paths || paths.length === 0) return;
        if (!window.jspdf) {
            alert('PDF library is not loaded. Please try again.');
            return;
        }

        const { jsPDF } = window.jspdf;
        const { N, T, S } = params;
        const sqrt3 = Math.sqrt(3);

        // 1. Define Hexagon Geometry & PDF Layout
        const hexVertices = [
            [0, 0], [0, N], [S * 0.5 * sqrt3, N + S * 0.5],
            [T * 0.5 * sqrt3, N + (2 * S - T) * 0.5], [T * 0.5 * sqrt3, (2 * S - T) * 0.5],
            [(T - S) * 0.5 * sqrt3, -(T - S) * 0.5]
        ];
        const minX = Math.min(...hexVertices.map(v => v[0]));
        const maxX = Math.max(...hexVertices.map(v => v[0]));
        const minY = Math.min(...hexVertices.map(v => v[1]));
        const maxY = Math.max(...hexVertices.map(v => v[1]));
        const hexWidth = maxX - minX;
        const hexHeight = maxY - minY;

        const pdf = new jsPDF({ orientation: hexWidth > hexHeight ? 'landscape' : 'portrait', unit: 'pt', format: 'a4' });
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const margin = 20; // in points
        const scale = Math.min((pageWidth - 2 * margin) / hexWidth, (pageHeight - 2 * margin) / hexHeight);
        const offsetX = (pageWidth - hexWidth * scale) / 2;
        const offsetY = pageHeight - (pageHeight - hexHeight * scale) / 2;

        // 2. Define Helper Functions
        const hexToRgb = hex => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [0, 0, 0];
        };

        const transform = p => [offsetX + (p[0] - minX) * scale, offsetY - (p[1] - minY) * scale];

        const drawPolygon = (vertices, fillColor) => {
            const transformed = vertices.map(transform);
            pdf.setFillColor(...hexToRgb(fillColor));
            pdf.setDrawColor(...hexToRgb(colors.border));
            pdf.setLineWidth(borderWidth * scale * 0.5);

            // Use lines method instead of polygon
            const lines = [];
            for (let i = 0; i < transformed.length; i++) {
                const current = transformed[i];
                const next = transformed[(i + 1) % transformed.length];
                lines.push([next[0] - current[0], next[1] - current[1]]);
            }
            pdf.lines(lines, transformed[0][0], transformed[0][1], [1, 1], 'FD');
        };

        // 3. Painter's Algorithm: Background -> Tiling -> Border
        // Step 3a: Draw background of horizontal lozenges inside the hexagon
        const timeStart = Math.floor(minX / (0.5 * sqrt3));
        const timeEnd = Math.ceil(maxX / (0.5 * sqrt3));
        for (let timeIdx = timeStart; timeIdx <= timeEnd; timeIdx++) {
            const hStart = Math.floor(minY + timeIdx * 0.5);
            const hEnd = Math.ceil(maxY + timeIdx * 0.5);
            for (let h = hStart; h <= hEnd; h++) {
                const x1 = timeIdx * 0.5 * sqrt3;
                const y1 = h - timeIdx * 0.5;
                const centerX = x1 + 0.5 * sqrt3;
                const centerY = y1;
                if (pointInPolygon([centerX, centerY], hexVertices)) {
                    drawPolygon([
                        [x1, y1], [x1 + 0.5 * sqrt3, y1 + 0.5],
                        [x1 + sqrt3, y1], [x1 + 0.5 * sqrt3, y1 - 0.5]
                    ], colors.gray3);
                }
            }
        }

        // Step 3b: Draw the actual up and down rhombi from the paths data
        for (let i = 0; i < T; i++) {
            for (let j = 0; j < N; j++) {
                const currentHeight = paths[j][i];
                const nextHeight = paths[j][i + 1];
                const x1 = i * 0.5 * sqrt3;
                const y1 = currentHeight - i * 0.5;
                let vertices, fillColor;
                if (nextHeight === currentHeight) { // "Down" rhombus
                    fillColor = colors.gray1;
                    vertices = [[x1, y1], [x1, y1 + 1], [x1 + 0.5 * sqrt3, y1 + 0.5], [x1 + 0.5 * sqrt3, y1 - 0.5]];
                } else { // "Up" rhombus
                    fillColor = colors.gray2;
                    vertices = [[x1, y1], [x1, y1 + 1], [x1 + 0.5 * sqrt3, y1 + 1.5], [x1 + 0.5 * sqrt3, y1 + 0.5]];
                }
                drawPolygon(vertices, fillColor);
            }
        }

        // Step 3c: Draw the final hexagon border
        pdf.setLineWidth(0.8); // Thicker final border
        pdf.setDrawColor(...hexToRgb(colors.border));

        const transformedHex = hexVertices.map(transform);
        const hexLines = [];
        for (let i = 0; i < transformedHex.length; i++) {
            const current = transformedHex[i];
            const next = transformedHex[(i + 1) % transformedHex.length];
            hexLines.push([next[0] - current[0], next[1] - current[1]]);
        }
        pdf.lines(hexLines, transformedHex[0][0], transformedHex[0][1], [1, 1], 'S'); // Stroke only

        // 4. Set Metadata and Save
        pdf.setProperties({
            title: `Lozenge Tiling N${N}_T${T}_S${S}`,
            subject: 'q-volume lozenge tiling',
            author: '3D q-volume lozenge tilings visualization',
            keywords: `lozenge tiling hexagon N=${N} T=${T} S${S} q=${params.q}`,
            creator: window.location.href
        });
        pdf.save(`lozenge_tiling_N${N}_T${T}_S${S}_q${params.q}.pdf`);
    }

    function exportPNG2D(paths, params, colors, borderWidth, quality) {
        if (!paths || paths.length === 0) return;
        if (!tilingVisualizer || !tilingVisualizer.canvas) return;

        // Calculate DPI multiplier (quality 0-100 maps to 72-600 DPI)
        const dpi = Math.max(72, Math.min(600, 72 + (quality / 100) * 528));
        const dpiMultiplier = dpi / 72; // 72 DPI is standard web resolution

        // Create a high-resolution temporary canvas
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');

        // Store original canvas dimensions
        const originalWidth = tilingVisualizer.canvas.width;
        const originalHeight = tilingVisualizer.canvas.height;
        const originalStyleWidth = tilingVisualizer.canvas.style.width;
        const originalStyleHeight = tilingVisualizer.canvas.style.height;

        // Set high-resolution dimensions
        const highResWidth = originalWidth * dpiMultiplier;
        const highResHeight = originalHeight * dpiMultiplier;

        tempCanvas.width = highResWidth;
        tempCanvas.height = highResHeight;

        // Temporarily replace the visualizer's canvas context
        const originalCanvas = tilingVisualizer.canvas;
        const originalCtx = tilingVisualizer.ctx;

        tilingVisualizer.canvas = tempCanvas;
        tilingVisualizer.ctx = tempCtx;

        // Scale context for high DPI
        tempCtx.scale(dpiMultiplier, dpiMultiplier);

        // Redraw at high resolution
        tilingVisualizer.draw(paths, params.N, params.T, params.S);

        // Export as PNG
        tempCanvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lozenge_tiling_2D_N${params.N}_T${params.T}_S${params.S}_q${params.q}_${Math.round(dpi)}dpi.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 'image/png');

        // Restore original canvas
        tilingVisualizer.canvas = originalCanvas;
        tilingVisualizer.ctx = originalCtx;
    }


    function toggleView() {
        is3DView = !is3DView;
        const canvas = document.getElementById('lozenge-canvas');
        const container = document.getElementById('three-container');

        if (is3DView) {
            canvas.style.display = 'none';
            container.style.display = 'block';
            tiling3DVisualizer.handleResize();
        } else {
            canvas.style.display = 'block';
            container.style.display = 'none';
        }

        updateVisualization();
    }

// Paste this new block before the 'function setupEventListeners()' line,
// replacing the old STL code entirely.

// =======================================================================
// =================== STL EXPORT FUNCTIONALITY (v3) =====================
// =======================================================================

/**
 * Main function to generate and download the STL file.
 * This version builds the model from a height map for maximum robustness.
 */
function generateAndDownloadSTL() {
    console.log("Starting STL export (v3)...");
    const params = wasmInterface.getParameters();
    const paths = wasmInterface.getPaths();

    if (!paths || !paths.length) {
        alert("No tiling data available to export.");
        return;
    }

    // 1. Generate a height map z=f(x,y) from the raw path data.
    const heightMap = getHeightMap(paths, params);
    console.log(`Generated a height map with ${heightMap.size} columns.`);

    // 2. Generate the full set of cubes from the height map.
    const cubeSet = new Set();
    heightMap.forEach((height, key) => {
        const [x, y] = key.split(',').map(Number);
        for (let z = 0; z < height; z++) {
            cubeSet.add(`${x},${y},${z}`);
        }
    });
    console.log(`Generated a set of ${cubeSet.size} total cubes.`);

    // 3. Iterate through each cube and check its neighbors to find exterior faces.
    let stlString = 'solid lozenge_tiling_model\n';
    const directions = [
        { dir: [1, 0, 0], name: '+X' }, { dir: [-1, 0, 0], name: '-X' },
        { dir: [0, 1, 0], name: '+Y' }, { dir: [0, -1, 0], name: '-Y' },
        { dir: [0, 0, 1], name: '+Z' }, { dir: [0, 0, -1], name: '-Z' }
    ];
    const stringToVec = (s) => { const p = s.split(',').map(Number); return { x: p[0], y: p[1], z: p[2] }; };

    cubeSet.forEach(cubeKey => {
        const cubePos = stringToVec(cubeKey);
        directions.forEach(d => {
            const neighborPos = { x: cubePos.x + d.dir[0], y: cubePos.y + d.dir[1], z: cubePos.z + d.dir[2] };
            if (!cubeSet.has(`${neighborPos.x},${neighborPos.y},${neighborPos.z}`)) {
                const faceTriangles = getCubeFace(cubePos, d.name);
                faceTriangles.forEach(tri => {
                    const n = calculateNormal(tri[0], tri[1], tri[2]);
                    stlString += `  facet normal ${n.x.toFixed(6)} ${n.y.toFixed(6)} ${n.z.toFixed(6)}\n`;
                    stlString += '    outer loop\n';
                    stlString += `      vertex ${tri[0].x.toFixed(6)} ${tri[0].y.toFixed(6)} ${tri[0].z.toFixed(6)}\n`;
                    stlString += `      vertex ${tri[1].x.toFixed(6)} ${tri[1].y.toFixed(6)} ${tri[1].z.toFixed(6)}\n`;
                    stlString += `      vertex ${tri[2].x.toFixed(6)} ${tri[2].y.toFixed(6)} ${tri[2].z.toFixed(6)}\n`;
                    stlString += '    endloop\n';
                    stlString += '  endfacet\n';
                });
            }
        });
    });

    stlString += 'endsolid lozenge_tiling_model\n';

    // 4. Trigger download.
    const blob = new Blob([stlString], { type: 'application/sla' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const { N, T, S, q } = params;
    link.download = `lozenge_solid_N${N}_T${T}_S${S}_q${q}.stl`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
    console.log("STL export complete.");
}

/**
 * Calculates a 2D height map `z = f(x,y)` from the source path data.
 * This is the foundation of the robust STL generation.
 * @returns {Map<string, number>} A map where key is "X,Y" and value is height Z.
 */
function getHeightMap(paths, { N, T, S }) {
    const heightMap = new Map();

    // 1. Generate the same path data used by the 3D visualizer.
    // Each path is a list of [x, y] points in a base plane.
    const pathTriplets = [];
    for (let i = 0; i < paths.length; i++) {
        const pathCopy = paths[i].slice().reverse();
        const firstElement = pathCopy[0];
        const adjustedPath = pathCopy.map(x => firstElement - x);
        let x = 0, y = 0;
        const triplets = [{ x, y }]; // z is constant per path, so we ignore it here
        for (let j = 1; j < adjustedPath.length; j++) {
            const prev = adjustedPath[j - 1], curr = adjustedPath[j];
            if (curr === prev + 1) x++; else if (curr === prev) y++;
            triplets.push({ x, y });
        }
        pathTriplets.push(triplets);
    }

    // 2. For each point on the base grid, count how many paths pass "above" it.
    // This count is the height of the cube column at that point.
    const maxX = S;
    const maxY = T - S;

    for (let x = 0; x <= maxX; x++) {
        for (let y = 0; y <= maxY; y++) {
            let height = 0;
            for (const path of pathTriplets) {
                // Find the path's y-value at our current x.
                let pathYatX = -1;
                const pathSegment = path.find(p => p.x === x);
                if (pathSegment) {
                    pathYatX = pathSegment.y;
                } else {
                    // If no point on path has this x, find where it crosses.
                    for (let i = 1; i < path.length; i++) {
                        if (path[i-1].x < x && path[i].x > x) {
                            pathYatX = path[i-1].y; // y is constant during an x-step
                            break;
                        }
                    }
                }

                // If the grid point (x,y) is under or on the path, it's covered.
                if (y <= pathYatX) {
                    height++;
                }
            }

            if (height > 0) {
                // The visualizer swaps x and y for rendering, so we do too for consistency.
                const key = `${y},${x}`;
                heightMap.set(key, height);
            }
        }
    }
    return heightMap;
}


/**
 * Returns the 2 triangles for a specific face of a cube.
 * The winding order ensures the normal points outwards.
 */
function getCubeFace(pos, faceName) {
    const v = [
        { x: pos.x,     y: pos.y,     z: pos.z },     // 0: bottom-left-back
        { x: pos.x + 1, y: pos.y,     z: pos.z },     // 1: bottom-right-back
        { x: pos.x + 1, y: pos.y + 1, z: pos.z },     // 2: bottom-right-front
        { x: pos.x,     y: pos.y + 1, z: pos.z },     // 3: bottom-left-front
        { x: pos.x,     y: pos.y,     z: pos.z + 1 }, // 4: top-left-back
        { x: pos.x + 1, y: pos.y,     z: pos.z + 1 }, // 5: top-right-back
        { x: pos.x + 1, y: pos.y + 1, z: pos.z + 1 }, // 6: top-right-front
        { x: pos.x,     y: pos.y + 1, z: pos.z + 1 }  // 7: top-left-front
    ];
    switch (faceName) {
        case '+X': return [[v[1], v[5], v[6]], [v[1], v[6], v[2]]]; // Right
        case '-X': return [[v[0], v[3], v[7]], [v[0], v[7], v[4]]]; // Left
        case '+Y': return [[v[2], v[6], v[7]], [v[2], v[7], v[3]]]; // Front
        case '-Y': return [[v[0], v[4], v[5]], [v[0], v[5], v[1]]]; // Back
        case '+Z': return [[v[4], v[7], v[6]], [v[4], v[6], v[5]]]; // Top
        case '-Z': return [[v[0], v[1], v[2]], [v[0], v[2], v[3]]]; // Bottom
        default: return [];
    }
}

// --- Vector Math Helpers ---
const V = {
  sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
  cross: (a, b) => ({ x: a.y * b.z - a.z * b.y, y: a.z * b.x - a.x * b.z, z: a.x * b.y - a.y * b.x }),
};
const calculateNormal = (v1, v2, v3) => {
    const n = V.cross(V.sub(v2, v1), V.sub(v3, v1));
    const l = Math.sqrt(n.x * n.x + n.y * n.y + n.z * n.z);
    return l > 0 ? { x: n.x / l, y: n.y / l, z: n.z / l } : { x: 0, y: 0, z: 0 };
};

// =================== END OF STL EXPORT CODE (v3) =====================
//

// Old v4 layer export function removed to prevent conflicts with v5

// =======================================================================
// ================ STL EXPORT FUNCTIONALITY (v5 - FINAL) ================
// =======================================================================

/**
 * Main function to generate and download a SOLID STL file.
 * This version uses the corrected getHeightMap to produce a hole-free model.
 */
function generateAndDownloadSTL() {
    console.log("Starting STL Solid export (v5)...");
    const params = wasmInterface.getParameters();
    const paths = wasmInterface.getPaths();
    if (!paths || !paths.length) { alert("No tiling data available to export."); return; }

    const heightMap = getHeightMap(paths, params);
    const cubeSet = new Set();
    heightMap.forEach((height, key) => {
        const [x, y] = key.split(',').map(Number);
        for (let z = 0; z < height; z++) {
            cubeSet.add(`${x},${y},${z}`);
        }
    });

    const stlString = generateSTLFromCubeSet(cubeSet, "lozenge_tiling_solid");
    downloadSTL(stlString, `lozenge_solid_N${params.N}_T${params.T}_S${params.S}_q${params.q}.stl`);
    console.log("STL Solid export complete.");
}

/**
 * Main function to generate and download a hollow STL LAYER.
 * Creates a layer between the top surface and the surface shifted by (-a,-a,-a).
 */
function generateAndDownloadSTLLayer() {
    console.log("Starting STL Layer export (v5)...");
    const params = wasmInterface.getParameters();
    const paths = wasmInterface.getPaths();
    if (!paths || !paths.length) { alert("No tiling data available to export."); return; }

    const a = Math.round(Math.min(5, params.N / 10));
    console.log(`Using layer thickness a = ${a}`);

    // Generate the height map for the top surface
    const topHeightMap = getHeightMap(paths, params);
    
    // Generate the height map for the bottom surface (shifted by (-a,-a,-a))
    const bottomHeightMap = new Map();
    topHeightMap.forEach((height, key) => {
        const [x, y] = key.split(',').map(Number);
        // The shifted surface is at position (x-a, y-a) with height reduced by a
        const shiftedKey = `${x - a},${y - a}`;
        if (topHeightMap.has(shiftedKey)) {
            const shiftedHeight = topHeightMap.get(shiftedKey) - a;
            bottomHeightMap.set(key, Math.max(0, shiftedHeight)); // Ensure non-negative height
        } else {
            bottomHeightMap.set(key, 0); // Default to ground level if no shifted surface exists
        }
    });

    // Create the layer between the two surfaces
    const layerCubeSet = new Set();
    topHeightMap.forEach((topHeight, key) => {
        const [x, y] = key.split(',').map(Number);
        const bottomHeight = bottomHeightMap.get(key) || 0;
        
        // Add cubes that exist between the bottom surface and top surface
        for (let z = bottomHeight; z < topHeight; z++) {
            layerCubeSet.add(`${x},${y},${z}`);
        }
    });

    console.log(`Generated a layer with ${layerCubeSet.size} cubes between surfaces.`);

    if (layerCubeSet.size === 0) {
        alert("The calculated layer is empty. No STL file will be generated.");
        return;
    }

    const stlString = generateSTLFromCubeSet(layerCubeSet, "lozenge_tiling_layer");
    downloadSTL(stlString, `lozenge_layer_a${a}_N${params.N}_T${params.T}_S${params.S}_q${params.q}.stl`);
    console.log("STL Layer export complete.");
}

/**
 * [CORRECTED] Calculates a 2D height map z = f(x,y) from the source path data.
 * This version is more robust and prevents holes in the surface.
 * @returns {Map<string, number>} A map where key is "X,Y" and value is height Z.
 */
function getHeightMap(paths, { N, T, S }) {
    const heightMap = new Map();

    const allPathsXY = [];
    for (let i = 0; i < paths.length; i++) {
        const pathCopy = paths[i].slice().reverse();
        const firstElement = pathCopy[0];
        const adjustedPath = pathCopy.map(x => firstElement - x);
        let x = 0, y = 0;
        const pathPoints = [{ x, y }];
        for (let j = 1; j < adjustedPath.length; j++) {
            const prev = adjustedPath[j - 1], curr = adjustedPath[j];
            if (curr === prev + 1) x++; else if (curr === prev) y++;
            pathPoints.push({ x, y });
        }
        allPathsXY.push(pathPoints);
    }

    const pathYLUT = allPathsXY.map(path => {
        const lut = new Array(S + 1);
        let currentY = 0;
        let pathIdx = 0;
        for (let x = 0; x <= S; x++) {
            while(pathIdx < path.length && path[pathIdx].x <= x) {
                if(path[pathIdx].x === x) currentY = path[pathIdx].y;
                pathIdx++;
            }
            lut[x] = currentY;
        }
        return lut;
    });

    for (let x_p = 0; x_p <= S; x_p++) {
        for (let y_p = 0; y_p <= T - S; y_p++) {
            let height = 0;
            pathYLUT.forEach(lut => {
                if (y_p <= lut[x_p]) {
                    height++;
                }
            });
            if (height > 0) {
                heightMap.set(`${y_p},${x_p}`, height);
            }
        }
    }
    return heightMap;
}

/**
 * Generic utility to generate an STL string from a set of cube coordinates.
 */
function generateSTLFromCubeSet(cubeSet, modelName) {
    let stlString = `solid ${modelName}\n`;
    const directions = [
        { dir: [1, 0, 0], name: '+X' }, { dir: [-1, 0, 0], name: '-X' },
        { dir: [0, 1, 0], name: '+Y' }, { dir: [0, -1, 0], name: '-Y' },
        { dir: [0, 0, 1], name: '+Z' }, { dir: [0, 0, -1], name: '-Z' }
    ];
    const stringToVec = (s) => { const p = s.split(',').map(Number); return { x: p[0], y: p[1], z: p[2] }; };

    cubeSet.forEach(cubeKey => {
        const cubePos = stringToVec(cubeKey);
        directions.forEach(d => {
            const neighborPos = { x: cubePos.x + d.dir[0], y: cubePos.y + d.dir[1], z: cubePos.z + d.dir[2] };
            if (!cubeSet.has(`${neighborPos.x},${neighborPos.y},${neighborPos.z}`)) {
                const faceTriangles = getCubeFace(cubePos, d.name);
                faceTriangles.forEach(tri => {
                    const n = calculateNormalV5(tri[0], tri[1], tri[2]);
                    stlString += `  facet normal ${n.x.toFixed(6)} ${n.y.toFixed(6)} ${n.z.toFixed(6)}\n`;
                    stlString += '    outer loop\n';
                    stlString += `      vertex ${tri[0].x.toFixed(6)} ${tri[0].y.toFixed(6)} ${tri[0].z.toFixed(6)}\n`;
                    stlString += `      vertex ${tri[1].x.toFixed(6)} ${tri[1].y.toFixed(6)} ${tri[1].z.toFixed(6)}\n`;
                    stlString += `      vertex ${tri[2].x.toFixed(6)} ${tri[2].y.toFixed(6)} ${tri[2].z.toFixed(6)}\n`;
                    stlString += '    endloop\n';
                    stlString += '  endfacet\n';
                });
            }
        });
    });
    stlString += `endsolid ${modelName}\n`;
    return stlString;
}

/**
 * Generic utility to trigger the download of an STL file.
 */
function downloadSTL(stlString, fileName) {
    const blob = new Blob([stlString], { type: 'application/sla' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
}

/**
 * Returns the 2 triangles for a specific face of a cube.
 */
function getCubeFace(pos, faceName) {
    const v = [
        { x: pos.x, y: pos.y, z: pos.z }, { x: pos.x + 1, y: pos.y, z: pos.z },
        { x: pos.x + 1, y: pos.y + 1, z: pos.z }, { x: pos.x, y: pos.y + 1, z: pos.z },
        { x: pos.x, y: pos.y, z: pos.z + 1 }, { x: pos.x + 1, y: pos.y, z: pos.z + 1 },
        { x: pos.x + 1, y: pos.y + 1, z: pos.z + 1 }, { x: pos.x, y: pos.y + 1, z: pos.z + 1 }
    ];
    switch (faceName) {
        case '+X': return [[v[1], v[5], v[6]], [v[1], v[6], v[2]]];
        case '-X': return [[v[0], v[3], v[7]], [v[0], v[7], v[4]]];
        case '+Y': return [[v[2], v[6], v[7]], [v[2], v[7], v[3]]];
        case '-Y': return [[v[0], v[4], v[5]], [v[0], v[5], v[1]]];
        case '+Z': return [[v[4], v[7], v[6]], [v[4], v[6], v[5]]];
        case '-Z': return [[v[0], v[1], v[2]], [v[0], v[2], v[3]]];
        default: return [];
    }
}

// --- Vector Math Helpers for v5 STL Export ---
const V5 = {
  sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
  cross: (a, b) => ({ x: a.y * b.z - a.z * b.y, y: a.z * b.x - a.x * b.z, z: a.x * b.y - a.y * b.x }),
};
const calculateNormalV5 = (v1, v2, v3) => {
    const n = V5.cross(V5.sub(v2, v1), V5.sub(v3, v1));
    const l = Math.sqrt(n.x * n.x + n.y * n.y + n.z * n.z);
    return l > 0 ? { x: n.x / l, y: n.y / l, z: n.z / l } : { x: 0, y: 0, z: 0 };
};

// ================= END OF STL EXPORT CODE (v5) =================


    function setupEventListeners() {
        // Initialize button
        document.getElementById('initialize').addEventListener('click', async () => {
            // Check if we're in imaginary mode and reset S properly
            const imaginaryMode = document.getElementById('imaginary-q-racah').checked;
            console.log('Initialize button clicked, imaginary mode:', imaginaryMode);
            if (imaginaryMode) {
                // Force S to 0 and update the S field
                document.getElementById('S').value = 0;
                console.log('Reset S to 0 for imaginary mode');
            }

            console.log('Calling initializeTiling from Initialize button');
            await initializeTiling();
            console.log('initializeTiling complete, calling updateVisualization');
            updateVisualization();
        });

        // Set parameters button
        document.getElementById('set-parameters')?.addEventListener('click', async () => {
            try {
                // Get current UI values
                const N = parseInt(document.getElementById('N').value) || 20;
                const T = parseInt(document.getElementById('T').value) || 50;
                const S = parseInt(document.getElementById('S').value) || 0;
                let q = parseFloat(document.getElementById('q').value) || 1.0;
                const visualStyle = parseInt(document.getElementById('style').value) || 1;

                // Handle Imaginary q-Racah mode
                const imaginaryMode = document.getElementById('imaginary-q-racah').checked;
                let mode = 5; // Default to Q_HAHN
                if (imaginaryMode) {
                    // In imaginary q-Racah mode, we need both q and kappa parameters
                    const imaginaryQ = parseFloat(document.getElementById('imaginary-q').value) || 0.5;
                    const kappaI = parseFloat(document.getElementById('kappa-i').value) || 3.0;
                    const kappasq = kappaI * kappaI; // kappasq = (kappa/i)^2

                    // Validate imaginary q-Racah parameters
                    if (imaginaryQ <= 0 || imaginaryQ >= 1) {
                        throw new Error('q must be strictly between 0 and 1 for imaginary q-Racah mode');
                    }
                    if (kappaI <= 0) {
                        throw new Error('κ/i must be positive for imaginary q-Racah mode');
                    }

                    // Set the imaginary q parameter separately, encode kappasq as negative q
                    if (wasmInterface.ready) {
                        wasmInterface.setImaginaryQ(imaginaryQ);
                    }
                    q = -kappasq;
                    mode = 7; // Use IMAGINARY_Q_RACAH mode
                } else {
                    // Validate regular q parameter
                    if (q <= 0) {
                        throw new Error('q must be positive for regular q-Hahn mode');
                    }
                }

                const currentParams = wasmInterface.getParameters();

                // Check if N, T, or S changed - these require reinitialization
                if (N !== currentParams.N || T !== currentParams.T || S !== currentParams.S) {
                    alert('Cannot change N, T, or S without creating a new tiling. Use "Initialize" instead.');
                    return;
                }

                // Update style directly in visualizer (no WASM call needed)
                if (tilingVisualizer) {
                    tilingVisualizer.setStyle(visualStyle);
                }

                // Update q parameter via WASM if it changed
                if (Math.abs(currentParams.q - q) > 0.001 || mode !== currentParams.mode) {
                    console.log(`Updating parameters: q from ${currentParams.q} to ${q}, mode from ${currentParams.mode} to ${mode}`);
                    try {
                        await wasmInterface.updateParametersWasm({ mode, q });
                        console.log(`Successfully updated q parameter to ${q}`);
                    } catch (error) {
                        // If WASM update fails, try updating locally as fallback
                        console.warn('WASM parameter update failed, updating locally:', error);
                        wasmInterface.mode_param = mode;
                        wasmInterface.q_param = q;
                        console.log(`Updated q parameter locally from ${currentParams.q} to ${q}`);
                    }
                }

                // Update the visualization
                updateVisualization();
            } catch (error) {
                const errorMessage = error?.message || error?.toString() || 'Unknown error';
                alert('Invalid parameters: ' + errorMessage);
            }
        });

        // Animation controls
        document.getElementById('step-plus')?.addEventListener('click', async () => {
            const steps = parseInt(document.getElementById('steps').value) || 1;
            for (let i = 0; i < steps; i++) {
                try {
                    await wasmInterface.stepForward();
                } catch (error) {
                    break;
                }
            }
            updateVisualization();
        });

        document.getElementById('step-minus')?.addEventListener('click', async () => {
            const steps = parseInt(document.getElementById('steps').value) || 1;
            for (let i = 0; i < steps; i++) {
                try {
                    await wasmInterface.stepBackward();
                } catch (error) {
                    break;
                }
            }
            updateVisualization();
        });

        document.getElementById('step-plus-back')?.addEventListener('click', async () => {
            const steps = parseInt(document.getElementById('steps').value) || 1;
            for (let i = 0; i < steps; i++) {
                try {
                    await wasmInterface.stepForward();
                } catch (error) {
                    break;
                }
            }
            for (let i = 0; i < steps; i++) {
                try {
                    await wasmInterface.stepBackward();
                } catch (error) {
                    break;
                }
            }
            updateVisualization();
        });

        document.getElementById('step-minus-forward')?.addEventListener('click', async () => {
            const steps = parseInt(document.getElementById('steps').value) || 1;
            for (let i = 0; i < steps; i++) {
                try {
                    await wasmInterface.stepBackward();
                } catch (error) {
                    break;
                }
            }
            for (let i = 0; i < steps; i++) {
                try {
                    await wasmInterface.stepForward();
                } catch (error) {
                    break;
                }
            }
            updateVisualization();
        });

        // View controls
        document.getElementById('toggle-view')?.addEventListener('click', toggleView);
        document.getElementById('zoom-in')?.addEventListener('click', () => {
            if (!is3DView && tilingVisualizer) {
                tilingVisualizer.zoom(1.2);
                updateVisualization();
            }
        });
        document.getElementById('zoom-out')?.addEventListener('click', () => {
            if (!is3DView && tilingVisualizer) {
                tilingVisualizer.zoom(0.8);
                updateVisualization();
            }
        });
        document.getElementById('zoom-reset')?.addEventListener('click', () => {
            if (!is3DView && tilingVisualizer) {
                tilingVisualizer.resetZoom();
                updateVisualization();
            }
        });

        // Camera controls for 3D view
        document.getElementById('apply-camera')?.addEventListener('click', () => {
            if (is3DView && tiling3DVisualizer) {
                const x = parseFloat(document.getElementById('cam-x').value) || 0;
                const y = parseFloat(document.getElementById('cam-y').value) || 0;
                const z = parseFloat(document.getElementById('cam-z').value) || 0;
                const distance = parseFloat(document.getElementById('cam-distance').value) || 50;

                tiling3DVisualizer.setCameraPosition(x, y, z, distance);
            }
        });

        document.getElementById('reset-camera')?.addEventListener('click', () => {
            if (is3DView && tiling3DVisualizer) {
                // Get current bounds to reset camera
                const params = wasmInterface.getParameters();
                const maxDim = Math.max(params.N, params.T);
                tiling3DVisualizer.centerCamera(maxDim/2, maxDim/2, maxDim/2);
            }
        });

        // Imaginary q-Racah checkbox control
        document.getElementById('imaginary-q-racah')?.addEventListener('change', (e) => {
            const kappaParam = document.getElementById('kappa-param');
            const regularQParam = document.getElementById('regular-q-param');
            const stepMinusBtn = document.getElementById('step-minus');
            const stepMinusForwardBtn = document.getElementById('step-minus-forward');
            const qInput = document.getElementById('q');

            if (e.target.checked) {
                // Show imaginary q-Racah parameters, hide regular q parameter
                kappaParam.style.display = 'flex';
                regularQParam.style.display = 'none';
            } else {
                // Hide imaginary q-Racah parameters, show regular q parameter
                kappaParam.style.display = 'none';
                regularQParam.style.display = 'flex';
                // In normal mode, q parameter must be positive
                qInput.setAttribute('min', '0.01');
            }
        });

        // Style controls
        document.getElementById('style')?.addEventListener('change', (e) => {
            const style = parseInt(e.target.value);
            if (tilingVisualizer) {
                tilingVisualizer.setStyle(style);
                updateVisualization();
            }
        });

        // Border width controls
        document.getElementById('border-width')?.addEventListener('input', (e) => {
            const width = parseFloat(e.target.value);
            if (tilingVisualizer) {
                tilingVisualizer.setBorderWidth(width);
                updateVisualization();
            }
        });

        document.getElementById('border-thin')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.setBorderWidth(0.001);
                document.getElementById('border-width').value = 0.001;
                updateVisualization();
            }
        });

        document.getElementById('border-medium')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.setBorderWidth(0.01);
                document.getElementById('border-width').value = 0.01;
                updateVisualization();
            }
        });

        document.getElementById('border-thick')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.setBorderWidth(0.03);
                document.getElementById('border-width').value = 0.03;
                updateVisualization();
            }
        });

        document.getElementById('border-ultra-thick')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.setBorderWidth(0.06);
                document.getElementById('border-width').value = 0.06;
                updateVisualization();
            }
        });

        // Palette controls
        document.getElementById('palette-select')?.addEventListener('change', (e) => {
            const paletteIndex = parseInt(e.target.value);
            if (tilingVisualizer) {
                tilingVisualizer.setPalette(paletteIndex);
                if (tiling3DVisualizer) {
                    tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                }
                updateVisualization();
            }
        });

        document.getElementById('prev-palette')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.cyclePalette(-1);
                if (tiling3DVisualizer) {
                    tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                }
                updateVisualization();
            }
        });

        document.getElementById('next-palette')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.cyclePalette(1);
                if (tiling3DVisualizer) {
                    tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                }
                updateVisualization();
            }
        });

        document.getElementById('permute-colors')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.permuteColors();
                if (tiling3DVisualizer) {
                    tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                }
                updateVisualization();
            }
        });

        // Custom colors
        document.getElementById('custom-colors')?.addEventListener('click', () => {
            const panel = document.getElementById('custom-colors-panel');
            if (panel) {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        });

        document.getElementById('close-custom-colors')?.addEventListener('click', () => {
            const panel = document.getElementById('custom-colors-panel');
            if (panel) {
                panel.style.display = 'none';
            }
        });

        // Custom color inputs
        const colorInputs = ['gray1', 'gray2', 'gray3', 'border'];
        colorInputs.forEach(colorType => {
            document.getElementById(`color-${colorType}`)?.addEventListener('input', (e) => {
                const color = e.target.value;
                document.getElementById(`hex-${colorType}`).value = color;
                if (tilingVisualizer) {
                    tilingVisualizer.setCustomColor(colorType, color);
                    if (tiling3DVisualizer) {
                        tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                    }
                    updateVisualization();
                }
            });

            document.getElementById(`hex-${colorType}`)?.addEventListener('input', (e) => {
                const color = e.target.value;
                if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                    document.getElementById(`color-${colorType}`).value = color;
                    if (tilingVisualizer) {
                        tilingVisualizer.setCustomColor(colorType, color);
                        if (tiling3DVisualizer) {
                            tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                        }
                        updateVisualization();
                    }
                }
            });
        });

        document.getElementById('reset-default-colors')?.addEventListener('click', () => {
            if (tilingVisualizer) {
                tilingVisualizer.setPalette(0); // Reset to UVA colors
                if (tiling3DVisualizer) {
                    tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                }
                updateVisualization();
                // Update custom color inputs
                document.getElementById('color-gray1').value = tilingVisualizer.colors.gray1;
                document.getElementById('hex-gray1').value = tilingVisualizer.colors.gray1;
                document.getElementById('color-gray2').value = tilingVisualizer.colors.gray2;
                document.getElementById('hex-gray2').value = tilingVisualizer.colors.gray2;
                document.getElementById('color-gray3').value = tilingVisualizer.colors.gray3;
                document.getElementById('hex-gray3').value = tilingVisualizer.colors.gray3;
                document.getElementById('color-border').value = tilingVisualizer.colors.border;
                document.getElementById('hex-border').value = tilingVisualizer.colors.border;
            }
        });

document.getElementById('export-stl')?.addEventListener('click', generateAndDownloadSTL);
document.getElementById('export-stl-layer')?.addEventListener('click', generateAndDownloadSTLLayer);


        // TikZ Export
        document.getElementById('export-tikz')?.addEventListener('click', () => {
            if (!tilingVisualizer) return;

            const paths = wasmInterface.getPaths();
            const params = wasmInterface.getParameters();

            if (!paths || paths.length === 0) {
                alert('No tiling data to export. Please initialize first.');
                return;
            }

            const tikzCode = generateTikZCode(paths, params, tilingVisualizer.colors);
            document.getElementById('tikz-export-textarea').value = tikzCode;
            document.getElementById('tikz-export-display').style.display = 'block';
        });

        document.getElementById('copy-tikz-clipboard')?.addEventListener('click', () => {
            const textarea = document.getElementById('tikz-export-textarea');
            textarea.select();
            document.execCommand('copy');
            alert('TikZ code copied to clipboard!');
        });

        document.getElementById('download-tikz-file')?.addEventListener('click', () => {
            const tikzCode = document.getElementById('tikz-export-textarea').value;
            const blob = new Blob([tikzCode], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'lozenge_tiling.tex';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        document.getElementById('hide-tikz-export')?.addEventListener('click', () => {
            document.getElementById('tikz-export-display').style.display = 'none';
        });

        // PDF Export
        document.getElementById('export-pdf')?.addEventListener('click', () => {
            if (!tilingVisualizer) return;

            const paths = wasmInterface.getPaths();
            const params = wasmInterface.getParameters();

            if (!paths || paths.length === 0) {
                alert('No tiling data to export. Please initialize first.');
                return;
            }

            generatePDF(paths, params, tilingVisualizer.colors, tilingVisualizer.borderWidth);
        });

        // PNG Quality Slider
        document.getElementById('png-quality')?.addEventListener('input', (e) => {
            const quality = parseInt(e.target.value);
            document.getElementById('png-quality-value').textContent = quality;
        });

        // PNG Export
        document.getElementById('export-png')?.addEventListener('click', () => {
            if (is3DView) {
                alert('PNG export is only available in 2D view. Please switch to 2D view first.');
                return;
            }

            const paths = wasmInterface.getPaths();
            const params = wasmInterface.getParameters();

            if (!paths || paths.length === 0) {
                alert('No tiling data to export. Please initialize first.');
                return;
            }

            if (!tilingVisualizer) return;

            const quality = parseInt(document.getElementById('png-quality').value) || 85;
            exportPNG2D(paths, params, tilingVisualizer.colors, tilingVisualizer.borderWidth, quality);
        });

        // JSON Export
        document.getElementById('export-json')?.addEventListener('click', () => {
            if (!tilingVisualizer) return;

            const paths = wasmInterface.getPaths();
            const params = wasmInterface.getParameters();

            if (!paths || paths.length === 0) {
                alert('No tiling data to export. Please initialize first.');
                return;
            }

            const lozengeData = {
                version: "1.0",
                timestamp: new Date().toISOString(),
                parameters: params,
                paths: paths,
                colors: tilingVisualizer.colors,
                metadata: {
                    generator: "3D q-volume lozenge tilings visualization",
                    url: window.location.href
                }
            };

            const jsonString = JSON.stringify(lozengeData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lozenge_tiling_N${params.N}_T${params.T}_S${params.S}_q${params.q}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // JSON Import
        document.getElementById('import-json')?.addEventListener('click', () => {
            document.getElementById('json-file-input').click();
        });

        document.getElementById('json-file-input')?.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const lozengeData = JSON.parse(e.target.result);

                    // Validate the JSON structure
                    if (!lozengeData.parameters || !lozengeData.paths) {
                        throw new Error('Invalid lozenge data format. Missing parameters or paths.');
                    }

                    // Update parameters in UI
                    const params = lozengeData.parameters;
                    document.getElementById('N').value = params.N || 40;
                    document.getElementById('T').value = params.T || 80;
                    document.getElementById('S').value = params.S || 10;
                    document.getElementById('q').value = params.q || 1.0;

                    // Update WASM interface with the imported data
                    wasmInterface.N_param = params.N;
                    wasmInterface.T_param = params.T;
                    wasmInterface.S_param = params.S;
                    wasmInterface.q_param = params.q;
                    wasmInterface.mode_param = params.mode || 5;
                    wasmInterface.paths = lozengeData.paths;

                    // Update colors if available
                    if (lozengeData.colors && tilingVisualizer) {
                        tilingVisualizer.colors = { ...tilingVisualizer.colors, ...lozengeData.colors };
                        tilingVisualizer.updateColorSwatches();
                        if (tiling3DVisualizer) {
                            tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                        }
                    }

                    // Update visualization
                    updateVisualization();

                    alert(`Successfully imported lozenge tiling data:\nN=${params.N}, T=${params.T}, S=${params.S}, q=${params.q}`);

                } catch (error) {
                    alert('Error importing JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);

            // Reset the file input so the same file can be imported again if needed
            event.target.value = '';
        });

        // Enhanced keyboard shortcuts
        document.addEventListener('keydown', async (e) => {
            // Don't handle shortcuts if user is typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            try {
                const steps = parseInt(document.getElementById('steps')?.value) || 1;

                switch(e.key.toLowerCase()) {
                    case 'a':
                        for (let i = 0; i < steps; i++) {
                            try {
                                await wasmInterface.stepForward();
                            } catch (error) {
                                break;
                            }
                        }
                        updateVisualization();
                        break;
                    case 'z':
                        for (let i = 0; i < steps; i++) {
                            try {
                                await wasmInterface.stepBackward();
                            } catch (error) {
                                break;
                            }
                        }
                        updateVisualization();
                        break;
                    case 's':
                        for (let i = 0; i < steps; i++) {
                            try {
                                await wasmInterface.stepForward();
                            } catch (error) {
                                break;
                            }
                        }
                        for (let i = 0; i < steps; i++) {
                            try {
                                await wasmInterface.stepBackward();
                            } catch (error) {
                                break;
                            }
                        }
                        updateVisualization();
                        break;
                    case 'x':
                        for (let i = 0; i < steps; i++) {
                            try {
                                await wasmInterface.stepBackward();
                            } catch (error) {
                                break;
                            }
                        }
                        for (let i = 0; i < steps; i++) {
                            try {
                                await wasmInterface.stepForward();
                            } catch (error) {
                                break;
                            }
                        }
                        updateVisualization();
                        break;
                    case 'v':
                        toggleView();
                        break;
                    case 'c':
                        if (tilingVisualizer) {
                            tilingVisualizer.cyclePalette(e.shiftKey ? -1 : 1);
                            if (tiling3DVisualizer) {
                                tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                            }
                            updateVisualization();
                        }
                        break;
                    case 'p':
                        if (tilingVisualizer) {
                            tilingVisualizer.permuteColors();
                            if (tiling3DVisualizer) {
                                tiling3DVisualizer.updateColors(tilingVisualizer.colors);
                            }
                            updateVisualization();
                        }
                        break;
                    case 'b':
                        if (tilingVisualizer) {
                            tilingVisualizer.cycleBorderWidth();
                            updateVisualization();
                        }
                        break;
                    case 'r':
                        if (is3DView && tiling3DVisualizer) {
                            // Reset camera to center view
                            const params = wasmInterface.getParameters();
                            const maxDim = Math.max(params.N, params.T);
                            tiling3DVisualizer.centerCamera(maxDim/2, maxDim/2, maxDim/2);
                        }
                        break;
                }
            } catch (error) {
                console.error('Operation failed:', error);
            }
        });
    }

    // Start the application
    init();
};
</script>
