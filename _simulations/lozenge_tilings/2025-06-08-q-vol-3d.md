---
title: Minimal q-volume lozenge tilings visualization
model: lozenge-tilings
author: 'Vadim Gorin (original code); Leonid Petrov (porting)'
---

<style>
  /* Minimal styling */
  .interface-container {
    max-width: 1000px;
    margin: 0 auto;
    padding: 16px;
  }

  .control-group {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
  }

  .parameters-grid {
    display: flex;
    gap: 16px;
    margin-bottom: 12px;
  }

  #lozenge-canvas, #three-canvas {
    width: 100%;
    max-width: 800px;
    height: 600px;
    border: 1px solid #ccc;
    display: block;
    margin: 0 auto;
  }

  #three-container {
    width: 100%;
    max-width: 800px;
    height: 600px;
    margin: 0 auto;
    border: 1px solid #ccc;
    display: block; /* Shown by default, 3D is default */
  }

  .keyboard-info {
    margin-top: 20px;
    padding: 10px;
    background: #f0f0f0;
    border-radius: 4px;
  }


</style>

<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>
<script src="/js/2025-06-08-q-vol-3d.js"></script>

<div class="interface-container">
  <!-- Parameters Only -->
  <div class="control-group">
    <div class="parameters-grid">
      <div>
        <label for="N">N:</label>
        <input type="number" id="N" value="4" min="1" max="200" style="width: 60px;">
      </div>
      <div>
        <label for="T">T:</label>
        <input type="number" id="T" value="10" min="1" max="500" style="width: 60px;">
      </div>
      <div>
        <label for="S">S:</label>
        <input type="number" id="S" value="0" min="0" style="width: 60px;">
      </div>
      <div>
        <label for="q">q:</label>
        <input type="number" id="q" value="1" step="0.02" min="0.01" style="width: 80px;">
      </div>
      <button id="initialize">Initialize</button>
    </div>
  </div>
</div>

<!-- 2D Visualization (hidden) -->
<canvas id="lozenge-canvas" style="display: none;"></canvas>

<!-- 3D Visualization (default) -->
<div id="three-container">
  <canvas id="three-canvas"></canvas>
</div>

<div class="keyboard-info">
  <strong>Keyboard shortcuts:</strong><br>
  A: S → S+1 | Z: S → S-1 | S: S → S+1 → S-1 | X: S → S-1 → S+1 | V: Toggle 2D/3D view
</div>


<script>
// Minimal UVA color scheme only
const UVA_COLORS = {
    gray1: '#E57200', // Orange - Up rhombi
    gray2: '#232D4B', // Navy - Down rhombi
    gray3: '#F9DCBF', // Beige - Horizontal
    border: '#666666'
};

Module.onRuntimeInitialized = async function() {
    // WASM Interface Class
    class WASMInterface {
        constructor() {
            this.ready = false;
            this.N_param = 4;
            this.T_param = 10;
            this.S_param = 0;
            this.mode_param = 5;
            this.q_param = 1.0;
            this.paths = [];
        }

        async initialize() {
            if (typeof Module === 'undefined') {
                throw new Error('Module is not defined. WASM JavaScript file may not be loaded.');
            }
            if (typeof Module.cwrap !== 'function') {
                throw new Error('Module.cwrap is not a function. WASM module may not be properly initialized.');
            }

            // Wrap exported functions
            this.initializeTiling = Module.cwrap('initializeTiling', 'number', ['number', 'number', 'number', 'number', 'number'], {async: true});
            this.performSOperator = Module.cwrap('performSOperator', 'number', [], {async: true});
            this.performSMinusOperator = Module.cwrap('performSMinusOperator', 'number', [], {async: true});
            this.exportPaths = Module.cwrap('exportPaths', 'number', [], {async: true});
            this.updateParameters = Module.cwrap('updateParameters', 'number', ['number', 'number'], {async: true});
            this.freeString = Module.cwrap('freeString', null, ['number']);

            this.ready = true;
        }

        async initializeTilingWasm(params) {
            if (!this.ready) throw new Error('WASM not ready');

            this.N_param = params.N;
            this.T_param = params.T;
            this.S_param = params.S;
            this.mode_param = params.mode;
            this.q_param = params.q;

            try {
                const ptr = await this.initializeTiling(params.N, params.T, params.S, params.mode, params.q);
                if (!ptr) {
                    throw new Error('initializeTiling returned null pointer');
                }
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`Initialization failed: ${error.message}`);
            }
        }

        async stepForward() {
            if (!this.ready) throw new Error('WASM not ready');
            if (this.S_param >= this.T_param) throw new Error('Cannot perform S→S+1: already at maximum');

            try {
                const ptr = await this.performSOperator();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                this.S_param = result.s;
                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`S operator failed: ${error.message}`);
            }
        }

        async stepBackward() {
            if (!this.ready) throw new Error('WASM not ready');
            if (this.S_param <= 0) throw new Error('Cannot perform S→S-1: already at minimum');

            try {
                const ptr = await this.performSMinusOperator();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                this.S_param = result.s;
                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`S- operator failed: ${error.message}`);
            }
        }

        async refreshPaths() {
            try {
                const ptr = await this.exportPaths();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (!result.error) {
                    this.paths = result.paths;
                }
            } catch (error) {
                console.error('Failed to refresh paths:', error);
            }
        }

        getPaths() {
            return this.paths;
        }

        getParameters() {
            return {
                N: this.N_param,
                T: this.T_param,
                S: this.S_param,
                mode: this.mode_param,
                q: this.q_param
            };
        }
    }

    // 2D Tiling Visualizer Class (using original drawing logic)
    class TilingVisualizer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.colors = {
                ...UVA_COLORS,
                white: '#FFFFFF',
                black: '#000000'
            };
            this.borderWidth = 0.01;
            this.style = 1; // Lozenges
            this.zoomLevel = 1.0;
            this.panX = 0;
            this.panY = 0;
        }

        updateCanvasDimensions(N, T, S) {
            const sqrt3 = Math.sqrt(3);

            // Calculate the bounding box of the hexagon
            const minX = 0;
            const maxX = T * 0.5 * sqrt3;
            const minY = -(T - S) * 0.5;
            const maxY = N + Math.max(S * 0.5, (2 * S - T) * 0.5);

            const hexWidth = maxX - minX;
            const hexHeight = maxY - minY;

            // Set canvas size with some padding
            const padding = 50;
            const canvasWidth = Math.min(hexWidth * 100 + padding * 2, window.innerWidth * 0.9);
            const canvasHeight = Math.min(hexHeight * 100 + padding * 2, window.innerHeight * 0.8);

            // Set canvas size accounting for device pixel ratio
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = canvasWidth * dpr;
            this.canvas.height = canvasHeight * dpr;
            this.canvas.style.width = canvasWidth + 'px';
            this.canvas.style.height = canvasHeight + 'px';

            // Scale context for high DPI displays
            this.ctx.scale(dpr, dpr);
        }

        draw(paths, N, T, S) {
            // Update canvas dimensions to fit hexagon exactly
            this.updateCanvasDimensions(N, T, S);

            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = this.colors.white;
            ctx.fillRect(0, 0, width, height);

            if (this.style === 5) {
                this.drawLatticePathsStyle(paths, N, T, S);
            } else {
                this.drawHexagonStyle(paths, N, T, S);
            }
        }

        drawHexagonStyle(paths, N, T, S) {
            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            const sqrt3 = Math.sqrt(3);

            // Calculate the bounding box of the hexagon
            const minX = 0;
            const maxX = T * 0.5 * sqrt3;
            const minY = -(T - S) * 0.5;
            const maxY = N + Math.max(S * 0.5, (2 * S - T) * 0.5);

            const hexWidth = maxX - minX;
            const hexHeight = maxY - minY;
            const hexCenterX = (minX + maxX) / 2;
            const hexCenterY = (minY + maxY) / 2;

            const margin = 0; // No margin - fit hexagon exactly
            const scale = Math.min(
                (width - 2 * margin) / hexWidth,
                (height - 2 * margin) / hexHeight
            ) * this.zoomLevel;

            ctx.save();
            ctx.translate(this.panX, this.panY);
            ctx.translate(width / 2, height / 2);
            ctx.scale(-scale, scale);  // Flip horizontally with negative x scale
            // Center the hexagon
            ctx.translate(-hexCenterX, -hexCenterY);

            this.drawBackgroundHexagon(N, T, S);

            for (let i = 0; i < T; i++) {
                for (let j = 0; j < N; j++) {
                    const currentHeight = paths[j][i];
                    const nextHeight = paths[j][i + 1];
                    this.drawRhombus(i, j, currentHeight, nextHeight);
                }
            }

            // Draw paths on top of the tiling
            this.drawPathsOverlay(paths, N, T, S);

            ctx.restore();
        }

        drawBackgroundHexagon(N, T, S) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            // First, clip to the hexagon shape
            const vertices = [
                {x: 0, y: 0},
                {x: 0, y: N},
                {x: S * 0.5 * sqrt3, y: N + S * 0.5},
                {x: T * 0.5 * sqrt3, y: N + (2 * S - T) * 0.5},
                {x: T * 0.5 * sqrt3, y: (2 * S - T) * 0.5},
                {x: (T - S) * 0.5 * sqrt3, y: -(T - S) * 0.5}
            ];

            ctx.save();

            // Create clipping path
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < 6; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.clip();

            // Draw background rhombi with borders aligned to lozenge grid
            for (let timeIdx = -1; timeIdx <= T; timeIdx++) {
                for (let height = -(T - S + 2); height <= N + S + 2; height++) {
                    // Use the same coordinate system as the actual rhombi
                    const x1 = timeIdx * 0.5 * sqrt3;
                    const y1 = height - timeIdx * 0.5;

                    // Calculate rhombus center for bounds checking
                    const centerX = x1 + 0.25 * sqrt3;
                    const centerY = y1 + 0.5;

                    // Check if rhombus center is roughly within bounds
                    if (centerX >= -0.5 * sqrt3 && centerX <= (T + 1) * 0.5 * sqrt3 &&
                        centerY >= -(T - S + 2) * 0.5 && centerY <= N + S + 1) {

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x1+0.5 * sqrt3, y1 + 0.5);
                        ctx.lineTo(x1 + sqrt3, y1);
                        ctx.lineTo(x1 + 0.5 * sqrt3, y1 - 0.5);
                        ctx.closePath();

                        ctx.fillStyle = this.colors.gray3;
                        ctx.fill();

                        ctx.strokeStyle = this.colors.border;
                        ctx.lineWidth = this.borderWidth;
                        ctx.stroke();
                    }
                }
            }

            ctx.restore();
        }

        drawRhombus(timeIdx, particleIdx, height, nextHeight) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            const x1 = timeIdx * 0.5 * sqrt3;
            const y1 = height - timeIdx * 0.5;
            const x2 = x1;
            const y2 = y1 + 1;

            let x3, y3, x4, y4;
            let fillColor;

            if (nextHeight === height) {
                // Down rhombus
                x3 = x2 + 0.5 * sqrt3;
                y3 = y2 - 0.5;
                x4 = x1 + 0.5 * sqrt3;
                y4 = y1 - 0.5;
                fillColor = this.colors.gray1;
            } else {
                // Up rhombus
                x3 = x2 + 0.5 * sqrt3;
                y3 = y2 + 0.5;
                x4 = x1 + 0.5 * sqrt3;
                y4 = y1 + 0.5;
                fillColor = this.colors.gray2;
            }

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.lineTo(x4, y4);
            ctx.closePath();

            ctx.fillStyle = fillColor;
            ctx.fill();

            // Add consistent thin borders to all rhombi
            ctx.strokeStyle = this.colors.border;
            ctx.lineWidth = this.borderWidth;
            ctx.stroke();
        }

        drawPathsOverlay(paths, N, T, S) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            // Draw paths as lines overlaid on the hexagon tiling
            ctx.save();

            // Draw each path
            for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
                const path = paths[pathIdx];

                ctx.beginPath();
                ctx.strokeStyle = '#FF0000';  // Red color for paths
                ctx.lineWidth = 0.05;
                ctx.fillStyle = '#FF0000';

                for (let timeIdx = 0; timeIdx < path.length; timeIdx++) {
                    const height = path[timeIdx];

                    // Convert to hexagon coordinates (same as rhombus coordinates)
                    const x = timeIdx * 0.5 * sqrt3;
                    const y = height - timeIdx * 0.5;

                    if (timeIdx === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    // Draw a small circle at each point
                    ctx.fillRect(x - 0.03, y - 0.03, 0.06, 0.06);
                }

                ctx.stroke();
            }

            ctx.restore();
        }

        drawLatticePathsStyle(paths, N, T, S) {
            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            const margin = 20; // Smaller margin for lattice paths
            const scaleX = (width - 2 * margin) / (T + 5);
            const scaleY = (height - 2 * margin) / (N + S + 5);
            const scale = Math.min(scaleX, scaleY) * this.zoomLevel;

            const maxY = N + S - 1;

            ctx.save();
            ctx.translate(this.panX + margin, this.panY + height - margin);
            ctx.scale(scale, -scale);

            ctx.fillStyle = this.colors.gray3;
            for (let i = 0; i <= T; i++) {
                for (let j = 0; j <= maxY; j++) {
                    ctx.fillRect(i - 0.1, j - 0.1, 0.2, 0.2);
                }
            }

            ctx.strokeStyle = this.colors.black;
            ctx.lineWidth = this.borderWidth;
            ctx.fillStyle = this.colors.black;

            for (let j = 0; j < N; j++) {
                ctx.beginPath();

                for (let i = 0; i <= T; i++) {
                    const x = i;
                    const y = paths[j][i];

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    ctx.fillRect(x - 0.05, y - 0.05, 0.1, 0.1);
                }

                ctx.stroke();
            }

            ctx.restore();
        }
    }

    // 3D Tiling Visualizer Class (minimal version with fixed pathsTo3D)
    class Tiling3DVisualizer {
        constructor(container) {
            this.container = container;
            this.colors = { ...UVA_COLORS };
            this.cameraInitialized = false;

            // Three.js setup
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0xffffff);

            // Camera
            this.camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );

            // Renderer
            this.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('three-canvas'),
                antialias: true
            });
            this.renderer.setSize(container.clientWidth, container.clientHeight);

            // Controls
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 10, 10);
            this.scene.add(directionalLight);

            // Group for rhombi
            this.boxGroup = new THREE.Group();
            this.scene.add(this.boxGroup);

            // Handle window resize
            window.addEventListener('resize', () => this.handleResize());

            // Start animation loop
            this.animate();
        }

        handleResize() {
            const width = this.container.clientWidth;
            const height = this.container.clientHeight;

            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();

            this.renderer.setSize(width, height);
        }

        pathsTo3D(paths, N, T, S) {
            // Store parameters for use in horizontal lozenge calculations
            this.currentN = N;
            this.currentT = T;
            this.currentS = S;
            
            // Clear existing geometry
            while(this.boxGroup.children.length > 0) {
                const child = this.boxGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                this.boxGroup.remove(child);
            }

            // Convert paths to triplet format (normal WASM mode)
            const pathTriplets = [];
            for (let i = 0; i < paths.length; i++) {
                const pathCopy = paths[i].slice().reverse();
                const firstElement = pathCopy[0];
                const adjustedPath = pathCopy.map(x => firstElement - x);

                const triplets = [];
                let x = 0, y = 0;
                const z = paths.length - i; // z-coordinate is constant for each path

                // Start with initial triplet
                triplets.push([x, y, z]);

                // Process each step in the path
                for (let j = 1; j < adjustedPath.length; j++) {
                    const prev = adjustedPath[j-1];
                    const curr = adjustedPath[j];

                    if (curr === prev + 1) {
                        // Path goes up by 1, increment first coordinate
                        x++;
                    } else if (curr === prev) {
                        // Path stays the same, increment second coordinate
                        y++;
                    }
                    triplets.push([x, y, z]);
                }
                pathTriplets.push(triplets);
            }

            // Create geometry for the surface
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const colors = [];
            const indices = [];

            // Helper to add a square face
            const addSquareFace = (v1, v2, v3, v4, color) => {
                const baseIndex = vertices.length / 3;

                // Add vertices
                vertices.push(v1[0], v1[1], v1[2]);
                vertices.push(v2[0], v2[1], v2[2]);
                vertices.push(v3[0], v3[1], v3[2]);
                vertices.push(v4[0], v4[1], v4[2]);

                // Calculate normal
                const edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
                const edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
                const normal = [
                    edge1[1] * edge2[2] - edge1[2] * edge2[1],
                    edge1[2] * edge2[0] - edge1[0] * edge2[2],
                    edge1[0] * edge2[1] - edge1[1] * edge2[0]
                ];
                const len = Math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2);
                if (len > 0) {
                    normal[0] /= len;
                    normal[1] /= len;
                    normal[2] /= len;
                }

                // Add normals
                for (let i = 0; i < 4; i++) {
                    normals.push(normal[0], normal[1], normal[2]);
                }

                // Add colors
                const c = new THREE.Color(color);
                for (let i = 0; i < 4; i++) {
                    colors.push(c.r, c.g, c.b);
                }

                // Add triangles
                indices.push(
                    baseIndex, baseIndex + 1, baseIndex + 2,
                    baseIndex, baseIndex + 2, baseIndex + 3
                );
            };

            // Create strips between consecutive paths (skip path -1 for vertical lozenges)
            for (let pathIdx = 1; pathIdx < pathTriplets.length; pathIdx++) {
                const topPath = pathTriplets[pathIdx];

                // Create bottom path by lowering z by 1
                const bottomPath = topPath.map(point => [point[0], point[1], point[2] - 1]);

                // Create strips between consecutive segments
                for (let i = 0; i < topPath.length - 1; i++) {
                    const topP1 = topPath[i];
                    const topP2 = topPath[i + 1];
                    const bottomP1 = bottomPath[i];
                    const bottomP2 = bottomPath[i + 1];

                    // Determine color based on segment direction
                    let color;
                    if (topP2[0] > topP1[0] && topP2[1] === topP1[1]) {
                        // x increases, y constant -> "up" rhombus
                        color = this.colors.gray2;
                    } else if (topP2[0] === topP1[0] && topP2[1] > topP1[1]) {
                        // x constant, y increases -> "down" rhombus
                        color = this.colors.gray1;
                    } else {
                        // Shouldn't happen with valid paths
                        color = this.colors.gray3;
                    }

                    // Create strip as a quadrilateral
                    // topP1 -> topP2 -> bottomP2 -> bottomP1
                    addSquareFace(topP1, topP2, bottomP2, bottomP1, color);
                }
            }

            // Place horizontal lozenges at all height levels
            this.placeAllHorizontalLozenges(pathTriplets, addSquareFace);

            // Find the bounds of the surface for camera positioning
            let maxX = 0, maxY = 0, maxZ = 0;
            for (const path of pathTriplets) {
                for (const point of path) {
                    maxX = Math.max(maxX, point[0]);
                    maxY = Math.max(maxY, point[1]);
                    maxZ = Math.max(maxZ, point[2]);
                }
            }

            // Set geometry attributes
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);

            // Create material
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: true
            });

            const mesh = new THREE.Mesh(geometry, material);
            this.boxGroup.add(mesh);

            // Add edges
            const edgesGeometry = new THREE.EdgesGeometry(geometry, 1);
            const edgesMaterial = new THREE.LineBasicMaterial({
                color: this.colors.border,
                linewidth: 2
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            this.boxGroup.add(edges);

            // Only center camera on initial load, not on resampling
            if (!this.cameraInitialized) {
                this.centerCamera(maxX, maxY, maxZ);
                this.cameraInitialized = true;
            }
        }

        addHorizontalLozenges(pathTriplets, addSquareFace) {
            // Horizontal lozenges have constant z-component and lie in xy-planes between path levels
            // Implementation based on the Mathematica logic
            
            // Process consecutive path pairs
            for (let pathIdx = 0; pathIdx < pathTriplets.length - 1; pathIdx++) {
                const upperPath = pathTriplets[pathIdx];      // Higher z-level
                const lowerPath = pathTriplets[pathIdx + 1];  // Lower z-level
                
                // The horizontal squares lie at the z-level of the lower path
                const zLevel = lowerPath[0][2];
                
                // Extract xy-projections and find horizontal squares
                const horizontalSquares = this.findHorizontalSquaresBetweenPaths(upperPath, lowerPath, zLevel);
                
                // Add each horizontal square as a face
                for (const square of horizontalSquares) {
                    addSquareFace(square[0], square[1], square[2], square[3], this.colors.gray3);
                }
            }
        }

        findHorizontalSquaresBetweenPaths(upperPath, lowerPath, zLevel) {
            const horizontalSquares = [];
            
            // Extract xy-projections of the paths (ignore z-coordinate)
            const upperXY = upperPath.map(point => [point[0], point[1]]);
            const lowerXY = lowerPath.map(point => [point[0], point[1]]);
            
            // Implement extractLastFromIncreasing logic from Mathematica
            const extractLastFromIncreasing = (list) => {
                const result = [];
                let i = 0;
                while (i < list.length) {
                    let j = i;
                    // Find the end of increasing sequence
                    while (j + 1 < list.length && list[j] < list[j + 1]) {
                        j++;
                    }
                    result.push(list[j]); // Take the last element of the increasing sequence
                    i = j + 1;
                }
                return result;
            };
            
            // Extract x-coordinates for both paths
            const upperXList = upperXY.map(point => point[0]);
            const lowerXList = lowerXY.map(point => point[0]);
            
            // Apply extractLastFromIncreasing to both paths
            const upperXExtracted = extractLastFromIncreasing(upperXList);
            const lowerXExtracted = extractLastFromIncreasing(lowerXList);
            
            // Find intersection of the two lists (common x-values)
            const commonX = upperXExtracted.filter(x => lowerXExtracted.includes(x));
            
            // Similarly for y-coordinates
            const upperYList = upperXY.map(point => point[1]);
            const lowerYList = lowerXY.map(point => point[1]);
            
            const upperYExtracted = extractLastFromIncreasing(upperYList);
            const lowerYExtracted = extractLastFromIncreasing(lowerYList);
            
            const commonY = upperYExtracted.filter(y => lowerYExtracted.includes(y));
            
            // Create horizontal squares for all combinations of common x,y values
            // Each square is a 1x1 unit square in the xy-plane at the given z-level
            for (const x of commonX) {
                for (const y of commonY) {
                    // Check if this (x,y) position should have a horizontal square
                    // by verifying it's properly between the paths
                    if (this.shouldPlaceHorizontalSquare(x, y, upperXY, lowerXY)) {
                        // Create a 1x1 square at position (x,y) with z = zLevel
                        const square = [
                            [x, y, zLevel],         // bottom-left
                            [x + 1, y, zLevel],     // bottom-right  
                            [x + 1, y + 1, zLevel], // top-right
                            [x, y + 1, zLevel]      // top-left
                        ];
                        horizontalSquares.push(square);
                    }
                }
            }
            
            return horizontalSquares;
        }
        
        shouldPlaceHorizontalSquare(x, y, upperPath, lowerPath) {
            // Check if a horizontal square at position (x,y) is valid
            // This is a simplified check - you may need to refine based on your specific rules
            
            // The square should be placed if both paths pass through or near this region
            const tolerance = 1.5; // Allow some tolerance for path proximity
            
            // Check if upper path passes near this region
            let upperNear = false;
            for (const point of upperPath) {
                if (Math.abs(point[0] - x) <= tolerance && Math.abs(point[1] - y) <= tolerance) {
                    upperNear = true;
                    break;
                }
            }
            
            // Check if lower path passes near this region  
            let lowerNear = false;
            for (const point of lowerPath) {
                if (Math.abs(point[0] - x) <= tolerance && Math.abs(point[1] - y) <= tolerance) {
                    lowerNear = true;
                    break;
                }
            }
            
            return upperNear && lowerNear;
        }

        placeAllHorizontalLozenges(pathTriplets, addSquareFace) {
            // Algorithmic placement based on Mathematica logic
            // For each pair of consecutive paths, find horizontal lozenges between them
            
            const S = this.currentS;
            const T = this.currentT;
            const N = this.currentN;
            
            // Handle top boundary (above the first path at z=N)
            if (pathTriplets.length > 0) {
                const topZ = N;
                const firstPath = pathTriplets[0];
                
                // Top boundary path (extreme version of path 0 at same height)
                const topBoundary = [];
                for (let i = 0; i <= S; i++) {
                    topBoundary.push([i, 0, topZ]);
                }
                for (let i = 1; i <= T - S; i++) {
                    topBoundary.push([S, i, topZ]);
                }
                
                // Calculate horizontal lozenges between top boundary and first path
                const zLevel = topZ - 1;
                const horizontalMatrix = this.calculateHorizontalLozengeMatrix(topBoundary, firstPath, S, T);
                
                // Place squares where matrix value is 1
                for (let a = 0; a <= S; a++) {
                    for (let b = 0; b <= T - S; b++) {
                        if (a < horizontalMatrix.length && b < horizontalMatrix[a].length && horizontalMatrix[a][b] === 1) {
                            const square = [
                                [a, b, zLevel],         // bottom-left
                                [a + 1, b, zLevel],     // bottom-right  
                                [a + 1, b + 1, zLevel], // top-right
                                [a, b + 1, zLevel]      // top-left
                            ];
                            addSquareFace(square[0], square[1], square[2], square[3], this.colors.gray3);
                        }
                    }
                }
            }
            
            // Handle middle paths (between consecutive actual paths)
            for (let pathIdx = 0; pathIdx < pathTriplets.length - 1; pathIdx++) {
                const upperPath = pathTriplets[pathIdx];      // Higher z-level path
                const lowerPath = pathTriplets[pathIdx + 1];  // Lower z-level path
                
                // The horizontal lozenges lie at z-level of upper path minus 1
                const zLevel = upperPath[0][2] - 1;
                
                // Calculate horizontal lozenges between these paths
                const horizontalMatrix = this.calculateHorizontalLozengeMatrix(upperPath, lowerPath, S, T);
                
                // Place squares where matrix value is 1
                for (let a = 0; a <= S; a++) {
                    for (let b = 0; b <= T - S; b++) {
                        if (a < horizontalMatrix.length && b < horizontalMatrix[a].length && horizontalMatrix[a][b] === 1) {
                            const square = [
                                [a, b, zLevel],         // bottom-left
                                [a + 1, b, zLevel],     // bottom-right  
                                [a + 1, b + 1, zLevel], // top-right
                                [a, b + 1, zLevel]      // top-left
                            ];
                            addSquareFace(square[0], square[1], square[2], square[3], this.colors.gray3);
                        }
                    }
                }
            }
            
            // Handle bottom boundary (below the last path at z=0)
            if (pathTriplets.length > 0) {
                const lastPath = pathTriplets[pathTriplets.length - 1];
                
                // Bottom boundary path (extreme version of last path at height 0)
                const bottomBoundary = [];
                for (let i = 0; i <= T - S; i++) {
                    bottomBoundary.push([0, i, 0]);
                }
                for (let i = 1; i <= S; i++) {
                    bottomBoundary.push([i, T - S, 0]);
                }
                
                // Calculate horizontal lozenges between last path and bottom boundary
                const zLevel = 0;
                const horizontalMatrix = this.calculateHorizontalLozengeMatrix(lastPath, bottomBoundary, S, T);
                
                // Place squares where matrix value is 1
                for (let a = 0; a <= S; a++) {
                    for (let b = 0; b <= T - S; b++) {
                        if (a < horizontalMatrix.length && b < horizontalMatrix[a].length && horizontalMatrix[a][b] === 1) {
                            const square = [
                                [a, b, zLevel],         // bottom-left
                                [a + 1, b, zLevel],     // bottom-right  
                                [a + 1, b + 1, zLevel], // top-right
                                [a, b + 1, zLevel]      // top-left
                            ];
                            addSquareFace(square[0], square[1], square[2], square[3], this.colors.gray3);
                        }
                    }
                }
            }
        }
        
        calculateHorizontalLozengeMatrix(upperPath, lowerPath, S, T) {
            // Implement the Mathematica logic: q[z] function and matrix calculation
            // Matrix dimensions: (S+1) rows (a=0 to S) × (T-S+1) columns (b=0 to T-S)
            const matrix = Array(S + 1).fill().map(() => Array(T - S + 1).fill(0));
            
            // Extract q[z] for both paths using extractLastFromIncreasing logic
            const upperQ = this.calculateQFunction(upperPath);
            const lowerQ = this.calculateQFunction(lowerPath);
            
            // Apply the condition: If[q[z][[b + 1]] > a >= q[z + 1][[b + 1]], 1, 0]
            for (let a = 0; a <= S; a++) {
                for (let b = 0; b <= T - S; b++) {
                    const upperVal = upperQ[b] || 0;  // q[z][[b + 1]] (1-indexed in Mathematica)
                    const lowerVal = lowerQ[b] || 0;  // q[z + 1][[b + 1]]
                    
                    if (upperVal > a && a >= lowerVal) {
                        matrix[a][b] = 1;
                    }
                }
            }
            
            return matrix;
        }
        
        calculateQFunction(path) {
            // Implement: q[z] := Last /@ Split[Table[If[p[z][[i]][[1]] == p[z][[i]][[2]], p[z][[i]][[2]], p[z][[i]][[1]]], {i, 1, 11}], #1 < #2 &]
            
            // Step 1: Create the table - for each point, take x if x != y, otherwise take y
            const table = [];
            for (let i = 0; i < path.length; i++) {
                const [x, y, z] = path[i];
                if (x === y) {
                    table.push(y);
                } else {
                    table.push(x);
                }
            }
            
            // Step 2: Apply extractLastFromIncreasing (equivalent to Last /@ Split[..., #1 < #2 &])
            return this.extractLastFromIncreasing(table);
        }
        
        extractLastFromIncreasing(list) {
            const result = [];
            let i = 0;
            while (i < list.length) {
                let j = i;
                // Find the end of increasing sequence
                while (j + 1 < list.length && list[j] < list[j + 1]) {
                    j++;
                }
                result.push(list[j]); // Take the last element of the increasing sequence
                i = j + 1;
            }
            return result;
        }

        centerCamera(maxX, maxY, maxZ) {
            // Center on the actual surface
            const centerX = maxX / 2;
            const centerY = maxY / 2;
            const centerZ = maxZ / 2;

            // Set controls target
            this.controls.target.set(centerX, centerY, centerZ);

            // Position camera from the left for good view (3x closer zoom)
            const distance = Math.max(maxX, maxY, maxZ) * 2 / 3;  // 3x zoom
            this.camera.position.set(
                centerX - distance * 1.2,  // Position camera from the left
                centerY + distance * 0.3,
                centerZ + distance * 0.7
            );

            this.controls.update();
        }

        animate() {
            requestAnimationFrame(() => this.animate());

            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }
    }

    // Main Application
    const wasmInterface = new WASMInterface();
    let tilingVisualizer = null;
    let tiling3DVisualizer = null;
    let is3DView = true; // Default to 3D view

    // Initialize
    async function init() {
        try {
            await wasmInterface.initialize();

            // Initialize 2D visualizer
            const canvas = document.getElementById('lozenge-canvas');
            tilingVisualizer = new TilingVisualizer(canvas);

            // Initialize 3D visualizer
            const container = document.getElementById('three-container');
            tiling3DVisualizer = new Tiling3DVisualizer(container);

            // Initialize with default parameters and perform 6 S→S+1 steps
            await initializeTiling();

            // Perform 6 S→S+1 steps before showing
            for (let i = 0; i < 6; i++) {
                try {
                    await wasmInterface.stepForward();
                } catch (error) {
                    break; // Stop if we can't step forward anymore
                }
            }

            // Update visualization after the steps
            updateVisualization();

            // DEBUG MODE (commented out):
            /*
            const debugPaths = [
                // p[-1] (top boundary) - at z=6
                [[0,0,6], [1,0,6], [2,0,6], [3,0,6], [4,0,6], [5,0,6], [6,0,6], [6,1,6], [6,2,6], [6,3,6], [6,4,6]],
                // p[0] - at z=5  
                [[0,0,5], [1,0,5], [2,0,5], [2,1,5], [3,1,5], [3,2,5], [4,2,5], [5,2,5], [5,3,5], [6,3,5], [6,4,5]], 
                // p[1] - at z=4
                [[0,0,4], [1,0,4], [2,0,4], [2,1,4], [3,1,4], [3,2,4], [3,3,4], [4,3,4], [5,3,4], [6,3,4], [6,4,4]],
                // p[2] - at z=3
                [[0,0,3], [0,1,3], [1,1,3], [2,1,3], [3,1,3], [3,2,3], [3,3,3], [4,3,3], [5,3,3], [5,4,3], [6,4,3]],
                // p[3] - at z=2
                [[0,0,2], [0,1,2], [0,2,2], [1,2,2], [2,2,2], [3,2,2], [3,3,2], [4,3,2], [4,4,2], [5,4,2], [6,4,2]],
                // p[4] (bottom) - at z=1
                [[0,0,1], [0,1,1], [0,2,1], [0,3,1], [0,4,1], [1,4,1], [2,4,1], [3,4,1], [4,4,1], [5,4,1], [6,4,1]]
            ];
            wasmInterface.N_param = 5;
            wasmInterface.T_param = 10; 
            wasmInterface.S_param = 6;
            wasmInterface.q_param = 1.0;
            wasmInterface.paths = debugPaths;
            wasmInterface.ready = true;
            updateVisualization();
            */

            // Set up event listeners
            setupEventListeners();

        } catch (error) {
            console.error('Initialization error:', error);
            alert('Failed to initialize: ' + error.message);
        }
    }

    async function initializeTiling() {
        const N = parseInt(document.getElementById('N').value) || 4;
        const T = parseInt(document.getElementById('T').value) || 10;
        const S = parseInt(document.getElementById('S').value) || 0;
        const q = parseFloat(document.getElementById('q').value) || 1.0;

        try {
            await wasmInterface.initializeTilingWasm({
                N: N,
                T: T,
                S: S,
                mode: 5,
                q: q
            });

            // Don't update visualization here - will be done after 5 steps
        } catch (error) {
            console.error('Initialization failed:', error);
            alert('Initialization failed: ' + error.message);
        }
    }

    function updateVisualization() {
        const params = wasmInterface.getParameters();
        const paths = wasmInterface.getPaths();

        // Update the S input field to reflect current S value
        document.getElementById('S').value = params.S;

        if (is3DView) {
            tiling3DVisualizer.pathsTo3D(paths, params.N, params.T, params.S);
        } else {
            tilingVisualizer.draw(paths, params.N, params.T, params.S);
        }

    }

    function toggleView() {
        is3DView = !is3DView;
        const canvas = document.getElementById('lozenge-canvas');
        const container = document.getElementById('three-container');

        if (is3DView) {
            canvas.style.display = 'none';
            container.style.display = 'block';
            tiling3DVisualizer.handleResize();
        } else {
            canvas.style.display = 'block';
            container.style.display = 'none';
        }

        updateVisualization();
    }


    function setupEventListeners() {
        // Initialize button
        document.getElementById('initialize').addEventListener('click', async () => {
            await initializeTiling();
            
            // Perform 6 S→S+1 steps after initialization
            for (let i = 0; i < 6; i++) {
                try {
                    await wasmInterface.stepForward();
                } catch (error) {
                    break; // Stop if we can't step forward anymore
                }
            }
            
            updateVisualization();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', async (e) => {
            try {
                switch(e.key.toLowerCase()) {
                    case 'a':
                        await wasmInterface.stepForward();
                        updateVisualization();
                        break;
                    case 'z':
                        await wasmInterface.stepBackward();
                        updateVisualization();
                        break;
                    case 's':
                        await wasmInterface.stepForward();
                        await wasmInterface.stepBackward();
                        updateVisualization();
                        break;
                    case 'x':
                        await wasmInterface.stepBackward();
                        await wasmInterface.stepForward();
                        updateVisualization();
                        break;
                    case 'v':
                        toggleView();
                        break;
                }
            } catch (error) {
                console.error('Operation failed:', error);
            }
        });
    }

    // Start the application
    init();
};
</script>
