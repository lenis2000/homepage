---
title: Minimal q-volume lozenge tilings visualization
model: lozenge-tilings
author: 'Vadim Gorin (original code); Leonid Petrov (porting)'
---

<style>
  /* Minimal styling */
  .interface-container {
    max-width: 1000px;
    margin: 0 auto;
    padding: 16px;
  }

  .control-group {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
  }

  .parameters-grid {
    display: flex;
    gap: 16px;
    margin-bottom: 12px;
  }

  #lozenge-canvas, #three-canvas {
    width: 100%;
    max-width: 800px;
    height: 600px;
    border: 1px solid #ccc;
    display: block;
    margin: 0 auto;
  }

  #three-container {
    width: 100%;
    max-width: 800px;
    height: 600px;
    margin: 0 auto;
    border: 1px solid #ccc;
    display: block; /* Shown by default, 3D is default */
  }

  .keyboard-info {
    margin-top: 20px;
    padding: 10px;
    background: #f0f0f0;
    border-radius: 4px;
  }

  .export-section {
    margin-top: 20px;
    padding: 10px;
    background: #f5f5f5;
    border-radius: 4px;
    border: 1px solid #e0e0e0;
  }

  #paths-export, #plane-partition-export {
    width: 100%;
    max-width: 800px;
    height: 150px;
    font-family: monospace;
    font-size: 12px;
    margin: 10px auto;
    display: block;
    resize: vertical;
  }
</style>

<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>
<script src="/js/2025-06-08-q-vol-3d.js"></script>

<div class="interface-container">
  <!-- Parameters Only -->
  <div class="control-group">
    <div class="parameters-grid">
      <div>
        <label for="N">N:</label>
        <input type="number" id="N" value="10" min="1" max="200" style="width: 60px;">
      </div>
      <div>
        <label for="T">T:</label>
        <input type="number" id="T" value="20" min="1" max="500" style="width: 60px;">
      </div>
      <div>
        <label for="S">S:</label>
        <input type="number" id="S" value="0" min="0" style="width: 60px;">
      </div>
      <div>
        <label for="q">q:</label>
        <input type="number" id="q" value="1" step="0.02" min="0.01" style="width: 80px;">
      </div>
      <button id="initialize">Initialize</button>
    </div>
  </div>
</div>

<!-- 2D Visualization (hidden) -->
<canvas id="lozenge-canvas" style="display: none;"></canvas>

<!-- 3D Visualization (default) -->
<div id="three-container">
  <canvas id="three-canvas"></canvas>
</div>

<div class="keyboard-info">
  <strong>Keyboard shortcuts:</strong><br>
  A: S → S+1 | Z: S → S-1 | S: S → S+1 → S-1 | X: S → S-1 → S+1 | V: Toggle 2D/3D view
</div>

<div class="export-section">
  <strong>Raw Paths Data:</strong><br>
  <textarea id="paths-export" readonly placeholder="Paths representation will appear here"></textarea>
  <br><br>
  <strong>Plane Partition:</strong><br>
  <textarea id="plane-partition-export" readonly placeholder="Plane partition representation will appear here"></textarea>
</div>

<script>
// Minimal UVA color scheme only
const UVA_COLORS = {
    gray1: '#E57200', // Orange - Up rhombi
    gray2: '#232D4B', // Navy - Down rhombi
    gray3: '#F9DCBF', // Beige - Horizontal
    border: '#666666'
};

Module.onRuntimeInitialized = async function() {
    // WASM Interface Class
    class WASMInterface {
        constructor() {
            this.ready = false;
            this.N_param = 10;
            this.T_param = 20;
            this.S_param = 0;
            this.mode_param = 5;
            this.q_param = 1.0;
            this.paths = [];
        }

        async initialize() {
            if (typeof Module === 'undefined') {
                throw new Error('Module is not defined. WASM JavaScript file may not be loaded.');
            }
            if (typeof Module.cwrap !== 'function') {
                throw new Error('Module.cwrap is not a function. WASM module may not be properly initialized.');
            }

            // Wrap exported functions
            this.initializeTiling = Module.cwrap('initializeTiling', 'number', ['number', 'number', 'number', 'number', 'number'], {async: true});
            this.performSOperator = Module.cwrap('performSOperator', 'number', [], {async: true});
            this.performSMinusOperator = Module.cwrap('performSMinusOperator', 'number', [], {async: true});
            this.exportPaths = Module.cwrap('exportPaths', 'number', [], {async: true});
            this.updateParameters = Module.cwrap('updateParameters', 'number', ['number', 'number'], {async: true});
            this.freeString = Module.cwrap('freeString', null, ['number']);

            this.ready = true;
            console.log('WASM module loaded successfully');
        }

        async initializeTilingWasm(params) {
            if (!this.ready) throw new Error('WASM not ready');

            this.N_param = params.N;
            this.T_param = params.T;
            this.S_param = params.S;
            this.mode_param = params.mode;
            this.q_param = params.q;

            try {
                const ptr = await this.initializeTiling(params.N, params.T, params.S, params.mode, params.q);
                if (!ptr) {
                    throw new Error('initializeTiling returned null pointer');
                }
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`Initialization failed: ${error.message}`);
            }
        }

        async stepForward() {
            if (!this.ready) throw new Error('WASM not ready');
            if (this.S_param >= this.T_param) throw new Error('Cannot perform S→S+1: already at maximum');

            try {
                const ptr = await this.performSOperator();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                this.S_param = result.s;
                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`S operator failed: ${error.message}`);
            }
        }

        async stepBackward() {
            if (!this.ready) throw new Error('WASM not ready');
            if (this.S_param <= 0) throw new Error('Cannot perform S→S-1: already at minimum');

            try {
                const ptr = await this.performSMinusOperator();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                this.S_param = result.s;
                await this.refreshPaths();
                return result;
            } catch (error) {
                throw new Error(`S- operator failed: ${error.message}`);
            }
        }

        async refreshPaths() {
            try {
                const ptr = await this.exportPaths();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (!result.error) {
                    this.paths = result.paths;
                }
            } catch (error) {
                console.error('Failed to refresh paths:', error);
            }
        }

        getPaths() {
            return this.paths;
        }

        getParameters() {
            return {
                N: this.N_param,
                T: this.T_param,
                S: this.S_param,
                mode: this.mode_param,
                q: this.q_param
            };
        }
    }

    // 2D Tiling Visualizer Class (using original drawing logic)
    class TilingVisualizer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.colors = {
                ...UVA_COLORS,
                white: '#FFFFFF',
                black: '#000000'
            };
            this.borderWidth = 0.01;
            this.style = 1; // Lozenges
            this.zoomLevel = 1.0;
            this.panX = 0;
            this.panY = 0;
        }

        updateCanvasDimensions(N, T, S) {
            const sqrt3 = Math.sqrt(3);

            // Calculate the bounding box of the hexagon
            const minX = 0;
            const maxX = T * 0.5 * sqrt3;
            const minY = -(T - S) * 0.5;
            const maxY = N + Math.max(S * 0.5, (2 * S - T) * 0.5);

            const hexWidth = maxX - minX;
            const hexHeight = maxY - minY;

            // Set canvas size with some padding
            const padding = 50;
            const canvasWidth = Math.min(hexWidth * 100 + padding * 2, window.innerWidth * 0.9);
            const canvasHeight = Math.min(hexHeight * 100 + padding * 2, window.innerHeight * 0.8);

            // Set canvas size accounting for device pixel ratio
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = canvasWidth * dpr;
            this.canvas.height = canvasHeight * dpr;
            this.canvas.style.width = canvasWidth + 'px';
            this.canvas.style.height = canvasHeight + 'px';

            // Scale context for high DPI displays
            this.ctx.scale(dpr, dpr);
        }

        draw(paths, N, T, S) {
            // Update canvas dimensions to fit hexagon exactly
            this.updateCanvasDimensions(N, T, S);

            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = this.colors.white;
            ctx.fillRect(0, 0, width, height);

            if (this.style === 5) {
                this.drawLatticePathsStyle(paths, N, T, S);
            } else {
                this.drawHexagonStyle(paths, N, T, S);
            }
        }

        drawHexagonStyle(paths, N, T, S) {
            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            const sqrt3 = Math.sqrt(3);

            // Calculate the bounding box of the hexagon
            const minX = 0;
            const maxX = T * 0.5 * sqrt3;
            const minY = -(T - S) * 0.5;
            const maxY = N + Math.max(S * 0.5, (2 * S - T) * 0.5);

            const hexWidth = maxX - minX;
            const hexHeight = maxY - minY;
            const hexCenterX = (minX + maxX) / 2;
            const hexCenterY = (minY + maxY) / 2;

            const margin = 0; // No margin - fit hexagon exactly
            const scale = Math.min(
                (width - 2 * margin) / hexWidth,
                (height - 2 * margin) / hexHeight
            ) * this.zoomLevel;

            ctx.save();
            ctx.translate(this.panX, this.panY);
            ctx.translate(width / 2, height / 2);
            ctx.scale(-scale, scale);  // Flip horizontally with negative x scale
            // Center the hexagon
            ctx.translate(-hexCenterX, -hexCenterY);

            this.drawBackgroundHexagon(N, T, S);

            for (let i = 0; i < T; i++) {
                for (let j = 0; j < N; j++) {
                    const currentHeight = paths[j][i];
                    const nextHeight = paths[j][i + 1];
                    this.drawRhombus(i, j, currentHeight, nextHeight);
                }
            }

            // Draw paths on top of the tiling
            this.drawPathsOverlay(paths, N, T, S);

            ctx.restore();
        }

        drawBackgroundHexagon(N, T, S) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            // First, clip to the hexagon shape
            const vertices = [
                {x: 0, y: 0},
                {x: 0, y: N},
                {x: S * 0.5 * sqrt3, y: N + S * 0.5},
                {x: T * 0.5 * sqrt3, y: N + (2 * S - T) * 0.5},
                {x: T * 0.5 * sqrt3, y: (2 * S - T) * 0.5},
                {x: (T - S) * 0.5 * sqrt3, y: -(T - S) * 0.5}
            ];

            ctx.save();

            // Create clipping path
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < 6; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.clip();

            // Draw background rhombi with borders aligned to lozenge grid
            for (let timeIdx = -1; timeIdx <= T; timeIdx++) {
                for (let height = -(T - S + 2); height <= N + S + 2; height++) {
                    // Use the same coordinate system as the actual rhombi
                    const x1 = timeIdx * 0.5 * sqrt3;
                    const y1 = height - timeIdx * 0.5;

                    // Calculate rhombus center for bounds checking
                    const centerX = x1 + 0.25 * sqrt3;
                    const centerY = y1 + 0.5;

                    // Check if rhombus center is roughly within bounds
                    if (centerX >= -0.5 * sqrt3 && centerX <= (T + 1) * 0.5 * sqrt3 &&
                        centerY >= -(T - S + 2) * 0.5 && centerY <= N + S + 1) {

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x1+0.5 * sqrt3, y1 + 0.5);
                        ctx.lineTo(x1 + sqrt3, y1);
                        ctx.lineTo(x1 + 0.5 * sqrt3, y1 - 0.5);
                        ctx.closePath();

                        ctx.fillStyle = this.colors.gray3;
                        ctx.fill();

                        ctx.strokeStyle = this.colors.border;
                        ctx.lineWidth = this.borderWidth;
                        ctx.stroke();
                    }
                }
            }

            ctx.restore();
        }

        drawRhombus(timeIdx, particleIdx, height, nextHeight) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            const x1 = timeIdx * 0.5 * sqrt3;
            const y1 = height - timeIdx * 0.5;
            const x2 = x1;
            const y2 = y1 + 1;

            let x3, y3, x4, y4;
            let fillColor;

            if (nextHeight === height) {
                // Down rhombus
                x3 = x2 + 0.5 * sqrt3;
                y3 = y2 - 0.5;
                x4 = x1 + 0.5 * sqrt3;
                y4 = y1 - 0.5;
                fillColor = this.colors.gray1;
            } else {
                // Up rhombus
                x3 = x2 + 0.5 * sqrt3;
                y3 = y2 + 0.5;
                x4 = x1 + 0.5 * sqrt3;
                y4 = y1 + 0.5;
                fillColor = this.colors.gray2;
            }

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.lineTo(x4, y4);
            ctx.closePath();

            ctx.fillStyle = fillColor;
            ctx.fill();

            // Add consistent thin borders to all rhombi
            ctx.strokeStyle = this.colors.border;
            ctx.lineWidth = this.borderWidth;
            ctx.stroke();
        }

        drawPathsOverlay(paths, N, T, S) {
            const ctx = this.ctx;
            const sqrt3 = Math.sqrt(3);

            // Draw paths as lines overlaid on the hexagon tiling
            ctx.save();

            // Draw each path
            for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
                const path = paths[pathIdx];

                ctx.beginPath();
                ctx.strokeStyle = '#FF0000';  // Red color for paths
                ctx.lineWidth = 0.05;
                ctx.fillStyle = '#FF0000';

                for (let timeIdx = 0; timeIdx < path.length; timeIdx++) {
                    const height = path[timeIdx];

                    // Convert to hexagon coordinates (same as rhombus coordinates)
                    const x = timeIdx * 0.5 * sqrt3;
                    const y = height - timeIdx * 0.5;

                    if (timeIdx === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    // Draw a small circle at each point
                    ctx.fillRect(x - 0.03, y - 0.03, 0.06, 0.06);
                }

                ctx.stroke();
            }

            ctx.restore();
        }

        drawLatticePathsStyle(paths, N, T, S) {
            const ctx = this.ctx;
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            const height = this.canvas.height / (window.devicePixelRatio || 1);

            const margin = 20; // Smaller margin for lattice paths
            const scaleX = (width - 2 * margin) / (T + 5);
            const scaleY = (height - 2 * margin) / (N + S + 5);
            const scale = Math.min(scaleX, scaleY) * this.zoomLevel;

            const maxY = N + S - 1;

            ctx.save();
            ctx.translate(this.panX + margin, this.panY + height - margin);
            ctx.scale(scale, -scale);

            ctx.fillStyle = this.colors.gray3;
            for (let i = 0; i <= T; i++) {
                for (let j = 0; j <= maxY; j++) {
                    ctx.fillRect(i - 0.1, j - 0.1, 0.2, 0.2);
                }
            }

            ctx.strokeStyle = this.colors.black;
            ctx.lineWidth = this.borderWidth;
            ctx.fillStyle = this.colors.black;

            for (let j = 0; j < N; j++) {
                ctx.beginPath();

                for (let i = 0; i <= T; i++) {
                    const x = i;
                    const y = paths[j][i];

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    ctx.fillRect(x - 0.05, y - 0.05, 0.1, 0.1);
                }

                ctx.stroke();
            }

            ctx.restore();
        }
    }

    // 3D Tiling Visualizer Class (minimal version with fixed pathsTo3D)
    class Tiling3DVisualizer {
        constructor(container) {
            this.container = container;
            this.colors = { ...UVA_COLORS };
            this.cameraInitialized = false;

            // Three.js setup
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0xffffff);

            // Camera
            this.camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );

            // Renderer
            this.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('three-canvas'),
                antialias: true
            });
            this.renderer.setSize(container.clientWidth, container.clientHeight);

            // Controls
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 10, 10);
            this.scene.add(directionalLight);

            // Group for rhombi
            this.boxGroup = new THREE.Group();
            this.scene.add(this.boxGroup);

            // Handle window resize
            window.addEventListener('resize', () => this.handleResize());

            // Start animation loop
            this.animate();
        }

        handleResize() {
            const width = this.container.clientWidth;
            const height = this.container.clientHeight;

            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();

            this.renderer.setSize(width, height);
        }

        pathsTo3D(paths, N, T, S) {
            // Clear existing geometry
            while(this.boxGroup.children.length > 0) {
                const child = this.boxGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                this.boxGroup.remove(child);
            }

            // Convert paths to triplet format (same as exportPathsData)
            const pathTriplets = [];
            for (let i = 0; i < paths.length; i++) {
                const pathCopy = paths[i].slice().reverse();
                const firstElement = pathCopy[0];
                const adjustedPath = pathCopy.map(x => firstElement - x);

                const triplets = [];
                let x = 0, y = 0;
                const z = paths.length - i; // z-coordinate is constant for each path

                // Start with initial triplet
                triplets.push([x, y, z]);

                // Process each step in the path
                for (let j = 1; j < adjustedPath.length; j++) {
                    const prev = adjustedPath[j-1];
                    const curr = adjustedPath[j];

                    if (curr === prev + 1) {
                        // Path goes up by 1, increment first coordinate
                        x++;
                    } else if (curr === prev) {
                        // Path stays the same, increment second coordinate
                        y++;
                    }
                    triplets.push([x, y, z]);
                }
                pathTriplets.push(triplets);
            }

            // Create geometry for the surface
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const colors = [];
            const indices = [];

            // Helper to add a square face
            const addSquareFace = (v1, v2, v3, v4, color) => {
                const baseIndex = vertices.length / 3;

                // Add vertices
                vertices.push(v1[0], v1[1], v1[2]);
                vertices.push(v2[0], v2[1], v2[2]);
                vertices.push(v3[0], v3[1], v3[2]);
                vertices.push(v4[0], v4[1], v4[2]);

                // Calculate normal
                const edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
                const edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
                const normal = [
                    edge1[1] * edge2[2] - edge1[2] * edge2[1],
                    edge1[2] * edge2[0] - edge1[0] * edge2[2],
                    edge1[0] * edge2[1] - edge1[1] * edge2[0]
                ];
                const len = Math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2);
                if (len > 0) {
                    normal[0] /= len;
                    normal[1] /= len;
                    normal[2] /= len;
                }

                // Add normals
                for (let i = 0; i < 4; i++) {
                    normals.push(normal[0], normal[1], normal[2]);
                }

                // Add colors
                const c = new THREE.Color(color);
                for (let i = 0; i < 4; i++) {
                    colors.push(c.r, c.g, c.b);
                }

                // Add triangles
                indices.push(
                    baseIndex, baseIndex + 1, baseIndex + 2,
                    baseIndex, baseIndex + 2, baseIndex + 3
                );
            };

            // Create strips between consecutive paths
            for (let pathIdx = 0; pathIdx < pathTriplets.length; pathIdx++) {
                const topPath = pathTriplets[pathIdx];

                // Create bottom path by lowering z by 1
                const bottomPath = topPath.map(point => [point[0], point[1], point[2] - 1]);

                // Create strips between consecutive segments
                for (let i = 0; i < topPath.length - 1; i++) {
                    const topP1 = topPath[i];
                    const topP2 = topPath[i + 1];
                    const bottomP1 = bottomPath[i];
                    const bottomP2 = bottomPath[i + 1];

                    // Determine color based on segment direction
                    let color;
                    if (topP2[0] > topP1[0] && topP2[1] === topP1[1]) {
                        // x increases, y constant -> "up" rhombus
                        color = this.colors.gray2;
                    } else if (topP2[0] === topP1[0] && topP2[1] > topP1[1]) {
                        // x constant, y increases -> "down" rhombus
                        color = this.colors.gray1;
                    } else {
                        // Shouldn't happen with valid paths
                        color = this.colors.gray3;
                    }

                    // Create strip as a quadrilateral
                    // topP1 -> topP2 -> bottomP2 -> bottomP1
                    addSquareFace(topP1, topP2, bottomP2, bottomP1, color);
                }
            }

            // Add horizontal squares between paths
            const allPaths = [...pathTriplets];

            // Create boundary paths
            if (pathTriplets.length > 0) {
                const topZ = pathTriplets[0][0][2]; // Height of first path
                const bottomZ = pathTriplets[pathTriplets.length - 1][0][2]; // Height of last path

                // Top boundary path (extreme version of path 0 at same height)
                const topBoundary = [];
                for (let i = 0; i <= S; i++) {
                    topBoundary.push([i, 0, topZ]);
                }
                for (let i = 1; i <= T - S; i++) {
                    topBoundary.push([S, i, topZ]);
                }

                // Bottom boundary path (extreme version of last path at height 0)
                const bottomBoundary = [];
                for (let i = 0; i <= T - S; i++) {
                    bottomBoundary.push([0, i, 0]);
                }
                for (let i = 1; i <= S; i++) {
                    bottomBoundary.push([i, T - S, 0]);
                }

                // Add boundary paths to the list
                allPaths.unshift(topBoundary); // Add at beginning
                allPaths.push(bottomBoundary); // Add at end
            }

            // DEBUG: Draw all paths as colored lines
            // Only draw top and bottom boundaries in black
            for (let pathIdx = 0; pathIdx < allPaths.length; pathIdx++) {
                const path = allPaths[pathIdx];

                // Only process top and bottom boundary paths
                if (pathIdx === 0 || pathIdx === allPaths.length - 1) {
                    const pathColor = '#000000'; // Black for both boundaries

                    // Draw path as line segments
                    for (let i = 0; i < path.length - 1; i++) {
                        const p1 = path[i];
                        const p2 = path[i + 1];

                        // Create thin strip to visualize the path
                        const stripHeight = 0.05;
                        const v1 = [p1[0], p1[1], p1[2] + stripHeight];
                        const v2 = [p2[0], p2[1], p2[2] + stripHeight];
                        const v3 = [p2[0], p2[1], p2[2] - stripHeight];
                        const v4 = [p1[0], p1[1], p1[2] - stripHeight];

                        addSquareFace(v1, v2, v3, v4, pathColor);
                    }
                }
            }

            // For each consecutive pair of paths, add horizontal squares
            for (let pathIdx = 0; pathIdx < allPaths.length - 1; pathIdx++) {
                const upperPath = allPaths[pathIdx];
                const lowerPath = allPaths[pathIdx + 1];

                // Determine the height for horizontal squares (between the two paths)
                const height = lowerPath[0][2];

                // Find the bounding region
                let minX = Math.min(...lowerPath.map(p => p[0]));
                let maxX = Math.max(...lowerPath.map(p => p[0]));
                let minY = Math.min(...lowerPath.map(p => p[1]));
                let maxY = Math.max(...lowerPath.map(p => p[1]));

                // Expand bounds based on upper path
                minX = Math.min(minX, Math.min(...upperPath.map(p => p[0])));
                maxX = Math.max(maxX, Math.max(...upperPath.map(p => p[0])));
                minY = Math.min(minY, Math.min(...upperPath.map(p => p[1])));
                maxY = Math.max(maxY, Math.max(...upperPath.map(p => p[1])));

                console.log(`Layer ${pathIdx}: bounds x=[${minX},${maxX}], y=[${minY},${maxY}], height=${height}`);
                console.log(`Upper path (first 3 points):`, upperPath.slice(0, 3));
                console.log(`Lower path (first 3 points):`, lowerPath.slice(0, 3));

                // Helper function to check if a point is <= all points in a path
                const isLEQAllPoints = (x, y, path) => {
                    return path.every(p => x <= p[0] && y <= p[1]);
                };

                // Helper function to check if a point is >= all points in a path
                const isGEQAllPoints = (x, y, path) => {
                    return path.every(p => x >= p[0] && y >= p[1]);
                };

                // Add horizontal squares in the region between the paths
                let squareCount = 0;
                let debugCount = 0;
                for (let x = minX; x < maxX; x++) {
                    for (let y = minY; y < maxY; y++) {
                        // Check if (x,y) is between the two paths
                        // (x,y) should be >= lowerPath points and <= upperPath points
                        const geqLower = isGEQAllPoints(x, y, lowerPath);
                        const leqUpper = isLEQAllPoints(x, y, upperPath);

                        // Debug first few attempts
                        if (debugCount < 5) {
                            console.log(`  Testing (${x},${y}): geqLower=${geqLower}, leqUpper=${leqUpper}`);
                            if (!geqLower) {
                                const failPoint = lowerPath.find(p => x < p[0] || y < p[1]);
                                console.log(`    Failed geqLower due to point:`, failPoint);
                            }
                            if (!leqUpper) {
                                const failPoint = upperPath.find(p => x > p[0] || y > p[1]);
                                console.log(`    Failed leqUpper due to point:`, failPoint);
                            }
                            debugCount++;
                        }

                        if (geqLower && leqUpper) {
                            // Add horizontal square at (x,y,height)
                            const v1 = [x, y, height];
                            const v2 = [x + 1, y, height];
                            const v3 = [x + 1, y + 1, height];
                            const v4 = [x, y + 1, height];

                            addSquareFace(v1, v2, v3, v4, this.colors.gray3);
                            squareCount++;
                        }
                    }
                }
                console.log(`Added ${squareCount} horizontal squares for layer ${pathIdx}`);
            }

            // Find the bounds of the surface for camera positioning
            let maxX = 0, maxY = 0, maxZ = 0;
            for (const path of pathTriplets) {
                for (const point of path) {
                    maxX = Math.max(maxX, point[0]);
                    maxY = Math.max(maxY, point[1]);
                    maxZ = Math.max(maxZ, point[2]);
                }
            }

            // Set geometry attributes
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);

            // Create material
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: true
            });

            const mesh = new THREE.Mesh(geometry, material);
            this.boxGroup.add(mesh);

            // Add edges
            const edgesGeometry = new THREE.EdgesGeometry(geometry, 1);
            const edgesMaterial = new THREE.LineBasicMaterial({
                color: this.colors.border,
                linewidth: 2
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            this.boxGroup.add(edges);

            // Only center camera on initial load, not on resampling
            if (!this.cameraInitialized) {
                this.centerCamera(maxX, maxY, maxZ);
                this.cameraInitialized = true;
            }
        }

        centerCamera(maxX, maxY, maxZ) {
            // Center on the actual surface
            const centerX = maxX / 2;
            const centerY = maxY / 2;
            const centerZ = maxZ / 2;

            // Set controls target
            this.controls.target.set(centerX, centerY, centerZ);

            // Position camera from the left for good view (3x closer zoom)
            const distance = Math.max(maxX, maxY, maxZ) * 2 / 3;  // 3x zoom
            this.camera.position.set(
                centerX - distance * 1.2,  // Position camera from the left
                centerY + distance * 0.3,
                centerZ + distance * 0.7
            );

            this.controls.update();
        }

        animate() {
            requestAnimationFrame(() => this.animate());

            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }
    }

    // Main Application
    const wasmInterface = new WASMInterface();
    let tilingVisualizer = null;
    let tiling3DVisualizer = null;
    let is3DView = true; // Default to 3D view

    // Initialize
    async function init() {
        try {
            await wasmInterface.initialize();

            // Initialize 2D visualizer
            const canvas = document.getElementById('lozenge-canvas');
            tilingVisualizer = new TilingVisualizer(canvas);

            // Initialize 3D visualizer
            const container = document.getElementById('three-container');
            tiling3DVisualizer = new Tiling3DVisualizer(container);

            // Initialize with default parameters and perform 5 S→S+1 steps
            await initializeTiling();

            // Perform 5 S→S+1 steps before showing
            for (let i = 0; i < 5; i++) {
                try {
                    await wasmInterface.stepForward();
                } catch (error) {
                    console.log(`Step ${i+1} failed:`, error.message);
                    break; // Stop if we can't step forward anymore
                }
            }

            // Update visualization after the steps
            updateVisualization();

            // Set up event listeners
            setupEventListeners();

        } catch (error) {
            console.error('Initialization error:', error);
            alert('Failed to initialize: ' + error.message);
        }
    }

    async function initializeTiling() {
        const N = parseInt(document.getElementById('N').value) || 10;
        const T = parseInt(document.getElementById('T').value) || 20;
        const S = parseInt(document.getElementById('S').value) || 0;
        const q = parseFloat(document.getElementById('q').value) || 1.0;

        try {
            await wasmInterface.initializeTilingWasm({
                N: N,
                T: T,
                S: S,
                mode: 5,
                q: q
            });

            // Don't update visualization here - will be done after 5 steps
        } catch (error) {
            console.error('Initialization failed:', error);
            alert('Initialization failed: ' + error.message);
        }
    }

    function updateVisualization() {
        const params = wasmInterface.getParameters();
        const paths = wasmInterface.getPaths();

        if (is3DView) {
            tiling3DVisualizer.pathsTo3D(paths, params.N, params.T, params.S);
        } else {
            tilingVisualizer.draw(paths, params.N, params.T, params.S);
        }

        // Automatically update both exports
        exportPathsData();
        exportPlanePartition();
    }

    function toggleView() {
        is3DView = !is3DView;
        const canvas = document.getElementById('lozenge-canvas');
        const container = document.getElementById('three-container');

        if (is3DView) {
            canvas.style.display = 'none';
            container.style.display = 'block';
            tiling3DVisualizer.handleResize();
        } else {
            canvas.style.display = 'block';
            container.style.display = 'none';
        }

        updateVisualization();
    }

    function exportPathsData() {
        const paths = wasmInterface.getPaths();
        const params = wasmInterface.getParameters();

        if (!paths || paths.length === 0) {
            document.getElementById('paths-export').value = 'No paths data available';
            return;
        }

        const N = params.N;
        const T = params.T;
        const sqrt3 = Math.sqrt(3);

        // Format paths as simple text matrix
        let output = `Paths Data (N=${N}, T=${T}, S=${params.S}, q=${params.q}):\n\n`;
        output += 'Each row represents one particle path, columns are time steps:\n\n';

        for (let i = 0; i < paths.length; i++) {
          const pathCopy = paths[i].slice().reverse();
          const firstElement = pathCopy[0];
          const adjustedPath = pathCopy.map(x => firstElement - x);

          // Generate triplets based on path changes
          const triplets = [];
          let x = 0, y = 0; // coordinates

          // Start with initial triplet
          triplets.push(`(${x},${y},${paths.length - i})`);

          // Process each step in the path
          for (let j = 1; j < adjustedPath.length; j++) {
            const prev = adjustedPath[j-1];
            const curr = adjustedPath[j];

            if (curr === prev + 1) {
              // Path goes up by 1, increment first coordinate
              x++;
            } else if (curr === prev) {
              // Path stays the same, increment second coordinate
              y++;
            }
            // Add the new triplet
            triplets.push(`(${x},${y},${paths.length - i})`);
          }

          output += `Path ${i}: [${triplets.join(', ')}]\n`;
        }

        document.getElementById('paths-export').value = output;
    }

    function exportPlanePartition() {
        const paths = wasmInterface.getPaths();
        const params = wasmInterface.getParameters();

        if (!paths || paths.length === 0) {
            alert('No tiling data available to export');
            return;
        }

        // Convert paths to plane partition
        // The paths represent a lozenge tiling where paths[i][j] is the height of particle i at time j
        // For a plane partition, we need to extract the 3D box configuration

        const N = params.N;
        const T = params.T;
        const S = params.S;

        // Create a 2D array to store the plane partition
        // The plane partition should be S × (T-S) based on the Fortran code
        const planePartition = [];

        // Initialize the plane partition array - size is S × (T-S)
        for (let i = 0; i < S; i++) {
            planePartition[i] = [];
            for (let j = 0; j < T - S; j++) {
                planePartition[i][j] = 0;
            }
        }

        // Fill the plane partition based on the paths using the Fortran algorithm
        // Phase 1: Process columns from j=0 to T-S-1 (0-indexed)
        for (let j = 0; j < T - S; j++) {
            let h = 0;  // height counter
            let k = 0;  // path index (0-indexed)
            let i = S - 1;  // plane partition row index (0-indexed)

            let r = 0;  // position counter
            while (r <= S + N - 1 && r <= j + N) {
                if (k < N && k < paths.length && j < paths[k].length && paths[k][j] === r) {
                    k++;
                    h++;  // increment height when path crosses
                } else {
                    // Store height in plane partition if within bounds
                    const col = j + (i - (S - 1));
                    if (i >= 0 && i < S && col >= 0 && col < T - S) {
                        planePartition[i][col] = h;
                    }
                    i--;
                }
                r++;
            }
        }

        // Phase 2: Process remaining positions when S > 1
        let i = S - 2;  // 0-indexed
        while (i >= 0) {
            let h = 0;
            let k = 0;
            let j = T - S - 1;  // 0-indexed

            let r = S - 1 - i;
            while (r <= S + N - 1 && r <= T - 1 - i + N - 1) {
                const timeIdx = T - 1 - i;  // 0-indexed
                if (k < N && k < paths.length && timeIdx < paths[k].length && paths[k][timeIdx] === r) {
                    k++;
                    h++;
                } else {
                    // Store height in plane partition if within bounds
                    const row = i + (j - (T - S - 1));
                    if (row >= 0 && row < S && j >= 0 && j < T - S) {
                        planePartition[row][j] = h;
                    }
                    j--;
                }
                r++;
            }
            i--;
        }

        // Format the plane partition as text
        let output = `Plane Partition (N=${N}, T=${T}, S=${S}, q=${params.q}):\n\n`;

        // Output in standard plane partition format
        // The Fortran code outputs as transpose, so we need to transpose and flip
        // Output dimensions: (T-S) rows × S columns
        for (let j = 0; j < T - S; j++) {
            let row = '';
            for (let i = S - 1; i >= 0; i--) {
                row += planePartition[i][j].toString().padStart(3, ' ');
            }
            output += row + '\n';
        }

        // Also add a compact notation showing non-zero entries
        output += '\nCompact notation (row,col,height):\n';
        const nonZeroEntries = [];
        // Iterate through the transposed output format
        for (let j = 0; j < T - S; j++) {
            for (let i = 0; i < S; i++) {
                if (planePartition[i][j] > 0) {
                    // Output in transposed coordinates
                    nonZeroEntries.push(`(${j},${S - 1 - i},${planePartition[i][j]})`);
                }
            }
        }
        output += nonZeroEntries.join(' ');

        // Set the output in the textarea
        document.getElementById('plane-partition-export').value = output;
    }

    function setupEventListeners() {
        // Initialize button
        document.getElementById('initialize').addEventListener('click', initializeTiling);

        // Keyboard shortcuts
        document.addEventListener('keydown', async (e) => {
            try {
                switch(e.key.toLowerCase()) {
                    case 'a':
                        await wasmInterface.stepForward();
                        updateVisualization();
                        break;
                    case 'z':
                        await wasmInterface.stepBackward();
                        updateVisualization();
                        break;
                    case 's':
                        await wasmInterface.stepForward();
                        await wasmInterface.stepBackward();
                        updateVisualization();
                        break;
                    case 'x':
                        await wasmInterface.stepBackward();
                        await wasmInterface.stepForward();
                        updateVisualization();
                        break;
                    case 'v':
                        toggleView();
                        break;
                }
            } catch (error) {
                console.error('Operation failed:', error);
            }
        });
    }

    // Start the application
    init();
};
</script>
