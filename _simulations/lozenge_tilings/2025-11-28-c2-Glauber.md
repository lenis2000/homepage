---
title: Glauber dynamics for lozenge tilings of a C2 region
model: lozenge-tilings
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/lozenge_tilings/2025-11-28-c2-Glauber.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/lozenge_tilings/2025-11-28-c2-Glauber.cpp'
    txt: 'C++ code for the simulation (compiled to WebAssembly)'
---

<style>
  .control-group {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 8px;
  }
  .control-group-title {
    font-size: 11px;
    font-weight: 600;
    color: #666;
    margin-bottom: 6px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  #lozenge-canvas {
    width: 100%;
    max-width: 900px;
    height: 550px;
    border: 1px solid #ccc;
    display: block;
    margin: 0 auto;
    background: #ffffff;
    border-radius: 6px;
  }
  [data-theme="dark"] #lozenge-canvas {
    background: #1a1a1a;
    border-color: #444;
  }
  .param-input {
    width: 45px;
    height: 28px;
    text-align: center;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
    font-family: 'SF Mono', Monaco, monospace;
  }
  .param-input:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
  }
  .param-label {
    font-size: 13px;
    color: #555;
    margin-right: 4px;
    font-weight: 500;
  }
  .param-group {
    display: inline-flex;
    align-items: center;
    margin-right: 12px;
  }
  .computed-box {
    display: inline-flex;
    align-items: center;
    background: #e8f5e9;
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 13px;
  }
  .computed-box .label {
    color: #666;
    margin-right: 6px;
  }
  .computed-box .value {
    font-weight: 600;
    color: #2e7d32;
    font-family: 'SF Mono', Monaco, monospace;
  }
  input[type="range"] {
    height: 4px;
    border-radius: 2px;
    background: #d0d0d0;
    appearance: none;
    outline: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: linear-gradient(135deg, #4CAF50, #66BB6A);
    cursor: pointer;
  }
  button {
    height: 30px;
    padding: 0 14px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    background: white;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s;
  }
  button:hover {
    background: #f5f5f5;
    border-color: #999;
  }
  button.primary {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
  }
  button.primary:hover {
    background: #45a049;
  }
  button.running {
    background: linear-gradient(135deg, #ff5722, #ff9800);
    color: white;
    border-color: #ff5722;
  }
  /* View toggle buttons */
  .view-toggle {
    display: inline-flex;
    border: 2px solid #1976d2;
    border-radius: 6px;
    overflow: hidden;
  }
  .view-toggle button {
    border: none;
    border-radius: 0;
    height: 32px;
    padding: 0 16px;
    font-weight: 500;
    background: white;
    color: #1976d2;
  }
  .view-toggle button.active {
    background: #1976d2;
    color: white;
  }
  .view-toggle button:hover:not(.active) {
    background: #e3f2fd;
  }
  .stats-inline {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    font-size: 12px;
  }
  .stats-inline .stat {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .stats-inline .stat-label {
    color: #888;
    text-transform: uppercase;
    font-size: 10px;
  }
  .stats-inline .stat-value {
    color: #1976d2;
    font-weight: 600;
    font-family: 'SF Mono', Monaco, monospace;
  }
  select {
    height: 30px;
    padding: 0 8px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    font-size: 13px;
    background: white;
    cursor: pointer;
  }
  .color-legend {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    font-size: 12px;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .color-box {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid rgba(0,0,0,0.1);
  }
  details {
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    overflow: hidden;
    margin: 8px auto;
    max-width: 900px;
  }
  details > summary {
    padding: 8px 12px;
    background: #f5f5f5;
    font-weight: 500;
    font-size: 13px;
    cursor: pointer;
  }
  details > .content {
    padding: 10px 12px;
    background: white;
  }
  [data-theme="dark"] .control-group {
    background-color: #2d2d2d;
    border-color: #444;
  }
  [data-theme="dark"] .control-group-title,
  [data-theme="dark"] .param-label {
    color: #bbb;
  }
  [data-theme="dark"] .param-input,
  [data-theme="dark"] select,
  [data-theme="dark"] button {
    background-color: #3a3a3a;
    border-color: #555;
    color: #ddd;
  }
  [data-theme="dark"] .computed-box {
    background: #2d4a2e;
  }
  [data-theme="dark"] .computed-box .value {
    color: #81c784;
  }
  @media (max-width: 767px) {
    #lozenge-canvas { height: 400px; }
    .param-group { margin-right: 8px; margin-bottom: 6px; }
    .param-input { width: 40px; }
  }
</style>

<script src="/js/colorschemes.js"></script>
<script src="/js/2025-11-28-c2-Glauber.js"></script>

<!-- Main controls -->
<div style="max-width: 900px; margin: 0 auto; padding: 8px;">

<!-- Shape Parameters -->
<div class="control-group">
  <div class="control-group-title">Shape</div>
  <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 6px;">
    <span class="param-group"><span class="param-label">b</span><input type="number" class="param-input" id="bInput" value="7" min="1" max="50"></span>
    <span class="param-group"><span class="param-label">c</span><input type="number" class="param-input" id="cInput" value="6" min="1" max="50"></span>
    <span class="param-group"><span class="param-label">d</span><input type="number" class="param-input" id="dInput" value="3" min="1" max="50"></span>
    <span class="param-group"><span class="param-label">e</span><input type="number" class="param-input" id="eInput" value="8" min="1" max="50"></span>
    <span class="param-group"><span class="param-label">h</span><input type="number" class="param-input" id="hInput" value="6" min="1" max="50"></span>
    <span class="computed-box"><span class="label">a = b-d+e+c =</span><span class="value" id="aVal">18</span></span>
  </div>
</div>

<!-- Controls Row -->
<div class="control-group">
  <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
    <!-- View Toggle -->
    <div class="view-toggle">
      <button id="lozengeViewBtn" class="active">Lozenge</button>
      <button id="dimerViewBtn">Dimer</button>
    </div>
    <!-- Simulation -->
    <button id="startStopBtn" class="primary">Start</button>
    <button id="resetBtn">Reset</button>
    <!-- Speed -->
    <div style="display: flex; align-items: center; gap: 6px;">
      <span style="font-size: 12px; color: #666;">Speed</span>
      <input type="range" id="speedSlider" min="1" max="400000" value="100" style="width: 100px;">
      <span id="speedVal" style="font-size: 12px; color: #1976d2; min-width: 45px;">100/s</span>
    </div>
    <!-- Palette -->
    <div style="display: flex; align-items: center; gap: 4px;">
      <button id="prev-palette" style="padding: 0 8px;">&#9664;</button>
      <select id="palette-select" style="width: 120px;"></select>
      <button id="next-palette" style="padding: 0 8px;">&#9654;</button>
    </div>
    <!-- Outlines -->
    <label style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: #555; cursor: pointer;">
      <input type="checkbox" id="showOutlines" checked style="accent-color: #4CAF50;">
      Outlines
    </label>
  </div>
</div>

<!-- Stats Row -->
<div class="control-group">
  <div class="stats-inline">
    <div class="stat"><span class="stat-label">Steps</span><span class="stat-value" id="stepCount">0</span></div>
    <div class="stat"><span class="stat-label">Flips</span><span class="stat-value" id="flipCount">0</span></div>
    <div class="stat"><span class="stat-label">Accept</span><span class="stat-value" id="acceptRate">0%</span></div>
    <div class="stat"><span class="stat-label">FPS</span><span class="stat-value" id="fps">0</span></div>
    <div class="stat"><span class="stat-label">T0</span><span class="stat-value" id="type0Count">0</span></div>
    <div class="stat"><span class="stat-label">T1</span><span class="stat-value" id="type1Count">0</span></div>
    <div class="stat"><span class="stat-label">T2</span><span class="stat-value" id="type2Count">0</span></div>
    <div class="stat"><span class="stat-label">Total</span><span class="stat-value" id="totalDimers">0</span></div>
  </div>
</div>

</div>

<!-- Canvas -->
<canvas id="lozenge-canvas"></canvas>

<!-- Export & Legend -->
<details>
  <summary>Export & Legend</summary>
  <div class="content">
    <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
      <button id="export-png">PNG</button>
      <button id="export-pdf">PDF</button>
      <span style="font-size: 11px; color: #666;">Quality:</span>
      <input type="range" id="export-quality" min="0" max="100" value="85" style="width: 60px;">
      <span id="export-quality-val" style="font-size: 11px; color: #1976d2;">85</span>
      <span style="border-left: 1px solid #ddd; height: 20px;"></span>
      <div class="color-legend">
        <span class="legend-item"><span class="color-box" id="swatch-type0"></span>T0</span>
        <span class="legend-item"><span class="color-box" id="swatch-type1"></span>T1</span>
        <span class="legend-item"><span class="color-box" id="swatch-type2"></span>T2</span>
        <span id="palette-name-display" style="font-weight: 500;"></span>
      </div>
    </div>
  </div>
</details>

<script>
// Pure JavaScript implementation (no WASM) - ported from complex_polygon.html
(function() {
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) {
        return { x: n, y: slope * n + j * deltaC };
    }

    function getRightTriangleCentroid(n, j) {
        const v1 = getVertex(n, j);
        const v2 = getVertex(n, j - 1);
        const v3 = getVertex(n + 1, j - 1);
        return { x: (v1.x + v2.x + v3.x) / 3, y: (v1.y + v2.y + v3.y) / 3 };
    }

    function getLeftTriangleCentroid(n, j) {
        const v1 = getVertex(n, j);
        const v2 = getVertex(n + 1, j);
        const v3 = getVertex(n + 1, j - 1);
        return { x: (v1.x + v2.x + v3.x) / 3, y: (v1.y + v2.y + v3.y) / 3 };
    }

    function pointInPolygon(x, y, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i].x, yi = polygon[i].y;
            const xj = polygon[j].x, yj = polygon[j].y;
            if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    }

    const directions = [
        { dn: 1, dj: -1 },
        { dn: 1, dj: 0 },
        { dn: 0, dj: 1 },
        { dn: -1, dj: 1 },
        { dn: -1, dj: 0 },
        { dn: 0, dj: -1 }
    ];

    function getComplexPolygonBoundary(b, c, d, e, h) {
        const a = b - d + e + c;
        const vertices = [];
        let n = 0, j = 0, dir = 0;

        function move(steps) {
            const { dn, dj } = directions[dir];
            for (let i = 0; i < steps; i++) {
                vertices.push(getVertex(n, j));
                n += dn;
                j += dj;
            }
        }
        function turnCCW(deg) { dir = (dir + deg / 60 + 6) % 6; }
        function turnCW(deg) { dir = (dir - deg / 60 + 6) % 6; }

        move(a);
        turnCCW(60); move(b);
        turnCCW(60); move(h);
        turnCCW(60); move(c);
        turnCCW(60); move(d);
        turnCW(60); move(e);
        turnCW(120); move(e);
        turnCW(60); move(d);
        turnCCW(60); move(c);
        turnCCW(60); move(h);
        turnCCW(60); move(b);
        turnCCW(60); move(a);
        turnCCW(60); move(2 * h);

        return vertices;
    }

    function getRightTriangleNeighbors(n, j) {
        return [
            { type: 'left', n: n, j: j },
            { type: 'left', n: n, j: j - 1 },
            { type: 'left', n: n - 1, j: j }
        ];
    }

    function getDimerType(black, whitePos) {
        const dn = whitePos.n - black.n;
        const dj = whitePos.j - black.j;
        if (dn === 0 && dj === 0) return 0;
        else if (dn === 0 && dj === -1) return 1;
        else if (dn === -1 && dj === 0) return 2;
        return 0;
    }

    function generateDimerCovering(blackVerts, whiteVerts) {
        const whiteMap = new Map();
        for (const w of whiteVerts) {
            whiteMap.set(`${w.n},${w.j}`, w);
        }
        const blackList = [...blackVerts];
        const adj = new Map();
        for (const black of blackList) {
            const key = `${black.n},${black.j}`;
            const neighbors = getRightTriangleNeighbors(black.n, black.j);
            const validNeighbors = neighbors.filter(nb => whiteMap.has(`${nb.n},${nb.j}`));
            adj.set(key, validNeighbors.map(nb => `${nb.n},${nb.j}`));
        }
        const matchWhiteToBlack = new Map();
        const matchBlackToWhite = new Map();
        function findAugmentingPath(blackKey, visited) {
            const neighbors = adj.get(blackKey) || [];
            for (const whiteKey of neighbors) {
                if (visited.has(whiteKey)) continue;
                visited.add(whiteKey);
                const matchedBlack = matchWhiteToBlack.get(whiteKey);
                if (!matchedBlack || findAugmentingPath(matchedBlack, visited)) {
                    matchWhiteToBlack.set(whiteKey, blackKey);
                    matchBlackToWhite.set(blackKey, whiteKey);
                    return true;
                }
            }
            return false;
        }
        for (const black of blackList) {
            const blackKey = `${black.n},${black.j}`;
            const visited = new Set();
            findAugmentingPath(blackKey, visited);
        }
        const dimers = [];
        for (const black of blackList) {
            const blackKey = `${black.n},${black.j}`;
            const whiteKey = matchBlackToWhite.get(blackKey);
            if (whiteKey) {
                const white = whiteMap.get(whiteKey);
                const [wn, wj] = whiteKey.split(',').map(Number);
                dimers.push({
                    black: black,
                    white: white,
                    type: getDimerType(black, { n: wn, j: wj })
                });
            }
        }
        return dimers;
    }

    function getHexEdgesAroundVertex(n, j) {
        return [
            { black: {n: n, j: j+1}, white: {n: n, j: j}, type: 1 },
            { black: {n: n, j: j}, white: {n: n, j: j}, type: 0 },
            { black: {n: n, j: j}, white: {n: n-1, j: j}, type: 2 },
            { black: {n: n-1, j: j+1}, white: {n: n-1, j: j}, type: 1 },
            { black: {n: n-1, j: j+1}, white: {n: n-1, j: j+1}, type: 0 },
            { black: {n: n, j: j+1}, white: {n: n-1, j: j+1}, type: 2 }
        ];
    }

    class C2GlauberJS {
        constructor() {
            this.boundary = [];
            this.dimers = [];
            this.blackTriangles = [];
            this.whiteTriangles = [];
            this.triangularVertices = [];
            this.blackSet = new Set();
            this.whiteSet = new Set();
            this.totalSteps = 0;
            this.flipCount = 0;
        }

        init(b, c, d, e, h) {
            this.boundary = getComplexPolygonBoundary(b, c, d, e, h);

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const v of this.boundary) {
                minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
            }

            const searchMinN = Math.floor(minX) - 2;
            const searchMaxN = Math.ceil(maxX) + 2;
            const searchMinJ = Math.floor((minY) / deltaC) - searchMaxN - 5;
            const searchMaxJ = Math.ceil((maxY) / deltaC) + searchMaxN + 5;

            this.blackTriangles = [];
            this.whiteTriangles = [];
            this.blackSet = new Set();
            this.whiteSet = new Set();
            this.triangularVertices = [];

            for (let n = searchMinN; n <= searchMaxN; n++) {
                for (let j = searchMinJ; j <= searchMaxJ; j++) {
                    const rc = getRightTriangleCentroid(n, j);
                    if (pointInPolygon(rc.x, rc.y, this.boundary)) {
                        this.blackTriangles.push({ n, j, cx: rc.x, cy: rc.y });
                        this.blackSet.add(`${n},${j}`);
                    }
                    const lc = getLeftTriangleCentroid(n, j);
                    if (pointInPolygon(lc.x, lc.y, this.boundary)) {
                        this.whiteTriangles.push({ n, j, cx: lc.x, cy: lc.y });
                        this.whiteSet.add(`${n},${j}`);
                    }
                    const v = getVertex(n, j);
                    if (pointInPolygon(v.x, v.y, this.boundary)) {
                        this.triangularVertices.push({ n, j, pos: v });
                    }
                }
            }

            const blackVertsWithCentroid = this.blackTriangles.map(v => ({
                n: v.n, j: v.j, centroid: { x: v.cx, y: v.cy }
            }));
            const whiteVertsWithCentroid = this.whiteTriangles.map(v => ({
                n: v.n, j: v.j, centroid: { x: v.cx, y: v.cy }
            }));
            this.currentDimers = generateDimerCovering(blackVertsWithCentroid, whiteVertsWithCentroid);
            this.totalSteps = 0;
            this.flipCount = 0;

            // Convert dimers to format expected by renderer
            this.dimers = this.currentDimers.map(d => ({
                bn: d.black.n, bj: d.black.j,
                wn: d.white.n, wj: d.white.j,
                t: d.type
            }));

            return {
                type0: this.dimers.filter(d => d.t === 0).length,
                type1: this.dimers.filter(d => d.t === 1).length,
                type2: this.dimers.filter(d => d.t === 2).length
            };
        }

        dimerExists(blackN, blackJ, whiteN, whiteJ) {
            return this.currentDimers.some(d =>
                d.black.n === blackN && d.black.j === blackJ &&
                d.white.n === whiteN && d.white.j === whiteJ
            );
        }

        performRotation(n, j) {
            const edges = getHexEdgesAroundVertex(n, j);
            const covered = [];
            const uncovered = [];

            for (const e of edges) {
                if (this.dimerExists(e.black.n, e.black.j, e.white.n, e.white.j)) {
                    covered.push(e);
                } else {
                    uncovered.push(e);
                }
            }

            if (covered.length !== 3 || uncovered.length !== 3) return false;

            for (const e of covered) {
                const idx = this.currentDimers.findIndex(d =>
                    d.black.n === e.black.n && d.black.j === e.black.j &&
                    d.white.n === e.white.n && d.white.j === e.white.j
                );
                if (idx >= 0) this.currentDimers.splice(idx, 1);
            }

            for (const e of uncovered) {
                const black = this.blackTriangles.find(b => b.n === e.black.n && b.j === e.black.j);
                const white = this.whiteTriangles.find(w => w.n === e.white.n && w.j === e.white.j);
                if (black && white) {
                    this.currentDimers.push({
                        black: { n: black.n, j: black.j, centroid: { x: black.cx, y: black.cy } },
                        white: { n: white.n, j: white.j, centroid: { x: white.cx, y: white.cy } },
                        type: e.type
                    });
                }
            }

            return true;
        }

        countCoveredEdges(n, j) {
            const edges = getHexEdgesAroundVertex(n, j);
            let count = 0;
            for (const e of edges) {
                if (this.dimerExists(e.black.n, e.black.j, e.white.n, e.white.j)) count++;
            }
            return count;
        }

        step(numSteps) {
            for (let s = 0; s < numSteps; s++) {
                this.totalSteps++;
                if (this.triangularVertices.length === 0) continue;
                const idx = Math.floor(Math.random() * this.triangularVertices.length);
                const v = this.triangularVertices[idx];
                const coveredCount = this.countCoveredEdges(v.n, v.j);
                if (coveredCount === 3 && Math.random() < 0.5) {
                    if (this.performRotation(v.n, v.j)) this.flipCount++;
                }
            }

            // Update dimers for renderer
            this.dimers = this.currentDimers.map(d => ({
                bn: d.black.n, bj: d.black.j,
                wn: d.white.n, wj: d.white.j,
                t: d.type
            }));

            return {
                type0: this.dimers.filter(d => d.t === 0).length,
                type1: this.dimers.filter(d => d.t === 1).length,
                type2: this.dimers.filter(d => d.t === 2).length
            };
        }

        getTotalSteps() { return this.totalSteps; }
        getFlipCount() { return this.flipCount; }
        getAcceptRate() { return this.totalSteps > 0 ? this.flipCount / this.totalSteps : 0; }
    }

    class LozengeRenderer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.showOutlines = true;
            this.showDimerView = false;
            this.currentPaletteIndex = 0;
            this.colorPalettes = window.ColorSchemes || [{ name: 'UVA', colors: ['#E57200', '#232D4B', '#F9DCBF', '#002D62'] }];
            this.setupCanvas();
        }

        setupCanvas() {
            const rect = this.canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = rect.width * dpr;
            this.canvas.height = rect.height * dpr;
            this.ctx.scale(dpr, dpr);
            this.displayWidth = rect.width;
            this.displayHeight = rect.height;
        }

        getCurrentPalette() { return this.colorPalettes[this.currentPaletteIndex]; }

        toCanvas(x, y, centerX, centerY, scale) {
            return [centerX + x * scale, centerY - y * scale];
        }

        getLozengeVertices(dimer) {
            const { bn, bj, t } = dimer;
            if (t === 0) {
                return [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            } else if (t === 1) {
                return [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
            } else {
                return [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            }
        }

        draw(sim) {
            const ctx = this.ctx;
            const palette = this.getCurrentPalette();
            const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';

            ctx.fillStyle = isDarkMode ? '#1a1a1a' : '#ffffff';
            ctx.fillRect(0, 0, this.displayWidth, this.displayHeight);

            if (!sim.boundary || sim.boundary.length === 0) return;

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const v of sim.boundary) {
                minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
            }

            const padding = 2;
            const rangeX = maxX - minX + 2 * padding;
            const rangeY = maxY - minY + 2 * padding;
            const plotRange = Math.max(rangeX, rangeY) / 2;
            const scale = Math.min(this.displayWidth, this.displayHeight) / (2 * plotRange);
            const centerX = this.displayWidth / 2 - ((minX + maxX) / 2) * scale;
            const centerY = this.displayHeight / 2 + ((minY + maxY) / 2) * scale;

            if (this.showDimerView) {
                this.drawDimerView(ctx, sim, palette, centerX, centerY, scale);
            } else {
                this.drawLozengeView(ctx, sim, palette, centerX, centerY, scale);
            }

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            const [sx, sy] = this.toCanvas(sim.boundary[0].x, sim.boundary[0].y, centerX, centerY, scale);
            ctx.moveTo(sx, sy);
            for (let i = 1; i < sim.boundary.length; i++) {
                const [px, py] = this.toCanvas(sim.boundary[i].x, sim.boundary[i].y, centerX, centerY, scale);
                ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.stroke();
        }

        drawLozengeView(ctx, sim, palette, centerX, centerY, scale) {
            const colors = [palette.colors[0], palette.colors[1], palette.colors[2]];
            for (const dimer of sim.dimers) {
                const verts = this.getLozengeVertices(dimer);
                const canvasVerts = verts.map(v => this.toCanvas(v.x, v.y, centerX, centerY, scale));
                ctx.fillStyle = colors[dimer.t];
                ctx.beginPath();
                ctx.moveTo(canvasVerts[0][0], canvasVerts[0][1]);
                for (let i = 1; i < canvasVerts.length; i++) ctx.lineTo(canvasVerts[i][0], canvasVerts[i][1]);
                ctx.closePath();
                ctx.fill();
                if (this.showOutlines) {
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }

        drawDimerView(ctx, sim, palette, centerX, centerY, scale) {
            const colors = [palette.colors[0], palette.colors[1], palette.colors[2]];
            const whiteMap = new Map();
            for (const w of sim.whiteTriangles) whiteMap.set(`${w.n},${w.j}`, w);

            ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
            ctx.lineWidth = 1;
            for (const b of sim.blackTriangles) {
                const [bcx, bcy] = this.toCanvas(b.cx, b.cy, centerX, centerY, scale);
                for (const nb of [{ n: b.n, j: b.j }, { n: b.n, j: b.j - 1 }, { n: b.n - 1, j: b.j }]) {
                    const w = whiteMap.get(`${nb.n},${nb.j}`);
                    if (w) {
                        const [wcx, wcy] = this.toCanvas(w.cx, w.cy, centerX, centerY, scale);
                        ctx.beginPath(); ctx.moveTo(bcx, bcy); ctx.lineTo(wcx, wcy); ctx.stroke();
                    }
                }
            }

            for (const dimer of sim.dimers) {
                const bc = sim.blackTriangles.find(b => b.n === dimer.bn && b.j === dimer.bj);
                const wc = sim.whiteTriangles.find(w => w.n === dimer.wn && w.j === dimer.wj);
                if (bc && wc) {
                    const [bcx, bcy] = this.toCanvas(bc.cx, bc.cy, centerX, centerY, scale);
                    const [wcx, wcy] = this.toCanvas(wc.cx, wc.cy, centerX, centerY, scale);
                    ctx.strokeStyle = colors[dimer.t];
                    ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.moveTo(bcx, bcy); ctx.lineTo(wcx, wcy); ctx.stroke();
                }
            }

            for (const b of sim.blackTriangles) {
                const [cx, cy] = this.toCanvas(b.cx, b.cy, centerX, centerY, scale);
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(cx, cy, 3, 0, 2 * Math.PI); ctx.fill();
            }
            for (const w of sim.whiteTriangles) {
                const [cx, cy] = this.toCanvas(w.cx, w.cy, centerX, centerY, scale);
                ctx.fillStyle = '#fff'; ctx.strokeStyle = '#333'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(cx, cy, 3, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            }
        }

        setPalette(index) {
            this.currentPaletteIndex = ((index % this.colorPalettes.length) + this.colorPalettes.length) % this.colorPalettes.length;
            this.updateLegend();
        }
        nextPalette() { this.setPalette(this.currentPaletteIndex + 1); }
        prevPalette() { this.setPalette(this.currentPaletteIndex - 1); }

        updateLegend() {
            const palette = this.getCurrentPalette();
            document.getElementById('swatch-type0').style.backgroundColor = palette.colors[0];
            document.getElementById('swatch-type1').style.backgroundColor = palette.colors[1];
            document.getElementById('swatch-type2').style.backgroundColor = palette.colors[2];
            document.getElementById('palette-name-display').textContent = palette.name;
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('lozenge-canvas');
        const sim = new C2GlauberJS();
        const renderer = new LozengeRenderer(canvas);

        let running = false, stepsPerSecond = 100, lastFrameTime = performance.now(), frameCount = 0, currentFps = 0;
        let b = 7, c = 6, d = 3, e = 8, h = 6;

        const el = {
            bInput: document.getElementById('bInput'),
            cInput: document.getElementById('cInput'),
            dInput: document.getElementById('dInput'),
            eInput: document.getElementById('eInput'),
            hInput: document.getElementById('hInput'),
            aVal: document.getElementById('aVal'),
            speedSlider: document.getElementById('speedSlider'),
            speedVal: document.getElementById('speedVal'),
            stepCount: document.getElementById('stepCount'),
            flipCount: document.getElementById('flipCount'),
            acceptRate: document.getElementById('acceptRate'),
            fps: document.getElementById('fps'),
            type0Count: document.getElementById('type0Count'),
            type1Count: document.getElementById('type1Count'),
            type2Count: document.getElementById('type2Count'),
            totalDimers: document.getElementById('totalDimers'),
            startStopBtn: document.getElementById('startStopBtn'),
            paletteSelect: document.getElementById('palette-select'),
            lozengeViewBtn: document.getElementById('lozengeViewBtn'),
            dimerViewBtn: document.getElementById('dimerViewBtn')
        };

        function initPaletteSelector() {
            renderer.colorPalettes.forEach((p, i) => {
                const opt = document.createElement('option');
                opt.value = i; opt.textContent = p.name;
                el.paletteSelect.appendChild(opt);
            });
            el.paletteSelect.value = renderer.currentPaletteIndex;
            renderer.updateLegend();
        }

        function formatNumber(n) {
            if (n >= 1e9) return (n / 1e9).toFixed(1) + 'B';
            if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
            if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
            return n.toString();
        }

        function updateStats(result) {
            el.stepCount.textContent = formatNumber(sim.getTotalSteps());
            el.flipCount.textContent = formatNumber(sim.getFlipCount());
            el.acceptRate.textContent = (sim.getAcceptRate() * 100).toFixed(1) + '%';
            el.fps.textContent = currentFps.toFixed(0);
            if (result) {
                el.type0Count.textContent = result.type0 || 0;
                el.type1Count.textContent = result.type1 || 0;
                el.type2Count.textContent = result.type2 || 0;
                el.totalDimers.textContent = (result.type0 || 0) + (result.type1 || 0) + (result.type2 || 0);
            }
        }

        function draw() { renderer.draw(sim); }

        function updateA() { el.aVal.textContent = b - d + e + c; }

        function initSimulation() {
            const result = sim.init(b, c, d, e, h);
            updateA(); draw(); updateStats(result);
        }

        function loop() {
            if (!running) { draw(); return; }
            const now = performance.now();
            frameCount++;
            if (now - lastFrameTime >= 1000) {
                currentFps = frameCount * 1000 / (now - lastFrameTime);
                frameCount = 0; lastFrameTime = now;
            }
            const stepsPerFrame = stepsPerSecond <= 60 ? 1 : Math.ceil(stepsPerSecond / 60);
            const result = sim.step(stepsPerFrame);
            draw(); updateStats(result);
            if (stepsPerSecond <= 60) {
                setTimeout(() => requestAnimationFrame(loop), 1000 / stepsPerSecond);
            } else {
                requestAnimationFrame(loop);
            }
        }

        function toggleRunning() {
            running = !running;
            el.startStopBtn.textContent = running ? 'Stop' : 'Start';
            el.startStopBtn.classList.toggle('running', running);
            if (running) { lastFrameTime = performance.now(); frameCount = 0; loop(); }
        }

        for (const [key, param] of [['bInput', 'b'], ['cInput', 'c'], ['dInput', 'd'], ['eInput', 'e'], ['hInput', 'h']]) {
            el[key].addEventListener('change', (ev) => {
                const val = parseInt(ev.target.value) || 1;
                ev.target.value = Math.max(1, Math.min(50, val));
                if (param === 'b') b = parseInt(ev.target.value);
                else if (param === 'c') c = parseInt(ev.target.value);
                else if (param === 'd') d = parseInt(ev.target.value);
                else if (param === 'e') e = parseInt(ev.target.value);
                else if (param === 'h') h = parseInt(ev.target.value);
                initSimulation();
            });
        }

        el.speedSlider.addEventListener('input', (ev) => {
            stepsPerSecond = parseInt(ev.target.value);
            el.speedVal.textContent = stepsPerSecond >= 1000 ? (stepsPerSecond / 1000).toFixed(1) + 'k/s' : stepsPerSecond + '/s';
        });

        el.lozengeViewBtn.addEventListener('click', () => {
            renderer.showDimerView = false;
            el.lozengeViewBtn.classList.add('active');
            el.dimerViewBtn.classList.remove('active');
            draw();
        });

        el.dimerViewBtn.addEventListener('click', () => {
            renderer.showDimerView = true;
            el.dimerViewBtn.classList.add('active');
            el.lozengeViewBtn.classList.remove('active');
            draw();
        });

        document.getElementById('showOutlines').addEventListener('change', (ev) => {
            renderer.showOutlines = ev.target.checked; draw();
        });

        el.paletteSelect.addEventListener('change', (ev) => { renderer.setPalette(parseInt(ev.target.value)); draw(); });
        document.getElementById('prev-palette').addEventListener('click', () => { renderer.prevPalette(); el.paletteSelect.value = renderer.currentPaletteIndex; draw(); });
        document.getElementById('next-palette').addEventListener('click', () => { renderer.nextPalette(); el.paletteSelect.value = renderer.currentPaletteIndex; draw(); });

        el.startStopBtn.addEventListener('click', toggleRunning);
        document.getElementById('resetBtn').addEventListener('click', () => {
            if (running) { running = false; el.startStopBtn.textContent = 'Start'; el.startStopBtn.classList.remove('running'); }
            initSimulation();
        });

        document.getElementById('export-quality').addEventListener('input', (ev) => {
            document.getElementById('export-quality-val').textContent = ev.target.value;
        });

        function getExportScale() { return 1 + (parseInt(document.getElementById('export-quality').value) / 100) * 3; }
        function isIOS() { return /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1); }

        function createExportCanvas() {
            const baseWidth = 900, baseHeight = 550, scale = getExportScale();
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = baseWidth * scale; exportCanvas.height = baseHeight * scale;
            const exportCtx = exportCanvas.getContext('2d');
            exportCtx.scale(scale, scale);
            const origCtx = renderer.ctx, origW = renderer.displayWidth, origH = renderer.displayHeight;
            renderer.ctx = exportCtx; renderer.displayWidth = baseWidth; renderer.displayHeight = baseHeight;
            renderer.draw(sim);
            renderer.ctx = origCtx; renderer.displayWidth = origW; renderer.displayHeight = origH;
            return exportCanvas;
        }

        async function downloadFile(blob, filename, mimeType) {
            if (isIOS() && navigator.share && navigator.canShare) {
                try {
                    const file = new File([blob], filename, { type: mimeType });
                    if (navigator.canShare({ files: [file] })) { await navigator.share({ files: [file], title: filename }); return; }
                } catch (e) {}
            }
            if (isIOS()) {
                const url = URL.createObjectURL(blob);
                window.open(url, '_blank') || (window.location.href = url);
            } else {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = filename; link.href = url; link.click();
                URL.revokeObjectURL(url);
            }
        }

        document.getElementById('export-png').addEventListener('click', async () => {
            createExportCanvas().toBlob(async (blob) => {
                await downloadFile(blob, `c2_tiling_${b}_${c}_${d}_${e}_${h}.png`, 'image/png');
            }, 'image/png');
        });

        document.getElementById('export-pdf').addEventListener('click', () => {
            if (!window.jspdf) {
                const s = document.createElement('script');
                s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                s.onload = exportPDF; document.head.appendChild(s);
            } else exportPDF();

            async function exportPDF() {
                const exportCanvas = createExportCanvas();
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({ orientation: 'landscape', unit: 'px', format: [exportCanvas.width, exportCanvas.height] });
                pdf.addImage(exportCanvas.toDataURL('image/png'), 'PNG', 0, 0, exportCanvas.width, exportCanvas.height);
                await downloadFile(pdf.output('blob'), `c2_tiling_${b}_${c}_${d}_${e}_${h}.pdf`, 'application/pdf');
            }
        });

        window.addEventListener('resize', () => { renderer.setupCanvas(); draw(); });

        initPaletteSelector();
        initSimulation();
        console.log('C2 Glauber dynamics ready (pure JS)');
    });
})();
</script>
