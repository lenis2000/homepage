---
title: Glauber dynamics for lozenge tilings of a C2 region
model: lozenge-tilings
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/lozenge_tilings/2025-11-28-c2-Glauber.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/lozenge_tilings/2025-11-28-c2-Glauber.cpp'
    txt: 'C++ code for the simulation (compiled to WebAssembly)'
---

<style>
  .control-group {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 8px;
  }
  .control-group-title {
    font-size: 11px;
    font-weight: 600;
    color: #666;
    margin-bottom: 6px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  #lozenge-canvas {
    width: 100%;
    max-width: 900px;
    height: 550px;
    border: 1px solid #ccc;
    display: block;
    margin: 0 auto;
    background: #ffffff;
    border-radius: 6px;
  }
  [data-theme="dark"] #lozenge-canvas {
    background: #1a1a1a;
    border-color: #444;
  }
  .param-input {
    width: 45px;
    height: 28px;
    text-align: center;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
    font-family: 'SF Mono', Monaco, monospace;
  }
  .param-input:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
  }
  .param-label {
    font-size: 13px;
    color: #555;
    margin-right: 4px;
    font-weight: 500;
  }
  .param-group {
    display: inline-flex;
    align-items: center;
    margin-right: 12px;
  }
  .computed-box {
    display: inline-flex;
    align-items: center;
    background: #e8f5e9;
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 13px;
  }
  .computed-box .label {
    color: #666;
    margin-right: 6px;
  }
  .computed-box .value {
    font-weight: 600;
    color: #2e7d32;
    font-family: 'SF Mono', Monaco, monospace;
  }
  input[type="range"] {
    height: 4px;
    border-radius: 2px;
    background: #d0d0d0;
    appearance: none;
    outline: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: linear-gradient(135deg, #4CAF50, #66BB6A);
    cursor: pointer;
  }
  button {
    height: 30px;
    padding: 0 14px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    background: white;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s;
  }
  button:hover {
    background: #f5f5f5;
    border-color: #999;
  }
  button.primary {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
  }
  button.primary:hover {
    background: #45a049;
  }
  button.running {
    background: linear-gradient(135deg, #ff5722, #ff9800);
    color: white;
    border-color: #ff5722;
  }
  /* View toggle buttons */
  .view-toggle {
    display: inline-flex;
    border: 2px solid #1976d2;
    border-radius: 6px;
    overflow: hidden;
  }
  .view-toggle button {
    border: none;
    border-radius: 0;
    height: 32px;
    padding: 0 16px;
    font-weight: 500;
    background: white;
    color: #1976d2;
  }
  .view-toggle button.active {
    background: #1976d2;
    color: white;
  }
  .view-toggle button:hover:not(.active) {
    background: #e3f2fd;
  }
  .stats-inline {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    font-size: 12px;
  }
  .stats-inline .stat {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .stats-inline .stat-label {
    color: #888;
    text-transform: uppercase;
    font-size: 10px;
  }
  .stats-inline .stat-value {
    color: #1976d2;
    font-weight: 600;
    font-family: 'SF Mono', Monaco, monospace;
  }
  select {
    height: 30px;
    padding: 0 8px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    font-size: 13px;
    background: white;
    cursor: pointer;
  }
  .color-legend {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    font-size: 12px;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .color-box {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid rgba(0,0,0,0.1);
  }
  details {
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    overflow: hidden;
    margin: 8px auto;
    max-width: 900px;
  }
  details > summary {
    padding: 8px 12px;
    background: #f5f5f5;
    font-weight: 500;
    font-size: 13px;
    cursor: pointer;
  }
  details > .content {
    padding: 10px 12px;
    background: white;
  }
  [data-theme="dark"] .control-group {
    background-color: #2d2d2d;
    border-color: #444;
  }
  [data-theme="dark"] .control-group-title,
  [data-theme="dark"] .param-label {
    color: #bbb;
  }
  [data-theme="dark"] .param-input,
  [data-theme="dark"] select,
  [data-theme="dark"] button {
    background-color: #3a3a3a;
    border-color: #555;
    color: #ddd;
  }
  [data-theme="dark"] .computed-box {
    background: #2d4a2e;
  }
  [data-theme="dark"] .computed-box .value {
    color: #81c784;
  }
  @media (max-width: 767px) {
    #lozenge-canvas { height: 400px; }
    .param-group { margin-right: 8px; margin-bottom: 6px; }
    .param-input { width: 40px; }
  }
</style>

<script src="/js/colorschemes.js"></script>
<script src="/js/2025-11-28-c2-Glauber.js"></script>

<!-- Main controls -->
<div style="max-width: 900px; margin: 0 auto; padding: 8px;">

<!-- Shape Parameters -->
<div class="control-group">
  <div class="control-group-title">Shape</div>
  <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 6px;">
    <span class="param-group"><span class="param-label">b</span><input type="number" class="param-input" id="bInput" value="7" min="1" max="100"></span>
    <span class="param-group"><span class="param-label">c</span><input type="number" class="param-input" id="cInput" value="6" min="1" max="100"></span>
    <span class="param-group"><span class="param-label">d</span><input type="number" class="param-input" id="dInput" value="3" min="1" max="100"></span>
    <span class="param-group"><span class="param-label">e</span><input type="number" class="param-input" id="eInput" value="8" min="1" max="100"></span>
    <span class="param-group"><span class="param-label">h</span><input type="number" class="param-input" id="hInput" value="6" min="1" max="100"></span>
    <button id="mediumBtn">Medium</button>
    <button id="largeBtn">Large</button>
    <span class="computed-box"><span class="label">a = b-d+e+c =</span><span class="value" id="aVal">18</span></span>
  </div>
</div>

<!-- Display Options -->
<div class="control-group">
  <div class="control-group-title">Display</div>
  <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
    <!-- View Toggle -->
    <div class="view-toggle">
      <button id="lozengeViewBtn" class="active">Lozenge</button>
      <button id="dimerViewBtn">Dimer</button>
    </div>
    <!-- Palette -->
    <div style="display: flex; align-items: center; gap: 4px;">
      <button id="prev-palette" style="padding: 0 8px;">&#9664;</button>
      <select id="palette-select" style="width: 120px;"></select>
      <button id="next-palette" style="padding: 0 8px;">&#9654;</button>
    </div>
    <!-- Color Permutation -->
    <button id="permuteColors" title="Permute colors (6 permutations)">Permute</button>
    <!-- Outline Width (percentage) -->
    <div style="display: flex; align-items: center; gap: 4px;">
      <span style="font-size: 12px; color: #555;">Outline:</span>
      <input type="number" id="outlineWidthPct" value="1.5" min="0" max="10" step="0.1" class="param-input" style="width: 50px;">
      <span style="font-size: 11px; color: #888;">%</span>
    </div>
    <!-- Boundary Outline Width (percentage) -->
    <div style="display: flex; align-items: center; gap: 4px;">
      <span style="font-size: 12px; color: #555;">Boundary:</span>
      <input type="number" id="boundaryWidthPct" value="10" min="0" max="5000" step="1" class="param-input" style="width: 50px;">
      <span style="font-size: 11px; color: #888;">%</span>
    </div>
    <!-- Side Labels -->
    <div style="display: flex; align-items: center; gap: 4px;">
      <input type="checkbox" id="showLabels">
      <label for="showLabels" style="font-size: 12px; color: #555; cursor: pointer;">Labels</label>
    </div>
  </div>
</div>

<!-- Simulation Controls -->
<div class="control-group">
  <div class="control-group-title">Simulation</div>
  <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
    <button id="startStopBtn" class="primary">Start</button>
    <button id="resetBtn">Reset</button>
    <!-- Speed -->
    <div style="display: flex; align-items: center; gap: 6px;">
      <span style="font-size: 12px; color: #666;">Speed</span>
      <input type="range" id="speedSlider" min="1" max="15000000" value="100" style="width: 100px;">
      <span id="speedVal" style="font-size: 12px; color: #1976d2; min-width: 45px;">100/s</span>
    </div>
    <!-- Q Bias -->
    <span class="param-group"><span class="param-label">q</span><input type="number" class="param-input" id="qInput" value="1" min="0" max="10" step="0.01" style="width: 60px;"></span>
  </div>
</div>

<!-- Stats Row -->
<div class="control-group">
  <div class="stats-inline">
    <div class="stat"><span class="stat-label">Steps</span><span class="stat-value" id="stepCount">0</span></div>
    <div class="stat"><span class="stat-label">Flips</span><span class="stat-value" id="flipCount">0</span></div>
    <div class="stat"><span class="stat-label">Accept</span><span class="stat-value" id="acceptRate">0%</span></div>
    <div class="stat"><span class="stat-label">Volume</span><span class="stat-value" id="volume">0</span></div>
    <div class="stat"><span class="stat-label">FPS</span><span class="stat-value" id="fps">0</span></div>
  </div>
</div>

</div>

<!-- Canvas -->
<canvas id="lozenge-canvas"></canvas>

<!-- Export & Legend -->
<details>
  <summary>Export & Legend</summary>
  <div class="content">
    <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
      <button id="export-png">PNG</button>
      <button id="export-pdf">PDF</button>
      <span style="font-size: 11px; color: #666;">Quality:</span>
      <input type="range" id="export-quality" min="0" max="100" value="85" style="width: 60px;">
      <span id="export-quality-val" style="font-size: 11px; color: #1976d2;">85</span>
      <span style="border-left: 1px solid #ddd; height: 20px;"></span>
      <div class="color-legend">
        <span class="legend-item"><span class="color-box" id="swatch-type0"></span>T0</span>
        <span class="legend-item"><span class="color-box" id="swatch-type1"></span>T1</span>
        <span class="legend-item"><span class="color-box" id="swatch-type2"></span>T2</span>
        <span id="palette-name-display" style="font-weight: 500;"></span>
      </div>
    </div>
  </div>
</details>

<script>
// WASM-based implementation for fast Glauber dynamics
Module.onRuntimeInitialized = function() {
    const slope = 1 / Math.sqrt(3);
    const deltaC = 2 / Math.sqrt(3);

    function getVertex(n, j) {
        return { x: n, y: slope * n + j * deltaC };
    }

    class C2GlauberWASM {
        constructor() {
            this.boundary = [];
            this.dimers = [];
            this.blackTriangles = [];
            this.whiteTriangles = [];
            this.initPolygonWasm = Module.cwrap('initPolygon', 'number', ['number', 'number', 'number', 'number', 'number']);
            this.performGlauberStepsWasm = Module.cwrap('performGlauberSteps', 'number', ['number']);
            this.exportDimersWasm = Module.cwrap('exportDimers', 'number', []);
            this.getAcceptRateWasm = Module.cwrap('getAcceptRate', 'number', []);
            this.setQBiasWasm = Module.cwrap('setQBias', null, ['number']);
            this.freeStringWasm = Module.cwrap('freeString', null, ['number']);
            this.totalSteps = 0;
            this.flipCount = 0;
        }

        setQBias(q) {
            this.setQBiasWasm(q);
        }

        init(b, c, d, e, h) {
            const ptr = this.initPolygonWasm(b, c, d, e, h);
            const jsonStr = Module.UTF8ToString(ptr);
            this.freeStringWasm(ptr);
            const result = JSON.parse(jsonStr);
            this.totalSteps = 0;
            this.flipCount = 0;
            this.refreshDimers();
            return result;
        }

        step(numSteps) {
            const ptr = this.performGlauberStepsWasm(numSteps);
            const jsonStr = Module.UTF8ToString(ptr);
            this.freeStringWasm(ptr);
            const result = JSON.parse(jsonStr);
            // Update from JSON result
            this.totalSteps = result.totalSteps || 0;
            this.flipCount = result.flipCount || 0;
            this.refreshDimers();
            return result;
        }

        refreshDimers() {
            const ptr = this.exportDimersWasm();
            const jsonStr = Module.UTF8ToString(ptr);
            this.freeStringWasm(ptr);
            const result = JSON.parse(jsonStr);
            this.boundary = result.boundary;
            this.dimers = result.dimers;
            this.blackTriangles = result.black;
            this.whiteTriangles = result.white;
        }

        getTotalSteps() { return this.totalSteps; }
        getFlipCount() { return this.flipCount; }
        getAcceptRate() { return this.getAcceptRateWasm(); }
    }

    class LozengeRenderer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.outlineWidthPct = 1.5; // percentage of dimers
            this.boundaryWidthPct = 2; // percentage for boundary outline
            this.showDimerView = false;
            this.showLabels = false;
            this.currentPaletteIndex = 0;
            this.colorPalettes = window.ColorSchemes || [{ name: 'UVA', colors: ['#E57200', '#232D4B', '#F9DCBF', '#002D62'] }];
            this.setupCanvas();
        }

        setupCanvas() {
            const rect = this.canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = rect.width * dpr;
            this.canvas.height = rect.height * dpr;
            this.ctx.scale(dpr, dpr);
            this.displayWidth = rect.width;
            this.displayHeight = rect.height;
        }

        getCurrentPalette() { return this.colorPalettes[this.currentPaletteIndex]; }

        toCanvas(x, y, centerX, centerY, scale) {
            return [centerX + x * scale, centerY - y * scale];
        }

        getLozengeVertices(dimer) {
            const { bn, bj, t } = dimer;
            if (t === 0) {
                return [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            } else if (t === 1) {
                return [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
            } else {
                return [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            }
        }

        draw(sim) {
            const ctx = this.ctx;
            const palette = this.getCurrentPalette();
            const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';

            ctx.fillStyle = isDarkMode ? '#1a1a1a' : '#ffffff';
            ctx.fillRect(0, 0, this.displayWidth, this.displayHeight);

            if (!sim.boundary || sim.boundary.length === 0) return;

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const v of sim.boundary) {
                minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
            }

            const padding = 2;
            const rangeX = maxX - minX + 2 * padding;
            const rangeY = maxY - minY + 2 * padding;
            const plotRange = Math.max(rangeX, rangeY) / 2;
            const scale = Math.min(this.displayWidth, this.displayHeight) / (2 * plotRange);
            const centerX = this.displayWidth / 2 - ((minX + maxX) / 2) * scale;
            const centerY = this.displayHeight / 2 + ((minY + maxY) / 2) * scale;

            if (this.showDimerView) {
                this.drawDimerView(ctx, sim, palette, centerX, centerY, scale);
            } else {
                this.drawLozengeView(ctx, sim, palette, centerX, centerY, scale);
            }

            ctx.strokeStyle = '#000';
            // Calculate boundary outline width based on percentage of dimer count
            const dimerCount = sim.dimers.length || 1;
            const refDimerCount = 100;
            const boundaryWidth = this.boundaryWidthPct * (refDimerCount / dimerCount);
            ctx.lineWidth = boundaryWidth;
            ctx.beginPath();
            const [sx, sy] = this.toCanvas(sim.boundary[0].x, sim.boundary[0].y, centerX, centerY, scale);
            ctx.moveTo(sx, sy);
            for (let i = 1; i < sim.boundary.length; i++) {
                const [px, py] = this.toCanvas(sim.boundary[i].x, sim.boundary[i].y, centerX, centerY, scale);
                ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.stroke();

            // Draw side labels if enabled
            if (this.showLabels) {
                this.drawSideLabels(ctx, sim, centerX, centerY, scale);
            }
        }

        drawSideLabels(ctx, sim, centerX, centerY, scale) {
            // Side lengths in order matching the boundary trace in C++:
            // a, b, h, c, d, e, e, d, c, h, b, a, 2h
            const A = b - d + e + c;
            const labels = ['a', 'b', 'h', 'c', 'd', 'e', 'e', 'd', 'c', 'h', 'b', 'a', '2h'];
            const sideLengths = [A, b, h, c, d, e, e, d, c, h, b, A, 2*h];

            // LaTeX-style italic serif font
            ctx.font = 'italic 16px "Times New Roman", Times, serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
            ctx.fillStyle = isDarkMode ? '#fff' : '#000';

            // Determine polygon winding direction using signed area
            // Positive = counter-clockwise, Negative = clockwise
            let signedArea = 0;
            for (let i = 0; i < sim.boundary.length; i++) {
                const p1 = sim.boundary[i];
                const p2 = sim.boundary[(i + 1) % sim.boundary.length];
                signedArea += (p2.x - p1.x) * (p2.y + p1.y);
            }
            // windingSign: +1 if clockwise (labels should be on right side of edge direction)
            //              -1 if counter-clockwise (labels should be on left side)
            const windingSign = signedArea > 0 ? 1 : -1;

            let currentPos = 0;
            for (let labelIdx = 0; labelIdx < labels.length; labelIdx++) {
                const sideLen = sideLengths[labelIdx];
                if (sideLen === 0) continue;

                // Find midpoint of this side
                const midIdx = currentPos + Math.floor(sideLen / 2);
                if (midIdx >= sim.boundary.length - 1) {
                    currentPos += sideLen;
                    continue;
                }

                const p1 = sim.boundary[midIdx];
                const p2 = sim.boundary[(midIdx + 1) % sim.boundary.length];
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;

                // Calculate normal direction (perpendicular to edge)
                // For edge from p1 to p2, the right-hand normal is (dy, -dx) normalized
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.sqrt(dx*dx + dy*dy) || 1;
                // Right-hand perpendicular (outward for clockwise winding)
                let nx = dy / len * windingSign;
                let ny = -dx / len * windingSign;

                // Offset label outward (outside the polygon)
                const offset = 22 / scale;
                const labelX = midX + nx * offset;
                const labelY = midY + ny * offset;

                const [cx, cy] = this.toCanvas(labelX, labelY, centerX, centerY, scale);
                ctx.fillText(labels[labelIdx], cx, cy);

                currentPos += sideLen;
            }
        }

        drawLozengeView(ctx, sim, palette, centerX, centerY, scale) {
            const colors = this.getPermutedColors();
            // Calculate outline width based on percentage of dimer count
            // Reference: 100 dimers at 1.5% gives ~1.5px outline
            const dimerCount = sim.dimers.length || 1;
            const refDimerCount = 100;
            const outlineWidth = this.outlineWidthPct * (refDimerCount / dimerCount);
            for (const dimer of sim.dimers) {
                const verts = this.getLozengeVertices(dimer);
                const canvasVerts = verts.map(v => this.toCanvas(v.x, v.y, centerX, centerY, scale));
                ctx.fillStyle = colors[dimer.t];
                ctx.beginPath();
                ctx.moveTo(canvasVerts[0][0], canvasVerts[0][1]);
                for (let i = 1; i < canvasVerts.length; i++) ctx.lineTo(canvasVerts[i][0], canvasVerts[i][1]);
                ctx.closePath();
                ctx.fill();
                if (outlineWidth > 0) {
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = outlineWidth;
                    ctx.stroke();
                }
            }
        }

        drawDimerView(ctx, sim, palette, centerX, centerY, scale) {
            const whiteMap = new Map();
            for (const w of sim.whiteTriangles) whiteMap.set(`${w.n},${w.j}`, w);
            const totalVertices = sim.blackTriangles.length + sim.whiteTriangles.length;

            // Draw triangular lattice grid
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const v of sim.boundary) {
                minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
            }
            const gridMinN = Math.floor(minX) - 1;
            const gridMaxN = Math.ceil(maxX) + 1;
            const gridMinJ = Math.floor(minY / deltaC) - gridMaxN - 2;
            const gridMaxJ = Math.ceil(maxY / deltaC) + gridMaxN + 2;

            ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
            ctx.lineWidth = 1;
            // Vertical lines
            for (let k = gridMinN; k <= gridMaxN; k++) {
                const y1 = slope * k + gridMinJ * deltaC - 2;
                const y2 = slope * k + gridMaxJ * deltaC + 2;
                const [x1c, y1c] = this.toCanvas(k, y1, centerX, centerY, scale);
                const [x2c, y2c] = this.toCanvas(k, y2, centerX, centerY, scale);
                ctx.beginPath(); ctx.moveTo(x1c, y1c); ctx.lineTo(x2c, y2c); ctx.stroke();
            }
            // +30° lines
            for (let k = gridMinJ - 5; k <= gridMaxJ + 5; k++) {
                const cVal = k * deltaC;
                const [x1c, y1c] = this.toCanvas(gridMinN - 2, slope * (gridMinN - 2) + cVal, centerX, centerY, scale);
                const [x2c, y2c] = this.toCanvas(gridMaxN + 2, slope * (gridMaxN + 2) + cVal, centerX, centerY, scale);
                ctx.beginPath(); ctx.moveTo(x1c, y1c); ctx.lineTo(x2c, y2c); ctx.stroke();
            }
            // -30° lines
            for (let k = gridMinJ - 5; k <= gridMaxJ + 5; k++) {
                const cVal = k * deltaC;
                const [x1c, y1c] = this.toCanvas(gridMinN - 2, -slope * (gridMinN - 2) + cVal, centerX, centerY, scale);
                const [x2c, y2c] = this.toCanvas(gridMaxN + 2, -slope * (gridMaxN + 2) + cVal, centerX, centerY, scale);
                ctx.beginPath(); ctx.moveTo(x1c, y1c); ctx.lineTo(x2c, y2c); ctx.stroke();
            }

            // Draw hex graph edges (gray)
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.4)';
            ctx.lineWidth = 1;
            for (const b of sim.blackTriangles) {
                const [bcx, bcy] = this.toCanvas(b.cx, b.cy, centerX, centerY, scale);
                for (const nb of [{ n: b.n, j: b.j }, { n: b.n, j: b.j - 1 }, { n: b.n - 1, j: b.j }]) {
                    const w = whiteMap.get(`${nb.n},${nb.j}`);
                    if (w) {
                        const [wcx, wcy] = this.toCanvas(w.cx, w.cy, centerX, centerY, scale);
                        ctx.beginPath(); ctx.moveTo(bcx, bcy); ctx.lineTo(wcx, wcy); ctx.stroke();
                    }
                }
            }

            // Draw dimer edges (black, not colored by type)
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            for (const dimer of sim.dimers) {
                const bc = sim.blackTriangles.find(b => b.n === dimer.bn && b.j === dimer.bj);
                const wc = sim.whiteTriangles.find(w => w.n === dimer.wn && w.j === dimer.wj);
                if (bc && wc) {
                    const [bcx, bcy] = this.toCanvas(bc.cx, bc.cy, centerX, centerY, scale);
                    const [wcx, wcy] = this.toCanvas(wc.cx, wc.cy, centerX, centerY, scale);
                    ctx.beginPath(); ctx.moveTo(bcx, bcy); ctx.lineTo(wcx, wcy); ctx.stroke();
                }
            }

            // Only draw vertices if total count <= 120
            if (totalVertices <= 120) {
                for (const b of sim.blackTriangles) {
                    const [cx, cy] = this.toCanvas(b.cx, b.cy, centerX, centerY, scale);
                    ctx.fillStyle = '#000';
                    ctx.beginPath(); ctx.arc(cx, cy, 3, 0, 2 * Math.PI); ctx.fill();
                }
                for (const w of sim.whiteTriangles) {
                    const [cx, cy] = this.toCanvas(w.cx, w.cy, centerX, centerY, scale);
                    ctx.fillStyle = '#fff'; ctx.strokeStyle = '#333'; ctx.lineWidth = 1.5;
                    ctx.beginPath(); ctx.arc(cx, cy, 3, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
                }
            }
        }

        setPalette(index) {
            this.currentPaletteIndex = ((index % this.colorPalettes.length) + this.colorPalettes.length) % this.colorPalettes.length;
            this.colorPermutation = 0;  // Reset permutation when changing palette
            this.updateLegend();
        }
        nextPalette() { this.setPalette(this.currentPaletteIndex + 1); }
        prevPalette() { this.setPalette(this.currentPaletteIndex - 1); }

        // Color permutation: 6 permutations of 3 colors (0,1,2)
        // Permutations: [0,1,2], [0,2,1], [1,0,2], [1,2,0], [2,0,1], [2,1,0]
        permuteColors() {
            this.colorPermutation = ((this.colorPermutation || 0) + 1) % 6;
            this.updateLegend();
        }

        getPermutedColors() {
            const palette = this.getCurrentPalette();
            const permutations = [
                [0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]
            ];
            const perm = permutations[this.colorPermutation || 0];
            return [palette.colors[perm[0]], palette.colors[perm[1]], palette.colors[perm[2]]];
        }

        updateLegend() {
            const colors = this.getPermutedColors();
            const palette = this.getCurrentPalette();
            document.getElementById('swatch-type0').style.backgroundColor = colors[0];
            document.getElementById('swatch-type1').style.backgroundColor = colors[1];
            document.getElementById('swatch-type2').style.backgroundColor = colors[2];
            document.getElementById('palette-name-display').textContent = palette.name;
        }
    }

    const canvas = document.getElementById('lozenge-canvas');
    const sim = new C2GlauberWASM();
    const renderer = new LozengeRenderer(canvas);

    let running = false, stepsPerSecond = 100, lastFrameTime = performance.now(), frameCount = 0, currentFps = 0;
    let b = 7, c = 6, d = 3, e = 8, h = 6;

    const el = {
        bInput: document.getElementById('bInput'),
        cInput: document.getElementById('cInput'),
        dInput: document.getElementById('dInput'),
        eInput: document.getElementById('eInput'),
        hInput: document.getElementById('hInput'),
        aVal: document.getElementById('aVal'),
        speedSlider: document.getElementById('speedSlider'),
        speedVal: document.getElementById('speedVal'),
        stepCount: document.getElementById('stepCount'),
        flipCount: document.getElementById('flipCount'),
        acceptRate: document.getElementById('acceptRate'),
        volume: document.getElementById('volume'),
        fps: document.getElementById('fps'),
        startStopBtn: document.getElementById('startStopBtn'),
        paletteSelect: document.getElementById('palette-select'),
        lozengeViewBtn: document.getElementById('lozengeViewBtn'),
        dimerViewBtn: document.getElementById('dimerViewBtn')
    };

    function initPaletteSelector() {
        renderer.colorPalettes.forEach((p, i) => {
            const opt = document.createElement('option');
            opt.value = i; opt.textContent = p.name;
            el.paletteSelect.appendChild(opt);
        });
        el.paletteSelect.value = renderer.currentPaletteIndex;
        renderer.updateLegend();
    }

    function formatNumber(n) {
        if (n >= 1e9) return (n / 1e9).toFixed(1) + 'B';
        if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
        if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
        return n.toString();
    }

    function updateStats(result) {
        el.stepCount.textContent = formatNumber(sim.getTotalSteps());
        el.flipCount.textContent = formatNumber(sim.getFlipCount());
        el.acceptRate.textContent = (sim.getAcceptRate() * 100).toFixed(1) + '%';
        el.fps.textContent = currentFps.toFixed(0);
        if (result && result.volume !== undefined) {
            el.volume.textContent = formatNumber(result.volume);
        }
    }

    function draw() { renderer.draw(sim); }

    function updateA() { el.aVal.textContent = b - d + e + c; }

    function initSimulation() {
        const result = sim.init(b, c, d, e, h);
        updateA(); draw(); updateStats(result);
    }

    let animationId = null;

    function loop() {
        if (!running) return;
        try {
            const now = performance.now();
            frameCount++;
            if (now - lastFrameTime >= 1000) {
                currentFps = frameCount * 1000 / (now - lastFrameTime);
                frameCount = 0; lastFrameTime = now;
            }
            const stepsPerFrame = stepsPerSecond <= 60 ? 1 : Math.ceil(stepsPerSecond / 60);
            const result = sim.step(stepsPerFrame);
            draw(); updateStats(result);
        } catch (err) {
            console.error('Loop error:', err);
        }
        if (running) {
            if (stepsPerSecond <= 60) {
                animationId = setTimeout(() => requestAnimationFrame(loop), 1000 / stepsPerSecond);
            } else {
                animationId = requestAnimationFrame(loop);
            }
        }
    }

    function toggleRunning() {
        running = !running;
        el.startStopBtn.textContent = running ? 'Stop' : 'Start';
        el.startStopBtn.classList.toggle('running', running);
        if (running) {
            lastFrameTime = performance.now();
            frameCount = 0;
            loop();
        } else {
            if (animationId) {
                cancelAnimationFrame(animationId);
                clearTimeout(animationId);
                animationId = null;
            }
        }
    }

    for (const [key, param] of [['bInput', 'b'], ['cInput', 'c'], ['dInput', 'd'], ['eInput', 'e'], ['hInput', 'h']]) {
        el[key].addEventListener('change', (ev) => {
            const val = parseInt(ev.target.value) || 1;
            ev.target.value = Math.max(1, Math.min(100, val));
            if (param === 'b') b = parseInt(ev.target.value);
            else if (param === 'c') c = parseInt(ev.target.value);
            else if (param === 'd') d = parseInt(ev.target.value);
            else if (param === 'e') e = parseInt(ev.target.value);
            else if (param === 'h') h = parseInt(ev.target.value);

            // Stop any running simulation before reinitializing
            const wasRunning = running;
            if (running) {
                running = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    clearTimeout(animationId);
                    animationId = null;
                }
            }

            // Reinitialize
            initSimulation();

            // Restart only if was running before
            if (wasRunning) {
                running = true;
                el.startStopBtn.textContent = 'Stop';
                el.startStopBtn.classList.add('running');
                lastFrameTime = performance.now();
                frameCount = 0;
                loop();
            }
        });
    }

    el.speedSlider.addEventListener('input', (ev) => {
        stepsPerSecond = parseInt(ev.target.value);
        el.speedVal.textContent = stepsPerSecond >= 1000 ? (stepsPerSecond / 1000).toFixed(1) + 'k/s' : stepsPerSecond + '/s';
    });

    el.lozengeViewBtn.addEventListener('click', () => {
        renderer.showDimerView = false;
        el.lozengeViewBtn.classList.add('active');
        el.dimerViewBtn.classList.remove('active');
        draw();
    });

    el.dimerViewBtn.addEventListener('click', () => {
        renderer.showDimerView = true;
        el.dimerViewBtn.classList.add('active');
        el.lozengeViewBtn.classList.remove('active');
        draw();
    });

    document.getElementById('outlineWidthPct').addEventListener('input', (ev) => {
        renderer.outlineWidthPct = parseFloat(ev.target.value) || 0; draw();
    });

    document.getElementById('boundaryWidthPct').addEventListener('input', (ev) => {
        renderer.boundaryWidthPct = parseFloat(ev.target.value) || 0; draw();
    });

    document.getElementById('showLabels').addEventListener('change', (ev) => {
        renderer.showLabels = ev.target.checked; draw();
    });

    el.paletteSelect.addEventListener('change', (ev) => { renderer.setPalette(parseInt(ev.target.value)); draw(); });
    document.getElementById('prev-palette').addEventListener('click', () => { renderer.prevPalette(); el.paletteSelect.value = renderer.currentPaletteIndex; draw(); });
    document.getElementById('next-palette').addEventListener('click', () => { renderer.nextPalette(); el.paletteSelect.value = renderer.currentPaletteIndex; draw(); });

    document.getElementById('permuteColors').addEventListener('click', () => { renderer.permuteColors(); draw(); });

    document.getElementById('qInput').addEventListener('change', (ev) => {
        const q = parseFloat(ev.target.value) || 1;
        ev.target.value = Math.max(0, Math.min(10, q));
        sim.setQBias(parseFloat(ev.target.value));
    });

    el.startStopBtn.addEventListener('click', toggleRunning);
    document.getElementById('resetBtn').addEventListener('click', () => {
        if (running) { running = false; el.startStopBtn.textContent = 'Start'; el.startStopBtn.classList.remove('running'); }
        initSimulation();
    });

    document.getElementById('mediumBtn').addEventListener('click', () => {
        if (running) { running = false; el.startStopBtn.textContent = 'Start'; el.startStopBtn.classList.remove('running'); }
        b = 25; c = 15; d = 10; e = 20; h = 25;
        el.bInput.value = b; el.cInput.value = c; el.dInput.value = d; el.eInput.value = e; el.hInput.value = h;
        initSimulation();
    });

    document.getElementById('largeBtn').addEventListener('click', () => {
        if (running) { running = false; el.startStopBtn.textContent = 'Start'; el.startStopBtn.classList.remove('running'); }
        b = 50; c = 30; d = 20; e = 40; h = 50;
        el.bInput.value = b; el.cInput.value = c; el.dInput.value = d; el.eInput.value = e; el.hInput.value = h;
        initSimulation();
    });

    document.getElementById('export-quality').addEventListener('input', (ev) => {
        document.getElementById('export-quality-val').textContent = ev.target.value;
    });

    function getExportScale() { return 1 + (parseInt(document.getElementById('export-quality').value) / 100) * 3; }
    function isIOS() { return /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1); }

    function createExportCanvas() {
        const baseWidth = 900, baseHeight = 550, scale = getExportScale();
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = baseWidth * scale; exportCanvas.height = baseHeight * scale;
        const exportCtx = exportCanvas.getContext('2d');
        exportCtx.scale(scale, scale);
        const origCtx = renderer.ctx, origW = renderer.displayWidth, origH = renderer.displayHeight;
        renderer.ctx = exportCtx; renderer.displayWidth = baseWidth; renderer.displayHeight = baseHeight;
        renderer.draw(sim);
        renderer.ctx = origCtx; renderer.displayWidth = origW; renderer.displayHeight = origH;
        return exportCanvas;
    }

    async function downloadFile(blob, filename, mimeType) {
        if (isIOS() && navigator.share && navigator.canShare) {
            try {
                const file = new File([blob], filename, { type: mimeType });
                if (navigator.canShare({ files: [file] })) { await navigator.share({ files: [file], title: filename }); return; }
            } catch (e) {}
        }
        if (isIOS()) {
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank') || (window.location.href = url);
        } else {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = filename; link.href = url; link.click();
            URL.revokeObjectURL(url);
        }
    }

    document.getElementById('export-png').addEventListener('click', async () => {
        createExportCanvas().toBlob(async (blob) => {
            await downloadFile(blob, `c2_tiling_${b}_${c}_${d}_${e}_${h}.png`, 'image/png');
        }, 'image/png');
    });

    document.getElementById('export-pdf').addEventListener('click', () => {
        if (!window.jspdf) {
            const s = document.createElement('script');
            s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
            s.onload = exportPDF; document.head.appendChild(s);
        } else exportPDF();

        async function exportPDF() {
            // Vector PDF export using jsPDF native drawing
            const scale = getExportScale();
            const baseWidth = renderer.canvas.width / window.devicePixelRatio;
            const baseHeight = renderer.canvas.height / window.devicePixelRatio;
            const pdfWidth = baseWidth * scale;
            const pdfHeight = baseHeight * scale;

            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({ orientation: pdfWidth > pdfHeight ? 'landscape' : 'portrait', unit: 'px', format: [pdfWidth, pdfHeight] });

            // Helper to parse CSS colors to RGB
            function parseColor(color) {
                if (color.startsWith('#')) {
                    const hex = color.slice(1);
                    if (hex.length === 3) {
                        return [parseInt(hex[0]+hex[0], 16), parseInt(hex[1]+hex[1], 16), parseInt(hex[2]+hex[2], 16)];
                    }
                    return [parseInt(hex.slice(0,2), 16), parseInt(hex.slice(2,4), 16), parseInt(hex.slice(4,6), 16)];
                }
                if (color.startsWith('rgb')) {
                    const m = color.match(/(\d+)/g);
                    return m ? [parseInt(m[0]), parseInt(m[1]), parseInt(m[2])] : [0, 0, 0];
                }
                return [0, 0, 0];
            }

            // Draw background
            const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
            const bgColor = parseColor(isDarkMode ? '#1a1a1a' : '#ffffff');
            pdf.setFillColor(bgColor[0], bgColor[1], bgColor[2]);
            pdf.rect(0, 0, pdfWidth, pdfHeight, 'F');

            if (!sim.boundary || sim.boundary.length === 0) {
                await downloadFile(pdf.output('blob'), `c2_tiling_${b}_${c}_${d}_${e}_${h}.pdf`, 'application/pdf');
                return;
            }

            // Calculate coordinate transform (same as renderer.draw)
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const v of sim.boundary) {
                minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
            }
            const padding = 2;
            const rangeX = maxX - minX + 2 * padding;
            const rangeY = maxY - minY + 2 * padding;
            const plotRange = Math.max(rangeX, rangeY) / 2;
            const coordScale = Math.min(pdfWidth, pdfHeight) / (2 * plotRange);
            const centerX = pdfWidth / 2 - ((minX + maxX) / 2) * coordScale;
            const centerY = pdfHeight / 2 + ((minY + maxY) / 2) * coordScale;

            function toCanvas(x, y) {
                return [centerX + x * coordScale, centerY - y * coordScale];
            }

            // Draw lozenges (vector)
            const colors = renderer.getPermutedColors();
            const dimerCount = sim.dimers.length || 1;
            const refDimerCount = 100;
            const outlineWidth = renderer.outlineWidthPct * (refDimerCount / dimerCount) * scale;

            for (const dimer of sim.dimers) {
                const verts = renderer.getLozengeVertices(dimer);
                const canvasVerts = verts.map(v => toCanvas(v.x, v.y));

                const fillColor = parseColor(colors[dimer.t]);
                pdf.setFillColor(fillColor[0], fillColor[1], fillColor[2]);

                // Draw filled polygon
                const points = canvasVerts.slice(1).map((v, i) => [v[0] - canvasVerts[i][0], v[1] - canvasVerts[i][1]]);
                points.push([canvasVerts[0][0] - canvasVerts[canvasVerts.length-1][0], canvasVerts[0][1] - canvasVerts[canvasVerts.length-1][1]]);
                pdf.moveTo(canvasVerts[0][0], canvasVerts[0][1]);
                pdf.lines(points, canvasVerts[0][0], canvasVerts[0][1], [1, 1], 'F', true);

                if (outlineWidth > 0) {
                    pdf.setDrawColor(0, 0, 0);
                    pdf.setLineWidth(outlineWidth);
                    pdf.moveTo(canvasVerts[0][0], canvasVerts[0][1]);
                    pdf.lines(points, canvasVerts[0][0], canvasVerts[0][1], [1, 1], 'S', true);
                }
            }

            // Draw boundary
            const boundaryWidth = renderer.boundaryWidthPct * (refDimerCount / dimerCount) * scale;
            pdf.setDrawColor(0, 0, 0);
            pdf.setLineWidth(boundaryWidth);
            const bStart = toCanvas(sim.boundary[0].x, sim.boundary[0].y);
            const bPoints = [];
            for (let i = 1; i < sim.boundary.length; i++) {
                const p = toCanvas(sim.boundary[i].x, sim.boundary[i].y);
                bPoints.push([p[0] - (i === 1 ? bStart[0] : toCanvas(sim.boundary[i-1].x, sim.boundary[i-1].y)[0]),
                              p[1] - (i === 1 ? bStart[1] : toCanvas(sim.boundary[i-1].x, sim.boundary[i-1].y)[1])]);
            }
            bPoints.push([bStart[0] - toCanvas(sim.boundary[sim.boundary.length-1].x, sim.boundary[sim.boundary.length-1].y)[0],
                          bStart[1] - toCanvas(sim.boundary[sim.boundary.length-1].x, sim.boundary[sim.boundary.length-1].y)[1]]);
            pdf.lines(bPoints, bStart[0], bStart[1], [1, 1], 'S', true);

            // Draw labels if enabled
            if (renderer.showLabels) {
                const A = b - d + e + c;
                const labels = ['a', 'b', 'h', 'c', 'd', 'e', 'e', 'd', 'c', 'h', 'b', 'a', '2h'];
                const sideLengths = [A, b, h, c, d, e, e, d, c, h, b, A, 2*h];

                pdf.setFont('times', 'italic');
                pdf.setFontSize(16 * scale);
                const textColor = parseColor(isDarkMode ? '#fff' : '#000');
                pdf.setTextColor(textColor[0], textColor[1], textColor[2]);

                let signedArea = 0;
                for (let i = 0; i < sim.boundary.length; i++) {
                    const p1 = sim.boundary[i];
                    const p2 = sim.boundary[(i + 1) % sim.boundary.length];
                    signedArea += (p2.x - p1.x) * (p2.y + p1.y);
                }
                const windingSign = signedArea > 0 ? 1 : -1;

                let currentPos = 0;
                for (let labelIdx = 0; labelIdx < labels.length; labelIdx++) {
                    const sideLen = sideLengths[labelIdx];
                    if (sideLen === 0) continue;
                    const midIdx = currentPos + Math.floor(sideLen / 2);
                    if (midIdx >= sim.boundary.length - 1) { currentPos += sideLen; continue; }

                    const p1 = sim.boundary[midIdx];
                    const p2 = sim.boundary[(midIdx + 1) % sim.boundary.length];
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;
                    const dx = p2.x - p1.x, dy = p2.y - p1.y;
                    const len = Math.sqrt(dx*dx + dy*dy) || 1;
                    const nx = dy / len * windingSign, ny = -dx / len * windingSign;
                    const offset = 22 / coordScale;
                    const [cx, cy] = toCanvas(midX + nx * offset, midY + ny * offset);
                    pdf.text(labels[labelIdx], cx, cy, { align: 'center', baseline: 'middle' });
                    currentPos += sideLen;
                }
            }

            await downloadFile(pdf.output('blob'), `c2_tiling_${b}_${c}_${d}_${e}_${h}.pdf`, 'application/pdf');
        }
    });

    window.addEventListener('resize', () => { renderer.setupCanvas(); draw(); });

    initPaletteSelector();
    initSimulation();
    console.log('C2 Glauber dynamics ready (WASM)');
};
</script>
