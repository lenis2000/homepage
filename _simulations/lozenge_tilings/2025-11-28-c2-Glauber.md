---
title: Glauber dynamics for lozenge tilings of a C2 region
model: lozenge-tilings
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/lozenge_tilings/2025-11-28-c2-Glauber.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/lozenge_tilings/2025-11-28-c2-Glauber.cpp'
    txt: 'C++ code for the simulation (compiled to WebAssembly)'
---

<style>
  .control-group {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 8px;
  }
  .control-group-title {
    font-size: 11px;
    font-weight: 600;
    color: #666;
    margin-bottom: 6px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  #lozenge-canvas {
    width: 100%;
    max-width: 900px;
    height: 550px;
    border: 1px solid #ccc;
    display: block;
    margin: 0 auto;
    background: #ffffff;
    border-radius: 6px;
  }
  [data-theme="dark"] #lozenge-canvas {
    background: #1a1a1a;
    border-color: #444;
  }
  .param-input {
    width: 45px;
    height: 28px;
    text-align: center;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
    font-family: 'SF Mono', Monaco, monospace;
  }
  .param-input:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
  }
  .param-label {
    font-size: 13px;
    color: #555;
    margin-right: 4px;
    font-weight: 500;
  }
  .param-group {
    display: inline-flex;
    align-items: center;
    margin-right: 12px;
  }
  .computed-box {
    display: inline-flex;
    align-items: center;
    background: #e8f5e9;
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 13px;
  }
  .computed-box .label {
    color: #666;
    margin-right: 6px;
  }
  .computed-box .value {
    font-weight: 600;
    color: #2e7d32;
    font-family: 'SF Mono', Monaco, monospace;
  }
  input[type="range"] {
    height: 4px;
    border-radius: 2px;
    background: #d0d0d0;
    appearance: none;
    outline: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: linear-gradient(135deg, #4CAF50, #66BB6A);
    cursor: pointer;
  }
  button {
    height: 30px;
    padding: 0 14px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    background: white;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s;
  }
  button:hover {
    background: #f5f5f5;
    border-color: #999;
  }
  button.primary {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
  }
  button.primary:hover {
    background: #45a049;
  }
  button.running {
    background: linear-gradient(135deg, #ff5722, #ff9800);
    color: white;
    border-color: #ff5722;
  }
  /* View toggle buttons */
  .view-toggle {
    display: inline-flex;
    border: 2px solid #1976d2;
    border-radius: 6px;
    overflow: hidden;
  }
  .view-toggle button {
    border: none;
    border-radius: 0;
    height: 32px;
    padding: 0 16px;
    font-weight: 500;
    background: white;
    color: #1976d2;
  }
  .view-toggle button.active {
    background: #1976d2;
    color: white;
  }
  .view-toggle button:hover:not(.active) {
    background: #e3f2fd;
  }
  .stats-inline {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    font-size: 12px;
  }
  .stats-inline .stat {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .stats-inline .stat-label {
    color: #888;
    text-transform: uppercase;
    font-size: 10px;
  }
  .stats-inline .stat-value {
    color: #1976d2;
    font-weight: 600;
    font-family: 'SF Mono', Monaco, monospace;
  }
  select {
    height: 30px;
    padding: 0 8px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    font-size: 13px;
    background: white;
    cursor: pointer;
  }
  .color-legend {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    font-size: 12px;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .color-box {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid rgba(0,0,0,0.1);
  }
  details {
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    overflow: hidden;
    margin: 8px auto;
    max-width: 900px;
  }
  details > summary {
    padding: 8px 12px;
    background: #f5f5f5;
    font-weight: 500;
    font-size: 13px;
    cursor: pointer;
  }
  details > .content {
    padding: 10px 12px;
    background: white;
  }
  [data-theme="dark"] .control-group {
    background-color: #2d2d2d;
    border-color: #444;
  }
  [data-theme="dark"] .control-group-title,
  [data-theme="dark"] .param-label {
    color: #bbb;
  }
  [data-theme="dark"] .param-input,
  [data-theme="dark"] select,
  [data-theme="dark"] button {
    background-color: #3a3a3a;
    border-color: #555;
    color: #ddd;
  }
  [data-theme="dark"] .computed-box {
    background: #2d4a2e;
  }
  [data-theme="dark"] .computed-box .value {
    color: #81c784;
  }
  @media (max-width: 767px) {
    #lozenge-canvas { height: 400px; }
    .param-group { margin-right: 8px; margin-bottom: 6px; }
    .param-input { width: 40px; }
  }
</style>

<script src="/js/colorschemes.js"></script>
<!-- Temporarily use pure JS implementation for debugging -->
<!-- <script src="/js/2025-11-28-c2-Glauber.js"></script> -->

<!-- Main controls -->
<div style="max-width: 900px; margin: 0 auto; padding: 8px;">

<!-- Shape Parameters -->
<div class="control-group">
  <div class="control-group-title">Shape</div>
  <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 6px;">
    <span class="param-group"><span class="param-label">b</span><input type="number" class="param-input" id="bInput" value="7" min="1" max="50"></span>
    <span class="param-group"><span class="param-label">c</span><input type="number" class="param-input" id="cInput" value="6" min="1" max="50"></span>
    <span class="param-group"><span class="param-label">d</span><input type="number" class="param-input" id="dInput" value="3" min="1" max="50"></span>
    <span class="param-group"><span class="param-label">e</span><input type="number" class="param-input" id="eInput" value="8" min="1" max="50"></span>
    <span class="param-group"><span class="param-label">h</span><input type="number" class="param-input" id="hInput" value="6" min="1" max="50"></span>
    <span class="computed-box"><span class="label">a = b-d+e+c =</span><span class="value" id="aVal">18</span></span>
  </div>
</div>

<!-- Controls Row -->
<div class="control-group">
  <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
    <!-- View Toggle -->
    <div class="view-toggle">
      <button id="lozengeViewBtn" class="active">Lozenge</button>
      <button id="dimerViewBtn">Dimer</button>
    </div>
    <!-- Simulation -->
    <button id="startStopBtn" class="primary">Start</button>
    <button id="resetBtn">Reset</button>
    <!-- Speed -->
    <div style="display: flex; align-items: center; gap: 6px;">
      <span style="font-size: 12px; color: #666;">Speed</span>
      <input type="range" id="speedSlider" min="1" max="400000" value="100" style="width: 100px;">
      <span id="speedVal" style="font-size: 12px; color: #1976d2; min-width: 45px;">100/s</span>
    </div>
    <!-- Palette -->
    <div style="display: flex; align-items: center; gap: 4px;">
      <button id="prev-palette" style="padding: 0 8px;">&#9664;</button>
      <select id="palette-select" style="width: 120px;"></select>
      <button id="next-palette" style="padding: 0 8px;">&#9654;</button>
    </div>
    <!-- Outlines -->
    <label style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: #555; cursor: pointer;">
      <input type="checkbox" id="showOutlines" checked style="accent-color: #4CAF50;">
      Outlines
    </label>
  </div>
</div>

<!-- Stats Row -->
<div class="control-group">
  <div class="stats-inline">
    <div class="stat"><span class="stat-label">Steps</span><span class="stat-value" id="stepCount">0</span></div>
    <div class="stat"><span class="stat-label">Flips</span><span class="stat-value" id="flipCount">0</span></div>
    <div class="stat"><span class="stat-label">Accept</span><span class="stat-value" id="acceptRate">0%</span></div>
    <div class="stat"><span class="stat-label">FPS</span><span class="stat-value" id="fps">0</span></div>
    <div class="stat"><span class="stat-label">T0</span><span class="stat-value" id="type0Count">0</span></div>
    <div class="stat"><span class="stat-label">T1</span><span class="stat-value" id="type1Count">0</span></div>
    <div class="stat"><span class="stat-label">T2</span><span class="stat-value" id="type2Count">0</span></div>
    <div class="stat"><span class="stat-label">Total</span><span class="stat-value" id="totalDimers">0</span></div>
  </div>
</div>

</div>

<!-- Canvas -->
<canvas id="lozenge-canvas"></canvas>

<!-- Export & Legend -->
<details>
  <summary>Export & Legend</summary>
  <div class="content">
    <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
      <button id="export-png">PNG</button>
      <button id="export-pdf">PDF</button>
      <span style="font-size: 11px; color: #666;">Quality:</span>
      <input type="range" id="export-quality" min="0" max="100" value="85" style="width: 60px;">
      <span id="export-quality-val" style="font-size: 11px; color: #1976d2;">85</span>
      <span style="border-left: 1px solid #ddd; height: 20px;"></span>
      <div class="color-legend">
        <span class="legend-item"><span class="color-box" id="swatch-type0"></span>T0</span>
        <span class="legend-item"><span class="color-box" id="swatch-type1"></span>T1</span>
        <span class="legend-item"><span class="color-box" id="swatch-type2"></span>T2</span>
        <span id="palette-name-display" style="font-weight: 500;"></span>
      </div>
    </div>
  </div>
</details>

<script>
if (typeof Module === 'undefined') {
    console.error('Module is not defined.');
    window.Module = { onRuntimeInitialized: function() {} };
}

Module.onRuntimeInitialized = async function() {

    class C2GlauberWASM {
        constructor() {
            this.ready = false;
            this.boundary = [];
            this.dimers = [];
            this.blackTriangles = [];
            this.whiteTriangles = [];
        }

        async initialize() {
            this.initPolygonWasm = Module.cwrap('initPolygon', 'number', ['number', 'number', 'number', 'number', 'number']);
            this.performGlauberStepsWasm = Module.cwrap('performGlauberSteps', 'number', ['number']);
            this.exportDimersWasm = Module.cwrap('exportDimers', 'number', []);
            this.getAcceptRateWasm = Module.cwrap('getAcceptRate', 'number', []);
            this.getTotalStepsWasm = Module.cwrap('getTotalSteps', 'number', []);
            this.getFlipCountWasm = Module.cwrap('getFlipCount', 'number', []);
            this.freeString = Module.cwrap('freeString', null, ['number']);
            this.ready = true;
        }

        async init(b, c, d, e, h) {
            const ptr = this.initPolygonWasm(b, c, d, e, h);
            const jsonStr = Module.UTF8ToString(ptr);
            this.freeString(ptr);
            const result = JSON.parse(jsonStr);
            if (result.error) throw new Error(result.error);
            await this.refreshDimers();
            return result;
        }

        async step(numSteps) {
            const ptr = this.performGlauberStepsWasm(numSteps);
            const jsonStr = Module.UTF8ToString(ptr);
            this.freeString(ptr);
            const result = JSON.parse(jsonStr);
            if (result.error) throw new Error(result.error);
            await this.refreshDimers();
            return result;
        }

        async refreshDimers() {
            const ptr = this.exportDimersWasm();
            const jsonStr = Module.UTF8ToString(ptr);
            this.freeString(ptr);
            const result = JSON.parse(jsonStr);
            if (!result.error) {
                this.boundary = result.boundary;
                this.dimers = result.dimers;
                this.blackTriangles = result.black;
                this.whiteTriangles = result.white;
            }
        }

        getAcceptRate() { return this.getAcceptRateWasm(); }
        getTotalSteps() { return this.getTotalStepsWasm(); }
        getFlipCount() { return this.getFlipCountWasm(); }
    }

    class LozengeRenderer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.showOutlines = true;
            this.showDimerView = false;
            this.currentPaletteIndex = 0;
            this.colorPalettes = window.ColorSchemes || [{ name: 'UVA', colors: ['#E57200', '#232D4B', '#F9DCBF', '#002D62'] }];
            this.setupCanvas();
        }

        setupCanvas() {
            const rect = this.canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = rect.width * dpr;
            this.canvas.height = rect.height * dpr;
            this.ctx.scale(dpr, dpr);
            this.displayWidth = rect.width;
            this.displayHeight = rect.height;
        }

        getCurrentPalette() { return this.colorPalettes[this.currentPaletteIndex]; }

        getVertex(n, j) {
            const slope = 1.0 / Math.sqrt(3.0);
            const deltaC = 2.0 / Math.sqrt(3.0);
            return { x: n, y: slope * n + j * deltaC };
        }

        toCanvas(x, y, centerX, centerY, scale) {
            return [centerX + x * scale, centerY - y * scale];
        }

        getLozengeVertices(dimer) {
            const { bn, bj, t } = dimer;
            if (t === 0) {
                return [this.getVertex(bn, bj), this.getVertex(bn + 1, bj), this.getVertex(bn + 1, bj - 1), this.getVertex(bn, bj - 1)];
            } else if (t === 1) {
                return [this.getVertex(bn, bj), this.getVertex(bn + 1, bj - 1), this.getVertex(bn + 1, bj - 2), this.getVertex(bn, bj - 1)];
            } else {
                return [this.getVertex(bn - 1, bj), this.getVertex(bn, bj), this.getVertex(bn + 1, bj - 1), this.getVertex(bn, bj - 1)];
            }
        }

        draw(wasm) {
            const ctx = this.ctx;
            const palette = this.getCurrentPalette();
            const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';

            ctx.fillStyle = isDarkMode ? '#1a1a1a' : '#ffffff';
            ctx.fillRect(0, 0, this.displayWidth, this.displayHeight);

            if (!wasm.boundary || wasm.boundary.length === 0) return;

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const v of wasm.boundary) {
                minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
            }

            const padding = 2;
            const rangeX = maxX - minX + 2 * padding;
            const rangeY = maxY - minY + 2 * padding;
            const plotRange = Math.max(rangeX, rangeY) / 2;
            const scale = Math.min(this.displayWidth, this.displayHeight) / (2 * plotRange);
            const centerX = this.displayWidth / 2 - ((minX + maxX) / 2) * scale;
            const centerY = this.displayHeight / 2 + ((minY + maxY) / 2) * scale;

            if (this.showDimerView) {
                this.drawDimerView(ctx, wasm, palette, centerX, centerY, scale);
            } else {
                this.drawLozengeView(ctx, wasm, palette, centerX, centerY, scale);
            }

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            const [sx, sy] = this.toCanvas(wasm.boundary[0].x, wasm.boundary[0].y, centerX, centerY, scale);
            ctx.moveTo(sx, sy);
            for (let i = 1; i < wasm.boundary.length; i++) {
                const [px, py] = this.toCanvas(wasm.boundary[i].x, wasm.boundary[i].y, centerX, centerY, scale);
                ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.stroke();
        }

        drawLozengeView(ctx, wasm, palette, centerX, centerY, scale) {
            const colors = [palette.colors[0], palette.colors[1], palette.colors[2]];
            for (const dimer of wasm.dimers) {
                const verts = this.getLozengeVertices(dimer);
                const canvasVerts = verts.map(v => this.toCanvas(v.x, v.y, centerX, centerY, scale));
                ctx.fillStyle = colors[dimer.t];
                ctx.beginPath();
                ctx.moveTo(canvasVerts[0][0], canvasVerts[0][1]);
                for (let i = 1; i < canvasVerts.length; i++) ctx.lineTo(canvasVerts[i][0], canvasVerts[i][1]);
                ctx.closePath();
                ctx.fill();
                if (this.showOutlines) {
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }

        drawDimerView(ctx, wasm, palette, centerX, centerY, scale) {
            const colors = [palette.colors[0], palette.colors[1], palette.colors[2]];
            const whiteMap = new Map();
            for (const w of wasm.whiteTriangles) whiteMap.set(`${w.n},${w.j}`, w);

            ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
            ctx.lineWidth = 1;
            for (const b of wasm.blackTriangles) {
                const [bcx, bcy] = this.toCanvas(b.cx, b.cy, centerX, centerY, scale);
                for (const nb of [{ n: b.n, j: b.j }, { n: b.n, j: b.j - 1 }, { n: b.n - 1, j: b.j }]) {
                    const w = whiteMap.get(`${nb.n},${nb.j}`);
                    if (w) {
                        const [wcx, wcy] = this.toCanvas(w.cx, w.cy, centerX, centerY, scale);
                        ctx.beginPath(); ctx.moveTo(bcx, bcy); ctx.lineTo(wcx, wcy); ctx.stroke();
                    }
                }
            }

            for (const dimer of wasm.dimers) {
                const bc = wasm.blackTriangles.find(b => b.n === dimer.bn && b.j === dimer.bj);
                const wc = wasm.whiteTriangles.find(w => w.n === dimer.wn && w.j === dimer.wj);
                if (bc && wc) {
                    const [bcx, bcy] = this.toCanvas(bc.cx, bc.cy, centerX, centerY, scale);
                    const [wcx, wcy] = this.toCanvas(wc.cx, wc.cy, centerX, centerY, scale);
                    ctx.strokeStyle = colors[dimer.t];
                    ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.moveTo(bcx, bcy); ctx.lineTo(wcx, wcy); ctx.stroke();
                }
            }

            for (const b of wasm.blackTriangles) {
                const [cx, cy] = this.toCanvas(b.cx, b.cy, centerX, centerY, scale);
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(cx, cy, 3, 0, 2 * Math.PI); ctx.fill();
            }
            for (const w of wasm.whiteTriangles) {
                const [cx, cy] = this.toCanvas(w.cx, w.cy, centerX, centerY, scale);
                ctx.fillStyle = '#fff'; ctx.strokeStyle = '#333'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(cx, cy, 3, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            }
        }

        setPalette(index) {
            this.currentPaletteIndex = ((index % this.colorPalettes.length) + this.colorPalettes.length) % this.colorPalettes.length;
            this.updateLegend();
        }
        nextPalette() { this.setPalette(this.currentPaletteIndex + 1); }
        prevPalette() { this.setPalette(this.currentPaletteIndex - 1); }

        updateLegend() {
            const palette = this.getCurrentPalette();
            document.getElementById('swatch-type0').style.backgroundColor = palette.colors[0];
            document.getElementById('swatch-type1').style.backgroundColor = palette.colors[1];
            document.getElementById('swatch-type2').style.backgroundColor = palette.colors[2];
            document.getElementById('palette-name-display').textContent = palette.name;
        }
    }

    const canvas = document.getElementById('lozenge-canvas');
    const wasm = new C2GlauberWASM();
    const renderer = new LozengeRenderer(canvas);

    let running = false, stepsPerSecond = 100, lastFrameTime = performance.now(), frameCount = 0, currentFps = 0;
    let b = 7, c = 6, d = 3, e = 8, h = 6;

    const el = {
        bInput: document.getElementById('bInput'),
        cInput: document.getElementById('cInput'),
        dInput: document.getElementById('dInput'),
        eInput: document.getElementById('eInput'),
        hInput: document.getElementById('hInput'),
        aVal: document.getElementById('aVal'),
        speedSlider: document.getElementById('speedSlider'),
        speedVal: document.getElementById('speedVal'),
        stepCount: document.getElementById('stepCount'),
        flipCount: document.getElementById('flipCount'),
        acceptRate: document.getElementById('acceptRate'),
        fps: document.getElementById('fps'),
        type0Count: document.getElementById('type0Count'),
        type1Count: document.getElementById('type1Count'),
        type2Count: document.getElementById('type2Count'),
        totalDimers: document.getElementById('totalDimers'),
        startStopBtn: document.getElementById('startStopBtn'),
        paletteSelect: document.getElementById('palette-select'),
        lozengeViewBtn: document.getElementById('lozengeViewBtn'),
        dimerViewBtn: document.getElementById('dimerViewBtn')
    };

    function initPaletteSelector() {
        renderer.colorPalettes.forEach((p, i) => {
            const opt = document.createElement('option');
            opt.value = i; opt.textContent = p.name;
            el.paletteSelect.appendChild(opt);
        });
        el.paletteSelect.value = renderer.currentPaletteIndex;
        renderer.updateLegend();
    }

    function formatNumber(n) {
        if (n >= 1e9) return (n / 1e9).toFixed(1) + 'B';
        if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
        if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
        return n.toString();
    }

    function updateStats(result) {
        el.stepCount.textContent = formatNumber(wasm.getTotalSteps());
        el.flipCount.textContent = formatNumber(wasm.getFlipCount());
        el.acceptRate.textContent = (wasm.getAcceptRate() * 100).toFixed(1) + '%';
        el.fps.textContent = currentFps.toFixed(0);
        if (result) {
            el.type0Count.textContent = result.type0 || 0;
            el.type1Count.textContent = result.type1 || 0;
            el.type2Count.textContent = result.type2 || 0;
            el.totalDimers.textContent = (result.type0 || 0) + (result.type1 || 0) + (result.type2 || 0);
        }
    }

    function draw() { renderer.draw(wasm); }

    function updateA() { el.aVal.textContent = b - d + e + c; }

    async function initSimulation() {
        try {
            const result = await wasm.init(b, c, d, e, h);
            updateA(); draw(); updateStats(result);
        } catch (err) { console.error('Init error:', err); }
    }

    async function loop() {
        if (!running) { draw(); return; }
        const now = performance.now();
        frameCount++;
        if (now - lastFrameTime >= 1000) {
            currentFps = frameCount * 1000 / (now - lastFrameTime);
            frameCount = 0; lastFrameTime = now;
        }
        try {
            const stepsPerFrame = stepsPerSecond <= 60 ? 1 : Math.ceil(stepsPerSecond / 60);
            const result = await wasm.step(stepsPerFrame);
            draw(); updateStats(result);
        } catch (err) { console.error('Step error:', err); }
        if (stepsPerSecond <= 60) {
            setTimeout(() => requestAnimationFrame(loop), 1000 / stepsPerSecond);
        } else {
            requestAnimationFrame(loop);
        }
    }

    function toggleRunning() {
        running = !running;
        el.startStopBtn.textContent = running ? 'Stop' : 'Start';
        el.startStopBtn.classList.toggle('running', running);
        if (running) { lastFrameTime = performance.now(); frameCount = 0; loop(); }
    }

    // Event handlers
    for (const [key, param] of [['bInput', 'b'], ['cInput', 'c'], ['dInput', 'd'], ['eInput', 'e'], ['hInput', 'h']]) {
        el[key].addEventListener('change', async (ev) => {
            const val = parseInt(ev.target.value) || 1;
            ev.target.value = Math.max(1, Math.min(50, val));
            if (param === 'b') b = parseInt(ev.target.value);
            else if (param === 'c') c = parseInt(ev.target.value);
            else if (param === 'd') d = parseInt(ev.target.value);
            else if (param === 'e') e = parseInt(ev.target.value);
            else if (param === 'h') h = parseInt(ev.target.value);
            await initSimulation();
        });
    }

    el.speedSlider.addEventListener('input', (ev) => {
        stepsPerSecond = parseInt(ev.target.value);
        el.speedVal.textContent = stepsPerSecond >= 1000 ? (stepsPerSecond / 1000).toFixed(1) + 'k/s' : stepsPerSecond + '/s';
    });

    el.lozengeViewBtn.addEventListener('click', () => {
        renderer.showDimerView = false;
        el.lozengeViewBtn.classList.add('active');
        el.dimerViewBtn.classList.remove('active');
        draw();
    });

    el.dimerViewBtn.addEventListener('click', () => {
        renderer.showDimerView = true;
        el.dimerViewBtn.classList.add('active');
        el.lozengeViewBtn.classList.remove('active');
        draw();
    });

    document.getElementById('showOutlines').addEventListener('change', (ev) => {
        renderer.showOutlines = ev.target.checked; draw();
    });

    el.paletteSelect.addEventListener('change', (ev) => { renderer.setPalette(parseInt(ev.target.value)); draw(); });
    document.getElementById('prev-palette').addEventListener('click', () => { renderer.prevPalette(); el.paletteSelect.value = renderer.currentPaletteIndex; draw(); });
    document.getElementById('next-palette').addEventListener('click', () => { renderer.nextPalette(); el.paletteSelect.value = renderer.currentPaletteIndex; draw(); });

    el.startStopBtn.addEventListener('click', toggleRunning);
    document.getElementById('resetBtn').addEventListener('click', async () => {
        if (running) { running = false; el.startStopBtn.textContent = 'Start'; el.startStopBtn.classList.remove('running'); }
        await initSimulation();
    });

    document.getElementById('export-quality').addEventListener('input', (ev) => {
        document.getElementById('export-quality-val').textContent = ev.target.value;
    });

    function getExportScale() { return 1 + (parseInt(document.getElementById('export-quality').value) / 100) * 3; }
    function isIOS() { return /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1); }

    function createExportCanvas() {
        const baseWidth = 900, baseHeight = 550, scale = getExportScale();
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = baseWidth * scale; exportCanvas.height = baseHeight * scale;
        const exportCtx = exportCanvas.getContext('2d');
        exportCtx.scale(scale, scale);
        const origCtx = renderer.ctx, origW = renderer.displayWidth, origH = renderer.displayHeight;
        renderer.ctx = exportCtx; renderer.displayWidth = baseWidth; renderer.displayHeight = baseHeight;
        renderer.draw(wasm);
        renderer.ctx = origCtx; renderer.displayWidth = origW; renderer.displayHeight = origH;
        return exportCanvas;
    }

    async function downloadFile(blob, filename, mimeType) {
        if (isIOS() && navigator.share && navigator.canShare) {
            try {
                const file = new File([blob], filename, { type: mimeType });
                if (navigator.canShare({ files: [file] })) { await navigator.share({ files: [file], title: filename }); return; }
            } catch (e) {}
        }
        if (isIOS()) {
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank') || (window.location.href = url);
        } else {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = filename; link.href = url; link.click();
            URL.revokeObjectURL(url);
        }
    }

    document.getElementById('export-png').addEventListener('click', async () => {
        createExportCanvas().toBlob(async (blob) => {
            await downloadFile(blob, `c2_tiling_${b}_${c}_${d}_${e}_${h}.png`, 'image/png');
        }, 'image/png');
    });

    document.getElementById('export-pdf').addEventListener('click', () => {
        if (!window.jspdf) {
            const s = document.createElement('script');
            s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
            s.onload = exportPDF; document.head.appendChild(s);
        } else exportPDF();

        async function exportPDF() {
            const exportCanvas = createExportCanvas();
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({ orientation: 'landscape', unit: 'px', format: [exportCanvas.width, exportCanvas.height] });
            pdf.addImage(exportCanvas.toDataURL('image/png'), 'PNG', 0, 0, exportCanvas.width, exportCanvas.height);
            await downloadFile(pdf.output('blob'), `c2_tiling_${b}_${c}_${d}_${e}_${h}.pdf`, 'application/pdf');
        }
    });

    window.addEventListener('resize', () => { renderer.setupCanvas(); draw(); });

    await wasm.initialize();
    initPaletteSelector();
    await initSimulation();
    console.log('C2 Glauber dynamics ready');
};
</script>
