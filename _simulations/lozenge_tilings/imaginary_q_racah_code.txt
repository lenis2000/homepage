IMAGINARY Q-RACAH CODE EXTRACTED FROM Main.f90
================================================

This file contains the code sections that implement imaginary and real q-Racah polynomials (modes 1 and 2) 
from the Tilings_Construction Fortran application.

MODE DEFINITIONS:
- Mode 1: Imaginary q-Racah (kappasq = -kappa^2 where kappa is imaginary)
- Mode 2: Real q-Racah (kappasq = -q^(2*log_q(kappa)))

========================================
INPUT PARAMETER HANDLING SECTIONS
========================================

1. NEW HEXAGON PARAMETER INPUT (Lines 552-611):
-------------------------------------------------

  if ((mode1==1).or.(mode1==2).or.(mode1==5)) then
   write(10,'(A,i5,A,i5,A,i5,A,f13.6)') 'Input new q:'
   read(10,*,err=10,end=10) q1
   if ((q1.le.0)) goto 10
  endif

  if (mode1==1) then  !kappasq=-kappa^2
   write(10,'(A)') 'Input non-zero imaginary part of a new kappa. '
   read(10,*,err=10,end=10) kappasq1
   kappasq1=kappasq1**2   !kappasq=-kappa^2
   if (kappasq1==0) goto 10
  endif

  if (mode1==2) then
    write(10,'(A)') 'Input log_q(kappa):'  !kappasq=-kappa^2
    write(10,*) 'Values between -N and T/2 are not advised'
	read(10,*,err=10,end=10) kappasq1
    if ((kappasq1.le.(T1/2.0)).AND. (kappasq1.ge.(-N1))) then
	 goto 10
    endif
    kappasq1=-q1**(2*kappasq1)  !kappasq=-kappa^2
  endif

  mode=mode1
  kappasq=kappasq1

2. UPPATH PARAMETER INPUT (Lines 668-730):
-------------------------------------------

  if ((mode1==1).or.(mode1==2).or.(mode1==5)) then
   write(10,'(A,i5,A,i5,A,i5,A,f13.6)') 'Input new q:'
   read(10,*,err=10,end=10) q1
   if ((q1.le.0)) goto 10
  endif

  if (mode1==1) then  !kappasq=-kappa^2
   write(10,'(A)') 'Input non-zero imaginary part of a new kappa. '
   read(10,*,err=10,end=10) kappasq1
   kappasq1=kappasq1**2   !kappasq=-kappa^2
   if (kappasq1==0) goto 10
  endif

  if (mode1==2) then
    write(10,'(A)') 'Input log_q(kappa):'  !kappasq=-kappa^2
    write(10,*) 'Values between -N and T/2 are not advised'
	read(10,*,err=10,end=10) kappasq1
    if ((kappasq1.le.(T1/2.0)).AND. (kappasq1.ge.(-N1))) then
	 goto 10
    endif
    kappasq1=-q1**(2*kappasq1)  !kappasq=-kappa^2
  endif

  mode=mode1
  kappasq=kappasq1

3. DIALOG PARAMETER INPUT (Lines 2645-2719):
---------------------------------------------

  if ((mode1==1).or.(mode1==2).or.(mode1==5)) then
    retlog = DLGGET (dlg, IDC_EDIT_q, buff)
   read(buff,*,err=101,end=101) q1
   if ((q1.le.0).OR.(q1==1)) goto 101
  endif

  if (mode1==1) then  !kappasq=-kappa^2
    retlog = DLGGET (dlg, IDC_EDIT_kappa, buff)
   read(buff,*,err=101,end=101) kappasq1
   kappasq1=kappasq1**2   !kappasq=-kappa^2
   if (kappasq1==0) goto 101
  endif

  if (mode1==2) then
    retlog = DLGGET (dlg, IDC_EDIT_lkappa, buff)
    read(buff,*,err=101,end=101) kappasq1
    if ((kappasq1.le.(T1/2.0)).AND. (kappasq1.ge.(-N1))) then
     write(buff1,*) kappasq1, 'should not lie inside [', -N1,',',T1/2.0,']'C
	 goto 101
    endif
    kappasq1=-q1**(2*kappasq1)  !kappasq=-kappa^2
  endif

  mode=mode1
  kappasq=kappasq1

========================================
SOPERATOR (S→S+1) ALGORITHM SECTION
========================================

S-OPERATOR Q-RACAH CASE (Lines 1866-2011):
--------------------------------------------

		case(1,2)  !Real and imaginary qRacah

         if ((T-tc-S)<(1)) then
          
           p(1)=1
		   do i=2,j-k+2
		    x=paths(k+i-2,tc)+0.0
		    if ((q<1)) then
             p(i)=p(i-1)*q*((1-q**(T-tc-S+x))/(1-q**(x+1)))
		   
		     if (kappasq.ne.0) then
              if ( (-x+T-1)>0 ) then
			     p(i)=p(i)*(1+kappasq*q**(-x+S+tc))/ (1+kappasq*q**(-x+T-1))     
                else
			     p(i)=p(i)*( q**(x-T+1)+kappasq*q**(S+tc-T+1) )/ (q**(x-T+1)+kappasq) 
              endif
			 
			  if ((-2*x+tc+S-2)>0) then
			    p(i)=p(i)*(1+kappasq*q**(-2*x+tc+S-2))/(1+kappasq*q**(-2*x+tc+S))
			   else
			    p(i)=p(i)*(q**(2*x-tc-S+2)+kappasq)/(q**(2*x-tc-S+2)+kappasq*q*q)
			  endif

			 endif

			else !so, q>1
		  	    
		      p(i)=p(i-1)*(1-q**(-(T-tc-S+x)))/(1-q**(-x-1))
			  if (kappasq==0) then
			   p(i)=p(i)*(q**(T-tc-S))
			  else
               if ( (-x+T-1)<0 ) then
			    p(i)=p(i)*(q**(T-tc-S)+kappasq*q**(-x+T))/ (1+kappasq*q**(-x+T-1))     
               else
			    p(i)=p(i)*(q**(x-tc-S+1)+kappasq*q)/ (q**(x-T+1)+kappasq) 
               endif
			   if ((-2*x+tc+S-2)<0) then
			    p(i)=p(i)*(1+kappasq*q**(-2*x+tc+S-2))/(1+kappasq*q**(-2*x+tc+S))
			   else
			    p(i)=p(i)*(q**(2*x-tc-S+2)+kappasq)/(q**(2*x-tc-S+2)+kappasq*q*q)
			   endif

			  endif
			endif
		     
		   enddo
	
         else
		  if (q>1) then
		   p(j-k+2)=1
		   do i=1,j-k+1
		    x=paths(j+1-i,tc)+0.0

            p(j-k+2-i)=p(j-k+2-i+1)*(1-q**(-x-1))/(1-q**(-(T-tc-S+x)))

			  if (kappasq==0) then
			   p(j-k+2-i)=p(j-k+2-i)*(q**(-(T-tc-S)))
			  else
               if ( (-x+T-1)<0 ) then
			    p(j-k+2-i)=p(j-k+2-i)* (1+kappasq*q**(-x+T-1))/(q**(T-tc-S)+kappasq*q**(-x+T))     
               else
			    p(j-k+2-i)=p(j-k+2-i)* (q**(x-T+1)+kappasq) /(q**(x-tc-S+1)+kappasq*q)
               endif
			   if ((-2*x+tc+S-2)<0) then
			    p(j-k+2-i)=p(j-k+2-i)*(1+kappasq*q**(-2*x+tc+S))/(1+kappasq*q**(-2*x+tc+S-2))
			   else
			    p(j-k+2-i)=p(j-k+2-i)*(q**(2*x-tc-S+2)+kappasq*q*q)/(q**(2*x-tc-S+2)+kappasq)
			   endif

			  endif

           enddo
          else  ! Last case: q<1; T-tc-S>0

            x0=-log( (q**(T-tc-S)-1)/(1-1/q))/log(q)   !Here we find a point with maximal probability
			i0=k
			do while ((i0<j).AND.(paths(i0,tc)<x0))
			  i0=i0+1
			enddo

            if (kappasq.ne.0) then
			 i0=j+1
			endif

			p(i0-k+1)=1

			do i=i0-k+2,j-k+2
		     x=paths(k+i-2,tc)+0.0
		     p(i)=p(i-1)*q*(1-q**(T-tc-S+x))/(1-q**(x+1))
			 if (kappasq.ne.0) then 

			  if ( (-x+T-1)>0 ) then
			     p(i)=p(i)*(1+kappasq*q**(-x+S+tc))/ (1+kappasq*q**(-x+T-1))     
                else
			     p(i)=p(i)*( q**(x-T+1)+kappasq*q**(S+tc-T+1) )/ (q**(x-T+1)+kappasq) 
              endif
			 
			  if ((-2*x+tc+S-2)>0) then
			    p(i)=p(i)*(1+kappasq*q**(-2*x+tc+S-2))/(1+kappasq*q**(-2*x+tc+S))
			   else
			    p(i)=p(i)*(q**(2*x-tc-S+2)+kappasq)/(q**(2*x-tc-S+2)+kappasq*q*q)
			  endif
			   
		     endif

		    enddo

            do i=2,i0-k+1
		     x=paths(i0+1-i,tc)+0.0
		     p(i0-k+2-i)=p(i0-k+2-i+1)*(1/q-q**(x))/(1-q**((T-tc-S+x))) 

		     if (kappasq.ne.0) then 

			  if ( (-x+T-1)>0 ) then
			     p(i0-k+2-i)=p(i0-k+2-i)*(1+kappasq*q**(-x+T-1))/(1+kappasq*q**(-x+S+tc))     
                else
			     p(i0-k+2-i)=p(i0-k+2-i)* (q**(x-T+1)+kappasq) /( q**(x-T+1)+kappasq*q**(S+tc-T+1) )
              endif
			 
			  if ((-2*x+tc+S-2)>0) then
			    p(i0-k+2-i)=p(i0-k+2-i)*(1+kappasq*q**(-2*x+tc+S))/(1+kappasq*q**(-2*x+tc+S-2))
			   else
			    p(i0-k+2-i)=p(i0-k+2-i)*(q**(2*x-tc-S+2)+kappasq*q*q)/(q**(2*x-tc-S+2)+kappasq)
			  endif
			   
		     endif

            enddo
            
		  endif
         endif

========================================
SMINUSOPERATOR (S→S-1) ALGORITHM SECTION
========================================

S-MINUS-OPERATOR Q-RACAH CASE (Lines 2248-2376):
--------------------------------------------------

		 case(1,2)  !Real and imaginary qRacah.  
                
		  if ( tc<S ) then
		  
		   if (q<1) then
		    p(1)=1
		    do i=2,j-k+2
		     x=paths(k+i-2,tc)+0.0
			 
			 p(i)=p(i-1)*(1-q**(N+tc-x))/(1-q**(N+S-x-1))
			 
			 if ( (-x-N+S)>0) then
			  p(i)=p(i)*(q**(S-tc)+kappasq*q**(-x-N+S))/(1+kappasq*q**(-x-N+S-1))
			 else
              p(i)=p(i)*(q**(x+N-tc)+kappasq)/(q**(x+N-S)+kappasq*q**(-1))
			 endif

			 if ( (2*x-tc-S)<0) then
			  p(i)=p(i)*(1+kappasq*q**(-2*x+tc-2+S))/(1+kappasq*q**(-2*x+tc+S))
			 else
			  p(i)=p(i)*(q**(2*x-tc-S)+kappasq*q**(-2))/(q**(2*x-tc-S)+kappasq)
			 endif
		    enddo
		   else  !q>1, tc<S

            x0=tc-1+N-log( (q**(tc-S)-1)/(1-q))/log(q)   !Here we find a point with maximal probability
			i0=k
			do while ((i0<j).AND.(paths(i0,tc)<x0))
			  i0=i0+1
			enddo
			
			i0=k
			
			p(i0-k+1)=1

			do i=i0-k+2,j-k+2
		     x=paths(k+i-2,tc)+0.0
		     p(i)=p(i-1)*(q**(-N-tc+x)-1)/(q**(-N-S+x)-q**(-1))
			 
			 if ( (-x-N+S)<0) then
			  p(i)=p(i)*(1+kappasq*q**(-x-N+tc))/(1+kappasq*q**(-x-N+S-1))
			 else
              p(i)=p(i)*(q**(x+N-S)+kappasq*q**(tc-S))/(q**(x+N-S)+kappasq*q**(-1))
			 endif
			 
			 if ( (2*x-tc-S)<0) then
			  p(i)=p(i)*(1+kappasq*q**(-2*x+tc-2+S))/(1+kappasq*q**(-2*x+tc+S))
			 else
			  p(i)=p(i)*(q**(2*x-tc-S)+kappasq*q**(-2))/(q**(2*x-tc-S)+kappasq)
			 endif
			enddo

            do i=2,i0-k+1
		     x=paths(i0+1-i,tc)+0.0
		     p(i0-k+2-i)=p(i0-k+2-i+1)*(q**(x-S-N)-1/q)/(q**(x-tc-N)-1)
			  
			 if ( (-x-N+S)<0) then  
			  p(i0-k+2-i)=p(i0-k+2-i)/(1+kappasq*q**(-x-N+tc))*(1+kappasq*q**(-x-N+S-1))
			 else
               p(i0-k+2-i)=p(i0-k+2-i)/(q**(x+N-S+1)+kappasq*q**(tc-S+1))*(q**(x+N-S+1)+kappasq)
			 endif

			 if ((2*x-tc-S)>0) then
			  p(i0-k+2-i)=p(i0-k+2-i)/(1+kappasq*q**(-2*x+tc-2+S))*(1+kappasq*q**(-2*x+tc+S))
             else
              p(i0-k+2-i)=p(i0-k+2-i)/(q**(2*x-tc-S)+kappasq*q**(-2))*(q**(2*x-tc-S)+kappasq)
			 endif

			enddo

		   endif
		
		  else        ! tc>S
		   p(j-k+2)=1
		   do i=1,j-k+1
		    x=paths(j+1-i,tc)+0.0
		    
			if (q<1) then 
			 p(j-k+2-i)=p(j-k+2-i+1)*(1-q**(N+S-x-1))/(1-q**(N+tc-x))
			 
			 if ( (-x-N+S)>0) then
			  p(j-k+2-i)=p(j-k+2-i)/(q**(S-tc)+kappasq*q**(-x-N+S))*(1+kappasq*q**(-x-N+S-1))
			 else
              p(j-k+2-i)=p(j-k+2-i)/(q**(x+N-tc)+kappasq)*(q**(x+N-S)+kappasq*q**(-1))
			 endif

			 if ((2*x-tc-S)<0) then
			  p(j-k+2-i)=p(j-k+2-i)/(1+kappasq*q**(-2*x+tc-2+S))*(1+kappasq*q**(-2*x+tc+S))
             else
              p(j-k+2-i)=p(j-k+2-i)/(q**(2*x-tc-S)+kappasq*q**(-2))*(q**(2*x-tc-S)+kappasq)
			 endif
			else   !q>1, tc>S

             p(j-k+2-i)=p(j-k+2-i+1)*(q**(x-S-N)-1/q)/(q**(x-tc-N)-1)
			 
			 if ( (-x-N+S)<0) then  
			  p(j-k+2-i)=p(j-k+2-i)/(1+kappasq*q**(-x-N+tc))*(1+kappasq*q**(-x-N+S-1))
			 else
               p(j-k+2-i)=p(j-k+2-i)/(q**(x+N-S)+kappasq*q**(tc-S))*(q**(x+N-S)+kappasq*q**(-1))
			 endif
			 
			 if ((2*x-tc-S)>0) then
			  p(j-k+2-i)=p(j-k+2-i)/(1+kappasq*q**(-2*x+tc-2+S))*(1+kappasq*q**(-2*x+tc+S))
             else
              p(j-k+2-i)=p(j-k+2-i)/(q**(2*x-tc-S)+kappasq*q**(-2))*(q**(2*x-tc-S)+kappasq)
			 endif

			endif

		   enddo
		  endif

========================================
NOTES AND MATHEMATICAL BACKGROUND
========================================

Key Variables:
- q: Deformation parameter (inverted in most modes: q=1/q1)
- kappasq: Represents -κ² where κ is the additional parameter
- Mode 1: κ is purely imaginary, so kappasq = -(imaginary_part)²
- Mode 2: κ = q^(log_q_value), so kappasq = -q^(2*log_q_value)
- N: Number of particles/paths
- T: Total time steps
- S: Height parameter
- tc: Current time coordinate
- x: Current path height coordinate

Mathematical Structure:
- The probability weights implement the q-Racah orthogonal polynomial measure
- Different cases handle q<1 vs q>1 and various boundary conditions
- The kappasq terms provide the additional parameter freedom in q-Racah polynomials
- Numerical stability is maintained through conditional checks and optimal starting points

This implementation allows simulation of random tilings distributed according to 
imaginary and real q-Racah polynomial measures, which correspond to specific 
statistical mechanical models of non-intersecting lattice paths and 3D Young diagrams.