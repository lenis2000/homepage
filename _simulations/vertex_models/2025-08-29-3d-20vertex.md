---
title: 3D Twenty-Vertex Model Simulation
model: vertex-models
author: 'Alexey Bufetov and Panagiotis Zografos (definition), Leonid Petrov (implementation)'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/vertex_models/2025-08-29-3d-20vertex.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/vertex_models/2025-08-29-3d-20vertex.cpp'
    txt: 'C++ code for the simulation'
---

<style>
  /* Interface container and responsive layout */
  .interface-container {
    display: grid;
    gap: 16px;
    padding: 16px;
    max-width: 1400px;
    margin: 0 auto;
  }

  /* Desktop layout */
  @media (min-width: 768px) {
    .interface-container {
      grid-template-columns: repeat(2, 1fr);
    }

    .control-group.full-width,
    .full-width {
      grid-column: 1 / -1;
    }
  }

  /* Mobile layout */
  @media (max-width: 767px) {
    .interface-container {
      grid-template-columns: 1fr;
    }
  }

  /* Visual grouping */
  .control-group {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
  }

  .control-group-title {
    font-size: 12px;
    font-weight: 600;
    color: #666;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  /* Canvas styling */
  #three-container {
    width: 100%;
    max-width: 1200px;
    height: 700px;
    margin: 0 auto;
    border: 1px solid #ccc;
    display: block;
  }

  /* Parameter grid layout */
  .parameters-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    margin-bottom: 12px;
    justify-content: center;
  }

  .param-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    padding: 8px;
  }

  .param-item label {
    font-weight: 600;
    font-size: 13px;
    color: #333;
    text-align: center;
    min-height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .param-item input {
    width: 80px;
    text-align: center;
  }

  .button-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  /* Consistent input styling */
  input[type="number"],
  input[type="range"],
  select {
    height: 36px;
    padding: 0 12px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    font-size: 14px;
    transition: border-color 0.2s;
  }

  input[type="range"] {
    padding: 0;
  }

  input[type="number"]:focus,
  select:focus {
    outline: none;
    border-color: #4CAF50;
  }

  /* Button improvements */
  button {
    height: 36px;
    padding: 0 16px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    background: white;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }

  button:hover {
    background: #f5f5f5;
    border-color: #999;
  }

  button:active {
    background: #e0e0e0;
  }

  /* Primary action buttons */
  button.primary {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
  }

  button.primary:hover {
    background: #45a049;
  }

  /* Progress bar */
  .progress-container {
    width: 100%;
    height: 20px;
    background: #f0f0f0;
    border-radius: 10px;
    overflow: hidden;
    margin: 10px 0;
    display: none;
  }

  .progress-bar {
    height: 100%;
    background: #4CAF50;
    width: 0%;
    transition: width 0.3s ease;
  }

  /* T-slider styling */
  .slider-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 10px 0;
  }

  .slider-container label {
    font-weight: 500;
  }

  .slider-container input[type="range"] {
    flex: 1;
  }

  .slider-value {
    min-width: 40px;
    text-align: center;
    font-weight: 600;
  }

  /* Legend */
  .legend {
    display: flex;
    gap: 20px;
    margin: 10px 0;
    padding: 10px;
    background: #fafafa;
    border-radius: 8px;
    flex-wrap: wrap;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .arrow-icon {
    width: 20px;
    height: 20px;
  }

  /* Mobile optimizations */
  @media (max-width: 767px) {
    .parameters-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }

    .param-item label {
      font-size: 12px;
    }

    .param-item input {
      width: 70px;
    }

    #three-container {
      height: 400px;
    }
  }

  /* Very small screens */
  @media (max-width: 480px) {
    .parameters-grid {
      grid-template-columns: 1fr;
    }

    .param-item input {
      width: 100px;
    }
  }

  /* Vertex configuration display */
  .vertex-config-display {
    font-family: monospace;
    font-size: 11px;
    background: #f8f8f8;
    padding: 8px;
    border-radius: 4px;
    margin-top: 10px;
    max-height: 200px;
    overflow-y: auto;
  }

  /* Details styling */
  details {
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 16px;
  }

  details > summary {
    padding: 12px 16px;
    background: #f5f5f5;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
  }

  details[open] > summary {
    border-bottom: 1px solid #e0e0e0;
  }

  details > .content {
    padding: 16px;
    background: white;
  }
</style>

<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>
<script src="/js/2025-08-29-3d-20vertex.js"></script>

<details id="about-simulation-details">
<summary>About this simulation</summary>
<div class="content">

This simulation demonstrates the <strong>twenty-vertex model</strong> introduced by Bufetov and Zografos (work in progress).
The model consists of a 3D lattice where arrows are placed on edges, always pointing in positive coordinate directions.
Each vertex has 8 possible incoming arrow configurations and 8 possible outgoing configurations, with conservation of arrow count through each vertex.

<br><br>
The model has 20 vertex types: 2 deterministic (000→000 and 111→111) and 18 stochastic configurations with tuneable weights.
The sampling proceeds in time slices where t = x + y + z, with boundary conditions: empty in xz and yz planes, full in xy plane.

</div>
</details>

---

<!-- Controls for the simulation -->
<div class="interface-container">

<!-- Main Parameters -->
<div class="control-group full-width">
  <div class="control-group-title">Model Parameters</div>
  <div style="display: flex; align-items: center; justify-content: center; gap: 16px; margin-bottom: 16px;">
    <label for="N" style="font-weight: 600; color: #333;">N:</label>
    <input type="number" id="N" value="10" min="2" max="300" style="width: 80px;">
    <button id="sample" class="primary">Sample Configuration</button>
  </div>
  <div class="progress-container" id="progress-container">
    <div class="progress-bar" id="progress-bar"></div>
  </div>
</div>

<!-- Vertex Weights -->
<details class="control-group full-width">
  <summary><div class="control-group-title">Vertex Weights (12 Free Parameters)</div></summary>
  <div class="content">
    <div class="parameters-grid">
      <div class="param-item">
        <label for="w0">100→100:</label>
        <input type="number" id="w0" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w1">100→010:</label>
        <input type="number" id="w1" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w2">010→100:</label>
        <input type="number" id="w2" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w3">010→010:</label>
        <input type="number" id="w3" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w4">001→100:</label>
        <input type="number" id="w4" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w5">001→010:</label>
        <input type="number" id="w5" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w6">110→110:</label>
        <input type="number" id="w6" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w7">110→101:</label>
        <input type="number" id="w7" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w8">101→110:</label>
        <input type="number" id="w8" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w9">101→101:</label>
        <input type="number" id="w9" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w10">011→110:</label>
        <input type="number" id="w10" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w11">011→101:</label>
        <input type="number" id="w11" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
    </div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
      Note: These 12 parameters, along with sum-to-one constraints, determine all 18 stochastic vertex weights.
      The notation abc→def means incoming arrows from directions (x,y,z) and outgoing to (x,y,z), where 1=arrow present.
    </div>
  </div>
</details>

<!-- Visualization Controls -->
<div class="control-group full-width">
  <div class="control-group-title">Visualization Controls</div>
  <div class="button-row">
    <button id="reset-camera">Reset Camera</button>
  </div>
  <div class="legend">
    <div class="legend-item">
      <svg class="arrow-icon" viewBox="0 0 20 20">
        <line x1="5" y1="10" x2="15" y2="10" stroke="red" stroke-width="2" marker-end="url(#arrowhead-x)"/>
        <defs>
          <marker id="arrowhead-x" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="red"/>
          </marker>
        </defs>
      </svg>
      <span>X-direction</span>
    </div>
    <div class="legend-item">
      <svg class="arrow-icon" viewBox="0 0 20 20">
        <line x1="10" y1="15" x2="10" y2="5" stroke="green" stroke-width="2" marker-end="url(#arrowhead-y)"/>
        <defs>
          <marker id="arrowhead-y" markerWidth="7" markerHeight="10" refX="3.5" refY="1" orient="auto">
            <polygon points="0 10, 3.5 0, 7 10" fill="green"/>
          </marker>
        </defs>
      </svg>
      <span>Y-direction</span>
    </div>
    <div class="legend-item">
      <svg class="arrow-icon" viewBox="0 0 20 20">
        <line x1="5" y1="15" x2="15" y2="5" stroke="blue" stroke-width="2" marker-end="url(#arrowhead-z)"/>
        <defs>
          <marker id="arrowhead-z" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
            <polygon points="0 7, 10 3, 7 10" fill="blue"/>
          </marker>
        </defs>
      </svg>
      <span>Z-direction</span>
    </div>
  </div>
</div>

<!-- Analytical Visualizations -->
<details class="control-group full-width">
  <summary><div class="control-group-title">Orthographic Density Projections</div></summary>
  <div class="content" style="display:grid;gap:12px">
    <div style="font-size:12px;color:#666;margin-bottom:8px">
      Arrow directions mapped to RGB channels: X→Red, Y→Green, Z→Blue. Shows flow density accumulation when collapsing one spatial dimension.
    </div>
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:16px">
      <div>
        <div style="font-weight:600;margin-bottom:6px;text-align:center">XY Plane (sum over Z)</div>
        <canvas id="proj-xy" width="256" height="256" style="width:100%;max-width:256px;border:1px solid #ccc;display:block;margin:0 auto"></canvas>
      </div>
      <div>
        <div style="font-weight:600;margin-bottom:6px;text-align:center">XZ Plane (sum over Y)</div>
        <canvas id="proj-xz" width="256" height="256" style="width:100%;max-width:256px;border:1px solid #ccc;display:block;margin:0 auto"></canvas>
      </div>
      <div>
        <div style="font-weight:600;margin-bottom:6px;text-align:center">YZ Plane (sum over X)</div>
        <canvas id="proj-yz" width="256" height="256" style="width:100%;max-width:256px;border:1px solid #ccc;display:block;margin:0 auto"></canvas>
      </div>
    </div>
  </div>
</details>

<details class="control-group full-width">
  <summary><div class="control-group-title">Time-Slice Activity</div></summary>
  <div class="content">
    <div style="font-size:12px;color:#666;margin-bottom:8px">
      Arrow counts by direction over time slices t = x + y + z. Shows temporal dynamics and growth fronts.
    </div>
    <canvas id="ts-activity" width="800" height="180" style="width:100%;max-width:800px;border:1px solid #ccc;display:block;margin:0 auto"></canvas>
  </div>
</details>

<details class="control-group full-width">
  <summary><div class="control-group-title">Height Map from Cube Occupancy</div></summary>
  <div class="content">
    <div style="font-size:12px;color:#666;margin-bottom:8px">
      Grayscale height map H(x,y) = Σ_z filled_cubes(x,y,z) with optional contour lines showing bulk geometry structure.
    </div>
    <canvas id="heightmap" width="512" height="512" style="width:100%;max-width:512px;border:1px solid #ccc;display:block;margin:0 auto"></canvas>
  </div>
</details>

<details class="control-group full-width">
  <summary><div class="control-group-title">Cross-Section Slicers</div></summary>
  <div class="content">
    <div style="font-size:12px;color:#666;margin-bottom:12px">
      View 2D cross-sections of the 3D vertex model at constant coordinate planes. Arrows shown as colored dots: Red (X-direction), Green (Y-direction), Blue (Z-direction).
    </div>
    
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:16px">
      
      <!-- X-slice (YZ plane) -->
      <div>
        <div style="font-weight:600;margin-bottom:8px;text-align:center">X = <span id="x-slice-value">5</span> (YZ plane)</div>
        <div class="slider-container">
          <label for="x-slice-slider">X:</label>
          <input type="range" id="x-slice-slider" min="0" max="10" value="5" style="flex:1">
        </div>
        <canvas id="slice-x" width="256" height="256" style="width:100%;max-width:256px;border:1px solid #ccc;display:block;margin:0 auto"></canvas>
      </div>
      
      <!-- Y-slice (XZ plane) -->
      <div>
        <div style="font-weight:600;margin-bottom:8px;text-align:center">Y = <span id="y-slice-value">5</span> (XZ plane)</div>
        <div class="slider-container">
          <label for="y-slice-slider">Y:</label>
          <input type="range" id="y-slice-slider" min="0" max="10" value="5" style="flex:1">
        </div>
        <canvas id="slice-y" width="256" height="256" style="width:100%;max-width:256px;border:1px solid #ccc;display:block;margin:0 auto"></canvas>
      </div>
      
      <!-- Z-slice (XY plane) -->
      <div>
        <div style="font-weight:600;margin-bottom:8px;text-align:center">Z = <span id="z-slice-value">5</span> (XY plane)</div>
        <div class="slider-container">
          <label for="z-slice-slider">Z:</label>
          <input type="range" id="z-slice-slider" min="0" max="10" value="5" style="flex:1">
        </div>
        <canvas id="slice-z" width="256" height="256" style="width:100%;max-width:256px;border:1px solid #ccc;display:block;margin:0 auto"></canvas>
      </div>
      
    </div>
  </div>
</details>

</div> <!-- End interface-container -->

<!-- 3D Visualization -->
<div id="three-container">
  <canvas id="three-canvas"></canvas>
</div>

<script>
// Check if Module is defined before setting onRuntimeInitialized
if (typeof Module === 'undefined') {
    console.error('Module is not defined. Make sure the WASM JavaScript file is loaded correctly.');
    window.Module = { onRuntimeInitialized: function() {} };
}

Module.onRuntimeInitialized = async function() {
    // WASM Interface Class
    class WASMInterface {
        constructor() {
            this.ready = false;
            this.N = 10;
            this.weights = new Float64Array(12);
            this.weights.fill(1.0/3.0);
            this.arrows = new Uint32Array(); // Will hold packed arrow data
            this.filledCubes = new Uint32Array(); // Will hold packed cube data
        }

        async initialize() {
            if (typeof Module === 'undefined') {
                throw new Error('Module is not defined. WASM JavaScript file may not be loaded.');
            }
            if (typeof Module.cwrap !== 'function') {
                throw new Error('Module.cwrap is not a function. WASM module may not be properly initialized.');
            }

            // Wrap exported functions
            this.initializeModel = Module.cwrap('initializeModel', 'number', ['number', 'number'], {async: true});
            this.sampleConfiguration = Module.cwrap('sampleConfiguration', 'number', [], {async: true});
            this.exportArrows = Module.cwrap('exportArrows', 'number', [], {async: true});
            this.exportFilledCubes = Module.cwrap('exportFilledCubes', 'number', [], {async: true});
            this.updateWeights = Module.cwrap('updateWeights', 'number', ['number'], {async: true});
            this.freeString = Module.cwrap('freeString', null, ['number']);
            this.getProgress = Module.cwrap('getProgress', 'number', []);

            this.ready = true;
        }

        async initModel(N, weights) {
            if (!this.ready) throw new Error('WASM not ready');

            this.N = N;
            this.weights = weights;

            try {
                // Check if Module._malloc and HEAPF64 are available
                if (typeof Module._malloc !== 'function' || typeof Module.HEAPF64 === 'undefined') {
                    // Use alternative allocation method via ccall
                    const ptr = await Module.ccall('initializeModel', 'number',
                        ['number', 'array'],
                        [N, weights],
                        {async: true}
                    );

                    if (!ptr) {
                        throw new Error('initializeModel returned null pointer');
                    }
                    const jsonStr = Module.UTF8ToString(ptr);
                    this.freeString(ptr);

                    const result = JSON.parse(jsonStr);
                    if (result.error) {
                        throw new Error(result.error);
                    }
                    return result;
                } else {
                    // Allocate memory for weights array
                    const weightsPtr = Module._malloc(12 * 8); // 12 doubles
                    const heap64 = new Float64Array(Module.HEAPF64.buffer, weightsPtr, 12);
                    heap64.set(weights);

                    const ptr = await this.initializeModel(N, weightsPtr);
                    Module._free(weightsPtr);

                    if (!ptr) {
                        throw new Error('initializeModel returned null pointer');
                    }
                    const jsonStr = Module.UTF8ToString(ptr);
                    this.freeString(ptr);

                    const result = JSON.parse(jsonStr);
                    if (result.error) {
                        throw new Error(result.error);
                    }

                    return result;
                }
            } catch (error) {
                throw new Error(`Initialization failed: ${error.message}`);
            }
        }

        async sample() {
            if (!this.ready) throw new Error('WASM not ready');

            try {
                const ptr = await this.sampleConfiguration();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                // Get arrow and cube data
                await this.refreshArrows();
                await this.refreshFilledCubes(); // Also fetch cube data
                return result;
            } catch (error) {
                throw new Error(`Sampling failed: ${error.message}`);
            }
        }

        async refreshArrows() {
            try {
                const ptr = await this.exportArrows();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.ptr && result.count > 0) {
                    // Create a view into the WASM heap for the arrow data
                    this.arrows = new Uint32Array(Module.HEAPU32.buffer, result.ptr, result.count);
                } else {
                    this.arrows = new Uint32Array(); // Empty
                }
            } catch (error) {
                console.error('Failed to refresh arrows:', error);
                this.arrows = new Uint32Array();
            }
        }

        async refreshFilledCubes() {
            try {
                const ptr = await this.exportFilledCubes();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.ptr && result.count > 0) {
                    this.filledCubes = new Uint32Array(Module.HEAPU32.buffer, result.ptr, result.count);
                } else {
                    this.filledCubes = new Uint32Array();
                }
            } catch (error) {
                console.error('Failed to refresh filled cubes:', error);
                this.filledCubes = new Uint32Array();
            }
        }

        async updateWeightsWasm(weights) {
            if (!this.ready) throw new Error('WASM not ready');

            this.weights = weights;

            try {
                // Check if Module._malloc and HEAPF64 are available
                if (typeof Module._malloc !== 'function' || typeof Module.HEAPF64 === 'undefined') {
                    // Use alternative allocation method via ccall
                    const ptr = await Module.ccall('updateWeights', 'number',
                        ['array'],
                        [weights],
                        {async: true}
                    );

                    const jsonStr = Module.UTF8ToString(ptr);
                    this.freeString(ptr);

                    const result = JSON.parse(jsonStr);
                    if (result.error) {
                        throw new Error(result.error);
                    }
                    return result;
                } else {
                    // Allocate memory for weights array
                    const weightsPtr = Module._malloc(12 * 8); // 12 doubles
                    const heap64 = new Float64Array(Module.HEAPF64.buffer, weightsPtr, 12);
                    heap64.set(weights);

                    const ptr = await this.updateWeights(weightsPtr);
                    Module._free(weightsPtr);

                    const jsonStr = Module.UTF8ToString(ptr);
                    this.freeString(ptr);

                    const result = JSON.parse(jsonStr);
                    if (result.error) {
                        throw new Error(result.error);
                    }

                    return result;
                }
            } catch (error) {
                throw new Error(`Weight update failed: ${error.message}`);
            }
        }

        getArrows() {
            return this.arrows; // This is now a Uint32Array
        }

        getFilledCubes() {
            return this.filledCubes; // Add this new getter
        }
    }


    // 3D Visualizer
    class Visualizer3D {
        constructor(container) {
            this.container = container;
            this.N = 10;

            // Three.js setup
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0xffffff);

            // Camera
            this.camera = new THREE.PerspectiveCamera(
                45,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            this.camera.position.set(30, 30, 30);
            this.camera.lookAt(0, 0, 0);

            // Renderer
            this.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('three-canvas'),
                antialias: true
            });
            this.renderer.setSize(container.clientWidth, container.clientHeight);

            // Controls
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 10, 10);
            this.scene.add(directionalLight);

            // Arrow group
            this.arrowGroup = new THREE.Group();
            this.scene.add(this.arrowGroup);

            // Grid helper
            this.gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0xcccccc);
            this.scene.add(this.gridHelper);

            // Handle window resize
            window.addEventListener('resize', () => this.handleResize());

            // Start animation loop
            this.animate();
        }

        handleResize() {
            const width = this.container.clientWidth;
            const height = this.container.clientHeight;

            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();

            this.renderer.setSize(width, height);
        }

        draw(arrows, filledCubes, N) {
            this.N = N;

            // Clear existing arrows
            while(this.arrowGroup.children.length > 0) {
                const child = this.arrowGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                this.arrowGroup.remove(child);
            }

            // Create line geometry for all arrows
            const vertices = [];
            const colors = [];

            // Add lines
            for (const packedArrow of arrows) {
                // Unpack data
                const x = (packedArrow >> 22) & 0x3FF;
                const y = (packedArrow >> 12) & 0x3FF;
                const z = (packedArrow >> 2) & 0x3FF;
                const dir = packedArrow & 0x3;

                let startPos = new THREE.Vector3(x, z, y); // Note y/z swap for THREE.js coordinate system
                let endPos = startPos.clone();

                if (dir === 0) { // X direction
                    endPos.x += 1;
                } else if (dir === 1) { // Y direction
                    endPos.z += 1;
                } else { // Z direction
                    endPos.y += 1;
                }

                // Add vertices
                vertices.push(startPos.x, startPos.y, startPos.z);
                vertices.push(endPos.x, endPos.y, endPos.z);

                // Add colors for both vertices
                let color = new THREE.Color();
                if (dir === 0) {
                    color.setRGB(1, 0, 0); // Red for X
                } else if (dir === 1) {
                    color.setRGB(0, 1, 0); // Green for Y
                } else {
                    color.setRGB(0, 0, 1); // Blue for Z
                }

                colors.push(color.r, color.g, color.b);
                colors.push(color.r, color.g, color.b);
            }

            // Create geometry for lines
            const lineGeometry = new THREE.BufferGeometry();
            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            lineGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // Create material for lines
            const lineMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                linewidth: 2
            });

            // Create line segments
            const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
            this.arrowGroup.add(lines);

            // Add cubes from C++ detection
            this.addCubes(filledCubes);

            // Center the view
            const center = N / 2;
            this.arrowGroup.position.set(-center, 0, -center);
            this.controls.target.set(0, center/2, 0);
            this.controls.update();
        }

        addCubes(filledCubes) {
            if (filledCubes.length === 0) return;

            // Use InstancedMesh for performance with many cubes
            const cubeGeometry = new THREE.BoxGeometry(1.0, 1.0, 1.0);
            const cubeMaterial = new THREE.MeshPhongMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.3
            });
            const cubeMesh = new THREE.InstancedMesh(cubeGeometry, cubeMaterial, filledCubes.length);

            const matrix = new THREE.Matrix4();
            for (let i = 0; i < filledCubes.length; i++) {
                const packedCube = filledCubes[i];
                // Unpack: x(10 bits), y(10 bits), z(10 bits)
                const x = (packedCube >> 20) & 0x3FF;
                const y = (packedCube >> 10) & 0x3FF;
                const z = packedCube & 0x3FF;

                // Position cube at center of the 1x1x1 cell
                matrix.setPosition(x + 0.5, z + 0.5, y + 0.5); // y/z swap
                cubeMesh.setMatrixAt(i, matrix);
            }

            this.arrowGroup.add(cubeMesh);
        }

        animate() {
            requestAnimationFrame(() => this.animate());
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }

        resetCamera() {
            this.camera.position.set(30, 30, 30);
            this.controls.target.set(0, this.N/4, 0);
            this.controls.update();
        }
    }

    // Analytical Visualization Functions
    function buildProjections(arrows, N) {
        // Each projection keeps per-direction counts for color channels
        const mkGrid = () => ({
            r: new Float32Array(N * N), // X-dir
            g: new Float32Array(N * N), // Y-dir
            b: new Float32Array(N * N), // Z-dir
            max: 0
        });

        const xy = mkGrid(), xz = mkGrid(), yz = mkGrid();

        for (let i = 0; i < arrows.length; i++) {
            const packed = arrows[i] >>> 0;
            const x = (packed >> 22) & 0x3FF;
            const y = (packed >> 12) & 0x3FF;
            const z = (packed >> 2) & 0x3FF;
            const dir = packed & 0x3;

            // index helpers
            const idxXY = x * N + y;
            const idxXZ = x * N + z;
            const idxYZ = y * N + z;

            // increment per direction
            const inc = (grid, idx) => {
                if (dir === 0) grid.r[idx] += 1;   // X→R
                else if (dir === 1) grid.g[idx] += 1; // Y→G
                else grid.b[idx] += 1;             // Z→B
                // track max across channels to normalize later
                const v = grid.r[idx] + grid.g[idx] + grid.b[idx];
                if (v > grid.max) grid.max = v;
            };

            inc(xy, idxXY);
            inc(xz, idxXZ);
            inc(yz, idxYZ);
        }

        return { xy, xz, yz };
    }

    function drawRGBProjection(canvas, grid, N) {
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const W = canvas.width, H = canvas.height;
        const img = ctx.createImageData(W, H);
        const scaleX = W / N, scaleY = H / N;
        const clamp255 = v => Math.max(0, Math.min(255, v|0));

        // Per-channel normalization: balance by each channel's own max for color purity
        let maxR = 0, maxG = 0, maxB = 0;
        for (let i = 0; i < N*N; i++) {
            if (grid.r[i] > maxR) maxR = grid.r[i];
            if (grid.g[i] > maxG) maxG = grid.g[i];
            if (grid.b[i] > maxB) maxB = grid.b[i];
        }
        const eps = 1e-9;

        // Paint each cell as a block of pixels
        for (let ix = 0; ix < N; ix++) {
            for (let iy = 0; iy < N; iy++) {
                const idx = ix * N + iy;
                const R = clamp255(255 * (grid.r[idx] / (maxR + eps)));
                const G = clamp255(255 * (grid.g[idx] / (maxG + eps)));
                const B = clamp255(255 * (grid.b[idx] / (maxB + eps)));

                const x0 = Math.floor(ix * scaleX), x1 = Math.floor((ix+1) * scaleX);
                const y0 = Math.floor(iy * scaleY), y1 = Math.floor((iy+1) * scaleY);
                for (let x = x0; x < x1; x++) {
                    for (let y = y0; y < y1; y++) {
                        const p = (y * W + x) * 4;
                        img.data[p+0] = R;
                        img.data[p+1] = G;
                        img.data[p+2] = B;
                        img.data[p+3] = 255;
                    }
                }
            }
        }
        ctx.putImageData(img, 0, 0);
    }

    function buildTimeActivity(arrows, N) {
        const maxT = 3 * (N - 1);
        const r = new Uint32Array(maxT + 1);
        const g = new Uint32Array(maxT + 1);
        const b = new Uint32Array(maxT + 1);
        for (let i = 0; i < arrows.length; i++) {
            const packed = arrows[i] >>> 0;
            const x = (packed >> 22) & 0x3FF;
            const y = (packed >> 12) & 0x3FF;
            const z = (packed >> 2) & 0x3FF;
            const dir = packed & 0x3;
            const t = x + y + z;
            if (dir === 0) r[t]++; else if (dir === 1) g[t]++; else b[t]++;
        }
        return { r, g, b, maxT };
    }

    function drawTimeActivity(canvas, series) {
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        const { r, g, b, maxT } = series;
        const maxVal = Math.max(1, ...r, ...g, ...b);
        const padL = 30, padR = 10, padT = 10, padB = 20;
        const plotW = W - padL - padR, plotH = H - padT - padB;

        // axes
        ctx.strokeStyle = '#999'; ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padL, padT); ctx.lineTo(padL, padT + plotH); ctx.lineTo(padL + plotW, padT + plotH);
        ctx.stroke();

        const drawLine = (arr, stroke) => {
            ctx.strokeStyle = stroke; ctx.lineWidth = 1.5; ctx.beginPath();
            for (let t = 0; t <= maxT; t++) {
                const x = padL + (t / maxT) * plotW;
                const y = padT + plotH - (arr[t] / maxVal) * plotH;
                if (t === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        };

        drawLine(r, 'red');
        drawLine(g, 'green');
        drawLine(b, 'blue');

        // Add axis labels
        ctx.fillStyle = '#666'; ctx.font = '12px sans-serif';
        ctx.fillText('Time slice t', W/2 - 30, H - 5);
        ctx.save();
        ctx.translate(15, H/2);
        ctx.rotate(-Math.PI/2);
        ctx.fillText('Arrow count', -30, 0);
        ctx.restore();
    }

    function buildHeightMap(filledCubes, N) {
        const H = new Uint16Array(N * N); // (x,y) grid
        for (let i = 0; i < filledCubes.length; i++) {
            const packed = filledCubes[i] >>> 0;
            const x = (packed >> 20) & 0x3FF;
            const y = (packed >> 10) & 0x3FF;
            // z is ignored; we count
            H[x * N + y] += 1;
        }
        let maxH = 0;
        for (let i = 0; i < H.length; i++) if (H[i] > maxH) maxH = H[i];
        return { H, maxH };
    }

    function drawHeightMap(canvas, map, N, withContours=true) {
        const { H, maxH } = map;
        const ctx = canvas.getContext('2d');
        const W = canvas.width, Hpx = canvas.height;
        const img = ctx.createImageData(W, Hpx);
        const sx = W / N, sy = Hpx / N;
        const eps = 1e-9;

        // grayscale cells
        for (let ix = 0; ix < N; ix++) {
            for (let iy = 0; iy < N; iy++) {
                const v = H[ix * N + iy] / (maxH + eps);
                const g = Math.floor(255 * v);
                const x0 = Math.floor(ix * sx), x1 = Math.floor((ix+1)*sx);
                const y0 = Math.floor(iy * sy), y1 = Math.floor((iy+1)*sy);
                for (let x = x0; x < x1; x++) {
                    for (let y = y0; y < y1; y++) {
                        const p = (y * W + x) * 4;
                        img.data[p+0] = img.data[p+1] = img.data[p+2] = g;
                        img.data[p+3] = 255;
                    }
                }
            }
        }
        ctx.putImageData(img, 0, 0);

        // optional light contouring (iso every ~10% of max)
        if (withContours && maxH >= 3) {
            ctx.strokeStyle = 'rgba(0,0,0,0.25)';
            ctx.lineWidth = 1;
            const levels = [];
            for (let k = 1; k <= 9; k++) levels.push(Math.max(1, Math.round((k/10)*maxH)));
            const cellW = sx, cellH = sy;

            // simple contour: draw borders where neighboring cells cross a level
            levels.forEach(L => {
                for (let ix = 0; ix < N; ix++) {
                    for (let iy = 0; iy < N; iy++) {
                        const v = H[ix*N+iy];
                        if (ix+1 < N) {
                            const v2 = H[(ix+1)*N+iy];
                            if ((v < L && v2 >= L) || (v >= L && v2 < L)) {
                                const x = Math.floor((ix+1)*cellW), y = Math.floor(iy*cellH), y2 = Math.floor((iy+1)*cellH);
                                ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y2); ctx.stroke();
                            }
                        }
                        if (iy+1 < N) {
                            const v2 = H[ix*N+(iy+1)];
                            if ((v < L && v2 >= L) || (v >= L && v2 < L)) {
                                const x = Math.floor(ix*cellW), x2 = Math.floor((ix+1)*cellW), y = Math.floor((iy+1)*cellH);
                                ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x2, y); ctx.stroke();
                            }
                        }
                    }
                }
            });
        }
    }

    // Cross-section slice functions
    function buildSliceData(arrows, filledCubes, N, axis, sliceIndex) {
        const sliceArrows = [];
        const sliceCubes = [];
        
        for (let i = 0; i < arrows.length; i++) {
            const packed = arrows[i] >>> 0;
            const x = (packed >> 22) & 0x3FF;
            const y = (packed >> 12) & 0x3FF;
            const z = (packed >> 2) & 0x3FF;
            const dir = packed & 0x3;
            
            let includeArrow = false;
            if (axis === 'x' && x === sliceIndex) includeArrow = true;
            else if (axis === 'y' && y === sliceIndex) includeArrow = true;
            else if (axis === 'z' && z === sliceIndex) includeArrow = true;
            
            if (includeArrow) {
                sliceArrows.push({ x, y, z, dir });
            }
        }
        
        for (let i = 0; i < filledCubes.length; i++) {
            const packed = filledCubes[i] >>> 0;
            const x = (packed >> 20) & 0x3FF;
            const y = (packed >> 10) & 0x3FF;
            const z = packed & 0x3FF;
            
            let includeCube = false;
            if (axis === 'x' && x === sliceIndex) includeCube = true;
            else if (axis === 'y' && y === sliceIndex) includeCube = true;
            else if (axis === 'z' && z === sliceIndex) includeCube = true;
            
            if (includeCube) {
                sliceCubes.push({ x, y, z });
            }
        }
        
        return { arrows: sliceArrows, cubes: sliceCubes };
    }
    
    function drawSlice(canvas, sliceData, N, axis, sliceIndex) {
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);
        
        // Background
        ctx.fillStyle = '#f8f8f8';
        ctx.fillRect(0, 0, W, H);
        
        // Grid
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        const cellW = W / N;
        const cellH = H / N;
        
        for (let i = 0; i <= N; i++) {
            ctx.beginPath();
            ctx.moveTo(i * cellW, 0);
            ctx.lineTo(i * cellW, H);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, i * cellH);
            ctx.lineTo(W, i * cellH);
            ctx.stroke();
        }
        
        // Draw cubes as light gray backgrounds
        ctx.fillStyle = 'rgba(200, 200, 0, 0.3)';
        for (const cube of sliceData.cubes) {
            let px, py;
            if (axis === 'x') {
                px = cube.y * cellW;
                py = (N - 1 - cube.z) * cellH; // Flip Z for display
            } else if (axis === 'y') {
                px = cube.x * cellW;
                py = (N - 1 - cube.z) * cellH; // Flip Z for display
            } else { // axis === 'z'
                px = cube.x * cellW;
                py = (N - 1 - cube.y) * cellH; // Flip Y for display
            }
            
            ctx.fillRect(px, py, cellW, cellH);
        }
        
        // Draw arrows as colored dots
        for (const arrow of sliceData.arrows) {
            let px, py;
            let color;
            
            // Position based on slice axis
            if (axis === 'x') {
                px = (arrow.y + 0.5) * cellW;
                py = (N - 1 - arrow.z + 0.5) * cellH; // Flip Z for display
            } else if (axis === 'y') {
                px = (arrow.x + 0.5) * cellW;
                py = (N - 1 - arrow.z + 0.5) * cellH; // Flip Z for display
            } else { // axis === 'z'
                px = (arrow.x + 0.5) * cellW;
                py = (N - 1 - arrow.y + 0.5) * cellH; // Flip Y for display
            }
            
            // Color based on direction
            if (arrow.dir === 0) color = 'red';      // X direction
            else if (arrow.dir === 1) color = 'green'; // Y direction
            else color = 'blue';                      // Z direction
            
            // Draw dot
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(px, py, 4, 0, 2 * Math.PI);
            ctx.fill();
            
            // Add white border for better visibility
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // Add axis labels
        ctx.fillStyle = '#333';
        ctx.font = '12px sans-serif';
        
        if (axis === 'x') {
            ctx.fillText('Y →', W - 20, H - 5);
            ctx.save();
            ctx.translate(15, 15);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('← Z', 0, 0);
            ctx.restore();
        } else if (axis === 'y') {
            ctx.fillText('X →', W - 20, H - 5);
            ctx.save();
            ctx.translate(15, 15);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('← Z', 0, 0);
            ctx.restore();
        } else { // axis === 'z'
            ctx.fillText('X →', W - 20, H - 5);
            ctx.save();
            ctx.translate(15, 15);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('← Y', 0, 0);
            ctx.restore();
        }
    }

    // Update analytical visualizations
    function updateAnalyticalViews(arrows, filledCubes, N) {
        try {
            // Orthographic projections
            const { xy, xz, yz } = buildProjections(arrows, N);
            drawRGBProjection(document.getElementById('proj-xy'), xy, N);
            drawRGBProjection(document.getElementById('proj-xz'), xz, N);
            drawRGBProjection(document.getElementById('proj-yz'), yz, N);

            // Time-slice activity
            const ts = buildTimeActivity(arrows, N);
            drawTimeActivity(document.getElementById('ts-activity'), ts);

            // Height map
            const hm = buildHeightMap(filledCubes, N);
            drawHeightMap(document.getElementById('heightmap'), hm, N);
        } catch (error) {
            console.error('Failed to update analytical views:', error);
        }
    }
    
    // Update slice visualizations
    function updateSlices(arrows, filledCubes, N) {
        try {
            const xSlice = parseInt(document.getElementById('x-slice-slider').value);
            const ySlice = parseInt(document.getElementById('y-slice-slider').value);
            const zSlice = parseInt(document.getElementById('z-slice-slider').value);
            
            // Update X slice (YZ plane)
            const xSliceData = buildSliceData(arrows, filledCubes, N, 'x', xSlice);
            drawSlice(document.getElementById('slice-x'), xSliceData, N, 'x', xSlice);
            
            // Update Y slice (XZ plane)
            const ySliceData = buildSliceData(arrows, filledCubes, N, 'y', ySlice);
            drawSlice(document.getElementById('slice-y'), ySliceData, N, 'y', ySlice);
            
            // Update Z slice (XY plane)
            const zSliceData = buildSliceData(arrows, filledCubes, N, 'z', zSlice);
            drawSlice(document.getElementById('slice-z'), zSliceData, N, 'z', zSlice);
        } catch (error) {
            console.error('Failed to update slices:', error);
        }
    }

    // Main application
    const wasmInterface = new WASMInterface();
    const viz3D = new Visualizer3D(document.getElementById('three-container'));

    let progressInterval = null;

    // Initialize WASM
    async function init() {
        try {
            await wasmInterface.initialize();
            console.log('WASM initialized successfully');

            // Initialize with default parameters
            const weights = new Float64Array(12);
            weights.fill(1.0/3.0);
            await wasmInterface.initModel(10, weights);

            // Initial sample
            await sampleAndDraw();
        } catch (error) {
            console.error('Failed to initialize WASM:', error);
            alert('Failed to initialize simulation. Please refresh the page.');
        }
    }

    // Sample and draw
    async function sampleAndDraw() {
        try {
            // Show progress bar
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';

            // Start progress monitoring
            progressInterval = setInterval(() => {
                const progress = wasmInterface.getProgress();
                progressBar.style.width = progress + '%';
            }, 100);

            // Sample configuration
            await wasmInterface.sample();

            // Stop progress monitoring
            clearInterval(progressInterval);
            progressBar.style.width = '100%';
            setTimeout(() => {
                progressContainer.style.display = 'none';
            }, 500);

            // Draw
            const arrows = wasmInterface.getArrows();
            const filledCubes = wasmInterface.getFilledCubes(); // Get cube data
            const N = wasmInterface.N;

            viz3D.draw(arrows, filledCubes, N); // Always use 3D view

            // Update analytical visualizations
            updateAnalyticalViews(arrows, filledCubes, N);
            
            // Update slice visualizations
            updateSlices(arrows, filledCubes, N);
        } catch (error) {
            console.error('Sampling failed:', error);
            alert('Sampling failed: ' + error.message);
            clearInterval(progressInterval);
            document.getElementById('progress-container').style.display = 'none';
        }
    }

    // Event handlers
    document.getElementById('sample').addEventListener('click', async () => {
        // Get current parameters
        const N = parseInt(document.getElementById('N').value);
        const weights = new Float64Array(12);
        for (let i = 0; i < 12; i++) {
            weights[i] = parseFloat(document.getElementById('w' + i).value);
        }


        try {
            // Update slider ranges if N changed
            updateSliderRanges(N);
            
            // Reinitialize with current parameters
            await wasmInterface.initModel(N, weights);
            // Sample new configuration
            await sampleAndDraw();
        } catch (error) {
            console.error('Sampling failed:', error);
            alert('Sampling failed: ' + error.message);
        }
    });


    document.getElementById('reset-camera').addEventListener('click', () => {
        viz3D.resetCamera();
    });

    // Slice slider event handlers
    function setupSliceSliders() {
        const xSlider = document.getElementById('x-slice-slider');
        const ySlider = document.getElementById('y-slice-slider');
        const zSlider = document.getElementById('z-slice-slider');
        
        const xValue = document.getElementById('x-slice-value');
        const yValue = document.getElementById('y-slice-value');
        const zValue = document.getElementById('z-slice-value');
        
        xSlider.addEventListener('input', () => {
            xValue.textContent = xSlider.value;
            if (wasmInterface.ready) {
                const arrows = wasmInterface.getArrows();
                const filledCubes = wasmInterface.getFilledCubes();
                const N = wasmInterface.N;
                updateSlices(arrows, filledCubes, N);
            }
        });
        
        ySlider.addEventListener('input', () => {
            yValue.textContent = ySlider.value;
            if (wasmInterface.ready) {
                const arrows = wasmInterface.getArrows();
                const filledCubes = wasmInterface.getFilledCubes();
                const N = wasmInterface.N;
                updateSlices(arrows, filledCubes, N);
            }
        });
        
        zSlider.addEventListener('input', () => {
            zValue.textContent = zSlider.value;
            if (wasmInterface.ready) {
                const arrows = wasmInterface.getArrows();
                const filledCubes = wasmInterface.getFilledCubes();
                const N = wasmInterface.N;
                updateSlices(arrows, filledCubes, N);
            }
        });
    }
    
    function updateSliderRanges(N) {
        const xSlider = document.getElementById('x-slice-slider');
        const ySlider = document.getElementById('y-slice-slider');
        const zSlider = document.getElementById('z-slice-slider');
        
        const xValue = document.getElementById('x-slice-value');
        const yValue = document.getElementById('y-slice-value');
        const zValue = document.getElementById('z-slice-value');
        
        const maxVal = N - 1;
        const midVal = Math.floor(N / 2);
        
        xSlider.max = maxVal;
        ySlider.max = maxVal;
        zSlider.max = maxVal;
        
        xSlider.value = midVal;
        ySlider.value = midVal;
        zSlider.value = midVal;
        
        xValue.textContent = midVal;
        yValue.textContent = midVal;
        zValue.textContent = midVal;
    }

    // Setup slice sliders
    setupSliceSliders();

    // Initialize on load
    init();
};
</script>
