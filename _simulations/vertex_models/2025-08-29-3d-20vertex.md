---
title: 3D Twenty-Vertex Model Simulation
model: vertex-models
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/vertex_models/2025-08-29-3d-20vertex.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/vertex_models/2025-08-29-3d-20vertex.cpp'
    txt: 'C++ code for the simulation'
---

<style>
  /* Interface container and responsive layout */
  .interface-container {
    display: grid;
    gap: 16px;
    padding: 16px;
    max-width: 1400px;
    margin: 0 auto;
  }

  /* Desktop layout */
  @media (min-width: 768px) {
    .interface-container {
      grid-template-columns: repeat(2, 1fr);
    }

    .control-group.full-width,
    .full-width {
      grid-column: 1 / -1;
    }
  }

  /* Mobile layout */
  @media (max-width: 767px) {
    .interface-container {
      grid-template-columns: 1fr;
    }
  }

  /* Visual grouping */
  .control-group {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
  }

  .control-group-title {
    font-size: 12px;
    font-weight: 600;
    color: #666;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  /* Canvas styling */
  #three-container {
    width: 100%;
    max-width: 1200px;
    height: 700px;
    margin: 0 auto;
    border: 1px solid #ccc;
    display: block;
  }

  /* Parameter grid layout */
  .parameters-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    margin-bottom: 12px;
  }

  .param-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }

  .param-item label {
    font-weight: 600;
    font-size: 13px;
    color: #333;
    text-align: center;
    min-height: 20px;
    display: flex;
    align-items: center;
  }

  .param-item input {
    width: 80px;
    text-align: center;
  }

  .button-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  /* Consistent input styling */
  input[type="number"],
  input[type="range"],
  select {
    height: 36px;
    padding: 0 12px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    font-size: 14px;
    transition: border-color 0.2s;
  }

  input[type="range"] {
    padding: 0;
  }

  input[type="number"]:focus,
  select:focus {
    outline: none;
    border-color: #4CAF50;
  }

  /* Button improvements */
  button {
    height: 36px;
    padding: 0 16px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    background: white;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }

  button:hover {
    background: #f5f5f5;
    border-color: #999;
  }

  button:active {
    background: #e0e0e0;
  }

  /* Primary action buttons */
  button.primary {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
  }

  button.primary:hover {
    background: #45a049;
  }

  /* Progress bar */
  .progress-container {
    width: 100%;
    height: 20px;
    background: #f0f0f0;
    border-radius: 10px;
    overflow: hidden;
    margin: 10px 0;
    display: none;
  }

  .progress-bar {
    height: 100%;
    background: #4CAF50;
    width: 0%;
    transition: width 0.3s ease;
  }

  /* T-slider styling */
  .slider-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 10px 0;
  }

  .slider-container label {
    font-weight: 500;
  }

  .slider-container input[type="range"] {
    flex: 1;
  }

  .slider-value {
    min-width: 40px;
    text-align: center;
    font-weight: 600;
  }

  /* Legend */
  .legend {
    display: flex;
    gap: 20px;
    margin: 10px 0;
    padding: 10px;
    background: #fafafa;
    border-radius: 8px;
    flex-wrap: wrap;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .arrow-icon {
    width: 20px;
    height: 20px;
  }

  /* Mobile optimizations */
  @media (max-width: 767px) {
    .parameters-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    
    .param-item label {
      font-size: 12px;
    }
    
    .param-item input {
      width: 70px;
    }
    
    #three-container {
      height: 400px;
    }
  }

  /* Very small screens */
  @media (max-width: 480px) {
    .parameters-grid {
      grid-template-columns: 1fr;
    }
    
    .param-item input {
      width: 100px;
    }
  }

  /* Vertex configuration display */
  .vertex-config-display {
    font-family: monospace;
    font-size: 11px;
    background: #f8f8f8;
    padding: 8px;
    border-radius: 4px;
    margin-top: 10px;
    max-height: 200px;
    overflow-y: auto;
  }

  /* Details styling */
  details {
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 16px;
  }

  details > summary {
    padding: 12px 16px;
    background: #f5f5f5;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
  }

  details[open] > summary {
    border-bottom: 1px solid #e0e0e0;
  }

  details > .content {
    padding: 16px;
    background: white;
  }
</style>

<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>
<script src="/js/2025-08-29-3d-20vertex.js"></script>

<details id="about-simulation-details">
<summary>About this simulation</summary>
<div class="content">

This simulation demonstrates the <strong>twenty-vertex model</strong> introduced by Bufetov and Zografos (work in progress).
The model consists of a 3D lattice where arrows are placed on edges, always pointing in positive coordinate directions.
Each vertex has 8 possible incoming arrow configurations and 8 possible outgoing configurations, with conservation of arrow count through each vertex.

<br><br>
The model has 20 vertex types: 2 deterministic (000→000 and 111→111) and 18 stochastic configurations with tuneable weights.
The sampling proceeds in time slices where t = x + y + z, with boundary conditions: empty in xz and yz planes, full in xy plane.

</div>
</details>

---

<!-- Controls for the simulation -->
<div class="interface-container">

<!-- Main Parameters -->
<div class="control-group full-width">
  <div class="control-group-title">Model Parameters</div>
  <div class="parameters-grid">
    <div class="param-item">
      <label for="N">N:</label>
      <input type="number" id="N" value="10" min="2" max="300" style="width: 80px;">
    </div>
  </div>
  <div class="button-row">
    <button id="sample" class="primary">Sample Configuration</button>
  </div>
  <div class="progress-container" id="progress-container">
    <div class="progress-bar" id="progress-bar"></div>
  </div>
</div>

<!-- Vertex Weights -->
<details class="control-group full-width">
  <summary><div class="control-group-title">Vertex Weights (12 Free Parameters)</div></summary>
  <div class="content">
    <div class="parameters-grid">
      <div class="param-item">
        <label for="w0">100→100:</label>
        <input type="number" id="w0" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w1">100→010:</label>
        <input type="number" id="w1" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w2">010→100:</label>
        <input type="number" id="w2" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w3">010→010:</label>
        <input type="number" id="w3" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w4">001→100:</label>
        <input type="number" id="w4" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w5">001→010:</label>
        <input type="number" id="w5" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w6">110→110:</label>
        <input type="number" id="w6" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w7">110→101:</label>
        <input type="number" id="w7" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w8">101→110:</label>
        <input type="number" id="w8" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w9">101→101:</label>
        <input type="number" id="w9" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w10">011→110:</label>
        <input type="number" id="w10" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
      <div class="param-item">
        <label for="w11">011→101:</label>
        <input type="number" id="w11" value="0.333" step="0.001" min="0" style="width: 80px;">
      </div>
    </div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
      Note: These 12 parameters, along with sum-to-one constraints, determine all 18 stochastic vertex weights.
      The notation abc→def means incoming arrows from directions (x,y,z) and outgoing to (x,y,z), where 1=arrow present.
    </div>
  </div>
</details>

<!-- Visualization Controls -->
<div class="control-group full-width">
  <div class="control-group-title">Visualization Controls</div>
  <div class="button-row">
    <button id="reset-camera">Reset Camera</button>
  </div>
  <div class="legend">
    <div class="legend-item">
      <svg class="arrow-icon" viewBox="0 0 20 20">
        <line x1="5" y1="10" x2="15" y2="10" stroke="red" stroke-width="2" marker-end="url(#arrowhead-x)"/>
        <defs>
          <marker id="arrowhead-x" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="red"/>
          </marker>
        </defs>
      </svg>
      <span>X-direction</span>
    </div>
    <div class="legend-item">
      <svg class="arrow-icon" viewBox="0 0 20 20">
        <line x1="10" y1="15" x2="10" y2="5" stroke="green" stroke-width="2" marker-end="url(#arrowhead-y)"/>
        <defs>
          <marker id="arrowhead-y" markerWidth="7" markerHeight="10" refX="3.5" refY="1" orient="auto">
            <polygon points="0 10, 3.5 0, 7 10" fill="green"/>
          </marker>
        </defs>
      </svg>
      <span>Y-direction</span>
    </div>
    <div class="legend-item">
      <svg class="arrow-icon" viewBox="0 0 20 20">
        <line x1="5" y1="15" x2="15" y2="5" stroke="blue" stroke-width="2" marker-end="url(#arrowhead-z)"/>
        <defs>
          <marker id="arrowhead-z" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
            <polygon points="0 7, 10 3, 7 10" fill="blue"/>
          </marker>
        </defs>
      </svg>
      <span>Z-direction</span>
    </div>
  </div>
</div>

</div> <!-- End interface-container -->

<!-- 3D Visualization -->
<div id="three-container">
  <canvas id="three-canvas"></canvas>
</div>

<script>
// Check if Module is defined before setting onRuntimeInitialized
if (typeof Module === 'undefined') {
    console.error('Module is not defined. Make sure the WASM JavaScript file is loaded correctly.');
    window.Module = { onRuntimeInitialized: function() {} };
}

Module.onRuntimeInitialized = async function() {
    // WASM Interface Class
    class WASMInterface {
        constructor() {
            this.ready = false;
            this.N = 10;
            this.weights = new Float64Array(12);
            this.weights.fill(1.0/3.0);
            this.arrows = new Uint32Array(); // Will hold packed arrow data
            this.filledCubes = new Uint32Array(); // Will hold packed cube data
        }

        async initialize() {
            if (typeof Module === 'undefined') {
                throw new Error('Module is not defined. WASM JavaScript file may not be loaded.');
            }
            if (typeof Module.cwrap !== 'function') {
                throw new Error('Module.cwrap is not a function. WASM module may not be properly initialized.');
            }

            // Wrap exported functions
            this.initializeModel = Module.cwrap('initializeModel', 'number', ['number', 'number'], {async: true});
            this.sampleConfiguration = Module.cwrap('sampleConfiguration', 'number', [], {async: true});
            this.exportArrows = Module.cwrap('exportArrows', 'number', [], {async: true});
            this.exportFilledCubes = Module.cwrap('exportFilledCubes', 'number', [], {async: true});
            this.updateWeights = Module.cwrap('updateWeights', 'number', ['number'], {async: true});
            this.freeString = Module.cwrap('freeString', null, ['number']);
            this.getProgress = Module.cwrap('getProgress', 'number', []);

            this.ready = true;
        }

        async initModel(N, weights) {
            if (!this.ready) throw new Error('WASM not ready');

            this.N = N;
            this.weights = weights;

            try {
                // Check if Module._malloc and HEAPF64 are available
                if (typeof Module._malloc !== 'function' || typeof Module.HEAPF64 === 'undefined') {
                    // Use alternative allocation method via ccall
                    const ptr = await Module.ccall('initializeModel', 'number', 
                        ['number', 'array'], 
                        [N, weights],
                        {async: true}
                    );
                    
                    if (!ptr) {
                        throw new Error('initializeModel returned null pointer');
                    }
                    const jsonStr = Module.UTF8ToString(ptr);
                    this.freeString(ptr);

                    const result = JSON.parse(jsonStr);
                    if (result.error) {
                        throw new Error(result.error);
                    }
                    return result;
                } else {
                    // Allocate memory for weights array
                    const weightsPtr = Module._malloc(12 * 8); // 12 doubles
                    const heap64 = new Float64Array(Module.HEAPF64.buffer, weightsPtr, 12);
                    heap64.set(weights);

                    const ptr = await this.initializeModel(N, weightsPtr);
                    Module._free(weightsPtr);

                    if (!ptr) {
                        throw new Error('initializeModel returned null pointer');
                    }
                    const jsonStr = Module.UTF8ToString(ptr);
                    this.freeString(ptr);

                    const result = JSON.parse(jsonStr);
                    if (result.error) {
                        throw new Error(result.error);
                    }

                    return result;
                }
            } catch (error) {
                throw new Error(`Initialization failed: ${error.message}`);
            }
        }

        async sample() {
            if (!this.ready) throw new Error('WASM not ready');

            try {
                const ptr = await this.sampleConfiguration();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.error) {
                    throw new Error(result.error);
                }

                // Get arrow and cube data
                await this.refreshArrows();
                await this.refreshFilledCubes(); // Also fetch cube data
                return result;
            } catch (error) {
                throw new Error(`Sampling failed: ${error.message}`);
            }
        }

        async refreshArrows() {
            try {
                const ptr = await this.exportArrows();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.ptr && result.count > 0) {
                    // Create a view into the WASM heap for the arrow data
                    this.arrows = new Uint32Array(Module.HEAPU32.buffer, result.ptr, result.count);
                } else {
                    this.arrows = new Uint32Array(); // Empty
                }
            } catch (error) {
                console.error('Failed to refresh arrows:', error);
                this.arrows = new Uint32Array();
            }
        }

        async refreshFilledCubes() {
            try {
                const ptr = await this.exportFilledCubes();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeString(ptr);

                const result = JSON.parse(jsonStr);
                if (result.ptr && result.count > 0) {
                    this.filledCubes = new Uint32Array(Module.HEAPU32.buffer, result.ptr, result.count);
                } else {
                    this.filledCubes = new Uint32Array();
                }
            } catch (error) {
                console.error('Failed to refresh filled cubes:', error);
                this.filledCubes = new Uint32Array();
            }
        }

        async updateWeightsWasm(weights) {
            if (!this.ready) throw new Error('WASM not ready');

            this.weights = weights;

            try {
                // Check if Module._malloc and HEAPF64 are available
                if (typeof Module._malloc !== 'function' || typeof Module.HEAPF64 === 'undefined') {
                    // Use alternative allocation method via ccall
                    const ptr = await Module.ccall('updateWeights', 'number', 
                        ['array'], 
                        [weights],
                        {async: true}
                    );
                    
                    const jsonStr = Module.UTF8ToString(ptr);
                    this.freeString(ptr);

                    const result = JSON.parse(jsonStr);
                    if (result.error) {
                        throw new Error(result.error);
                    }
                    return result;
                } else {
                    // Allocate memory for weights array
                    const weightsPtr = Module._malloc(12 * 8); // 12 doubles
                    const heap64 = new Float64Array(Module.HEAPF64.buffer, weightsPtr, 12);
                    heap64.set(weights);

                    const ptr = await this.updateWeights(weightsPtr);
                    Module._free(weightsPtr);

                    const jsonStr = Module.UTF8ToString(ptr);
                    this.freeString(ptr);

                    const result = JSON.parse(jsonStr);
                    if (result.error) {
                        throw new Error(result.error);
                    }

                    return result;
                }
            } catch (error) {
                throw new Error(`Weight update failed: ${error.message}`);
            }
        }

        getArrows() {
            return this.arrows; // This is now a Uint32Array
        }

        getFilledCubes() {
            return this.filledCubes; // Add this new getter
        }
    }


    // 3D Visualizer
    class Visualizer3D {
        constructor(container) {
            this.container = container;
            this.N = 10;
            
            // Three.js setup
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0xffffff);

            // Camera
            this.camera = new THREE.PerspectiveCamera(
                45,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            this.camera.position.set(30, 30, 30);
            this.camera.lookAt(0, 0, 0);

            // Renderer
            this.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('three-canvas'),
                antialias: true
            });
            this.renderer.setSize(container.clientWidth, container.clientHeight);

            // Controls
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 10, 10);
            this.scene.add(directionalLight);

            // Arrow group
            this.arrowGroup = new THREE.Group();
            this.scene.add(this.arrowGroup);

            // Grid helper
            this.gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0xcccccc);
            this.scene.add(this.gridHelper);

            // Handle window resize
            window.addEventListener('resize', () => this.handleResize());

            // Start animation loop
            this.animate();
        }

        handleResize() {
            const width = this.container.clientWidth;
            const height = this.container.clientHeight;

            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();

            this.renderer.setSize(width, height);
        }

        draw(arrows, filledCubes, N) {
            this.N = N;

            // Clear existing arrows
            while(this.arrowGroup.children.length > 0) {
                const child = this.arrowGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                this.arrowGroup.remove(child);
            }

            // Create line geometry for all arrows
            const vertices = [];
            const colors = [];

            // Add lines
            for (const packedArrow of arrows) {
                // Unpack data
                const x = (packedArrow >> 22) & 0x3FF;
                const y = (packedArrow >> 12) & 0x3FF;
                const z = (packedArrow >> 2) & 0x3FF;
                const dir = packedArrow & 0x3;

                let startPos = new THREE.Vector3(x, z, y); // Note y/z swap for THREE.js coordinate system
                let endPos = startPos.clone();

                if (dir === 0) { // X direction
                    endPos.x += 1;
                } else if (dir === 1) { // Y direction
                    endPos.z += 1;
                } else { // Z direction
                    endPos.y += 1;
                }

                // Add vertices
                vertices.push(startPos.x, startPos.y, startPos.z);
                vertices.push(endPos.x, endPos.y, endPos.z);

                // Add colors for both vertices
                let color = new THREE.Color();
                if (dir === 0) {
                    color.setRGB(1, 0, 0); // Red for X
                } else if (dir === 1) {
                    color.setRGB(0, 1, 0); // Green for Y
                } else {
                    color.setRGB(0, 0, 1); // Blue for Z
                }
                
                colors.push(color.r, color.g, color.b);
                colors.push(color.r, color.g, color.b);
            }

            // Create geometry for lines
            const lineGeometry = new THREE.BufferGeometry();
            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            lineGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // Create material for lines
            const lineMaterial = new THREE.LineBasicMaterial({ 
                vertexColors: true,
                linewidth: 2
            });

            // Create line segments
            const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
            this.arrowGroup.add(lines);

            // Add cubes from C++ detection
            this.addCubes(filledCubes);

            // Center the view
            const center = N / 2;
            this.arrowGroup.position.set(-center, 0, -center);
            this.controls.target.set(0, center/2, 0);
            this.controls.update();
        }

        addCubes(filledCubes) {
            if (filledCubes.length === 0) return;

            // Use InstancedMesh for performance with many cubes
            const cubeGeometry = new THREE.BoxGeometry(1.0, 1.0, 1.0);
            const cubeMaterial = new THREE.MeshPhongMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.3
            });
            const cubeMesh = new THREE.InstancedMesh(cubeGeometry, cubeMaterial, filledCubes.length);

            const matrix = new THREE.Matrix4();
            for (let i = 0; i < filledCubes.length; i++) {
                const packedCube = filledCubes[i];
                // Unpack: x(10 bits), y(10 bits), z(10 bits)
                const x = (packedCube >> 20) & 0x3FF;
                const y = (packedCube >> 10) & 0x3FF;
                const z = packedCube & 0x3FF;
                
                // Position cube at center of the 1x1x1 cell
                matrix.setPosition(x + 0.5, z + 0.5, y + 0.5); // y/z swap
                cubeMesh.setMatrixAt(i, matrix);
            }
            
            this.arrowGroup.add(cubeMesh);
        }

        animate() {
            requestAnimationFrame(() => this.animate());
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }

        resetCamera() {
            this.camera.position.set(30, 30, 30);
            this.controls.target.set(0, this.N/4, 0);
            this.controls.update();
        }
    }

    // Main application
    const wasmInterface = new WASMInterface();
    const viz3D = new Visualizer3D(document.getElementById('three-container'));
    
    let progressInterval = null;

    // Initialize WASM
    async function init() {
        try {
            await wasmInterface.initialize();
            console.log('WASM initialized successfully');
            
            // Initialize with default parameters
            const weights = new Float64Array(12);
            weights.fill(1.0/3.0);
            await wasmInterface.initModel(10, weights);
            
            // Initial sample
            await sampleAndDraw();
        } catch (error) {
            console.error('Failed to initialize WASM:', error);
            alert('Failed to initialize simulation. Please refresh the page.');
        }
    }

    // Sample and draw
    async function sampleAndDraw() {
        try {
            // Show progress bar
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';

            // Start progress monitoring
            progressInterval = setInterval(() => {
                const progress = wasmInterface.getProgress();
                progressBar.style.width = progress + '%';
            }, 100);

            // Sample configuration
            await wasmInterface.sample();

            // Stop progress monitoring
            clearInterval(progressInterval);
            progressBar.style.width = '100%';
            setTimeout(() => {
                progressContainer.style.display = 'none';
            }, 500);

            // Draw
            const arrows = wasmInterface.getArrows();
            const filledCubes = wasmInterface.getFilledCubes(); // Get cube data
            const N = wasmInterface.N;

            viz3D.draw(arrows, filledCubes, N); // Always use 3D view
        } catch (error) {
            console.error('Sampling failed:', error);
            alert('Sampling failed: ' + error.message);
            clearInterval(progressInterval);
            document.getElementById('progress-container').style.display = 'none';
        }
    }

    // Event handlers
    document.getElementById('sample').addEventListener('click', async () => {
        // Get current parameters
        const N = parseInt(document.getElementById('N').value);
        const weights = new Float64Array(12);
        for (let i = 0; i < 12; i++) {
            weights[i] = parseFloat(document.getElementById('w' + i).value);
        }
        
        
        try {
            // Reinitialize with current parameters
            await wasmInterface.initModel(N, weights);
            // Sample new configuration
            await sampleAndDraw();
        } catch (error) {
            console.error('Sampling failed:', error);
            alert('Sampling failed: ' + error.message);
        }
    });


    document.getElementById('reset-camera').addEventListener('click', () => {
        viz3D.resetCamera();
    });


    // Initialize on load
    init();
};
</script>