---
title: Stochastic Colored Six-Vertex Model
model: vertex-models
author: Leo Petrov
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/vertex_models/2025-11-25-sln-6v.cpp'
    txt: 'C++ source code for the simulation'
---

<style>
  .interface-container {
    display: grid;
    gap: 16px;
    padding: 16px;
    max-width: 1200px;
    margin: 0 auto;
  }

  @media (min-width: 768px) {
    .interface-container {
      grid-template-columns: repeat(2, 1fr);
    }
    .full-width {
      grid-column: 1 / -1;
    }
  }

  @media (max-width: 767px) {
    .interface-container {
      grid-template-columns: 1fr;
    }
  }

  .control-group {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
  }

  .control-group-title {
    font-size: 12px;
    font-weight: 600;
    color: #666;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  #sln-canvas {
    width: 100%;
    max-width: 800px;
    height: 800px;
    border: 1px solid #ccc;
    display: block;
    margin: 0 auto;
    background: white;
  }

  .parameters-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 12px;
    margin-bottom: 12px;
  }

  .param-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .param-item label {
    font-weight: 500;
    font-size: 13px;
  }

  .param-item input {
    width: 100%;
  }

  .button-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  input[type="number"],
  input[type="text"] {
    height: 36px;
    padding: 0 12px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    font-size: 14px;
  }

  input[type="number"]:focus,
  input[type="text"]:focus {
    outline: none;
    border-color: #4CAF50;
  }

  button {
    height: 36px;
    padding: 0 16px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    background: white;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }

  button:hover {
    background: #f5f5f5;
    border-color: #999;
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  button.primary {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
  }

  button.primary:hover {
    background: #45a049;
  }

  .status-display {
    background: #e8f5e9;
    border: 1px solid #4CAF50;
    border-radius: 8px;
    padding: 12px;
    margin-top: 8px;
  }

  .status-display.error {
    background: #ffebee;
    border-color: #f44336;
  }

  .export-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }

  .quality-slider {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .quality-slider input[type="range"] {
    width: 100px;
  }

  .quality-slider span {
    min-width: 60px;
    font-size: 13px;
  }

  .slider-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }

  .slider-row label {
    min-width: 100px;
    font-size: 13px;
  }

  .slider-row input[type="range"] {
    flex: 1;
    min-width: 80px;
  }

  .slider-row span {
    min-width: 40px;
    font-size: 13px;
    text-align: right;
  }

  @media (max-width: 767px) {
    #sln-canvas {
      height: 400px;
    }

    button {
      min-height: 44px;
      padding: 0 12px;
    }

    .parameters-grid {
      grid-template-columns: 1fr 1fr;
    }
  }
</style>

<div class="interface-container">
  <div class="control-group">
    <div class="control-group-title">Parameters</div>
    <div class="parameters-grid">
      <div class="param-item">
        <label for="param-n">Grid Size N:</label>
        <input type="number" id="param-n" value="500" min="1" max="2000" step="10">
      </div>
      <div class="param-item">
        <label for="param-b1">b1 (up prob):</label>
        <input type="text" id="param-b1" value="0.1" inputmode="decimal">
      </div>
      <div class="param-item">
        <label for="param-b2">b2 (right prob):</label>
        <input type="text" id="param-b2" value="0.6" inputmode="decimal">
      </div>
      <div class="param-item">
        <label for="param-seed">Seed (0=random):</label>
        <input type="number" id="param-seed" value="0" min="0">
      </div>
    </div>
    <div class="button-row">
      <button id="btn-generate" class="primary">Generate</button>
    </div>
    <div id="status" class="status-display" style="display: none;"></div>
  </div>

  <div class="control-group">
    <div class="control-group-title">Display Settings</div>
    <div class="slider-row">
      <label for="line-thickness">Line Thickness:</label>
      <input type="range" id="line-thickness" min="0.1" max="5" value="2" step="0.1">
      <span id="line-thickness-value">2</span>
    </div>
    <div class="slider-row">
      <label for="color-saturation">Saturation:</label>
      <input type="range" id="color-saturation" min="0" max="100" value="100" step="5">
      <span id="color-saturation-value">100%</span>
    </div>
    <div class="slider-row">
      <label for="color-lightness">Lightness:</label>
      <input type="range" id="color-lightness" min="20" max="80" value="40" step="5">
      <span id="color-lightness-value">40%</span>
    </div>
    <div class="slider-row">
      <label for="color-nonlinearity">Color Distribution:</label>
      <input type="range" id="color-nonlinearity" min="0" max="100" value="20" step="5">
      <span id="color-nonlinearity-value">20%</span>
    </div>
  </div>

  <div class="control-group">
    <div class="control-group-title">Export</div>
    <div class="export-group">
      <button id="btn-export-png">Export PNG</button>
      <div class="quality-slider">
        <label for="png-quality">Quality:</label>
        <input type="range" id="png-quality" min="0" max="100" value="85" step="5">
        <span id="png-quality-value">85% (517 DPI)</span>
      </div>
    </div>
    <div class="export-group" style="margin-top: 8px;">
      <button id="btn-export-pdf">Export PDF</button>
      <button id="btn-export-svg">Export SVG</button>
    </div>
  </div>

  <div class="full-width">
    <canvas id="sln-canvas" width="800" height="800"></canvas>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="/js/2025-11-25-sln-6v.js"></script>

<script>
(function() {
  // DOM elements
  const canvas = document.getElementById('sln-canvas');
  const ctx = canvas.getContext('2d');
  const paramN = document.getElementById('param-n');
  const paramB1 = document.getElementById('param-b1');
  const paramB2 = document.getElementById('param-b2');
  const paramSeed = document.getElementById('param-seed');
  const btnGenerate = document.getElementById('btn-generate');
  const btnExportPng = document.getElementById('btn-export-png');
  const btnExportPdf = document.getElementById('btn-export-pdf');
  const btnExportSvg = document.getElementById('btn-export-svg');
  const pngQuality = document.getElementById('png-quality');
  const pngQualityValue = document.getElementById('png-quality-value');
  const statusDiv = document.getElementById('status');

  // Display settings sliders
  const lineThicknessSlider = document.getElementById('line-thickness');
  const lineThicknessValue = document.getElementById('line-thickness-value');
  const colorSaturationSlider = document.getElementById('color-saturation');
  const colorSaturationValue = document.getElementById('color-saturation-value');
  const colorLightnessSlider = document.getElementById('color-lightness');
  const colorLightnessValue = document.getElementById('color-lightness-value');
  const colorNonlinearitySlider = document.getElementById('color-nonlinearity');
  const colorNonlinearityValue = document.getElementById('color-nonlinearity-value');

  // State
  let pathsData = null;
  let currentN = 250;
  let currentHorn = 250;

  // Display settings
  let lineThickness = 2.0;
  let colorSaturation = 1.0;
  let colorLightness = 0.4;
  let colorNonlinearity = 0.2;

  // WASM functions
  let runSimulation, getPaths, freeString;

  // Initialize WASM module
  Module.onRuntimeInitialized = function() {
    runSimulation = Module.cwrap('runSimulation', 'number', ['number', 'number', 'number', 'number', 'number']);
    getPaths = Module.cwrap('getPaths', 'number', []);
    freeString = Module.cwrap('freeString', null, ['number']);

    btnGenerate.disabled = false;
    showStatus('Ready. Auto-generating initial simulation...', false);

    // Auto-generate on load
    setTimeout(generate, 100);
  };

  // Utility functions
  function parseDecimal(id) {
    const s = document.getElementById(id).value.trim().replace(',', '.');
    return parseFloat(s);
  }

  function showStatus(msg, isError = false) {
    statusDiv.style.display = 'block';
    statusDiv.textContent = msg;
    statusDiv.className = 'status-display' + (isError ? ' error' : '');
  }

  function updateQualityDisplay() {
    const q = parseInt(pngQuality.value);
    const dpi = Math.round(72 + (q / 100) * 528);
    pngQualityValue.textContent = `${q}% (${dpi} DPI)`;
  }

  function updateSliderDisplays() {
    lineThicknessValue.textContent = lineThicknessSlider.value;
    colorSaturationValue.textContent = colorSaturationSlider.value + '%';
    colorLightnessValue.textContent = colorLightnessSlider.value + '%';
    colorNonlinearityValue.textContent = colorNonlinearitySlider.value + '%';

    lineThickness = parseFloat(lineThicknessSlider.value);
    colorSaturation = parseInt(colorSaturationSlider.value) / 100;
    colorLightness = parseInt(colorLightnessSlider.value) / 100;
    colorNonlinearity = parseInt(colorNonlinearitySlider.value) / 100;
  }

  // HSL to RGB conversion
  function hslToRgb(h, s, l) {
    const f = (n) => {
      const k = (n + h / 30) % 12;
      const a = s * Math.min(l, 1 - l);
      const c = l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));
      return Math.max(0, Math.min(1, c));
    };
    return [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  }

  function rgbToHex(r, g, b) {
    return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
  }

  // Generate rainbow color for path index
  function getPathColor(index, totalPaths) {
    const t = totalPaths > 1 ? index / (totalPaths - 1) : 0;

    // Color distribution: 0% = concentrate on greens/cyans, 100% = concentrate on reds/magentas
    // Map slider 0-1 to power 0.2 to 5 (extreme nonlinearity both ways)
    let t_adjusted;
    if (colorNonlinearity < 0.5) {
      // Left side: power < 1, concentrates colors toward higher t (greens/blues)
      const power = 0.2 + (colorNonlinearity * 2) * 0.8;  // 0.2 to 1.0
      t_adjusted = Math.pow(t, power);
    } else {
      // Right side: power > 1, concentrates colors toward lower t (reds/oranges)
      const power = 1 + ((colorNonlinearity - 0.5) * 2) * 4;  // 1.0 to 5.0
      t_adjusted = Math.pow(t, power);
    }

    // Full spectrum: red (0) to magenta (300)
    const hue = 300 * (1 - t_adjusted);

    // Apply saturation (0 = grayscale, 1 = full color)
    const sat = colorSaturation;

    // Apply lightness with some variation
    const lit = colorLightness * (1 + 0.2 * Math.cos(t * Math.PI * 2));
    const finalLit = Math.min(0.9, Math.max(0.1, lit));

    const [r, g, b] = hslToRgb(hue, sat, finalLit);
    return rgbToHex(r, g, b);
  }

  // Drawing function
  function drawPaths(data, targetCtx, targetCanvas) {
    const useCtx = targetCtx || ctx;
    const useCanvas = targetCanvas || canvas;
    const n = data.n;
    const horn = data.horn;
    const paths = data.paths;

    // Clear canvas
    useCtx.fillStyle = 'white';
    useCtx.fillRect(0, 0, useCanvas.width, useCanvas.height);

    if (!paths || paths.length === 0) return;

    // Calculate scale to fit canvas with margin
    const margin = 20;
    const availWidth = useCanvas.width - 2 * margin;
    const availHeight = useCanvas.height - 2 * margin;
    const scale = Math.min(availWidth / horn, availHeight / n);

    // Draw each path with current settings
    const baseLineWidth = Math.max(0.3, scale * 0.2);
    useCtx.lineWidth = baseLineWidth * lineThickness;
    useCtx.lineCap = 'round';
    useCtx.lineJoin = 'round';

    const totalPaths = paths.length;
    // Draw purple/blue (higher) first, red/green (lower) on top
    for (let index = totalPaths - 1; index >= 0; index--) {
      const path = paths[index];
      if (!path.points || path.points.length < 2) continue;

      // Use JS-generated color based on current slider settings
      useCtx.strokeStyle = getPathColor(index, totalPaths);
      useCtx.beginPath();

      const firstPt = path.points[0];
      // Transform: x stays as x, y is flipped (0 at bottom)
      useCtx.moveTo(margin + firstPt[0] * scale, useCanvas.height - margin - firstPt[1] * scale);

      for (let i = 1; i < path.points.length; i++) {
        const pt = path.points[i];
        useCtx.lineTo(margin + pt[0] * scale, useCanvas.height - margin - pt[1] * scale);
      }

      useCtx.stroke();
    }
  }

  // Generate simulation
  function generate() {
    const n = parseInt(paramN.value) || 250;
    const horn = n; // Square grid
    const b1 = parseDecimal('param-b1') || 0.5;
    const b2 = parseDecimal('param-b2') || 0.1;
    const seed = parseInt(paramSeed.value) || 0;

    showStatus('Running simulation...', false);
    btnGenerate.disabled = true;

    // Use setTimeout to allow UI update
    setTimeout(() => {
      try {
        // Run simulation
        const resultPtr = runSimulation(n, horn, b1, b2, seed);
        const resultStr = Module.UTF8ToString(resultPtr);
        freeString(resultPtr);
        const result = JSON.parse(resultStr);

        if (result.error) {
          showStatus('Error: ' + result.error, true);
          btnGenerate.disabled = false;
          return;
        }

        currentN = result.n;
        currentHorn = result.horn;

        // Get paths
        const pathsPtr = getPaths();
        const pathsStr = Module.UTF8ToString(pathsPtr);
        freeString(pathsPtr);
        pathsData = JSON.parse(pathsStr);

        if (pathsData.error) {
          showStatus('Error getting paths: ' + pathsData.error, true);
          btnGenerate.disabled = false;
          return;
        }

        // Draw
        drawPaths(pathsData);

        showStatus(`Generated ${pathsData.paths.length} paths on ${currentN}x${currentHorn} grid (b1=${b1}, b2=${b2})`, false);
        btnGenerate.disabled = false;
        btnExportPng.disabled = false;
        btnExportPdf.disabled = currentN > 500;  // PDF only for N <= 500
        btnExportSvg.disabled = false;
        btnExportPdf.title = currentN > 500 ? 'PDF export disabled for N > 500' : '';

      } catch (e) {
        showStatus('Error: ' + e.message, true);
        btnGenerate.disabled = false;
      }
    }, 50);
  }

  // Export PNG with quality control
  function exportPNG() {
    if (!pathsData) return;

    const quality = parseInt(pngQuality.value);
    const dpi = 72 + (quality / 100) * 528;
    const dpiMultiplier = dpi / 72;

    // Create high-res canvas
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');

    tempCanvas.width = canvas.width * dpiMultiplier;
    tempCanvas.height = canvas.height * dpiMultiplier;

    // Scale and redraw using the same function
    tempCtx.scale(dpiMultiplier, dpiMultiplier);
    // Create a pseudo-canvas object for the drawing function
    const pseudoCanvas = { width: canvas.width, height: canvas.height };
    drawPaths(pathsData, tempCtx, pseudoCanvas);

    // Download
    tempCanvas.toBlob((blob) => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `colored_6v_N${currentN}_${Math.round(dpi)}dpi.png`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 'image/png');
  }

  // Export PDF
  function exportPDF() {
    if (!pathsData || !window.jspdf) {
      alert('PDF library not loaded or no data to export.');
      return;
    }

    const { jsPDF } = window.jspdf;
    const n = pathsData.n;
    const horn = pathsData.horn;
    const paths = pathsData.paths;
    const totalPaths = paths.length;

    // A4 dimensions in points
    const pdf = new jsPDF({
      orientation: n > horn ? 'portrait' : 'landscape',
      unit: 'pt',
      format: 'a4'
    });

    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 40;
    const availWidth = pageWidth - 2 * margin;
    const availHeight = pageHeight - 2 * margin;
    const scale = Math.min(availWidth / horn, availHeight / n);

    // Helper for hex to RGB
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
      ] : [0, 0, 0];
    }

    // Use current line thickness setting
    const baseLineWidth = Math.max(0.2, scale * 0.15);
    pdf.setLineWidth(baseLineWidth * lineThickness);

    // Draw purple/blue (higher) first, red/green (lower) on top
    for (let index = totalPaths - 1; index >= 0; index--) {
      const path = paths[index];
      if (!path.points || path.points.length < 2) continue;

      const color = getPathColor(index, totalPaths);
      const rgb = hexToRgb(color);
      pdf.setDrawColor(rgb[0], rgb[1], rgb[2]);

      for (let i = 0; i < path.points.length - 1; i++) {
        const p1 = path.points[i];
        const p2 = path.points[i + 1];

        const x1 = margin + p1[0] * scale;
        const y1 = pageHeight - margin - p1[1] * scale;
        const x2 = margin + p2[0] * scale;
        const y2 = pageHeight - margin - p2[1] * scale;

        pdf.line(x1, y1, x2, y2);
      }
    }

    // Save
    pdf.save(`colored_6v_N${currentN}.pdf`);
  }

  // Export SVG
  function exportSVG() {
    if (!pathsData) return;

    const n = pathsData.n;
    const horn = pathsData.horn;
    const paths = pathsData.paths;
    const totalPaths = paths.length;
    const width = 800;
    const height = 800;
    const margin = 20;
    const availWidth = width - 2 * margin;
    const availHeight = height - 2 * margin;
    const scale = Math.min(availWidth / horn, availHeight / n);

    // Use current line thickness setting
    const baseLineWidth = Math.max(0.3, scale * 0.2);
    const strokeWidth = (baseLineWidth * lineThickness).toFixed(2);

    let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <rect width="100%" height="100%" fill="white"/>
`;

    // Draw purple/blue (higher) first, red/green (lower) on top
    for (let index = totalPaths - 1; index >= 0; index--) {
      const path = paths[index];
      if (!path.points || path.points.length < 2) continue;

      const color = getPathColor(index, totalPaths);
      const d = path.points.map((pt, i) => {
        const x = margin + pt[0] * scale;
        const y = height - margin - pt[1] * scale;
        return `${i === 0 ? 'M' : 'L'}${x.toFixed(2)},${y.toFixed(2)}`;
      }).join(' ');

      svg += `  <path d="${d}" stroke="${color}" fill="none" stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round"/>\n`;
    }

    svg += '</svg>';

    // Download
    const blob = new Blob([svg], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `colored_6v_N${currentN}.svg`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Event listeners
  btnGenerate.addEventListener('click', generate);
  btnExportPng.addEventListener('click', exportPNG);

  // Display settings sliders - redraw on change
  function onDisplaySettingChange() {
    updateSliderDisplays();
    if (pathsData) {
      drawPaths(pathsData);
    }
  }

  lineThicknessSlider.addEventListener('input', onDisplaySettingChange);
  colorSaturationSlider.addEventListener('input', onDisplaySettingChange);
  colorLightnessSlider.addEventListener('input', onDisplaySettingChange);
  colorNonlinearitySlider.addEventListener('input', onDisplaySettingChange);
  btnExportPdf.addEventListener('click', exportPDF);
  btnExportSvg.addEventListener('click', exportSVG);
  pngQuality.addEventListener('input', updateQualityDisplay);

  // Initialize
  btnGenerate.disabled = true;
  btnExportPng.disabled = true;
  btnExportPdf.disabled = true;
  btnExportSvg.disabled = true;
  updateQualityDisplay();
  updateSliderDisplays();
  showStatus('Loading WebAssembly module...', false);
})();
</script>

<div class="description mt-4">
  <h4>Description</h4>
  <p>
    The <b>stochastic colored six-vertex model</b> is an ùî∞ùî©<sub>n+1</sub>-related integrable stochastic system
    on a square lattice. Each path carries a "color" (an integer label), and at each vertex,
    two incoming paths (from the left and bottom) interact and produce two outgoing paths
    (going up and right) according to probabilistic rules.
  </p>
  <p>
    The stochastic weights depend on the relative ordering of the incoming colors:
  </p>
  <ul>
    <li>When <b>bottom color &gt; left color</b>: paths cross with probability 1‚àíb<sub>2</sub>, or go straight with probability b<sub>2</sub></li>
    <li>When <b>bottom color &lt; left color</b>: paths go straight with probability b<sub>1</sub>, or cross with probability 1‚àíb<sub>1</sub></li>
    <li>When <b>colors are equal</b>: paths continue straight (deterministic)</li>
  </ul>
  <p>
    The boundary conditions place paths with colors 0, 1, 2, ..., N‚àí1 entering from the left boundary
    at heights 0, 1, 2, ..., N‚àí1, respectively. The rainbow coloring visualizes how these colored paths
    interact, cross, and separate as they evolve through the lattice, revealing the characteristic
    "arctic curve" phenomenon where paths freeze into deterministic regions.
  </p>
  <h4>References</h4>
  <ul>
    <li>
      A. Borodin, M. Wheeler,
      <a href="https://arxiv.org/abs/1808.01866" target="_blank"><i>Coloured stochastic vertex models and their spectral theory</i></a>,
      arXiv:1808.01866 [math.PR], 2018.
    </li>
  </ul>
</div>
