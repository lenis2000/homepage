---
layout: simulation
title: t-PNG and a generalization
date: 2025-08-25
model: vertex-models
author: Leo Petrov
---

<div class="container" style="max-width: 900px;">
  <div class="row">
    <div class="col-md-12">
      <h2>t-PNG and a generalization</h2>
      
      <div class="simulation-container">
        <canvas id="tpng-canvas" width="800" height="600" style="border: 1px solid #ccc;"></canvas>
      </div>
      
      <div class="controls mt-3">
        <button id="start-btn" class="btn btn-primary">Start</button>
        <button id="stop-btn" class="btn btn-secondary">Stop</button>
        <button id="reset-btn" class="btn btn-warning">Reset</button>
      </div>
      
      <div class="parameters mt-3">
        <h4>Parameters</h4>
        <div class="form-group">
          <label for="t-param">t parameter:</label>
          <input type="range" id="t-param" min="0" max="1" step="0.01" value="0.5" class="form-control-range">
          <span id="t-value">0.5</span>
        </div>
      </div>
      
      <div class="description mt-4">
        <h4>Description</h4>
        <p>
          This simulation implements the t-PNG (t-Polynuclear Growth) vertex model and its generalization.
          The model describes the evolution of interfaces in growth processes with parameter t controlling
          the dynamics.
        </p>
      </div>
    </div>
  </div>
</div>

<script>
// t-PNG Vertex Model Simulation
(function() {
    const canvas = document.getElementById('tpng-canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    const resetBtn = document.getElementById('reset-btn');
    const tParam = document.getElementById('t-param');
    const tValue = document.getElementById('t-value');
    
    let animationId = null;
    let t = 0.5;
    let gridSize = 40;
    let cellSize = Math.min(canvas.width, canvas.height) / gridSize;
    
    // Vertex model state
    let vertices = [];
    let time = 0;
    
    // Initialize vertex grid
    function initVertices() {
        vertices = [];
        for (let i = 0; i < gridSize; i++) {
            vertices[i] = [];
            for (let j = 0; j < gridSize; j++) {
                // Initialize with random configuration
                vertices[i][j] = {
                    type: Math.random() < 0.5 ? 0 : 1,
                    height: 0
                };
            }
        }
        time = 0;
    }
    
    // Update vertex configuration based on t-PNG rules
    function updateVertices() {
        const newVertices = JSON.parse(JSON.stringify(vertices));
        
        for (let i = 1; i < gridSize - 1; i++) {
            for (let j = 1; j < gridSize - 1; j++) {
                // t-PNG update rules
                const neighbors = [
                    vertices[i-1][j],
                    vertices[i+1][j],
                    vertices[i][j-1],
                    vertices[i][j+1]
                ];
                
                // Apply vertex model dynamics with parameter t
                const sumNeighbors = neighbors.reduce((sum, n) => sum + n.type, 0);
                const prob = t * sumNeighbors / 4 + (1 - t) * vertices[i][j].type;
                
                if (Math.random() < prob) {
                    newVertices[i][j].type = 1;
                    newVertices[i][j].height = Math.min(...neighbors.map(n => n.height)) + 1;
                } else {
                    newVertices[i][j].type = 0;
                }
            }
        }
        
        vertices = newVertices;
        time++;
    }
    
    // Draw the vertex model
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                const vertex = vertices[i][j];
                const x = j * cellSize;
                const y = i * cellSize;
                
                // Color based on height
                const hue = (vertex.height * 30) % 360;
                const lightness = vertex.type === 1 ? 50 : 80;
                ctx.fillStyle = `hsl(${hue}, 70%, ${lightness}%)`;
                ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                
                // Draw vertex connections
                if (vertex.type === 1) {
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    
                    // Draw edges to neighbors
                    if (i > 0 && vertices[i-1][j].type === 1) {
                        ctx.moveTo(x + cellSize/2, y);
                        ctx.lineTo(x + cellSize/2, y - cellSize/2);
                    }
                    if (j > 0 && vertices[i][j-1].type === 1) {
                        ctx.moveTo(x, y + cellSize/2);
                        ctx.lineTo(x - cellSize/2, y + cellSize/2);
                    }
                    
                    ctx.stroke();
                }
            }
        }
        
        // Display time
        ctx.fillStyle = '#000';
        ctx.font = '16px Arial';
        ctx.fillText(`Time: ${time}`, 10, 25);
    }
    
    // Animation loop
    function animate() {
        updateVertices();
        draw();
        animationId = requestAnimationFrame(animate);
    }
    
    // Event handlers
    startBtn.addEventListener('click', () => {
        if (!animationId) {
            animate();
        }
    });
    
    stopBtn.addEventListener('click', () => {
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    });
    
    resetBtn.addEventListener('click', () => {
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
        initVertices();
        draw();
    });
    
    tParam.addEventListener('input', (e) => {
        t = parseFloat(e.target.value);
        tValue.textContent = t.toFixed(2);
    });
    
    // Initialize
    initVertices();
    draw();
})();
</script>