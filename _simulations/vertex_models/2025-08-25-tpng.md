---
title: Discretized t-PNG (Stochastic Rule 54)
model: vertex-models
author: Leo Petrov
---

<div class="container" style="max-width: 1200px;">
  <div class="row">
    <div class="col-md-12">
      <h2>Discretized t-PNG Model</h2>
      
      <div class="description mt-3 mb-4">
        <h4>Description</h4>
        <p>
          The discrete t-PNG model (stochastic rule 54) lives on the integer quadrant {1,2,...}². 
          It evolves as a Markov chain in continuous time t = x + y. Bernoulli processes with rates 
          a_x and a_y on the boundaries emit rays: vertical rays from the x-axis, horizontal rays 
          from the y-axis. When rays meet, they cross with probability t (horizontal moves up, 
          vertical moves right) or merge and disappear with probability 1-t. Empty cells with 
          empty left, down, and left-down neighbors can spontaneously become occupied with probability b.
        </p>
        <p><em>This model was introduced by Tomaž Prosen (private communication).</em></p>
      </div>
      
      <div class="simulation-container">
        <canvas id="tpng-canvas" width="700" height="700" style="border: 1px solid #ccc;"></canvas>
      </div>
      
      <div class="controls mt-3">
        <button id="start-btn" class="btn btn-primary">Start</button>
        <button id="stop-btn" class="btn btn-secondary">Stop</button>
        <button id="reset-btn" class="btn btn-warning">Reset</button>
        <button id="step-btn" class="btn btn-info">Step</button>
      </div>
      
      <div class="row mt-3">
        <div class="col-md-3">
          <h5>Interaction Parameters</h5>
          <div class="form-group">
            <label for="t-param">t (crossing probability):</label>
            <input type="range" id="t-param" min="0" max="1" step="0.01" value="0.5" class="form-control-range">
            <span id="t-value">0.5</span>
          </div>
          <div class="form-group">
            <label for="b-param">b (birth probability):</label>
            <input type="range" id="b-param" min="0" max="1" step="0.01" value="0.1" class="form-control-range">
            <span id="b-value">0.1</span>
          </div>
        </div>
        
        <div class="col-md-3">
          <h5>Boundary Rates</h5>
          <div class="form-group">
            <label for="ax-param">a_x (x-axis rate):</label>
            <input type="range" id="ax-param" min="0" max="1" step="0.01" value="0.5" class="form-control-range">
            <span id="ax-value">0.50</span>
          </div>
          <div class="form-group">
            <label for="ay-param">a_y (y-axis rate):</label>
            <input type="range" id="ay-param" min="0" max="1" step="0.01" value="0.5" class="form-control-range">
            <span id="ay-value">0.50</span>
          </div>
        </div>
        
        <div class="col-md-3">
          <h5>Simulation Control</h5>
          <div class="form-group">
            <label for="size-param">Grid Size:</label>
            <input type="range" id="size-param" min="20" max="400" step="10" value="20" class="form-control-range">
            <span id="size-value">20</span>
          </div>
          <div class="form-group">
            <label for="speed-param">Speed:</label>
            <input type="range" id="speed-param" min="1" max="100" step="1" value="50" class="form-control-range">
            <span id="speed-value">50</span>
          </div>
        </div>
        
        <div class="col-md-3">
          <h5>Statistics</h5>
          <p>Time: <span id="time-display">0</span></p>
          <p>Occupied cells: <span id="occupied-count">0</span></p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// Discrete t-PNG Model (Stochastic Rule 54)
(function() {
    const canvas = document.getElementById('tpng-canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    const resetBtn = document.getElementById('reset-btn');
    const stepBtn = document.getElementById('step-btn');
    const tParam = document.getElementById('t-param');
    const tValue = document.getElementById('t-value');
    const bParam = document.getElementById('b-param');
    const bValue = document.getElementById('b-value');
    const axParam = document.getElementById('ax-param');
    const axValue = document.getElementById('ax-value');
    const ayParam = document.getElementById('ay-param');
    const ayValue = document.getElementById('ay-value');
    const sizeParam = document.getElementById('size-param');
    const sizeValue = document.getElementById('size-value');
    const speedParam = document.getElementById('speed-param');
    const speedValue = document.getElementById('speed-value');
    const timeDisplay = document.getElementById('time-display');
    const occupiedCount = document.getElementById('occupied-count');
    
    let t = 0.5;  // Crossing probability
    let b = 0.1;  // Birth probability
    let ax = 0.5; // X-axis Bernoulli rate
    let ay = 0.5; // Y-axis Bernoulli rate
    let speed = 50; // Simulation speed
    
    // Grid dimensions
    let gridSize = 20; // Grid size (default 20x20)
    let cellSize = Math.min(canvas.width, canvas.height) / gridSize;
    
    // Grid state (0 = empty, 1 = occupied)
    let grid = [];
    let nextGrid = [];
    let time = 0;
    let animationId = null;
    let isRunning = false;
    
    // Initialize grid
    function initGrid() {
        grid = [];
        nextGrid = [];
        for (let i = 0; i < gridSize; i++) {
            grid[i] = [];
            nextGrid[i] = [];
            for (let j = 0; j < gridSize; j++) {
                grid[i][j] = 0;
                nextGrid[i][j] = 0;
            }
        }
        time = 0;
    }
    
    // Get cell value (with boundary conditions)
    function getCell(x, y) {
        if (x < 0 || y < 0 || x >= gridSize || y >= gridSize) {
            return 0;
        }
        return grid[x][y];
    }
    
    // Count occupied cells
    function countOccupied() {
        let count = 0;
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                if (grid[i][j] === 1) count++;
            }
        }
        return count;
    }
    
    // Single step of the Markov chain - evolves diagonal at time t to t+1
    function step() {
        // Time t corresponds to diagonal x + y = t
        // We evolve from diagonal t to diagonal t+1
        
        // Copy current grid to next grid
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                nextGrid[i][j] = grid[i][j];
            }
        }
        
        // Process the diagonal at current time
        const nextTime = time + 1;
        
        // Process all points (x,y) where x + y = nextTime
        for (let x = 0; x <= Math.min(nextTime, gridSize - 1); x++) {
            const y = nextTime - x;
            if (y >= gridSize || y < 0) continue;
            
            // Special case: boundary emissions
            if (x === 0 && y > 0) {
                // Y-axis: can emit horizontal ray with probability ay
                if (Math.random() < ay) {
                    nextGrid[x][y] = 1;
                } else {
                    nextGrid[x][y] = 0;
                }
                continue;
            }
            if (y === 0 && x > 0) {
                // X-axis: can emit vertical ray with probability ax
                if (Math.random() < ax) {
                    nextGrid[x][y] = 1;
                } else {
                    nextGrid[x][y] = 0;
                }
                continue;
            }
            
            // Interior points: apply the cellular automaton rule
            // v at (x,y) on diagonal t+1 depends on:
            // s = (x-1, y) and s' = (x, y-1) on diagonal t
            // u = (x-1, y-1) on diagonal t-1
            if (x > 0 && y > 0) {
                const s = getCell(x - 1, y);        // left neighbor on diagonal t
                const sPrime = getCell(x, y - 1);   // down neighbor on diagonal t
                const u = getCell(x - 1, y - 1);    // SW neighbor on diagonal t-1
                
                // Apply the rule:
                // If s != 0 or s' != 0, then v = 1 - u
                if (s !== 0 || sPrime !== 0) {
                    nextGrid[x][y] = 1 - u;
                } else {
                    // s = s' = 0
                    if (u === 0) {
                        // v = 1 with probability b, 0 with probability 1-b
                        nextGrid[x][y] = (Math.random() < b) ? 1 : 0;
                    } else {
                        // u = 1
                        // v = 1 with probability t, 0 with probability 1-t
                        nextGrid[x][y] = (Math.random() < t) ? 1 : 0;
                    }
                }
            }
        }
        
        // Swap grids
        let temp = grid;
        grid = nextGrid;
        nextGrid = temp;
        
        time++;
        timeDisplay.textContent = time;
        occupiedCount.textContent = countOccupied();
    }
    
    // Draw the configuration
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Calculate cell size to fit the grid in the canvas
        // Use the smaller dimension to ensure everything fits
        cellSize = Math.min(canvas.width / gridSize, canvas.height / gridSize);
        
        // Draw grid background
        ctx.fillStyle = '#f8f8f8';
        ctx.fillRect(0, 0, gridSize * cellSize, gridSize * cellSize);
        
        // Draw grid lines (optional for small grids)
        if (gridSize <= 50) {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= gridSize; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, gridSize * cellSize);
                ctx.stroke();
                // Horizontal lines
                if (i * cellSize <= canvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * cellSize);
                    ctx.lineTo(gridSize * cellSize, i * cellSize);
                    ctx.stroke();
                }
            }
        }
        
        // Draw axes (thicker lines)
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        // X-axis (bottom)
        ctx.beginPath();
        ctx.moveTo(0, gridSize * cellSize);
        ctx.lineTo(gridSize * cellSize, gridSize * cellSize);
        ctx.stroke();
        // Y-axis (left)
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, gridSize * cellSize);
        ctx.stroke();
        
        // Draw next time diagonal (x + y = time + 1) with slope -1
        if (time >= 0 && time + 1 < 2 * gridSize) {
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            // Diagonal x + y = time + 1.5, shifted by (1/2, 1/2)
            // Slope -1: as x increases, y decreases
            const diagonalValue = time + 1.5;
            
            // Find start and end points
            let startX, startY, endX, endY;
            
            if (diagonalValue <= gridSize - 0.5) {
                // Diagonal intersects x-axis and y-axis
                startX = diagonalValue; // x-axis intersection (y = -0.5)
                startY = -0.5;
                endX = -0.5; // y-axis intersection (x = -0.5)
                endY = diagonalValue;
            } else {
                // Diagonal intersects top and right edges
                startX = gridSize - 0.5; // right edge intersection
                startY = diagonalValue - (gridSize - 0.5);
                endX = diagonalValue - (gridSize - 0.5); // top edge intersection
                endY = gridSize - 0.5;
            }
            
            // Clamp to grid bounds
            startX = Math.max(-0.5, Math.min(gridSize - 0.5, startX));
            startY = Math.max(-0.5, Math.min(gridSize - 0.5, startY));
            endX = Math.max(-0.5, Math.min(gridSize - 0.5, endX));
            endY = Math.max(-0.5, Math.min(gridSize - 0.5, endY));
            
            // Convert to canvas coordinates (remember y-axis is flipped)
            const canvasStartX = (startX + 0.5) * cellSize;
            const canvasStartY = (gridSize - 0.5 - startY) * cellSize;
            const canvasEndX = (endX + 0.5) * cellSize;
            const canvasEndY = (gridSize - 0.5 - endY) * cellSize;
            
            ctx.moveTo(canvasStartX, canvasStartY);
            ctx.lineTo(canvasEndX, canvasEndY);
            ctx.stroke();
        }
        
        // Draw occupied cells
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                if (grid[i][j] === 1) {
                    // Map grid coordinates to canvas
                    // i is x (horizontal), j is y (vertical)
                    // Canvas has y=0 at top, grid has y=0 at bottom
                    const canvasX = i * cellSize;
                    const canvasY = (gridSize - 1 - j) * cellSize;
                    
                    // Color based on position
                    if (i === 0 && j > 0) {
                        // Y-axis emission (horizontal ray source)
                        ctx.fillStyle = '#dc2626'; // Red
                    } else if (j === 0 && i > 0) {
                        // X-axis emission (vertical ray source)
                        ctx.fillStyle = '#2563eb'; // Blue
                    } else {
                        // Interior cell
                        ctx.fillStyle = '#333'; // Dark gray
                    }
                    
                    // Draw cell without gaps
                    ctx.fillRect(canvasX, canvasY, cellSize, cellSize);
                }
            }
        }
    }
    
    // Animation loop
    function animate() {
        if (isRunning) {
            step();
            draw();
            animationId = setTimeout(() => {
                requestAnimationFrame(animate);
            }, 1000 / speed);
        }
    }
    
    // Event handlers
    startBtn.addEventListener('click', () => {
        if (!isRunning) {
            isRunning = true;
            animate();
            startBtn.textContent = 'Pause';
        } else {
            isRunning = false;
            if (animationId) {
                clearTimeout(animationId);
            }
            startBtn.textContent = 'Start';
        }
    });
    
    stopBtn.addEventListener('click', () => {
        isRunning = false;
        if (animationId) {
            clearTimeout(animationId);
        }
        startBtn.textContent = 'Start';
    });
    
    resetBtn.addEventListener('click', () => {
        isRunning = false;
        if (animationId) {
            clearTimeout(animationId);
        }
        initGrid();
        draw();
        startBtn.textContent = 'Start';
        timeDisplay.textContent = '0';
        occupiedCount.textContent = '0';
    });
    
    stepBtn.addEventListener('click', () => {
        if (!isRunning) {
            step();
            draw();
        }
    });
    
    tParam.addEventListener('input', (e) => {
        t = parseFloat(e.target.value);
        tValue.textContent = t.toFixed(2);
    });
    
    bParam.addEventListener('input', (e) => {
        b = parseFloat(e.target.value);
        bValue.textContent = b.toFixed(2);
    });
    
    axParam.addEventListener('input', (e) => {
        ax = parseFloat(e.target.value);
        axValue.textContent = ax.toFixed(2);
    });
    
    ayParam.addEventListener('input', (e) => {
        ay = parseFloat(e.target.value);
        ayValue.textContent = ay.toFixed(2);
    });
    
    sizeParam.addEventListener('input', (e) => {
        const newSize = parseInt(e.target.value);
        sizeValue.textContent = newSize;
        gridSize = newSize;
        isRunning = false;
        if (animationId) {
            clearTimeout(animationId);
        }
        initGrid();
        draw();
        startBtn.textContent = 'Start';
    });
    
    speedParam.addEventListener('input', (e) => {
        speed = parseInt(e.target.value);
        speedValue.textContent = speed;
    });
    
    // Initialize
    initGrid();
    draw();
})();
</script>