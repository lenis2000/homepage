---
title: Discretized t-PNG (Stochastic Rule 54)
model: vertex-models
author: Leo Petrov
---

<div class="container" style="max-width: 1200px;">
  <div class="row">
    <div class="col-md-12">
      <h2>Discretized t-PNG Model</h2>

      <div class="description mt-3 mb-4">
        <h4>Description</h4>
        <p>
          The discrete t-PNG model (stochastic rule 54) lives on the integer quadrant {1,2,...}².
          It evolves as a Markov chain in continuous time t = x + y. Bernoulli processes with rates
          a_x and a_y on the boundaries emit rays: vertical rays from the x-axis, horizontal rays
          from the y-axis. When rays meet, they cross with probability t (horizontal moves up,
          vertical moves right) or merge and disappear with probability 1-t. Empty cells with
          empty left, down, and left-down neighbors can spontaneously become occupied with probability b.
        </p>
        <p><em>This model was introduced by Tomaž Prosen (private communication).</em></p>
      </div>

      <div class="simulation-container">
        <canvas id="tpng-canvas" width="700" height="700" style="border: 1px solid #ccc;"></canvas>
      </div>

      <div class="controls mt-3">
        <button id="start-btn" class="btn btn-primary">Start</button>
        <button id="stop-btn" class="btn btn-secondary">Stop</button>
        <button id="reset-btn" class="btn btn-warning">Reset</button>
        <button id="step-btn" class="btn btn-info">Step</button>
      </div>

      <div class="row mt-3">
        <div class="col-md-3">
          <h5>Interaction Parameters</h5>
          <div class="form-group">
            <label for="t-param">t (crossing probability):</label>
            <input type="text" id="t-param" inputmode="decimal" class="form-control" value="0.5" placeholder="e.g. 0.1 or 0,1">
          </div>
          <div class="form-group">
            <label for="b-param">b (birth probability):</label>
            <input type="text" id="b-param" inputmode="decimal" class="form-control" value="0.1">
          </div>
        </div>

        <div class="col-md-3">
          <h5>Boundary Rates</h5>
          <div class="form-group">
            <label for="ax-param">a_x (x-axis rate):</label>
            <input type="text" id="ax-param" inputmode="decimal" class="form-control" value="0.5">
          </div>
          <div class="form-group">
            <label for="ay-param">a_y (y-axis rate):</label>
            <input type="text" id="ay-param" inputmode="decimal" class="form-control" value="0.5">
          </div>
        </div>

        <div class="col-md-3">
          <h5>Simulation Control</h5>
          <div class="form-group">
            <label for="size-param">Grid Size:</label>
            <input type="range" id="size-param" min="20" max="700" step="10" value="20" class="form-control-range">
            <span id="size-value">20</span>
          </div>
          <div class="form-group">
            <label for="speed-param">Speed (× N):</label>
            <input type="range" id="speed-param" min="0.1" max="10" step="0.1" value="2.5" class="form-control-range">
            <span id="speed-value">2.5</span>
          </div>
        </div>

        <div class="col-md-3">
          <h5>Statistics</h5>
          <p>Time: <span id="time-display">0</span></p>
          <p>Occupied cells: <span id="occupied-count">0</span></p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// Read & validate [0,1]; accepts both "." and ","
function readUnitInterval(id){
  const s = document.getElementById(id).value.trim().replace(',', '.');
  const x = Number(s);
  if (!Number.isFinite(x) || x < 0 || x > 1) throw new Error(`${id} must be between 0 and 1`);
  return x;
}

// Discrete t-PNG Model (Stochastic Rule 54)
(function() {
    const canvas = document.getElementById('tpng-canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    const resetBtn = document.getElementById('reset-btn');
    const stepBtn = document.getElementById('step-btn');
    const tParam = document.getElementById('t-param');
    const bParam = document.getElementById('b-param');
    const axParam = document.getElementById('ax-param');
    const ayParam = document.getElementById('ay-param');
    const sizeParam = document.getElementById('size-param');
    const sizeValue = document.getElementById('size-value');
    const speedParam = document.getElementById('speed-param');
    const speedValue = document.getElementById('speed-value');
    const timeDisplay = document.getElementById('time-display');
    const occupiedCount = document.getElementById('occupied-count');


    let t = 0.5;  // Crossing probability
    let b = 0.1;  // Birth probability
    let ax = 0.5; // X-axis Bernoulli rate
    let ay = 0.5; // Y-axis Bernoulli rate
    let speedMultiplier = 2.5; // Speed multiplier (will be multiplied by grid size)

    // Grid dimensions
    let gridSize = 20; // Grid size (default 20x20)
    let cellSize = Math.min(canvas.width, canvas.height) / gridSize;

    // Grid state (0 = empty, 1 = occupied)
    let grid = [];
    let nextGrid = [];
    let time = 0;
    let animationId = null;
    let isRunning = false;

    // Initialize grid
    function initGrid() {
        grid = [];
        nextGrid = [];
        for (let i = 0; i < gridSize; i++) {
            grid[i] = [];
            nextGrid[i] = [];
            for (let j = 0; j < gridSize; j++) {
                grid[i][j] = 0;
                nextGrid[i][j] = 0;
            }
        }
        time = 0;
    }

    // Get cell value (with boundary conditions)
    function getCell(x, y) {
        if (x < 0 || y < 0 || x >= gridSize || y >= gridSize) {
            return 0;
        }
        return grid[x][y];
    }

    // Count occupied cells
    function countOccupied() {
        let count = 0;
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                if (grid[i][j] === 1) count++;
            }
        }
        return count;
    }

    // Single step of the Markov chain - evolves diagonal at time t to t+1
    function step() {
        // Time t corresponds to diagonal x + y = t
        // We evolve from diagonal t to diagonal t+1

        // Copy current grid to next grid
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                nextGrid[i][j] = grid[i][j];
            }
        }

        // Process the diagonal at current time
        const nextTime = time + 1;

        // Process all points (x,y) where x + y = nextTime
        for (let x = 0; x <= Math.min(nextTime, gridSize - 1); x++) {
            const y = nextTime - x;
            if (y >= gridSize || y < 0) continue;

            // Special case: boundary emissions
            if (x === 0 && y > 0) {
                // Y-axis: can emit horizontal ray with probability ay
                if (Math.random() < ay) {
                    nextGrid[x][y] = 1;
                } else {
                    nextGrid[x][y] = 0;
                }
                continue;
            }
            if (y === 0 && x > 0) {
                // X-axis: can emit vertical ray with probability ax
                if (Math.random() < ax) {
                    nextGrid[x][y] = 1;
                } else {
                    nextGrid[x][y] = 0;
                }
                continue;
            }

            // Interior points: apply the cellular automaton rule
            // v at (x,y) on diagonal t+1 depends on:
            // s = (x-1, y) and s' = (x, y-1) on diagonal t
            // u = (x-1, y-1) on diagonal t-1
            if (x > 0 && y > 0) {
                const s = getCell(x - 1, y);        // left neighbor on diagonal t
                const sPrime = getCell(x, y - 1);   // down neighbor on diagonal t
                const u = getCell(x - 1, y - 1);    // SW neighbor on diagonal t-1

                // Apply the rule:
                // If s != 0 or s' != 0, then v = 1 - u
                if (s !== 0 || sPrime !== 0) {
                    nextGrid[x][y] = 1 - u;
                } else {
                    // s = s' = 0
                    if (u === 0) {
                        // v = 1 with probability b, 0 with probability 1-b
                        nextGrid[x][y] = (Math.random() < b) ? 1 : 0;
                    } else {
                        // u = 1
                        // v = 1 with probability t, 0 with probability 1-t
                        nextGrid[x][y] = (Math.random() < t) ? 1 : 0;
                    }
                }
            }
        }

        // Swap grids
        let temp = grid;
        grid = nextGrid;
        nextGrid = temp;

        time++;
        timeDisplay.textContent = time;
        occupiedCount.textContent = countOccupied();

        // Auto-stop condition: t >= 2N + 3
        if (time >= 2 * gridSize + 3) {
            isRunning = false;
            if (animationId) {
                clearTimeout(animationId);
            }
            startBtn.textContent = 'Start';
        }
    }

    // Draw the configuration
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Calculate cell size to fit the grid in the canvas
        // Use the smaller dimension to ensure everything fits
        cellSize = Math.min(canvas.width / gridSize, canvas.height / gridSize);

        // Draw grid background
        ctx.fillStyle = '#f8f8f8';
        ctx.fillRect(0, 0, gridSize * cellSize, gridSize * cellSize);

        // Draw grid lines (optional for small grids)
        if (gridSize <= 50) {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= gridSize; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, gridSize * cellSize);
                ctx.stroke();
                // Horizontal lines
                if (i * cellSize <= canvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * cellSize);
                    ctx.lineTo(gridSize * cellSize, i * cellSize);
                    ctx.stroke();
                }
            }
        }

        // Draw axes (thicker lines)
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        // X-axis (bottom)
        ctx.beginPath();
        ctx.moveTo(0, gridSize * cellSize);
        ctx.lineTo(gridSize * cellSize, gridSize * cellSize);
        ctx.stroke();
        // Y-axis (left)
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, gridSize * cellSize);
        ctx.stroke();

        // Draw next time diagonal (x + y = time + 1) with slope -1
        if (time >= 0 && time + 1 < 2 * gridSize) {
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.beginPath();

            // Diagonal x + y = time + 1.5, shifted by (1/2, 1/2)
            // Slope -1: as x increases, y decreases
            const diagonalValue = time + 1.5;

            // Find start and end points
            let startX, startY, endX, endY;

            if (diagonalValue <= gridSize - 0.5) {
                // Diagonal intersects x-axis and y-axis
                startX = diagonalValue; // x-axis intersection (y = -0.5)
                startY = -0.5;
                endX = -0.5; // y-axis intersection (x = -0.5)
                endY = diagonalValue;
            } else {
                // Diagonal intersects top and right edges
                startX = gridSize - 0.5; // right edge intersection
                startY = diagonalValue - (gridSize - 0.5);
                endX = diagonalValue - (gridSize - 0.5); // top edge intersection
                endY = gridSize - 0.5;
            }

            // Clamp to grid bounds
            startX = Math.max(-0.5, Math.min(gridSize - 0.5, startX));
            startY = Math.max(-0.5, Math.min(gridSize - 0.5, startY));
            endX = Math.max(-0.5, Math.min(gridSize - 0.5, endX));
            endY = Math.max(-0.5, Math.min(gridSize - 0.5, endY));

            // Convert to canvas coordinates (remember y-axis is flipped)
            const canvasStartX = (startX + 0.5) * cellSize;
            const canvasStartY = (gridSize - 0.5 - startY) * cellSize;
            const canvasEndX = (endX + 0.5) * cellSize;
            const canvasEndY = (gridSize - 0.5 - endY) * cellSize;

            ctx.moveTo(canvasStartX, canvasStartY);
            ctx.lineTo(canvasEndX, canvasEndY);
            ctx.stroke();
        }

        // Draw occupied cells
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                if (grid[i][j] === 1) {
                    // Map grid coordinates to canvas
                    // i is x (horizontal), j is y (vertical)
                    // Canvas has y=0 at top, grid has y=0 at bottom
                    const canvasX = i * cellSize;
                    const canvasY = (gridSize - 1 - j) * cellSize;

                    // Color based on position
                    if (i === 0 && j > 0) {
                        // Y-axis emission (horizontal ray source)
                        ctx.fillStyle = '#dc2626'; // Red
                    } else if (j === 0 && i > 0) {
                        // X-axis emission (vertical ray source)
                        ctx.fillStyle = '#2563eb'; // Blue
                    } else {
                        // Interior cell
                        ctx.fillStyle = '#333'; // Dark gray
                    }

                    // Draw cell without gaps
                    ctx.fillRect(canvasX, canvasY, cellSize, cellSize);
                }
            }
        }
    }

    // Animation loop
    function animate() {
        if (isRunning) {
            step();
            draw();
            const actualSpeed = speedMultiplier * gridSize / 10;
            animationId = setTimeout(() => {
                requestAnimationFrame(animate);
            }, 1000 / actualSpeed);
        }
    }

    // Event handlers
    startBtn.addEventListener('click', () => {
        if (!isRunning) {
            isRunning = true;
            animate();
            startBtn.textContent = 'Pause';
        } else {
            isRunning = false;
            if (animationId) {
                clearTimeout(animationId);
            }
            startBtn.textContent = 'Start';
        }
    });

    stopBtn.addEventListener('click', () => {
        isRunning = false;
        if (animationId) {
            clearTimeout(animationId);
        }
        startBtn.textContent = 'Start';
    });

    resetBtn.addEventListener('click', () => {
        isRunning = false;
        if (animationId) {
            clearTimeout(animationId);
        }
        initGrid();
        draw();
        startBtn.textContent = 'Start';
        timeDisplay.textContent = '0';
        occupiedCount.textContent = '0';
    });

    stepBtn.addEventListener('click', () => {
        if (!isRunning) {
            step();
            draw();
        }
    });

    tParam.addEventListener('input', (e) => {
        try {
            t = readUnitInterval('t-param');
        } catch (err) {
            console.warn(err.message);
        }
    });

    bParam.addEventListener('input', (e) => {
        try {
            b = readUnitInterval('b-param');
        } catch (err) {
            console.warn(err.message);
        }
    });

    axParam.addEventListener('input', (e) => {
        try {
            ax = readUnitInterval('ax-param');
        } catch (err) {
            console.warn(err.message);
        }
    });

    ayParam.addEventListener('input', (e) => {
        try {
            ay = readUnitInterval('ay-param');
        } catch (err) {
            console.warn(err.message);
        }
    });


    sizeParam.addEventListener('input', (e) => {
        const newSize = parseInt(e.target.value);
        sizeValue.textContent = newSize;

        // Stop the simulation first
        isRunning = false;
        if (animationId) {
            clearTimeout(animationId);
        }

        // Update grid size and reinitialize
        gridSize = newSize;
        cellSize = Math.min(canvas.width / gridSize, canvas.height / gridSize);
        initGrid();
        draw();
        startBtn.textContent = 'Start';
    });

    speedParam.addEventListener('input', (e) => {
        speedMultiplier = parseFloat(e.target.value);
        speedValue.textContent = speedMultiplier;
    });

    // Initialize
    initGrid();
    draw();
})();
</script>
