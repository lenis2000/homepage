---
title: Random Permutation from a Drawn Shape via RSK
model: random-matrices
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/permutations/2025-07-05-rsk-syt.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/permutations/2025-07-05-rsk-syt.cpp'
    txt: 'C++ code for the simulation'
---

<script src="{{site.url}}/js/d3.v7.min.js"></script>
<script src="{{site.url}}/js/2025-07-05-rsk-syt.js"></script>

<div class="row">
  <div class="col-12 mb-3">
    <p>
      Draw a decreasing function shape in the box below. This shape will be discretized into a Young diagram of size $N$. The app then samples two random Standard Young Tableaux (SYT) of this shape and applies the inverse RSK correspondence to generate a random permutation $\pi \in S_N$. The permutation is shown as a matrix on the right.
    </p>
  </div>
</div>

<div class="row">
  <div class="col-12 col-md-6">
    <h5>1. Draw Shape & Set Size</h5>
    <canvas id="drawingCanvas" width="400" height="200" style="border: 1px solid black; cursor: crosshair;"></canvas>
    <div class="controls mt-3">
      <label for="nInput">Total size $N$:</label>
      <input id="nInput" type="range" min="10" max="500" step="1" value="100" />
      <span id="nValue">100</span>
      <button id="runBtn" class="btn btn-primary ml-3">Generate Permutation</button>
    </div>
  </div>

  <div class="col-12 col-md-6">
    <h5>2. Resulting Permutation Matrix</h5>
    <canvas id="permutationMatrix" width="400" height="400" style="border: 1px solid #ccc;"></canvas>
  </div>
</div>

<style>
  #drawingCanvas, #permutationMatrix {
    max-width: 100%;
    height: auto;
  }
</style>

<script>
    let userPath = [];
    let isDrawing = false;

    async function init() {
        // Wait for WASM module to be ready
        await new Promise(resolve => {
            if (typeof Module !== 'undefined' && Module.ready) {
                resolve();
            } else if (typeof Module !== 'undefined') {
                Module.onRuntimeInitialized = resolve;
            } else {
                // Fallback for script loading order issues
                window.addEventListener('load', () => Module.onRuntimeInitialized = resolve);
            }
        });

        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        
        const clearAndRedraw = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            if(userPath.length > 0) {
                ctx.moveTo(userPath[0].x, userPath[0].y);
                for(let i = 1; i < userPath.length; i++) {
                    ctx.lineTo(userPath[i].x, userPath[i].y);
                }
                ctx.stroke();
            }
        };

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            userPath = [{ x: e.offsetX, y: e.offsetY }];
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                userPath.push({ x: e.offsetX, y: e.offsetY });
                clearAndRedraw();
            }
        });

        canvas.addEventListener('mouseup', () => { isDrawing = false; });
        canvas.addEventListener('mouseleave', () => { isDrawing = false; });
        
        document.getElementById('nInput').addEventListener('input', (e) => {
            document.getElementById('nValue').textContent = e.target.value;
        });

        document.getElementById('runBtn').addEventListener('click', runSimulation);
    }

    function discretizeShape(path, totalBoxesN, canvasWidth, canvasHeight) {
        if (path.length < 2) return [];

        // 1. Filter path to be monotonic: x increases, y is non-increasing.
        // This ensures the drawing represents a valid Young diagram shape.
        let cleanPath = [path[0]];
        for (let i = 1; i < path.length; i++) {
            if (path[i].x > cleanPath[cleanPath.length - 1].x && path[i].y >= 0) {
                 // Enforce non-increasing y-values (row lengths)
                const lastY = cleanPath[cleanPath.length - 1].y;
                cleanPath.push({ x: path[i].x, y: Math.min(path[i].y, lastY) });
            }
        }
        if (cleanPath.length < 2) return [];

        // 2. Create an interpolated function f(x) from the cleaned path.
        const f = (x) => {
            if (x < cleanPath[0].x) return cleanPath[0].y;
            const lastPoint = cleanPath[cleanPath.length - 1];
            if (x > lastPoint.x) return lastPoint.y;
            
            for (let i = 0; i < cleanPath.length - 1; i++) {
                if (x >= cleanPath[i].x && x <= cleanPath[i + 1].x) {
                    const t = (x - cleanPath[i].x) / (cleanPath[i + 1].x - cleanPath[i].x);
                    return cleanPath[i].y * (1 - t) + cleanPath[i + 1].y * t;
                }
            }
            return lastPoint.y;
        };
        
        // 3. Calculate area under the curve to find scaling factor.
        let area = 0;
        for (let x = 0; x < canvasWidth; x++) {
            area += Math.max(0, f(x));
        }
        if (area < 1) return [];

        const scale = Math.sqrt(totalBoxesN / area);

        // 4. Generate the partition by sampling the scaled function.
        let shape = [];
        let currentSum = 0;
        // Iterate through rows (y-axis)
        for (let i = 0; i < canvasHeight * scale; i++) {
            // Find the width (x-value) for this row. This requires inverting f(x).
            // A simpler way: Iterate through x, define rows.
        }
        
        // Let's use a simpler, direct sampling method.
        // The x-axis of drawing corresponds to rows, y-axis to row length.
        shape = [];
        currentSum = 0;
        const maxX = cleanPath[cleanPath.length - 1].x;
        for (let x = 0; x < maxX * scale; x++) {
            const row_length = Math.floor(f(x / scale) * scale);
            if (row_length > 0) {
                shape.push(row_length);
                currentSum += row_length;
            } else {
                break;
            }
        }

        // 5. Trim the partition to have the exact sum N.
        while (currentSum > totalBoxesN && shape.length > 0) {
            let last = shape.length - 1;
            let diff = currentSum - totalBoxesN;
            if (shape[last] > diff) {
                shape[last] -= diff;
                currentSum -= diff;
            } else {
                currentSum -= shape[last];
                shape.pop();
            }
        }
        
        return shape.filter(len => len > 0); // Final cleanup
    }

    function runSimulation() {
        const N = parseInt(document.getElementById('nInput').value, 10);
        if (userPath.length < 2) {
            alert("Please draw a shape first.");
            return;
        }
        const drawingCanvas = document.getElementById('drawingCanvas');
        const shape = discretizeShape(userPath, N, drawingCanvas.width, drawingCanvas.height);

        if (shape.length === 0) {
            alert("Could not create a valid diagram from the drawing. Please draw a smoother, decreasing shape.");
            return;
        }

        // Call WASM function
        const shapeBytes = Int32Array.from(shape);
        const shapePtr = Module._malloc(shapeBytes.length * shapeBytes.BYTES_PER_ELEMENT);
        Module.HEAP32.set(shapeBytes, shapePtr / shapeBytes.BYTES_PER_ELEMENT);
        
        Module.ccall('generatePermutation', null, ['number', 'number'], [shapePtr, shape.length]);

        Module._free(shapePtr);

        // Get result and draw
        const permSize = Module._getPermutationSize();
        if (permSize > 0) {
            const permPtr = Module._getPermutationData();
            const permutation = Array.from(new Int32Array(Module.HEAP32.buffer, permPtr, permSize));
            drawPermutationMatrix(permutation);
        } else {
            // Clear previous matrix if generation failed
            const canvas = document.getElementById('permutationMatrix');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,canvas.width, canvas.height);
        }
    }

    function drawPermutationMatrix(pi) {
        const n = pi.length;
        const canvas = document.getElementById('permutationMatrix');
        const ctx = canvas.getContext('2d');
        const boxSize = canvas.width / n;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = 'navy';
        for (let i = 0; i < n; i++) {
            // pi is 1-indexed from C++, so pi[i] is the value at index i.
            // We want to plot (i, pi[i]-1)
            const x = i * boxSize;
            const y = (pi[i] - 1) * boxSize;
            ctx.fillRect(x, y, boxSize, boxSize);
        }
        
        // Draw grid lines for small N
        if (n <= 50) {
            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 0.5;
            for(let i = 1; i < n; i++) {
                ctx.beginPath();
                ctx.moveTo(i * boxSize, 0);
                ctx.lineTo(i * boxSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * boxSize);
                ctx.lineTo(canvas.width, i * boxSize);
                ctx.stroke();
            }
        }
    }

    // Initialize after the page loads
    window.addEventListener('load', init);
</script>