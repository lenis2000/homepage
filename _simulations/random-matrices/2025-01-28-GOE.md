---
title: GOE eigenvalues (GPU.js version)
model: random-matrices
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/random-matrices/2025-01-28-GOE.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: ''
    txt: 'C++ code for the simulation'
---



<script src="{{site.url}}/js/d3.v7.min.js"></script>
<script src="{{site.url}}/js/goe.js"></script>


<p>
    This simulation uses <code>WebAssembly</code> and the <code>Eigen</code> library to compute eigenvalues
    of a Gaussian Orthogonal Ensemble (GOE) matrix.
</p>
<div class="controls">
    <label for="nInput">Matrix size N:</label>
    <input id="nInput" type="range" min="2" max="800" step="1" value="50" />
    <span id="nValue">50</span>
    <button id="runBtn">Generate & Plot Eigenvalues</button>
</div>
<svg id="plot"></svg>

<script>
    async function initWasm() {
        try {
            // Wait for the Module to be ready
            await new Promise((resolve) => {
                if (Module.ready) resolve();
                else Module.onRuntimeInitialized = resolve;
            });

            // Run initial simulation
            const defaultN = 30;
            const eigenvals = getEigenvalues(defaultN);
            drawHistogram(eigenvals);
        } catch (error) {
            console.error('Failed to load WASM:', error);
            document.body.innerHTML += `<p style="color: red">Error loading WASM: ${error.message}</p>`;
        }
    }

    function getEigenvalues(N) {
        if (!Module || !Module._computeEigenvalues) return [];

        try {
            const ptr = Module._computeEigenvalues(N);
            return new Float64Array(Module.HEAPF64.buffer, ptr, N);
        } catch (error) {
            console.error('Error computing eigenvalues:', error);
            return [];
        }
    }

    function drawHistogram(eigenvals) {
        const svg = d3.select("#plot");
        svg.selectAll("*").remove();

        const margin = { top: 20, right: 30, bottom: 30, left: 40 };
        const width = svg.node().getBoundingClientRect().width;
        const height = svg.node().getBoundingClientRect().height;

        const xScale = d3.scaleLinear()
            .domain([-2.5, 2.5])
            .range([margin.left, width - margin.right]);

        const N = eigenvals.length;
        const numBins = N <= 100 ? 10 : 40;
        const bins = d3.bin()
            .domain([-2.5, 2.5])
            .thresholds(numBins)(eigenvals);

        // Calculate bin width and normalize histogram
        const binWidth = (bins[0].x1 - bins[0].x0);
        const totalArea = N * binWidth;
        const normalizedBins = bins.map(bin => ({
            ...bin,
            normalizedLength: bin.length / totalArea
        }));

        const yScale = d3.scaleLinear()
            .domain([0, d3.max(normalizedBins, d => d.normalizedLength)])
            .range([height - margin.bottom, margin.top]);

        svg.append("g")
            .attr("transform", `translate(0,${height - margin.bottom})`)
            .call(d3.axisBottom(xScale));

        svg.append("g")
            .attr("transform", `translate(${margin.left},0)`)
            .call(d3.axisLeft(yScale));

        svg.selectAll(".bar")
            .data(normalizedBins)
            .join("rect")
            .attr("class", "bar")
            .attr("x", d => xScale(d.x0))
            .attr("width", d => xScale(d.x1) - xScale(d.x0))
            .attr("y", d => yScale(d.normalizedLength))
            .attr("height", d => yScale(0) - yScale(d.normalizedLength))
            .attr("fill", "steelblue");

        const semicircleData = Array.from({ length: 200 }, (_, i) => {
            const x = -2 + (i / 199) * 4;
            const y = Math.abs(x) <= 2 ? Math.sqrt(4 - x ** 2) / (2 * Math.PI) : 0;
            return { x, y };
        });

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveBasis);

        svg.append("path")
            .datum(semicircleData)
            .attr("fill", "none")
            .attr("stroke", "red")
            .attr("stroke-width", 1.5)
            .attr("d", line);
    }

    document.getElementById("runBtn").addEventListener("click", () => {
        const N = parseInt(document.getElementById("nInput").value, 10);
        const eigenvals = getEigenvalues(N);
        drawHistogram(eigenvals);
    });

    document.getElementById("nInput").addEventListener("input", (e) => {
        document.getElementById("nValue").textContent = e.target.value;
    });

    window.addEventListener('resize', () => {
        const N = parseInt(document.getElementById("nInput").value, 10);
        const eigenvals = getEigenvalues(N);
        drawHistogram(eigenvals);
    });

    // Initialize when the page loads
    initWasm();
</script>
