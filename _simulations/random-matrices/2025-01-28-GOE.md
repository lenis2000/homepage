---
title: GOE eigenvalues
model: random-matrices
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/random-matrices/2025-01-28-GOE.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/random-matrices/2025-01-28-GOE.cpp'
    txt: 'C++ code for the simulation'
---

<script src="{{site.url}}/js/d3.v7.min.js"></script>
<script src="{{site.url}}/js/2025-01-28-GOE.js"></script>

<div class="container">
  <div class="row">
    <div class="col-12 col-lg-8">
      <p>
          This simulation uses <code>WebAssembly</code> and the <code>Eigen</code> library to compute eigenvalues
          of a Gaussian Orthogonal Ensemble (GOE) matrix.
      </p>
      <div class="controls mb-3">
          <label for="nInput">Matrix size N:</label>
          <input id="nInput" type="range" min="2" max="800" step="1" value="50" />
          <span id="nValue">50</span>
          <button id="runBtn" class="btn btn-primary">Generate & Plot Eigenvalues</button>
      </div>
      <div id="topEigenvals" class="mb-3">
          <h5>Top 5 Eigenvalues:</h5>
          <ol id="eigenvalList">
              <!-- Populated by JavaScript -->
          </ol>
      </div>
      <svg id="plot" width="100%" style="min-height: 400px;"></svg>
    </div>
  </div>
</div>

<script>
    async function initWasm() {
        try {
            // Wait for the Module to be ready
            await new Promise((resolve) => {
                if (Module.ready) resolve();
                else Module.onRuntimeInitialized = resolve;
            });

            // Run initial simulation
            const defaultN = 30;
            const eigenvals = getEigenvalues(defaultN);
            drawHistogram(eigenvals);
            displayTopEigenvalues(eigenvals);
        } catch (error) {
            console.error('Failed to load WASM:', error);
            document.body.innerHTML += `<p style="color: red">Error loading WASM: ${error.message}</p>`;
        }
    }

    function getEigenvalues(N) {
        if (!Module || !Module._computeEigenvalues) return [];

        try {
            const ptr = Module._computeEigenvalues(N);
            return Array.from(new Float64Array(Module.HEAPF64.buffer, ptr, N));
        } catch (error) {
            console.error('Error computing eigenvalues:', error);
            return [];
        }
    }

    function drawHistogram(eigenvals) {
        const svg = d3.select("#plot");
        svg.selectAll("*").remove();

        const margin = { top: 20, right: 30, bottom: 30, left: 40 };
        const width = svg.node().getBoundingClientRect().width;
        const height = svg.node().getBoundingClientRect().height;

        const xScale = d3.scaleLinear()
            .domain([-2.5, 2.5])
            .range([margin.left, width - margin.right]);

        const N = eigenvals.length;
        const numBins = N <= 100 ? 10 : 40;
        const bins = d3.bin()
            .domain([-2.5, 2.5])
            .thresholds(numBins)(eigenvals);

        // Calculate bin width and normalize histogram
        const binWidth = (bins[0].x1 - bins[0].x0);
        const totalArea = N * binWidth;
        const normalizedBins = bins.map(bin => ({
            ...bin,
            normalizedLength: bin.length / totalArea
        }));

        const yScale = d3.scaleLinear()
            .domain([0, d3.max(normalizedBins, d => d.normalizedLength)])
            .range([height - margin.bottom, margin.top]);

        svg.append("g")
            .attr("transform", `translate(0,${height - margin.bottom})`)
            .call(d3.axisBottom(xScale));

        svg.append("g")
            .attr("transform", `translate(${margin.left},0)`)
            .call(d3.axisLeft(yScale));

        svg.selectAll(".bar")
            .data(normalizedBins)
            .join("rect")
            .attr("class", "bar")
            .attr("x", d => xScale(d.x0))
            .attr("width", d => xScale(d.x1) - xScale(d.x0))
            .attr("y", d => yScale(d.normalizedLength))
            .attr("height", d => yScale(0) - yScale(d.normalizedLength))
            .attr("fill", "#00204E"); // UVA Blue

        const semicircleData = Array.from({ length: 200 }, (_, i) => {
            const x = -2 + (i / 199) * 4;
            const y = Math.abs(x) <= 2 ? Math.sqrt(4 - x ** 2) / (2 * Math.PI) : 0;
            return { x, y };
        });

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveBasis);

        svg.append("path")
            .datum(semicircleData)
            .attr("fill", "none")
            .attr("stroke", "#F56C26") // UVA Orange
            .attr("stroke-width", 1.5)
            .attr("d", line);
    }

    function displayTopEigenvalues(eigenvals) {
        const topList = eigenvals.slice().sort((a, b) => b - a).slice(0, 5);
        const listElement = document.getElementById("eigenvalList");
        listElement.innerHTML = "";
        topList.forEach(val => {
            const li = document.createElement("li");
            li.textContent = val.toFixed(4);
            listElement.appendChild(li);
        });
    }

    document.getElementById("runBtn").addEventListener("click", () => {
        const N = parseInt(document.getElementById("nInput").value, 10);
        const eigenvals = getEigenvalues(N);
        drawHistogram(eigenvals);
        displayTopEigenvalues(eigenvals);
    });

    document.getElementById("nInput").addEventListener("input", (e) => {
        document.getElementById("nValue").textContent = e.target.value;
    });

    window.addEventListener('resize', () => {
        const N = parseInt(document.getElementById("nInput").value, 10);
        const eigenvals = getEigenvalues(N);
        drawHistogram(eigenvals);
        displayTopEigenvalues(eigenvals);
    });

    // Initialize when the page loads
    initWasm();
</script>
