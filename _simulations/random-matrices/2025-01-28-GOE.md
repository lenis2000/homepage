---
title: GOE eigenvalues
model: random-matrices
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/random-matrices/2025-01-28-GOE.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
---

<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<div class="container mt-4 mb-3" style="overflow: visible;">
  <p>
    This interactive simulation visualizes the eigenvalues of a <strong>Gaussian Orthogonal Ensemble (GOE)</strong> matrix.
    A GOE matrix is a real symmetric matrix with entries drawn from a Gaussian distribution.
    The matrix is scaled by <code>1 / sqrt(N)</code>, ensuring that as <em>N</em> grows, the eigenvalues concentrate within the interval <code>[-2, 2]</code>,
    adhering to Wigner's semicircle law.
    <br/><br/>
    <strong>Instructions:</strong>
    <ol>
      <li>Use the slider to select the matrix size <strong>N</strong> (up to 300).</li>
      <li>Click <code>Generate & Plot Eigenvalues</code> to create a new GOE matrix, compute its eigenvalues, and visualize them in a histogram.</li>
      <li>The red curve represents the theoretical semicircle distribution for comparison.</li>
    </ol>
    <strong>Note:</strong> Larger values of <code>N</code> may require more computation time, depending on your device's performance.
  </p>

  <!-- Simulation Controls -->
  <div class="my-3 p-3 bg-light" style="overflow: visible;">
    <h2 class="h4 mb-3">Simulation Controls</h2>

    <div class="row mb-3">
      <!-- Control for N -->
      <div class="col-12 col-md-6 d-flex align-items-center mb-2">
        <label for="nInput" class="me-2 mb-0">Matrix size N:</label>
        <input
          id="nInput"
          type="range"
          class="form-range"
          value="30"
          min="2"
          max="300"
          step="1"
        />
        &nbsp;<span id="nValue" class="ms-2" style="text-align:right;">30</span>&nbsp;&nbsp;
        <button id="runBtn" class="btn btn-sm btn-primary ms-2">
          Generate & Plot Eigenvalues
        </button>
      </div>
    </div>

    <!-- Tooltip for histogram bars -->
    <div
      id="tooltip"
      style="
        position: absolute;
        text-align: center;
        padding: 6px;
        font: 12px sans-serif;
        background: #fff;
        border: 1px solid #aaa;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 9999;
      "
    ></div>

    <!-- Responsive SVG container for the histogram plot -->
    <svg
      id="plot"
      style="width: 100%; height: auto; display: block;"
      preserveAspectRatio="xMidYMid meet"
    ></svg>
  </div>
</div>


<script src="{{site.url}}/js/d3.v7.min.js"></script>
<script src="{{site.url}}/js/numeric.min.js"></script>

<script>
// ======================================================
// 1) Optimized Random Normal Generator (Box-Muller Transform)
//    Using two-sample generation to reduce calls to Math.random()
// ======================================================
let randnSpare = null;
function randn() {
  if (randnSpare !== null) {
    const val = randnSpare;
    randnSpare = null;
    return val;
  }
  let u1 = 0, u2 = 0;
  while (u1 <= Number.EPSILON) {
    u1 = Math.random();
    u2 = Math.random();
  }
  const R = Math.sqrt(-2.0 * Math.log(u1));
  const theta = 2.0 * Math.PI * u2;
  const z0 = R * Math.cos(theta);
  const z1 = R * Math.sin(theta);
  randnSpare = z1;
  return z0;
}

// ======================================================
// 2) Generate GOE matrix of size N, scale by 1/sqrt(N)
// ======================================================
function generateGOE(N) {
  const A = Array.from({ length: N }, () => Array(N).fill(0));
  const invSqrtN = 1 / Math.sqrt(N);

  for (let i = 0; i < N; i++) {
    for (let j = i; j < N; j++) {
      const val = randn() * invSqrtN;
      A[i][j] = val;
      A[j][i] = val; // Ensure symmetric
    }
  }
  return A;
}

// ======================================================
// 3) Compute eigenvalues using numeric.js EVD
// ======================================================
function computeEigenvalues(A) {
  const ev = numeric.eig(A);
  const eigenvals = ev.lambda.x;

  // numeric.js returns real parts in ev.lambda.x (for real symmetric, imaginary parts are zero)
  if (!Array.isArray(eigenvals) || eigenvals.some(val => typeof val !== 'number' || isNaN(val))) {
    console.error("Invalid eigenvalues:", eigenvals);
    return [];
  }

  // Sorting not strictly necessary for histogram, so we skip it to save time
  // eigenvals.sort((a, b) => a - b);

  return eigenvals;
}

// ======================================================
// 4) Main simulation: generate and get eigenvalues
// ======================================================
function simulateGOE(N) {
  const A = generateGOE(N);
  return computeEigenvalues(A);
}

// ======================================================
// 5) Plot a histogram of the eigenvalues + overlay semicircle
// ======================================================
function drawHistogram(eigenvals) {
  const N = eigenvals.length;
  const svg = d3.select("#plot");
  svg.selectAll("*").remove(); // Clear previous plot

  const margin = { top: 30, right: 30, bottom: 40, left: 50 };
  const width = 800, height = 450;
  svg
    .attr("viewBox", [0, 0, width, height])
    .style("border", "none");

  const minVal = d3.min(eigenvals);
  const maxVal = d3.max(eigenvals);
  // Set domain slightly wider than expected for better visualization
  const lowerX = Math.min(-2.5, minVal - 0.1 * Math.abs(minVal));
  const upperX = Math.max(2.5, maxVal + 0.1 * Math.abs(maxVal));

  const binGenerator = d3.bin()
    .domain([lowerX, upperX])
    .thresholds(40);
  const bins = binGenerator(eigenvals);

  // Calculate density for a density histogram
  const binWidth = bins[0] ? (bins[0].x1 - bins[0].x0) : 1;
  bins.forEach(bin => {
    bin.density = bin.length / (N * binWidth);
  });

  const xScale = d3.scaleLinear()
    .domain([lowerX, upperX])
    .range([margin.left, width - margin.right]);

  const yMax = d3.max(bins, d => d.density);
  const yScale = d3.scaleLinear()
    .domain([0, yMax * 1.1])
    .range([height - margin.bottom, margin.top]);

  // X Axis
  svg.append("g")
    .attr("transform", `translate(0, ${height - margin.bottom})`)
    .call(d3.axisBottom(xScale).ticks(10));

  // Y Axis
  svg.append("g")
    .attr("transform", `translate(${margin.left}, 0)`)
    .call(d3.axisLeft(yScale).ticks(8));

  // Bars
  svg.selectAll(".bar")
    .data(bins)
    .join("rect")
      .attr("class", "bar")
      .attr("x", d => xScale(d.x0))
      .attr("width", d => Math.max(1, xScale(d.x1) - xScale(d.x0) - 1))
      .attr("y", d => yScale(d.density))
      .attr("height", d => yScale(0) - yScale(d.density))
      .attr("fill", "steelblue")
      .on("mouseover", (event, d) => {
        const tooltip = d3.select("#tooltip");
        tooltip
          .style("opacity", 1)
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY + 10) + "px")
          .html(`Bin [${d.x0.toFixed(2)}, ${d.x1.toFixed(2)})<br/>Count: ${d.length}`);
      })
      .on("mousemove", event => {
        const tooltip = d3.select("#tooltip");
        tooltip
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY + 10) + "px");
      })
      .on("mouseout", () => {
        d3.select("#tooltip").style("opacity", 0);
      });

  // ==============================
  // Semicircle Overlay:
  //   f(x) = (1 / (2Ï€)) * sqrt(4 - x^2), for |x| <= 2
  // ==============================
  const semicircleData = [];
  const points = 200;
  for (let i = 0; i <= points; i++) {
    const x = -2 + (4 * i / points); // Range from -2 to 2
    const y = (Math.abs(x) <= 2)
      ? (1 / (2 * Math.PI)) * Math.sqrt(4 - x * x)
      : 0;
    semicircleData.push({ x, y });
  }

  const line = d3.line()
    .x(d => xScale(d.x))
    .y(d => yScale(d.y))
    .curve(d3.curveBasis);

  svg.append("path")
    .datum(semicircleData)
    .attr("fill", "none")
    .attr("stroke", "red")
    .attr("stroke-width", 2)
    .attr("d", line);

  // Title
  svg.append("text")
    .attr("x", width / 2)
    .attr("y", margin.top / 2)
    .attr("text-anchor", "middle")
    .style("font-size", "16px")
    .text("GOE Eigenvalues Histogram with Semicircle Law");
}

// ======================================================
// 6) Combined Function to Run Simulation and Plot
// ======================================================
function simulateAndDraw(N) {
  if (N > 200) {
    console.warn("Large N may lead to longer computation times.");
  }

  const eigenvals = simulateGOE(N);
  if (!Array.isArray(eigenvals) || eigenvals.length !== N) {
    alert("Error computing eigenvalues. Please try a smaller matrix size.");
    return;
  }

  drawHistogram(eigenvals);
}

// ======================================================
// 7) Event Listeners
// ======================================================
const runBtn = document.getElementById("runBtn");
const nInput = document.getElementById("nInput");
const nValueSpan = document.getElementById("nValue");

runBtn.addEventListener("click", () => {
  const nVal = parseInt(nInput.value, 10);
  if (isNaN(nVal) || nVal < 2 || nVal > 300) {
    alert("Please choose an integer N between 2 and 300.");
    return;
  }
  simulateAndDraw(nVal);
});

nInput.addEventListener("input", (e) => {
  nValueSpan.textContent = parseInt(e.target.value, 10);
});

// ======================================================
// 8) Auto-run on Page Load with Default N
// ======================================================
(function autoRunOnLoad() {
  const defaultN = parseInt(nInput.value, 10);
  simulateAndDraw(defaultN);
})();
</script>
