---
title: 3D t-embedding of an Aztec diamond graph (doubly periodic case)
model: domino-tilings
author: 'Leonid Petrov'
code:
- link:    'https://github.com/lenis2000/homepage/blob/master/_simulations/domino_tilings/2025-03-28-t-emb-3d.md'
  txt: 'Interactive 3D T-embedding; see the source code of this page at the link'
- link:    'https://github.com/lenis2000/homepage/blob/master/_simulations/domino_tilings/2025-03-28-t-emb-3d-json.cpp'
  txt: 'C++ code for the simulation with tunable scale parameter a (3D version)'
---


An illustration of the **T-embedding** of the Aztec diamond graph (parameter \(n\)), with **3D height** given by the imaginary part of the **O**-embedding. The \((x,y)\) coordinates come from \( \mathrm{Re}(T), -\mathrm{Im}(T)\), and the \(z\) coordinate is \(\mathrm{Im}(O)\). No origami map is displayed.

Some references:
<ul>
    <li>
      <strong>Perfect t‑Embeddings of Uniformly Weighted Aztec Diamonds and Tower Graphs</strong><br>
      <em>Tomas Berggren, Matthew Nicoletti, Marianna Russkikh (2023, IMRN)</em><br>
      <a href="https://doi.org/10.1093/imrn/rnad299" target="_blank">DOI:10.1093/imrn/rnad299</a>
    </li>
    <li>
      <strong>Bipartite Dimer Model: Perfect t‑Embeddings and Lorentz‑minimal Surfaces</strong><br>
      <em>Dmitry Chelkak, Benoît Laslier, Marianna Russkikh (2021)</em><br>
      <a href="https://arxiv.org/abs/2109.06272" target="_blank">arXiv:2109.06272</a>
    </li>
    <li>
      <strong>Fluctuations in the Aztec Diamonds via a Lorentz‑minimal Surface</strong><br>
      <em>Dmitry Chelkak, Sanjay Ramassamy (2020)</em><br>
      <a href="https://arxiv.org/abs/2002.07540" target="_blank">arXiv:2002.07540</a>
    </li>
</ul>

<!-- Three.js and OrbitControls (adjust paths if needed) -->
<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>

<!-- WASM/JS from our C++ code, compiled by emcc (adjust path if needed) -->
<script src="/js/2025-03-28-t-emb-3d-json.js"></script>

<div style="margin-bottom: 1em; font-size: 18px;">
  <label for="n-input">Aztec Diamond parameter \(n\) (1–200):</label>
  <input id="n-input" type="number" value="4" min="1" max="200" step="1">

  <label for="a-input" style="margin-left: 15px;">Doubly periodic parameter \(a\):</label>
  <input id="a-input" type="number" value="1.0" min="0.1" max="10" step="0.1">

  <button id="update-btn">Update</button>
</div>

<!-- Container for the 3D canvas -->
<div id="three-container" style="width: 100%; height: 80vh;"></div>

<script>
/*
  We'll call doTembJSONwithA(n, a) from the WASM to get a JSON with T and O arrays.
  Then build a 3D geometry using:
    x = Re(T)
    y = -Im(T)
    z = Im(O)
  We'll create line segments for adjacency among T-vertices (with special handling
  of boundary and corners exactly as in the 2D file), and small spheres at T-vertices.
  No edges or spheres for the O-embedding.
*/

Module.onRuntimeInitialized = async function() {
  // Wrap the WASM exports
  const doTembJSONwithA = Module.cwrap('doTembJSONwithA', 'number', ['number','number'], {async: true});
  const freeString = Module.cwrap('freeString', null, ['number']);

  // Helper: call the WASM function, parse JSON
  async function getTandOarrays(n, a) {
    const ptr = await doTembJSONwithA(n, a);
    const jsonStr = Module.UTF8ToString(ptr);
    freeString(ptr);
    return JSON.parse(jsonStr); // { T: [...], O: [...], B: [...] }
  }

  // Build T-edges with the same special boundary/corner logic as in the 2D code
  function buildEdges(vertices, n) {
    const indexMap = new Map();
    vertices.forEach((v, idx) => {
      indexMap.set(`${v.k},${v.j}`, idx);
    });

    const edges = [];
    const neighborSteps = [
      { dk:  1, dj:  0 },
      { dk: -1, dj:  0 },
      { dk:  0, dj:  1 },
      { dk:  0, dj: -1 },
    ];
    const isBoundary = (k,j) => (Math.abs(k) + Math.abs(j) === n);

    // Add special edges connecting the four corners and some boundary adjustments
    const specialEdges = [
      // corners
      { from: { k: 0,  j: n },  to: { k: n,  j: 0 } },
      { from: { k: 0,  j: -n }, to: { k: n,  j: 0 } },
      { from: { k: 0,  j: -n }, to: { k: -n, j: 0 } },
      { from: { k: 0,  j: n },  to: { k: -n, j: 0 } },
      // direct connections among boundary
      { from: { k: n-1,   j: 0 },  to: { k: n,    j: 0 } },
      { from: { k: 0,     j: n-1 },to: { k: 0,    j: n } },
      { from: { k: -(n-1),j: 0 },  to: { k: -n,   j: 0 } },
      { from: { k: 0,     j: -(n-1) },to: { k: 0, j: -n } },
    ];

    specialEdges.forEach(s => {
      const fromKey = `${s.from.k},${s.from.j}`;
      const toKey   = `${s.to.k},${s.to.j}`;
      if (indexMap.has(fromKey) && indexMap.has(toKey)) {
        const i1 = indexMap.get(fromKey);
        const i2 = indexMap.get(toKey);
        edges.push([Math.min(i1, i2), Math.max(i1, i2)]);
      }
    });

    // Add edges for direct neighbor steps, skipping boundary->interior mismatch
    vertices.forEach((v, idx) => {
      neighborSteps.forEach(step => {
        const nk = v.k + step.dk;
        const nj = v.j + step.dj;
        const key = `${nk},${nj}`;
        if (!indexMap.has(key)) return;
        const nbrIdx = indexMap.get(key);

        // If exactly one endpoint is boundary and the other is interior, skip
        const oneIsBoundary = isBoundary(v.k, v.j) ^ isBoundary(nk, nj);
        if (!oneIsBoundary) {
          if (nbrIdx > idx) {
            edges.push([idx, nbrIdx]);
          }
        }
      });
    });

    return edges;
  }

  // Add a "ring" of edges around the boundary (k,j) where |k|+|j|=n-1,
  // sorting them angularly
  function addBoundaryRingEdges(vertices, edges, n) {
    const boundaryIndices = [];
    vertices.forEach((v, idx) => {
      if (Math.abs(v.k) + Math.abs(v.j) === n-1) {
        boundaryIndices.push(idx);
      }
    });

    boundaryIndices.sort((iA, iB) => {
      const vA = vertices[iA];
      const vB = vertices[iB];
      // compare polar angles
      const aA = Math.atan2(vA.im, vA.re);
      const aB = Math.atan2(vB.im, vB.re);
      return aA - aB;
    });

    for (let i = 0; i < boundaryIndices.length; i++) {
      const iA = boundaryIndices[i];
      const iB = boundaryIndices[(i+1) % boundaryIndices.length];
      edges.push([Math.min(iA, iB), Math.max(iA, iB)]);
    }
  }

  // Three.js scene variables
  let scene, camera, renderer, controls;
  let lineGroup;
  let sphereGroup;

  init3D();
  // Trigger initial update (n,a are randomized once DOM is ready below)
  handleUpdate();

  function init3D() {
    const container = document.getElementById('three-container');
    const width  = container.clientWidth;
    const height = container.clientHeight;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    camera = new THREE.PerspectiveCamera(45, width / height, 0.001, 1000);
    camera.position.set(0, 0, 3);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(width, height);
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.minDistance = 0.1;
    controls.maxDistance = 1000;

    window.addEventListener('resize', onWindowResize, false);
    animate();
  }

  function onWindowResize() {
    const container = document.getElementById('three-container');
    const width  = container.clientWidth;
    const height = container.clientHeight;

    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }

  async function handleUpdate() {
    // Get n, a
    const nVal = parseInt(document.getElementById("n-input").value, 10);
    const aVal = parseFloat(document.getElementById("a-input").value);

    if (nVal < 1 || nVal > 200) {
      alert("Please pick integer n in [1, 200].");
      return;
    }
    if (aVal <= 0) {
      alert("Parameter a must be positive!");
      return;
    }

    let data;
    try {
      data = await getTandOarrays(nVal, aVal); // data = { T: [...], O: [...], B: [...] }
    } catch (e) {
      console.error("Error from doTembJSONwithA:", e);
      return;
    }

    const Tvertices = data.T; // array of {k,j,re,im}
    // Build a map of (k,j) -> Im(O) for the z coordinate
    const OImMap = new Map();
    data.O.forEach(o => {
      // we'll store Im(O) in OImMap. Notice 'o.re' might be Re(O),
      // 'o.im' is the imaginary part. We want "o.im" for the z-coordinate
      // if your compiled code stores them differently, adjust accordingly.
      OImMap.set(`${o.k},${o.j}`, - o.im);
    });

    // Build T edges with special corners/boundary logic
    const Tedges = buildEdges(Tvertices, nVal);
    addBoundaryRingEdges(Tvertices, Tedges, nVal);

    // Remove old geometry
    if (lineGroup) {
      scene.remove(lineGroup);
      lineGroup.children.forEach((child)=>child.geometry.dispose());
    }
    if (sphereGroup) {
      scene.remove(sphereGroup);
      sphereGroup.children.forEach((child)=>child.geometry.dispose());
    }

    // 1) Create line segments for T-edges
    lineGroup = new THREE.Group();
    {
      const material = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });
      Tedges.forEach(edge => {
        const i1 = edge[0];
        const i2 = edge[1];
        const v1 = Tvertices[i1];
        const v2 = Tvertices[i2];

        // find z-coords from O's imaginary part
        const z1 = OImMap.has(`${v1.k},${v1.j}`) ? OImMap.get(`${v1.k},${v1.j}`) : 0;
        const z2 = OImMap.has(`${v2.k},${v2.j}`) ? OImMap.get(`${v2.k},${v2.j}`) : 0;

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array([
          v1.re, -v1.im, z1,
          v2.re, -v2.im, z2
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const line = new THREE.Line(geometry, material);
        lineGroup.add(line);
      });
    }
    scene.add(lineGroup);

    // 2) Create small spheres at T-vertices
    sphereGroup = new THREE.Group();
    {
      const sphereGeom = new THREE.SphereGeometry(0.004, 8, 8);
      const sphereMat  = new THREE.MeshBasicMaterial({ color: 0x000000 });

      Tvertices.forEach(v => {
        // Skip any point that might be at (0,0)
          if (Math.abs(z) < 1e-10) return;
        const z = OImMap.has(`${v.k},${v.j}`) ? OImMap.get(`${v.k},${v.j}`) : 0;
        const mesh = new THREE.Mesh(sphereGeom, sphereMat);
        mesh.position.set(v.re, -v.im, z);
        sphereGroup.add(mesh);
      });
    }
    scene.add(sphereGroup);
  }

  // Hook the "Update" button
  document.getElementById("update-btn").addEventListener("click", handleUpdate);

  // Randomize n (2..20) and a (0.2..1) on page load
  document.addEventListener("DOMContentLoaded", function() {
    const nRand = Math.floor(Math.random() * (20 - 2 + 1)) + 2; // 2..20
    const aRand = (Math.random() * (1 - 0.2) + 0.2).toFixed(1); // 0.2..1
    document.getElementById('n-input').value = nRand;
    document.getElementById('a-input').value = aRand;
    handleUpdate();
  });
};
</script>
