---
title: 3D t-embedding of an Aztec diamond graph (doubly periodic case)
model: domino-tilings
author: 'Leonid Petrov'
code:
- link:    'https://github.com/lenis2000/homepage/blob/master/_simulations/domino_tilings/2025-03-28-t-emb-3d.md'
  txt: 'Interactive 3D T-embedding; see the source code of this page at the link'
- link:    'https://github.com/lenis2000/homepage/blob/master/_simulations/domino_tilings/2025-03-28-t-emb-3d-json.cpp'
  txt: 'C++ code for the simulation with tunable scale parameter a (3D version)'
---


An illustration of the **T-embedding** of the Aztec diamond graph (parameter $$n$$), with **3D height** given by the imaginary part of the **O**-embedding. The $$(x,y)$$ coordinates come from $$ \mathrm{Re}(T), -\mathrm{Im}(T)$$, and the $$z$$ coordinate is $$\mathrm{Im}(O)$$.

Some references:
<ul>
    <li>
      <strong>Perfect t‑Embeddings of Uniformly Weighted Aztec Diamonds and Tower Graphs</strong><br>
      <em>Tomas Berggren, Matthew Nicoletti, Marianna Russkikh (2023, IMRN)</em><br>
      <a href="https://doi.org/10.1093/imrn/rnad299" target="_blank">DOI:10.1093/imrn/rnad299</a>
    </li>
    <li>
      <strong>Bipartite Dimer Model: Perfect t‑Embeddings and Lorentz‑minimal Surfaces</strong><br>
      <em>Dmitry Chelkak, Benoît Laslier, Marianna Russkikh (2021)</em><br>
      <a href="https://arxiv.org/abs/2109.06272" target="_blank">arXiv:2109.06272</a>
    </li>
    <li>
      <strong>Fluctuations in the Aztec Diamonds via a Lorentz‑minimal Surface</strong><br>
      <em>Dmitry Chelkak, Sanjay Ramassamy (2020)</em><br>
      <a href="https://arxiv.org/abs/2002.07540" target="_blank">arXiv:2002.07540</a>
    </li>
</ul>

<!-- Three.js and OrbitControls (adjust paths if needed) -->
<script src="/js/three.min.js"></script>
<script src="/js/OrbitControls.js"></script>

<!-- WASM/JS from our C++ code, compiled by emcc (adjust path if needed) -->
<script src="/js/2025-03-28-t-emb-3d-json.js"></script>

<div style="margin-bottom: 1em; font-size: 18px;">
  <label for="n-input">Aztec Diamond parameter \(n\) (1–200):</label>
  <input id="n-input" type="number" value="4" min="1" max="200" step="1" onchange="handleUpdate()">

  <label for="a-input" style="margin-left: 15px;">Doubly periodic parameter \(a\):</label>
  <input id="a-input" type="number" value="1.0" min="0.1" max="10" step="0.1" onchange="handleUpdate()">

  <button id="update-btn">Update</button>

  <br><label for="show-labels" style="margin-top: 15px;">
    <input id="show-labels" type="checkbox"> Show vertex labels
  </label>

  <label for="label-scale" style="margin-left: 15px;">Label size:</label>
  <input id="label-scale" type="range" min="1" max="70" step="1" value="30" style="width: 100px; vertical-align: middle;">
  <div style="margin-top: 10px;">
      <label>Camera movement:</label>
      <button id="move-left-btn" style="padding: 2px 8px; margin: 0 5px; font-size: 14px; vertical-align: middle;">←</button>
      <button id="move-up-btn" style="padding: 2px 8px; margin: 0 5px; font-size: 14px; vertical-align: middle;">↑</button>
      <button id="move-down-btn" style="padding: 2px 8px; margin: 0 5px; font-size: 14px; vertical-align: middle;">↓</button>
      <button id="move-right-btn" style="padding: 2px 8px; margin: 0 5px; font-size: 14px; vertical-align: middle;">→</button>
      <button id="reset-view-btn" style="padding: 2px 8px; margin: 0 5px; font-size: 14px; vertical-align: middle;">Reset View</button>
  </div>
</div>

<!-- Container for the 3D canvas -->
<div id="three-container" style="width: 100%; height: 80vh;"></div>

<script>
/*
  We'll call doTembJSONwithA(n, a) from the WASM to get a JSON with T and O arrays.
  Then build a 3D geometry using:
    x = Re(T)
    y = -Im(T)
    z = Im(O)
  We'll create line segments for adjacency among T-vertices, small spheres as T-vertices
  (with a styled radius), and optional labels.
*/

Module.onRuntimeInitialized = async function() {
  // Wrap the WASM exports
  const doTembJSONwithA = Module.cwrap('doTembJSONwithA', 'number', ['number','number'], {async: true});
  const freeString = Module.cwrap('freeString', null, ['number']);

  // Helper: call the WASM function, parse JSON
  async function getTandOarrays(n, a) {
    const ptr = await doTembJSONwithA(n, a);
    const jsonStr = Module.UTF8ToString(ptr);
    freeString(ptr);
    return JSON.parse(jsonStr); // { T: [...], O: [...], B: [...] }
  }

  // Build T-edges with the same special boundary/corner logic as in 2D code
  function buildEdges(vertices, n) {
    const indexMap = new Map();
    vertices.forEach((v, idx) => {
      indexMap.set(`${v.k},${v.j}`, idx);
    });

    const edges = [];
    const neighborSteps = [
      { dk:  1, dj:  0 },
      { dk: -1, dj:  0 },
      { dk:  0, dj:  1 },
      { dk:  0, dj: -1 },
    ];
    const isBoundary = (k,j) => (Math.abs(k) + Math.abs(j) === n);

    // Add special edges connecting corners and boundary
    const specialEdges = [
      // corners
      { from: { k: 0,  j: n },  to: { k: n,  j: 0 } },
      { from: { k: 0,  j: -n }, to: { k: n,  j: 0 } },
      { from: { k: 0,  j: -n }, to: { k: -n, j: 0 } },
      { from: { k: 0,  j: n },  to: { k: -n, j: 0 } },
      // direct connections among boundary
      { from: { k: n-1,   j: 0 },  to: { k: n,    j: 0 } },
      { from: { k: 0,     j: n-1 },to: { k: 0,    j: n } },
      { from: { k: -(n-1),j: 0 },  to: { k: -n,   j: 0 } },
      { from: { k: 0,     j: -(n-1) },to: { k: 0, j: -n } },
    ];

    specialEdges.forEach(s => {
      const fromKey = `${s.from.k},${s.from.j}`;
      const toKey   = `${s.to.k},${s.to.j}`;
      if (indexMap.has(fromKey) && indexMap.has(toKey)) {
        const i1 = indexMap.get(fromKey);
        const i2 = indexMap.get(toKey);
        edges.push([Math.min(i1, i2), Math.max(i1, i2)]);
      }
    });

    // Add edges for direct neighbor steps, skipping boundary->interior mismatch
    vertices.forEach((v, idx) => {
      neighborSteps.forEach(step => {
        const nk = v.k + step.dk;
        const nj = v.j + step.dj;
        const key = `${nk},${nj}`;
        if (!indexMap.has(key)) return;
        const nbrIdx = indexMap.get(key);

        const oneIsBoundary = isBoundary(v.k, v.j) ^ isBoundary(nk, nj);
        if (!oneIsBoundary) {
          if (nbrIdx > idx) {
            edges.push([idx, nbrIdx]);
          }
        }
      });
    });

    return edges;
  }

  // Add a ring of edges around boundary where |k|+|j|=n-1
  function addBoundaryRingEdges(vertices, edges, n) {
    const boundaryIndices = [];
    vertices.forEach((v, idx) => {
      if (Math.abs(v.k) + Math.abs(v.j) === n-1) {
        boundaryIndices.push(idx);
      }
    });

    boundaryIndices.sort((iA, iB) => {
      const vA = vertices[iA];
      const vB = vertices[iB];
      const aA = Math.atan2(vA.im, vA.re);
      const aB = Math.atan2(vB.im, vB.re);
      return aA - aB;
    });

    for (let i = 0; i < boundaryIndices.length; i++) {
      const iA = boundaryIndices[i];
      const iB = boundaryIndices[(i+1) % boundaryIndices.length];
      edges.push([Math.min(iA, iB), Math.max(iA, iB)]);
    }
  }

  let scene, camera, renderer, controls;
  let lineGroup, sphereGroup, labelGroup, faceGroup;
  let zoomFactor = 0.95;
  let sceneScale = 1.0; // Track the overall scene scale

  init3D();
  handleUpdate(); // We'll also call this after randomizing n,a at DOMContentLoaded


  function init3D() {
    const container = document.getElementById('three-container');
    const width  = container.clientWidth;
    const height = container.clientHeight;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    camera = new THREE.PerspectiveCamera(45, width / height, 0.0001, 10000);
    camera.position.set(0, 0, 3);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(width, height);
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.minDistance = 0.0001;
    controls.maxDistance = 5000;
    controls.enableZoom = true; // Enable zoom with mouse/trackpad

    window.addEventListener('resize', onWindowResize, false);
    animate();
  }

  function onWindowResize() {
    const container = document.getElementById('three-container');
    const width  = container.clientWidth;
    const height = container.clientHeight;

    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();

    // Update label size based on camera distance and user slider
    if (labelGroup) {
      const cameraDistance = camera.position.distanceTo(new THREE.Vector3(0,0,0));
      const userScaleFactor = parseFloat(document.getElementById('label-scale').value || "1");

      labelGroup.children.forEach(sprite => {
        if (sprite.visible) {
          // Adjust label size based on distance and user preference
          const baseSpriteScale = 0.005;
          const distanceScaleFactor = Math.max(0.5, Math.min(2.0, cameraDistance / 3.0));
          const width = sprite.scale.x / (baseSpriteScale * sprite.userData.lastScaleFactor || 1);
          const height = sprite.scale.y / (baseSpriteScale * sprite.userData.lastScaleFactor || 1);

          const combinedScaleFactor = distanceScaleFactor * userScaleFactor;
          sprite.scale.set(
            width * baseSpriteScale * combinedScaleFactor,
            height * baseSpriteScale * combinedScaleFactor,
            1
          );

          // Remember the last scale factor we applied
          sprite.userData.lastScaleFactor = combinedScaleFactor;
        }
      });
    }

    renderer.render(scene, camera);
  }

  // Create a sprite with text (for labels)
  function createTextSprite(message) {
    // Basic canvas-based sprite
    const fontSize = 24;  // Smaller font size
    const borderThickness = 2;  // Thinner border
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = `${fontSize}px Arial`;

    const textWidth = ctx.measureText(message).width;
    // set canvas size based on text
    canvas.width = textWidth + borderThickness*2;
    canvas.height = fontSize + borderThickness*2;

    // re-apply font since canvas was resized
    ctx.font = `${fontSize}px Arial`;

    // background color - more transparent
    ctx.fillStyle = 'rgba(0,0,255,0.4)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // text color
    ctx.fillStyle = 'white';
    ctx.textBaseline = 'top';
    ctx.fillText(message, borderThickness, borderThickness);

    const texture = new THREE.Texture(canvas);
    texture.needsUpdate = true;

    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMaterial);
    // scale so text is very small in 3D:
    const scaleFactor = 0.005;  // Smaller scale factor
    sprite.scale.set(canvas.width * scaleFactor, canvas.height * scaleFactor, 1);

    return sprite;
  }

  async function handleUpdate() {
    const nVal = parseInt(document.getElementById("n-input").value, 10);
    const aVal = parseFloat(document.getElementById("a-input").value);

    if (nVal < 1 || nVal > 200) {
      alert("Please pick integer n in [1, 200].");
      return;
    }
    if (aVal <= 0) {
      alert("Parameter a must be positive!");
      return;
    }

    let data;
    try {
      data = await getTandOarrays(nVal, aVal); // { T: [...], O: [...], B: [...] }
    } catch (e) {
      console.error("Error from doTembJSONwithA:", e);
      return;
    }

    const Tvertices = data.T;
    const OImMap = new Map();
    data.O.forEach(o => {
      OImMap.set(`${o.k},${o.j}`, -o.im);
    });

    const Tedges = buildEdges(Tvertices, nVal);
    addBoundaryRingEdges(Tvertices, Tedges, nVal);

    // Reset scene scale when loading new data
    sceneScale = 1.0;

    // Remove old geometry
    if (lineGroup) {
      scene.remove(lineGroup);
      lineGroup.children.forEach((child)=>child.geometry.dispose());
    }
    if (sphereGroup) {
      scene.remove(sphereGroup);
      sphereGroup.children.forEach((child)=>child.geometry.dispose());
    }
    if (faceGroup) {
      scene.remove(faceGroup);
      faceGroup.children.forEach((child)=>child.geometry.dispose());
    }
    if (labelGroup) {
      scene.remove(labelGroup);
      labelGroup.children.forEach((child)=>child.material?.dispose?.());
    }

    // 1) Lines
    lineGroup = new THREE.Group();
    {
      const material = new THREE.LineBasicMaterial({ color: 0x000000 });
      Tedges.forEach(edge => {
        const i1 = edge[0];
        const i2 = edge[1];
        const v1 = Tvertices[i1];
        const v2 = Tvertices[i2];

        const z1 = OImMap.has(`${v1.k},${v1.j}`) ? OImMap.get(`${v1.k},${v1.j}`) : 0;
        const z2 = OImMap.has(`${v2.k},${v2.j}`) ? OImMap.get(`${v2.k},${v2.j}`) : 0;

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array([
          v1.re, -v1.im, z1,
          v2.re, -v2.im, z2
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const line = new THREE.Line(geometry, material);
        lineGroup.add(line);
      });
    }
    scene.add(lineGroup);

    // 2) Spheres for vertices
    sphereGroup = new THREE.Group();
    {
      // Styled sphere radius
      const sphereGeom = new THREE.SphereGeometry(0.0005, 16, 16);
      const sphereMat  = new THREE.MeshBasicMaterial({ color: 0x000000 });

      Tvertices.forEach(v => {
        const z = OImMap.has(`${v.k},${v.j}`) ? OImMap.get(`${v.k},${v.j}`) : 0;
        // Skip any point that might be at (0,0) in O's imaginary sense
        if (Math.abs(z) < 1e-10) return;
        const mesh = new THREE.Mesh(sphereGeom, sphereMat);
        mesh.position.set(v.re, -v.im, z);
        sphereGroup.add(mesh);
      });
    }
    scene.add(sphereGroup);
    
    // 3) Polygon faces - find and create faces using the edges
    faceGroup = new THREE.Group();
    {
      // Create a function to find cycles in the graph - focusing on 4-cycles
      // which are likely the faces in an Aztec diamond
      function findFaces(vertices, edges) {
        // We'll find all 4-cycles (squares) in the graph
        const faces = [];
        const adjacencyList = new Map();
        
        // Create adjacency list from edges
        vertices.forEach((_, idx) => {
          adjacencyList.set(idx, []);
        });
        
        edges.forEach(edge => {
          const [v1, v2] = edge;
          adjacencyList.get(v1).push(v2);
          adjacencyList.get(v2).push(v1);
        });
        
        // For each edge, try to find 4-cycles containing it
        edges.forEach(edge => {
          const [start, neighbor] = edge;
          
          // For each neighbor of the first vertex
          adjacencyList.get(neighbor).forEach(secondNeighbor => {
            // Skip going back to start
            if (secondNeighbor === start) return;
            
            // For each neighbor of the second neighbor
            adjacencyList.get(secondNeighbor).forEach(thirdNeighbor => {
              // Skip going back to neighbor
              if (thirdNeighbor === neighbor) return;
              
              // Check if third neighbor connects back to start
              if (adjacencyList.get(thirdNeighbor).includes(start)) {
                // Found a 4-cycle: start -> neighbor -> secondNeighbor -> thirdNeighbor -> start
                const cycle = [start, neighbor, secondNeighbor, thirdNeighbor];
                
                // Check if this cycle contains any corner or boundary vertices (n,0), (0,n), etc.
                const containsCornerOrBoundary = cycle.some(vertexIdx => {
                  const v = Tvertices[vertexIdx];
                  // Check if it's a corner or boundary vertex
                  return (v.k === 0 && Math.abs(v.j) === nVal) || 
                         (v.j === 0 && Math.abs(v.k) === nVal) ||
                         (Math.abs(v.k) + Math.abs(v.j) === nVal);
                });
                
                // Skip faces with corner or boundary vertices
                if (containsCornerOrBoundary) {
                  return;
                }
                
                // Sort the cycle to get a canonical representation
                const canonicalCycle = [...cycle].sort().join(',');
                
                // Check if we've already found this cycle
                const isDuplicate = faces.some(face => {
                  const sortedFace = [...face].sort().join(',');
                  return sortedFace === canonicalCycle;
                });
                
                if (!isDuplicate) {
                  faces.push(cycle);
                }
              }
            });
          });
        });
        
        return faces;
      }
      
      // Find faces in the graph
      const faces = findFaces(Tvertices, Tedges);
      
      // Create a semi-transparent material for faces
      const faceMaterial = new THREE.MeshBasicMaterial({
        color: 0x3366cc,
        transparent: true,
        opacity: 0.25,
        side: THREE.DoubleSide
      });
      
      // Create a mesh for each face
      faces.forEach(face => {
        const positions = [];
        
        // Get positions for each vertex in this face
        face.forEach(vertexIndex => {
          const v = Tvertices[vertexIndex];
          const z = OImMap.has(`${v.k},${v.j}`) ? OImMap.get(`${v.k},${v.j}`) : 0;
          positions.push(v.re, -v.im, z);
        });
        
        // Create geometry
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        
        // Add indices for triangulation (assuming 4-vertex faces)
        if (face.length === 4) {
          geometry.setIndex([0, 1, 2, 0, 2, 3]); // Two triangles
        } else if (face.length === 3) {
          // Triangle doesn't need triangulation
        } else {
          // For faces with more than 4 vertices, use fan triangulation
          const indices = [];
          for (let i = 1; i < face.length - 1; i++) {
            indices.push(0, i, i + 1);
          }
          geometry.setIndex(indices);
        }
        
        // Create mesh and add to group
        const mesh = new THREE.Mesh(geometry, faceMaterial);
        faceGroup.add(mesh);
      });
    }
    scene.add(faceGroup);

    // 4) Optional labels
    labelGroup = new THREE.Group();
    const showLabels = document.getElementById('show-labels').checked;

    Tvertices.forEach(v => {
      // replicate the "interesting" logic from the 2D code
      if (
        Math.abs(v.k) + Math.abs(v.j) < nVal ||
        (v.k === 0 && Math.abs(v.j) === nVal) ||
        (v.j === 0 && Math.abs(v.k) === nVal)
      ) {
        const z = OImMap.has(`${v.k},${v.j}`) ? OImMap.get(`${v.k},${v.j}`) : 0;
        // We'll create a label even if z=0, but let's position it slightly above
        const labelSprite = createTextSprite(`${v.k},${v.j}`);
        labelSprite.position.set(v.re, -v.im, z + 0.01);
        labelSprite.visible = showLabels;
        labelGroup.add(labelSprite);
      }
    });
    scene.add(labelGroup);
  }

  // Toggle label visibility when checkbox changes
  document.getElementById('show-labels').addEventListener('change', function() {
    if (!labelGroup) return;
    labelGroup.children.forEach(sprite => {
      sprite.visible = this.checked;
    });
  });

  // Update labels when scale slider changes
  document.getElementById('label-scale').addEventListener('input', function() {
    // No need to do anything here as the animate loop will handle scaling
  });

  // Make handleUpdate available globally
  window.handleUpdate = handleUpdate;

  // Hook the "Update" button
  document.getElementById("update-btn").addEventListener("click", handleUpdate);

  // Reset view button handler

  document.getElementById("reset-view-btn").addEventListener("click", function() {
    // Reset camera to initial position and reset scene scale
    camera.position.set(0, 0, 3);
    camera.lookAt(0, 0, 0);
    camera.near = 0.0001; // Reset near clipping plane
    camera.updateProjectionMatrix();

    // Reset scene scale
    sceneScale = 1.0;
    if (lineGroup) lineGroup.scale.set(sceneScale, sceneScale, sceneScale);
    if (sphereGroup) sphereGroup.scale.set(sceneScale, sceneScale, sceneScale);
    if (faceGroup) faceGroup.scale.set(sceneScale, sceneScale, sceneScale);
    if (labelGroup) labelGroup.scale.set(sceneScale, sceneScale, sceneScale);

    controls.reset();
  });

  // Camera movement controls
  document.getElementById("move-up-btn").addEventListener("click", function() {
    // Move camera up relative to current view
    const moveAmount = 0.1 * camera.position.distanceTo(controls.target);
    const upVector = new THREE.Vector3(0, 1, 0);
    upVector.applyQuaternion(camera.quaternion);
    camera.position.addScaledVector(upVector, moveAmount);
    controls.target.addScaledVector(upVector, moveAmount);
    controls.update();
  });

  document.getElementById("move-down-btn").addEventListener("click", function() {
    // Move camera down relative to current view
    const moveAmount = 0.1 * camera.position.distanceTo(controls.target);
    const upVector = new THREE.Vector3(0, 1, 0);
    upVector.applyQuaternion(camera.quaternion);
    camera.position.addScaledVector(upVector, -moveAmount);
    controls.target.addScaledVector(upVector, -moveAmount);
    controls.update();
  });

  document.getElementById("move-left-btn").addEventListener("click", function() {
    // Move camera left relative to current view
    const moveAmount = 0.1 * camera.position.distanceTo(controls.target);
    const rightVector = new THREE.Vector3(1, 0, 0);
    rightVector.applyQuaternion(camera.quaternion);
    camera.position.addScaledVector(rightVector, -moveAmount);
    controls.target.addScaledVector(rightVector, -moveAmount);
    controls.update();
  });

  document.getElementById("move-right-btn").addEventListener("click", function() {
    // Move camera right relative to current view
    const moveAmount = 0.1 * camera.position.distanceTo(controls.target);
    const rightVector = new THREE.Vector3(1, 0, 0);
    rightVector.applyQuaternion(camera.quaternion);
    camera.position.addScaledVector(rightVector, moveAmount);
    controls.target.addScaledVector(rightVector, moveAmount);
    controls.update();
  });

  // Randomize n (2..20) and a (0.2..1) on page load
  document.addEventListener("DOMContentLoaded", function() {
    const nRand = Math.floor(Math.random() * (20 - 2 + 1)) + 2; // 2..20
    const aRand = (Math.random() * (1 - 0.2) + 0.2).toFixed(1); // 0.2..1
    document.getElementById('n-input').value = nRand;
    document.getElementById('a-input').value = aRand;
    handleUpdate();

    // Add keyboard controls for zooming and navigation
    window.addEventListener('keydown', function(event) {
      const moveAmount = 0.1 * camera.position.distanceTo(controls.target);

      // Arrow keys for camera movement
      if (event.key === 'ArrowUp') {
        const upVector = new THREE.Vector3(0, 1, 0);
        upVector.applyQuaternion(camera.quaternion);
        camera.position.addScaledVector(upVector, moveAmount);
        controls.target.addScaledVector(upVector, moveAmount);
        controls.update();
      }
      else if (event.key === 'ArrowDown') {
        const upVector = new THREE.Vector3(0, 1, 0);
        upVector.applyQuaternion(camera.quaternion);
        camera.position.addScaledVector(upVector, -moveAmount);
        controls.target.addScaledVector(upVector, -moveAmount);
        controls.update();
      }
      else if (event.key === 'ArrowLeft') {
        const rightVector = new THREE.Vector3(1, 0, 0);
        rightVector.applyQuaternion(camera.quaternion);
        camera.position.addScaledVector(rightVector, -moveAmount);
        controls.target.addScaledVector(rightVector, -moveAmount);
        controls.update();
      }
      else if (event.key === 'ArrowRight') {
        const rightVector = new THREE.Vector3(1, 0, 0);
        rightVector.applyQuaternion(camera.quaternion);
        camera.position.addScaledVector(rightVector, moveAmount);
        controls.target.addScaledVector(rightVector, moveAmount);
        controls.update();
      }
      // 'R' key to reset view
      else if (event.key === 'r' || event.key === 'R') {
        camera.position.set(0, 0, 3);
        camera.lookAt(0, 0, 0);
        camera.near = 0.0001;
        camera.updateProjectionMatrix();

        sceneScale = 1.0;
        if (lineGroup) lineGroup.scale.set(sceneScale, sceneScale, sceneScale);
        if (sphereGroup) sphereGroup.scale.set(sceneScale, sceneScale, sceneScale);
        if (faceGroup) faceGroup.scale.set(sceneScale, sceneScale, sceneScale);
        if (labelGroup) labelGroup.scale.set(sceneScale, sceneScale, sceneScale);

        controls.reset();
      }
    });
  });
};
</script>
