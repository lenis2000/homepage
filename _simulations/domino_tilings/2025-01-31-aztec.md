---
title: Aztec Diamond Random Tiling
model: domin-_tilings
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/random-matrices/2025-01-31-aztec.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/random-matrices/2025-01-31-aztec.cpp'
    txt: 'C++ code for the simulation'
---

<script src="{{site.url}}/js/d3.v7.min.js"></script>
<script src="{{site.url}}/js/2025-01-31-aztec.js"></script>

<!-- Container for visualizations -->
<div id="aztecHeatmap"></div>
<div id="aztecDominoes" style="margin-top:30px;"></div>

<script>
(function(){
  // 1) Load the WASM module, then run the simulation
  //    This portion depends on how you normally instantiate your WASM exports.
  //    If your environment differs, you might need to adapt the usage of Module, etc.

  // On window load (or DOM load)
  document.addEventListener("DOMContentLoaded", function() {
    // We pick an Aztec dimension here, e.g. N=100
    const N = 100;
    // Call into the WASM to generate
    Module.ccall('computeAztec', 'number', ['number'], [N]);

    // Grab the final matrix from the WASM heap
    const dim = Module.ccall('getCurrentN', 'number');
    const size = 2 * dim;
    const ptrData = Module.ccall('getAztecData', 'number');
    const aztecData = new Float64Array(Module.HEAPF64.buffer, ptrData, size*size);

    // Convert to a 2D array for easier indexing in JS
    const matrix = [];
    for(let i = 0; i < size; i++){
      matrix[i] = [];
      for(let j = 0; j < size; j++){
        matrix[i][j] = aztecData[i*size + j];
      }
    }

    // 2) Draw the original "heatmap" for backward compatibility
    drawHeatmap();

    // 3) Draw the new colored-domino Aztec diamond
    drawDominoes(matrix);
  });

  // -----------------------------------------------------------------------
  // Original heatmap function (unchanged)
  function drawHeatmap(){
    const heatMapDim = Module.ccall('getHeatMapDim','number');
    const ptrMap = Module.ccall('getHeatMapData','number');
    const rawMap = new Uint8Array(Module.HEAPU8.buffer, ptrMap, 4*heatMapDim*heatMapDim);

    const canvas = document.createElement('canvas');
    canvas.width = heatMapDim;
    canvas.height = heatMapDim;
    document.getElementById('aztecHeatmap').appendChild(canvas);

    const ctx = canvas.getContext('2d');
    const imgData = ctx.createImageData(heatMapDim, heatMapDim);
    for(let i=0; i<heatMapDim*heatMapDim; i++){
      imgData.data[4*i+0] = rawMap[4*i+0];
      imgData.data[4*i+1] = rawMap[4*i+1];
      imgData.data[4*i+2] = rawMap[4*i+2];
      imgData.data[4*i+3] = rawMap[4*i+3];
    }
    ctx.putImageData(imgData, 0, 0);
  }

  // -----------------------------------------------------------------------
  // New function to render dominoes in a diamond layout with color-coding
  function drawDominoes(matrix){
    const size = matrix.length;

    // We'll create an SVG for the diamond drawing
    const width = 800, height = 800;
    const svg = d3.select("#aztecDominoes")
      .append("svg")
      .attr("width", width)
      .attr("height", height);

    // For better centering, shift the diamond near the middle:
    const offsetX = width/2;
    const offsetY = height/2;

    // The Python script placed dominos at (x, y) = (j-i, size+1-(i+j)), etc.
    // Then used a patch size that depends on parity of i/j. We'll replicate:

    for(let i=0; i<size; i++){
      for(let j=0; j<size; j++){
        if(matrix[i][j] === 1){
          // Compute diamond coordinates
          let x = (j - i);
          let y = (size + 1 - (i + j));

          // Determine color by parity
          let color;
          if(i % 2 === 1 && j % 2 === 1){
            color = "green";
          }
          else if(i % 2 === 1 && j % 2 === 0){
            color = "blue";
          }
          else if(i % 2 === 0 && j % 2 === 0){
            color = "red";
          }
          else {
            color = "yellow";
          }

          // Domino "patch" size:
          // For i%2==1 & j%2==1 or i%2==0 & j%2==0, Python used (4 x 2) rectangles.
          // For the other parities, it used (2 x 4). We also shift them slightly.
          let w, h, shiftX=0, shiftY=0;
          const largeDomino = ((i%2 === 0 && j%2 === 0) || (i%2 === 1 && j%2 === 1));

          if(largeDomino){
            w = 4; h = 2;
            shiftX = -2; shiftY = -1;
          } else {
            w = 2; h = 4;
            shiftX = -1; shiftY = -2;
          }

          // Scale everything so it’s visible
          // e.g., each “unit” is 4 or 5 pixels in the final coordinate system
          const scale = 5;
          // x and y in Python were top-left corners for the rectangle.
          // We'll apply an offset so the shape is near the center.
          const px = offsetX + scale * (x + shiftX);
          // In Python's coordinate system, increasing y goes upward,
          // but in SVG, increasing y goes downward. We can invert sign or offset:
          const py = offsetY - scale * (y + shiftY);

          svg.append("rect")
            .attr("x", px)
            .attr("y", py)
            .attr("width", scale * w)
            .attr("height", scale * h)
            .style("fill", color);
        }
      }
    }
  }
})();
</script>
