---
title: Aztec Diamond Random Tiling
model: domin-_tilings
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/random-matrices/2025-01-31-aztec.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/random-matrices/2025-01-31-aztec.cpp'
    txt: 'C++ code for the simulation'
---

<!-- 1) Include Bootstrap for responsive layouts.
     (You can adjust or omit the version/CDN as needed.) -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />

<!-- 2) Load D3 (required for drawing) and the existing WASM JS (unused for now). -->
<script src="{{site.url}}/js/d3.v7.min.js"></script>
<script src="{{site.url}}/js/2025-01-31-aztec.js"></script>

<!-- 3) A responsive container using Bootstrap. -->
<div class="container-fluid">
  <div class="row mt-3">
    <div class="col-12">
      <!-- Control row: input for N, plus button. -->
      <label for="aztecOrder">Aztec Diamond order (N):</label>
      <input type="number" id="aztecOrder" value="5" min="1" style="width:60px;" />
      <button class="btn btn-primary btn-sm" onclick="redrawAztecDiamond()">Draw</button>
    </div>
  </div>

  <div class="row mt-3">
    <div class="col-12">
      <!-- We'll place our SVG here. -->
      <div id="tilingContainer" class="w-100"></div>
    </div>
  </div>
</div>

<script>
/**
 * Check if (i, j) lies inside the Aztec diamond of order N:
 *   |i| + |j| <= N.
 */
function inAztecDiamond(i, j, N) {
  return (Math.abs(i) + Math.abs(j) <= N);
}

/**
 * Simple “greedy” pairing for a *faux* tiling.
 * For each square with (i+j) even, try to pair horizontally;
 * if not available, try vertically.
 */
function generateDominos(N) {
  const covered = new Set();
  const dominos = [];

  function key(i, j) { return `${i},${j}`; }

  for (let i = -N; i <= N; i++) {
    for (let j = -N; j <= N; j++) {
      if (!inAztecDiamond(i, j, N)) continue;
      const k = key(i, j);
      if (covered.has(k)) continue;

      if ((i + j) % 2 === 0) {
        // Try horizontally first
        if (inAztecDiamond(i, j+1, N) && !covered.has(key(i, j+1))) {
          dominos.push([[i, j], [i, j+1]]);
          covered.add(k).add(key(i, j+1));
        }
        // Else try vertically
        else if (inAztecDiamond(i+1, j, N) && !covered.has(key(i+1, j))) {
          dominos.push([[i, j], [i+1, j]]);
          covered.add(k).add(key(i+1, j));
        }
      }
    }
  }

  return dominos;
}

/**
 * Assign one of 4 colors based on orientation (horizontal vs vertical)
 * and parity to get a varied coloring.
 */
function getDominoColor(domino) {
  const [[i1, j1], [i2, j2]] = domino;
  if (i1 === i2) {
    // Horizontal
    return ((i1 + j1) % 4 === 0) ? "#e74c3c" : "#ff7960";
  } else {
    // Vertical
    return ((i1 + j1) % 4 === 0) ? "#3498db" : "#80c8ff";
  }
}

/**
 * Draw an Aztec diamond of order N into an SVG that always fills 100% width.
 * We use a 'viewBox' that covers [0..dim] x [0..dim], where dim = 2N+1.
 * Each square is 1 unit.
 */
function drawAztecDiamond(N) {
  const dominos = generateDominos(N);
  // Full bounding dimension in “diamond” coordinates
  const dim = 2 * N + 1;

  // Clear old SVG
  const container = d3.select("#tilingContainer");
  container.selectAll("svg").remove();

  // Create new SVG, scaled by viewBox.
  // The entire diamond fits in user-coords [0..dim], but we also push the diamond up so
  // that the bottom-left is at (0,0). We'll define x,y carefully below.
  const svg = container.append("svg")
    .attr("width", "100%")
    .attr("height", "auto")
    .attr("viewBox", `0 0 ${dim} ${dim}`)
    .attr("preserveAspectRatio", "xMidYMid meet")
    .style("border", "1px solid #ccc");

  // Place each domino as a rectangle.
  // Horizontal domino from (i,j) to (i,j+1):
  //   x = (j + N), y = (N - i),  width=2, height=1
  // Vertical domino from (i,j) to (i+1,j):
  //   x = (j + N), y = (N - i - 1), width=1, height=2
  svg.selectAll("rect.domino")
    .data(dominos)
    .enter()
    .append("rect")
      .attr("class", "domino")
      .attr("x", d => {
         const [[i1, j1], [i2, j2]] = d;
         // leftmost j
         const jMin = Math.min(j1, j2);
         return jMin + N;
       })
      .attr("y", d => {
         const [[i1, j1], [i2, j2]] = d;
         // top is max i => we invert i so y grows upward in the diamond
         const iMax = Math.max(i1, i2);
         // for horizontal, the rect is placed at y = N - i1
         // for vertical, the rectangle extends 2 units downward from iMax
         if (i1 === i2) {
           // horizontal
           return N - i1;
         } else {
           // vertical
           return N - iMax - 1;
         }
       })
      .attr("width", d => (d[0][0] === d[1][0]) ? 2 : 1 )   // 2 wide if horizontal
      .attr("height", d => (d[0][1] === d[1][1]) ? 2 : 1 ) // 2 tall if vertical
      .attr("fill", getDominoColor)
      .attr("stroke", "#555")
      .attr("stroke-width", 0.5);
}

/** Redraw button callback. */
function redrawAztecDiamond() {
  const N = +document.getElementById("aztecOrder").value;
  drawAztecDiamond(N);
}

/** Initial draw on page load. */
document.addEventListener("DOMContentLoaded", function() {
  drawAztecDiamond(5);
});
</script>

<!--
NOTES:
1) This uses Bootstrap’s `.container-fluid` and 100%-width SVG for a responsive layout.
2) The domino “size” is scaled by the SVG’s `viewBox`. If N grows, each square becomes smaller,
   yet the drawing continues to fill the same horizontal space.
3) The “tiling” is still a simple greedy pairing: for a true Aztec tiling, replace generateDominos(N).
4) Because the code keeps references to the existing WASM .js, you can integrate real
   random tilings or advanced logic without breaking layout or links.
-->
