---
title: Aztec Diamond
model: domino-tilings
author: 'Leonid Petrov'
code:
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/random-matrices/2025-01-31-Aztec.md'
    txt: 'This simulation is interactive, written in JavaScript, see the source code of this page at the link'
  - link: 'https://github.com/lenis2000/homepage/blob/master/_simulations/random-matrices/2025-01-31-Aztec.cpp'
    txt: 'C++ code for the simulation'
---

<script src="{{site.url}}/js/d3.v7.min.js"></script>
<script src="{{site.url}}/js/2025-01-31-Aztec.js"></script>

<div class="row">
  <div class="col-12">
    <p>
      Below is a simple visualization of an <strong>Aztec diamond</strong> of order <code>n</code>.
      The squares are computed in <code>C++</code>, compiled to <code>WebAssembly</code>, and displayed with <code>d3.js</code>.
      Currently it only draws the shape (the set of squares), but it can be extended to generate random or specific domino tilings.
    </p>
  </div>
</div>

<div class="row">
  <!-- Controls -->
  <div class="col-12 col-lg-8">
    <div class="controls mb-3">
      <label for="nInput">Aztec diamond order <code>n</code>:</label>
      <input id="nInput" type="range" min="1" max="15" step="1" value="4" />
      <span id="nValue">4</span>&nbsp;&nbsp;
      <button id="drawBtn" class="btn btn-primary">Draw Aztec Diamond</button>
    </div>
  </div>
</div>

<div class="row">
  <!-- The SVG container for the Aztec Diamond -->
  <div class="col-12">
    <svg id="aztecSvg" width="100%" style="min-height: 600px; border: 1px solid #ccc;"></svg>
  </div>
</div>

<script>
    // After WASM initialization, we can automatically generate the first shape.
    async function initWasmAztec() {
        try {
            await new Promise((resolve) => {
                if (ModuleAztec.ready) resolve();
                else ModuleAztec.onRuntimeInitialized = resolve;
            });

            // Draw an Aztec diamond for n=4 at startup
            document.getElementById("nInput").value = 4;
            document.getElementById("nValue").textContent = 4;
            drawAztecDiamond();
        } catch (error) {
            console.error("Failed to load WASM Aztec module:", error);
        }
    }

    function drawAztecDiamond() {
        const n = parseInt(document.getElementById("nInput").value, 10);
        // This calls into the C++ function: getAztecSquares(n)
        if (!ModuleAztec || !ModuleAztec._getAztecSquaresCount) return;

        ModuleAztec._generateAztecDiamond(n);
        const count = ModuleAztec._getAztecSquaresCount();
        const ptr   = ModuleAztec._getAztecSquaresPtr();

        // Each square is stored as 4 floats: (x1, y1, x2, y2)
        // We'll read them into a JS array of length (count * 4).
        const rawData = new Float32Array(ModuleAztec.HEAPF32.buffer, ptr, count * 4);

        // Convert to a more convenient array of objects
        const squares = [];
        for (let i = 0; i < count; i++) {
            const x1 = rawData[4*i];
            const y1 = rawData[4*i + 1];
            const x2 = rawData[4*i + 2];
            const y2 = rawData[4*i + 3];
            squares.push({ x1, y1, x2, y2 });
        }

        // Now draw them with d3
        const svg = d3.select("#aztecSvg");
        svg.selectAll("*").remove();

        // Determine bounding box
        let minX = d3.min(squares, d => d.x1);
        let maxX = d3.max(squares, d => d.x2);
        let minY = d3.min(squares, d => d.y1);
        let maxY = d3.max(squares, d => d.y2);

        // We'll build a scale to fit the squares nicely
        const width = svg.node().getBoundingClientRect().width;
        const height = svg.node().getBoundingClientRect().height;

        // Add a small margin
        const margin = 10;
        const scaleX = d3.scaleLinear()
                         .domain([minX, maxX])
                         .range([margin, width - margin]);
        const scaleY = d3.scaleLinear()
                         // Note: invert the Y range so that positive Y goes up
                         .domain([maxY, minY])
                         .range([margin, height - margin]);

        // We'll draw each square as a <rect>
        svg.selectAll("rect")
           .data(squares)
           .enter()
           .append("rect")
           .attr("x", d => scaleX(d.x1))
           .attr("y", d => scaleY(d.y2))  // d.y2 is top if we invert
           .attr("width", d => scaleX(d.x2) - scaleX(d.x1))
           .attr("height", d => scaleY(d.y1) - scaleY(d.y2))
           .attr("fill", "#0044aa")
           .attr("stroke", "#333")
           .attr("stroke-width", 0.5);
    }

    // Button + slider hooks
    document.getElementById("drawBtn").addEventListener("click", drawAztecDiamond);
    document.getElementById("nInput").addEventListener("input", (e) => {
        document.getElementById("nValue").textContent = e.target.value;
    });

    // Initialize WASM once the page has loaded
    initWasmAztec();
</script>
