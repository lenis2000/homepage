---
title: t-embeddding of an Aztec diamond graph
model: domino-tilings
author: 'Leonid Petrov'
code:
- link:    'https://github.com/lenis2000/homepage/blob/master/_simulations/domino_tilings/2025-03-25-t-emb.md'
  txt: 'This simulation is interactive, written in JavaScript; see the source code of this page at the link'
- link:    'https://github.com/lenis2000/homepage/blob/master/_simulations/domino_tilings/2025-03-25-t-emb.cpp'
  txt: 'C++ code for the simulation'
---


<style>
  /* Make the SVG fill the page; feel free to adjust */
  #t-emb-svg {
    width: 100%;
    height: 90vh;
    background: #fff;
  }

  /* Basic style for edges and vertices */
  .edge {
    stroke: black;
    stroke-width: 0.001px;
    fill: none;
  }
  .vertex {
    fill: black;
    stroke: none;
    r: 0.005; /* smaller default size for vertices */
  }
  .vertex:hover {
    fill: orange;
  }

  #controls {
    margin-bottom: 8px;
  }
  #progress {
    font-weight: bold;
    margin-bottom: 8px;
  }
</style>

<!-- Make sure d3.v7.min.js is loaded BEFORE the WASM script and this code -->
<!-- e.g. -->
<script src="/js/d3.v7.min.js"></script>
<script src="/js/2025-03-25-t-emb-json.js"></script>

<div id="controls">
  <label for="n-input">Aztec Diamond parameter n (1–111):</label>
  <input id="n-input" type="number" value="10" min="1" max="111" step="1">
  <button id="update-btn">Update</button>
</div>
<div id="progress"></div>

<svg id="t-emb-svg"></svg>

<script>
// The WebAssembly module from 2025-03-25-t-emb-json.js will define "Module".
// Wait for it to initialize, so we can call doTembJSON.
Module.onRuntimeInitialized = async function() {
  // Wrap the exported WASM functions
  const doTembJSON = Module.cwrap('doTembJSON', 'number', ['number'], {async: true});
  const freeString = Module.cwrap('freeString', null, ['number']);

  // We'll draw in #t-emb-svg
  const svg = d3.select("#t-emb-svg");
  const progressEl = document.getElementById("progress");

  // Helper: call doTembJSON(n), parse the JSON
  async function getTembedding(n) {
    const ptr = await doTembJSON(n);
    const jsonStr = Module.UTF8ToString(ptr);
    freeString(ptr);
    return JSON.parse(jsonStr); // { "T": [...], "O": [...] }
  }

  // Build edges in the Aztec diamond by connecting (k,j) to neighbors:
  //   (k±1,j) or (k,j±1)  if |k|+|j| <= n
  function buildEdges(Tvertices) {
    // Tvertices is array of {k, j, re, im}
    // 1) Create a Map from "k,j" to array index
    const indexMap = new Map();
    Tvertices.forEach((v, idx) => {
      indexMap.set(`${v.k},${v.j}`, idx);
    });

    // 2) For each vertex, try (±1,0), (0,±1)
    const edges = [];
    const neighborSteps = [
      { dk: 1, dj: 0 },
      { dk: -1, dj: 0 },
      { dk: 0, dj: 1 },
      { dk: 0, dj: -1 },
    ];

    Tvertices.forEach((v, idx) => {
      neighborSteps.forEach(step => {
        const nk = v.k + step.dk;
        const nj = v.j + step.dj;
        const key = `${nk},${nj}`;
        if (indexMap.has(key)) {
          const nbrIdx = indexMap.get(key);
          if (nbrIdx > idx) {
            edges.push([idx, nbrIdx]);
          }
        }
      });
    });
    return edges;
  }

  // Actually draw the T-embedded Aztec diamond
  async function updateVisualization(n) {
    progressEl.textContent = `Loading T-embedding for n=${n}...`;

    // Clear old elements
    svg.selectAll("*").remove();

    let data;
    try {
      data = await getTembedding(n);
    } catch (e) {
      console.error("Error calling doTembJSON:", e);
      progressEl.textContent = "Error fetching data from WASM.";
      return;
    }

    // data.T = array of { k, j, re, im }
    // We'll store that in Tvertices
    const Tvertices = data.T;

    // Build edges based on integer adjacency
    const edges = buildEdges(Tvertices);

    // Find bounding box in complex plane
    //  x = re,  y = im
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    Tvertices.forEach(pt => {
      const { re, im } = pt;
      if (re < minX) minX = re;
      if (re > maxX) maxX = re;
      if (im < minY) minY = im;
      if (im > maxY) maxY = im;
    });

    // Pad a bit
    const pad = 0.2;
    const w = maxX - minX;
    const h = maxY - minY;
    minX -= w*pad;  maxX += w*pad;
    minY -= h*pad;  maxY += h*pad;

    // Set the viewBox so the entire T-embedding fits
    // Note: y is flipped in standard SVG coords if you want "top=positive"
    svg.attr("viewBox", [minX, -maxY, (maxX - minX), (maxY - minY)].join(" "));

    // Draw edges
    svg.append("g")
      .selectAll("line.edge")
      .data(edges)
      .join("line")
      .attr("class", "edge")
      .attr("x1", d => Tvertices[d[0]].re)
      .attr("y1", d => -Tvertices[d[0]].im)
      .attr("x2", d => Tvertices[d[1]].re)
      .attr("y2", d => -Tvertices[d[1]].im);

    // Draw vertices (as small circles)
    const radius = Math.max(w, h) * 0.003; // scale radius for your taste
    svg.append("g")
      .selectAll("circle.vertex")
      .data(Tvertices)
      .join("circle")
      .attr("class", "vertex")
      .attr("r", radius)
      .attr("cx", d => d.re)
      .attr("cy", d => -d.im);

    progressEl.textContent =
      `Done: n=${n}, vertices=${Tvertices.length}, edges=${edges.length}`;
  }

  // Hook up the "Update" button
  document.getElementById("update-btn").addEventListener("click", () => {
    const nVal = parseInt(document.getElementById("n-input").value, 10);
    if (isNaN(nVal) || nVal < 1 || nVal > 111) {
      alert("Please pick integer 1–111.");
      return;
    }
    updateVisualization(nVal);
  });

  // Initial draw with n=10 (or any default)
  updateVisualization(10);
};
</script>
