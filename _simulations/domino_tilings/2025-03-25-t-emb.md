---
title: t-embedding of an Aztec diamond graph
model: domino-tilings
author: 'Leonid Petrov'
code:
- link:    'https://github.com/lenis2000/homepage/blob/master/_simulations/domino_tilings/2025-03-25-t-emb.md'
  txt: 'This simulation is interactive, written in JavaScript; see the source code of this page at the link'
- link:    'https://github.com/lenis2000/homepage/blob/master/_simulations/domino_tilings/2025-03-25-t-emb.cpp'
  txt: 'C++ code for the simulation'
---

An illustration of the T-embedding of an Aztec diamond graph.
Some references:
<ul>
    <li>
      <strong>Perfect t‑Embeddings of Uniformly Weighted Aztec Diamonds and Tower Graphs</strong><br>
      <em>Tomas Berggren, Matthew Nicoletti, Marianna Russkikh (2023, IMRN)</em><br>
      <a href="https://doi.org/10.1093/imrn/rnad299" target="_blank">DOI:10.1093/imrn/rnad299</a>
    </li>
    <li>
      <strong>Bipartite Dimer Model: Perfect t‑Embeddings and Lorentz‑minimal Surfaces</strong><br>
      <em>Dmitry Chelkak, Benoît Laslier, Marianna Russkikh (2021)</em><br>
      <a href="https://arxiv.org/abs/2109.06272" target="_blank">arXiv:2109.06272</a>
    </li>
    <li>
      <strong>Fluctuations in the Aztec Diamonds via a Lorentz‑minimal Surface</strong><br>
      <em>Dmitry Chelkak, Sanjay Ramassamy (2020)</em><br>
      <a href="https://arxiv.org/abs/2002.07540" target="_blank">arXiv:2002.07540</a>
    </li>
</ul>

<style>
  /* Fill the window; adjust as needed */
  #t-emb-svg {
    width: 100%;
    height: 90vh;
    background: #fff;
  }

  .edge {
    stroke: black;
    stroke-width: 0.001px;
    fill: none;
  }
  .vertex {
    fill: black;
    stroke: none;
    r: 0.001;
  }
  .vertex:hover {
    fill: orange;
  }

  .boundary {
    stroke: red;
    fill: none;
    stroke-width: 0.003;
  }

  #controls {
    margin-bottom: 8px;
  }
  #progress {
    font-weight: bold;
    margin-bottom: 8px;
  }
</style>

<!--
   Make sure d3.v7.min.js is loaded BEFORE the WASM script and this code.
   The WASM script is at /js/2025-03-25-t-emb-json.js.
   It defines "Module" which we'll use in the onRuntimeInitialized callback.
-->
<script src="/js/d3.v7.min.js"></script>
<script src="/js/2025-03-25-t-emb-json.js"></script>

<div id="controls">
  <label for="n-input">Aztec Diamond parameter n (0–200):</label>
  <input id="n-input" type="number" value="16" min="0" max="200" step="1">
  <button id="update-btn">Update</button>
</div>
<div id="progress"></div>

<!--
     We assign a fixed viewBox.
     We place a <g id="mainG"> inside so that we can zoom/pan the entire content.
-->
<svg id="t-emb-svg" viewBox="-2 -2 4 4">
  <g id="mainG"></g>
</svg>

<script>
/*
  Once the WASM module is ready, we can call doTembJSON(n) to obtain
  a JSON describing the T-embedding:
    {
      "T": [ {k, j, re, im}, ...],
      "O": [ ... ],
      "B": [ {re, im}, ... ]  // boundary
    }
  We'll draw it into #mainG, and attach a D3 zoom behavior to #t-emb-svg
  so the user can pan and zoom.
*/
Module.onRuntimeInitialized = async function() {
  // Wrap the exported WASM functions
  const doTembJSON = Module.cwrap('doTembJSON', 'number', ['number'], {async: true});
  const freeString = Module.cwrap('freeString', null, ['number']);

  const svg   = d3.select("#t-emb-svg");
  const mainG = d3.select("#mainG");
  const progressEl = document.getElementById("progress");

  // Set up zoom/pan behavior on the SVG, applying transformations to mainG
  const zoom = d3.zoom()
    .scaleExtent([0.5, 30]) // min and max zoom
    .on("zoom", (event) => {
      mainG.attr("transform", event.transform);
    });
  svg.call(zoom);

  // Helper: call doTembJSON(n) from the WASM, parse the returned JSON string
  async function getTembedding(n) {
    const ptr = await doTembJSON(n);
    const jsonStr = Module.UTF8ToString(ptr);
    freeString(ptr);
    return JSON.parse(jsonStr);
  }

  // Build the interior edges among T-vertices
  function buildEdges(Tvertices, n) {
    const indexMap = new Map();
    Tvertices.forEach((v, idx) => {
      indexMap.set(`${v.k},${v.j}`, idx);
    });

    const edges = [];
    const neighborSteps = [
      { dk:  1, dj:  0 },
      { dk: -1, dj:  0 },
      { dk:  0, dj:  1 },
      { dk:  0, dj: -1 },
    ];
    const isBoundary = (k,j) => (Math.abs(k)+Math.abs(j) === n);

    Tvertices.forEach((v, idx) => {
      neighborSteps.forEach(step => {
        const nk = v.k + step.dk;
        const nj = v.j + step.dj;
        const key = `${nk},${nj}`;
        if (!indexMap.has(key)) return;
        const nbrIdx = indexMap.get(key);

        // If exactly one endpoint is boundary and the other is interior, skip it
        const oneIsBoundary = isBoundary(v.k,v.j) ^ isBoundary(nk,nj);
        if (!oneIsBoundary) {
          // Avoid duplicating edges
          if (nbrIdx > idx) {
            edges.push([idx, nbrIdx]);
          }
        }
      });
    });
    return edges;
  }

  // Optionally connect boundary vertices in a ring (by angle order)
  function addBoundaryRingEdges(Tvertices, edges, n) {
    // gather indices of boundary T-vertices (the ring is at n-1 for T-embedding)
    const boundaryIndices = [];
    Tvertices.forEach((v, idx) => {
      if (Math.abs(v.k) + Math.abs(v.j) === n-1) {
        boundaryIndices.push(idx);
      }
    });
    // sort them by angle
    boundaryIndices.sort((iA, iB) => {
      const vA = Tvertices[iA];
      const vB = Tvertices[iB];
      const aA = Math.atan2(vA.im, vA.re);
      const aB = Math.atan2(vB.im, vB.re);
      return aA - aB;
    });
    // connect consecutive boundary vertices
    for (let i = 0; i < boundaryIndices.length; i++) {
      const iA = boundaryIndices[i];
      const iB = boundaryIndices[(i + 1) % boundaryIndices.length];
      edges.push([
        Math.min(iA, iB),
        Math.max(iA, iB)
      ]);
    }
  }

  // Actually draw the T-embedded Aztec diamond
  async function updateVisualization(n) {
    progressEl.textContent = `Loading T-embedding for n=${n}...`;
    // Remove old geometry, but keep mainG itself so the zoom/pan state is preserved
    mainG.selectAll("*").remove();

    let data;
    try {
      data = await getTembedding(n);
    } catch (e) {
      console.error("Error calling doTembJSON:", e);
      progressEl.textContent = "Error fetching data from WASM.";
      return;
    }

    // data has "T", "O", and "B"
    const Tvertices = data.T;  // array of {k, j, re, im}
    const boundary  = data.B;  // array of {re, im} (optional use)

    // Build edges and boundary ring edges
    const edges = buildEdges(Tvertices, n);
    addBoundaryRingEdges(Tvertices, edges, n);

    // 1) Draw interior edges
    mainG.append("g")
      .selectAll("line.edge")
      .data(edges)
      .join("line")
      .attr("class", "edge")
      .attr("x1", d => Tvertices[d[0]].re)
      .attr("y1", d => -Tvertices[d[0]].im)
      .attr("x2", d => Tvertices[d[1]].re)
      .attr("y2", d => -Tvertices[d[1]].im);

    // 2) Draw T-vertices
    //    Pick a small radius for them
    const r= 0.001;
    mainG.append("g")
      .selectAll("circle.vertex")
      .data(Tvertices)
      .join("circle")
      .attr("class", "vertex")
      .attr("r", r)
      .attr("cx", d => d.re)
      .attr("cy", d => -d.im);

    progressEl.textContent = `Done: n=${n}, T-vertices=${Tvertices.length}, edges=${edges.length}, boundary size=${boundary.length}`;
  }

  // Hook up the "Update" button
  document.getElementById("update-btn").addEventListener("click", handleUpdate);

  // Also update automatically when n-input changes
  document.getElementById("n-input").addEventListener("input", handleUpdate);

  function handleUpdate() {
    const nVal = parseInt(document.getElementById("n-input").value, 10);
    if (nVal < 0 || nVal > 200) {
      alert("Please pick integer n in [0, 200].");
      return;
    }
    updateVisualization(nVal);
  }

  // Initial visualization
  handleUpdate();
};
</script>
