---
layout: null
permalink: triangle/
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Does Chaos Hide the Truth? — Leonid Petrov</title>
    <meta name="description" content="An interactive data art piece where impossible geometry emerges from probabilistic truth. MCMC-sampled lozenge tilings anneal from chaos into a Penrose triangle.">
    <meta property="og:title" content="Does Chaos Hide the Truth?">
    <meta property="og:description" content="Impossible geometry emerges from probabilistic truth. An interactive data art piece by Leonid Petrov.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://lpetrov.cc/triangle/">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Does Chaos Hide the Truth?">
    <meta name="twitter:description" content="Impossible geometry emerges from probabilistic truth. An interactive data art piece by Leonid Petrov.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Didot', 'Bodoni MT', 'Noto Serif Display', 'Georgia', serif;
        }

        #canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: none;
        }

        /* Hook screen */
        #hook-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10;
        }

        #hook-screen .question {
            color: #fff;
            font-size: clamp(2rem, 5vw, 4rem);
            font-style: italic;
            font-weight: 300;
            letter-spacing: 0.12em;
            text-align: center;
            padding: 0 2rem;
            opacity: 0;
            animation: fadeIn 2.5s ease-out forwards;
        }

        #hook-bg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }

        #hook-screen .hint {
            color: rgba(255, 255, 255, 0.35);
            font-size: clamp(0.7rem, 1.5vw, 0.85rem);
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            font-weight: 300;
            letter-spacing: 0.35em;
            text-transform: uppercase;
            margin-top: 4rem;
            opacity: 0;
            animation: fadeIn 1s ease-out 2s forwards, pulse 3s ease-in-out 3s infinite;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.7; }
        }

        /* Caption */
        #caption {
            position: absolute;
            bottom: 10vh;
            left: 0; right: 0;
            text-align: center;
            color: rgba(255, 255, 255, 0.85);
            font-size: clamp(0.85rem, 1.8vw, 1.15rem);
            font-style: italic;
            font-weight: 300;
            letter-spacing: 0.18em;
            opacity: 0;
            transition: opacity 2.5s ease-in;
            pointer-events: none;
            z-index: 5;
        }

        #caption.visible {
            opacity: 1;
        }

        /* Entropy slider - gallery control */
        #controls {
            position: absolute;
            bottom: 4vh;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 1rem;
            opacity: 0;
            transition: opacity 1.5s ease-in;
            z-index: 5;
        }

        #controls.visible {
            opacity: 1;
        }

        #controls .slider-label {
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.55rem;
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.25em;
            font-weight: 300;
            white-space: nowrap;
        }

        #entropy {
            width: 200px;
            height: 1px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            cursor: pointer;
        }

        #entropy::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.3s ease, background 0.3s ease;
        }

        #entropy::-webkit-slider-thumb:hover {
            transform: scale(1.4);
            background: rgba(255, 255, 255, 0.9);
        }

        #entropy::-moz-range-thumb {
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.6);
            border: none;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Gallery attribution */
        #attribution {
            position: absolute;
            bottom: 1.2vh;
            right: 2vw;
            color: rgba(255, 255, 255, 0.18);
            font-size: 0.5rem;
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            font-weight: 300;
            letter-spacing: 0.15em;
            opacity: 0;
            transition: opacity 2s ease-in;
            pointer-events: none;
            z-index: 5;
        }

        #attribution.visible {
            opacity: 1;
        }

        /* Loading indicator */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            display: none;
            z-index: 15;
        }
    </style>
</head>
<body>
    <div id="hook-screen">
        <canvas id="hook-bg"></canvas>
        <p class="question">"Does Chaos Hide the Truth?"</p>
        <p class="hint">Enter</p>
    </div>

    <canvas id="canvas"></canvas>

    <div id="caption">Local Truth, Global Paradox</div>

    <div id="controls">
        <span class="slider-label">Order</span>
        <input type="range" id="entropy" min="0" max="100" value="0" aria-label="Entropy: Order to Chaos">
        <span class="slider-label">Chaos</span>
    </div>

    <div id="attribution">Leonid Petrov &middot; Does Chaos Hide the Truth? &middot; 2026</div>

    <div id="loading">Loading...</div>

    <script src="/js/2025-11-28-ultimate-lozenge.js"></script>
    <script>
    (function() {
        'use strict';

        // ========================================================================
        // HOOK BACKGROUND — faint drifting lozenges
        // ========================================================================
        const hookBg = document.getElementById('hook-bg');
        const hookCtx = hookBg.getContext('2d');
        let hookAnimId = null;

        function initHookBg() {
            const dpr = window.devicePixelRatio || 1;
            const w = window.innerWidth;
            const h = window.innerHeight;
            hookBg.width = w * dpr;
            hookBg.height = h * dpr;
            hookCtx.scale(dpr, dpr);
        }

        // Generate a set of slowly drifting lozenge particles
        const NUM_PARTICLES = 24;
        const particles = [];
        function seedParticles() {
            particles.length = 0;
            const w = window.innerWidth;
            const h = window.innerHeight;
            for (let i = 0; i < NUM_PARTICLES; i++) {
                particles.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    size: 8 + Math.random() * 20,
                    rotation: Math.random() * Math.PI * 2,
                    drift: 0.08 + Math.random() * 0.15,
                    rotSpeed: (Math.random() - 0.5) * 0.003,
                    alpha: 0.02 + Math.random() * 0.04
                });
            }
        }

        function drawLozenge(cx, cy, size, rotation, alpha) {
            const aspect = 0.58; // lozenge aspect ratio
            hookCtx.save();
            hookCtx.translate(cx, cy);
            hookCtx.rotate(rotation);
            hookCtx.beginPath();
            hookCtx.moveTo(0, -size);
            hookCtx.lineTo(size * aspect, 0);
            hookCtx.lineTo(0, size);
            hookCtx.lineTo(-size * aspect, 0);
            hookCtx.closePath();
            hookCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            hookCtx.fill();
            hookCtx.restore();
        }

        function animateHookBg() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            hookCtx.clearRect(0, 0, w, h);

            for (const p of particles) {
                p.y -= p.drift;
                p.rotation += p.rotSpeed;
                // Wrap around
                if (p.y < -p.size * 2) {
                    p.y = h + p.size * 2;
                    p.x = Math.random() * w;
                }
                drawLozenge(p.x, p.y, p.size, p.rotation, p.alpha);
            }
            hookAnimId = requestAnimationFrame(animateHookBg);
        }

        function startHookBg() {
            initHookBg();
            seedParticles();
            animateHookBg();
        }

        function stopHookBg() {
            if (hookAnimId) {
                cancelAnimationFrame(hookAnimId);
                hookAnimId = null;
            }
        }

        // ========================================================================
        // CONFIGURATION
        // ========================================================================
        // Sophisticated palette — warm light, cool shadow for 3D depth
        const LOZENGE_PALETTE = [
            { light: '#EDE8E0', dark: '#E0DBD3' },  // Type 0 (top): warm cream
            { light: '#A0ADB8', dark: '#8A97A2' },  // Type 1 (right): cool blue-gray
            { light: '#CCC0B0', dark: '#B8AC9C' }   // Type 2 (left): warm taupe
        ];
        const SCALE_ITERATIONS = 4; // 12 * 4^4 = 3072 triangles
        const STEPS_PER_FRAME = 5000;

        // Narrative Timeline
        const CHAOS_DURATION = 4000;    // Stay chaotic for 4s
        const ANNEAL_DURATION = 15000;  // Slowly freeze for 15s

        const Q_CHAOS = 1.0;    // Maximum entropy
        const Q_ORDER = 50.0;   // Maximum order

        // Base Penrose triangle shape (12 triangles) - creates hole with winding
        const BASE_SHAPE = [
            { n: -9, j: 5, type: 2 },
            { n: -9, j: 6, type: 1 },
            { n: -9, j: 6, type: 2 },
            { n: -9, j: 7, type: 1 },
            { n: -8, j: 6, type: 2 },
            { n: -8, j: 7, type: 1 },
            { n: -7, j: 6, type: 1 },
            { n: -7, j: 5, type: 2 },
            { n: -7, j: 5, type: 1 },
            { n: -8, j: 5, type: 2 },
            { n: -8, j: 5, type: 1 },
            { n: -9, j: 7, type: 2 }
        ];

        // ========================================================================
        // STATE
        // ========================================================================
        const STATES = {
            HOOK: 'hook',
            LOADING: 'loading',
            TRANSFORMING: 'transforming',
            FROZEN: 'frozen',
            INTERACTIVE: 'interactive'
        };

        let currentState = STATES.HOOK;
        let sim = null;
        let activeTriangles = new Map();
        let animationId = null;
        let sonifier = null;

        // Animation phase state — drives visual effects during chaos→order
        let animPhase = {
            chaosEnergy: 0,   // 0–1: how much warm color vibration to apply
            annealProgress: 0, // 0–1: how far through annealing (0=chaos, 1=frozen)
            time: 0            // raw timestamp for oscillation effects
        };

        // Rendering
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let displayWidth, displayHeight;
        let zoom = 1, panX = 0, panY = 0;

        // Triangular lattice constants
        const slope = 1 / Math.sqrt(3);
        const deltaC = 2 / Math.sqrt(3);

        // ========================================================================
        // GEOMETRY HELPERS
        // ========================================================================
        function getVertex(n, j) {
            return {
                x: n,
                y: slope * n + j * deltaC
            };
        }

        function getTriangleCentroid(n, j, type) {
            if (type === 1) {
                // Black (right-facing): (n,j), (n,j-1), (n+1,j-1)
                const v0 = getVertex(n, j);
                const v1 = getVertex(n, j - 1);
                const v2 = getVertex(n + 1, j - 1);
                return { x: (v0.x + v1.x + v2.x) / 3, y: (v0.y + v1.y + v2.y) / 3 };
            } else {
                // White (left-facing): (n,j), (n+1,j), (n+1,j-1)
                const v0 = getVertex(n, j);
                const v1 = getVertex(n + 1, j);
                const v2 = getVertex(n + 1, j - 1);
                return { x: (v0.x + v1.x + v2.x) / 3, y: (v0.y + v1.y + v2.y) / 3 };
            }
        }

        function pointInPolygon(x, y, polygon) {
            if (!polygon || polygon.length < 3) return false;
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // ========================================================================
        // SHAPE SCALING (uses WASM boundaries like ultimate-lozenge)
        // ========================================================================
        function trianglesToMap(triangles) {
            const map = new Map();
            for (const t of triangles) {
                map.set(`${t.n},${t.j},${t.type}`, { n: t.n, j: t.j, type: t.type });
            }
            return map;
        }

        function worldToLattice(x, y) {
            const n = Math.round(x);
            const j = Math.round((y - slope * n) / deltaC);
            return { n, j };
        }

        // Scale mesh using WASM-computed boundaries (from sim.boundaries)
        function doubleMeshWithBoundaries(triangles, boundaries) {
            if (triangles.size === 0 || !boundaries || boundaries.length === 0) return triangles;

            // Find outer boundary (largest area)
            let outerIdx = 0;
            let maxDiag = -1;
            const latticeBoundaries = boundaries.map(b => b.map(v => worldToLattice(v.x, v.y)));

            latticeBoundaries.forEach((b, i) => {
                let mn = Infinity, mxn = -Infinity, mj = Infinity, mxj = -Infinity;
                for (const v of b) {
                    mn = Math.min(mn, v.n); mxn = Math.max(mxn, v.n);
                    mj = Math.min(mj, v.j); mxj = Math.max(mxj, v.j);
                }
                const diag = (mxn - mn) ** 2 + (mxj - mj) ** 2;
                if (diag > maxDiag) { maxDiag = diag; outerIdx = i; }
            });

            // Anchor at centroid
            const outerLattice = latticeBoundaries[outerIdx];
            let cenN = 0, cenJ = 0;
            for (const v of outerLattice) { cenN += v.n; cenJ += v.j; }
            const anchorN = Math.round(cenN / outerLattice.length);
            const anchorJ = Math.round(cenJ / outerLattice.length);

            // Scale all boundaries
            const scaledBoundaries = latticeBoundaries.map(b => {
                return b.map(v => {
                    const newN = anchorN + (v.n - anchorN) * 2;
                    const newJ = anchorJ + (v.j - anchorJ) * 2;
                    return getVertex(newN, newJ);
                });
            });

            const scaledOuter = scaledBoundaries[outerIdx];
            const scaledHoles = scaledBoundaries.filter((_, i) => i !== outerIdx);

            // Bounding box
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const v of scaledOuter) {
                minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
            }

            // Rasterize
            const newTriangles = new Map();
            const searchMinN = Math.floor(minX) - 2;
            const searchMaxN = Math.ceil(maxX) + 2;
            const nRange = searchMaxN - searchMinN;
            const searchMinJ = Math.floor(minY / deltaC) - nRange - 5;
            const searchMaxJ = Math.ceil(maxY / deltaC) + nRange + 5;

            for (let n = searchMinN; n <= searchMaxN; n++) {
                for (let j = searchMinJ; j <= searchMaxJ; j++) {
                    // Check type 1 (black)
                    const c1 = getTriangleCentroid(n, j, 1);
                    if (pointInPolygon(c1.x, c1.y, scaledOuter)) {
                        let inHole = false;
                        for (const hole of scaledHoles) {
                            if (pointInPolygon(c1.x, c1.y, hole)) { inHole = true; break; }
                        }
                        if (!inHole) newTriangles.set(`${n},${j},1`, { n, j, type: 1 });
                    }
                    // Check type 2 (white)
                    const c2 = getTriangleCentroid(n, j, 2);
                    if (pointInPolygon(c2.x, c2.y, scaledOuter)) {
                        let inHole = false;
                        for (const hole of scaledHoles) {
                            if (pointInPolygon(c2.x, c2.y, hole)) { inHole = true; break; }
                        }
                        if (!inHole) newTriangles.set(`${n},${j},2`, { n, j, type: 2 });
                    }
                }
            }

            return newTriangles;
        }

        // Iteratively scale using WASM boundaries
        async function generateScaledShape(simInterface) {
            let triangles = trianglesToMap(BASE_SHAPE);

            for (let i = 0; i < SCALE_ITERATIONS; i++) {
                // Init WASM to get boundaries
                simInterface.initFromTriangles(triangles);
                if (!simInterface.isValid || !simInterface.boundaries || simInterface.boundaries.length === 0) {
                    console.error('Invalid shape at iteration', i);
                    break;
                }
                // Scale using WASM boundaries
                triangles = doubleMeshWithBoundaries(triangles, simInterface.boundaries);
            }

            return triangles;
        }

        // ========================================================================
        // AUDIO SONIFICATION — ambient drone that shifts with order/chaos
        // ========================================================================
        class FlipSonifier {
            constructor() {
                this.audioCtx = null;
                this.masterGain = null;
                this.drone = null;
                this.droneGain = null;
                this.droneFilter = null;
            }

            init() {
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume();
                }
                this.masterGain = this.audioCtx.createGain();
                this.masterGain.connect(this.audioCtx.destination);
                this.masterGain.gain.value = 0.25;

                // Sustained drone: two detuned sine oscillators for warmth
                const t = this.audioCtx.currentTime;

                this.droneGain = this.audioCtx.createGain();
                this.droneGain.gain.setValueAtTime(0, t);

                this.droneFilter = this.audioCtx.createBiquadFilter();
                this.droneFilter.type = 'lowpass';
                this.droneFilter.frequency.value = 800;
                this.droneFilter.Q.value = 1;

                // Oscillator 1: fundamental
                const osc1 = this.audioCtx.createOscillator();
                osc1.type = 'sine';
                osc1.frequency.value = 110; // A2
                const g1 = this.audioCtx.createGain();
                g1.gain.value = 0.5;
                osc1.connect(g1);
                g1.connect(this.droneGain);

                // Oscillator 2: detuned +3 cents for subtle beating
                const osc2 = this.audioCtx.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.value = 110;
                osc2.detune.value = 3;
                const g2 = this.audioCtx.createGain();
                g2.gain.value = 0.4;
                osc2.connect(g2);
                g2.connect(this.droneGain);

                // Oscillator 3: octave above, very quiet shimmer
                const osc3 = this.audioCtx.createOscillator();
                osc3.type = 'sine';
                osc3.frequency.value = 220;
                const g3 = this.audioCtx.createGain();
                g3.gain.value = 0.1;
                osc3.connect(g3);
                g3.connect(this.droneGain);

                this.droneGain.connect(this.droneFilter);
                this.droneFilter.connect(this.masterGain);

                osc1.start(t);
                osc2.start(t);
                osc3.start(t);

                this.drone = [osc1, osc2, osc3];

                // Fade in over 1s
                this.droneGain.gain.setTargetAtTime(1, t, 0.3);
            }

            // Update drone based on current entropy (0 = ordered, 1 = chaotic)
            setEntropy(entropy) {
                if (!this.audioCtx || !this.drone) return;
                const t = this.audioCtx.currentTime;

                // Pitch: chaos = higher (A2 → D3), order = lower (A2)
                const baseFreq = 110;
                const chaosFreq = 147; // D3
                const freq = baseFreq + (chaosFreq - baseFreq) * entropy;

                this.drone[0].frequency.setTargetAtTime(freq, t, 0.15);
                this.drone[1].frequency.setTargetAtTime(freq, t, 0.15);
                this.drone[2].frequency.setTargetAtTime(freq * 2, t, 0.15);

                // Detune increases with chaos for more unsettled sound
                this.drone[1].detune.setTargetAtTime(3 + entropy * 12, t, 0.15);

                // Filter opens with chaos, closes with order
                const filterFreq = 400 + entropy * 1200;
                this.droneFilter.frequency.setTargetAtTime(filterFreq, t, 0.1);

                // Volume: slightly louder during chaos
                const vol = 0.6 + entropy * 0.4;
                this.droneGain.gain.setTargetAtTime(vol, t, 0.1);
            }

            fadeOut(duration = 2000) {
                if (!this.masterGain || !this.audioCtx) return;
                const t = this.audioCtx.currentTime;
                this.masterGain.gain.setTargetAtTime(0, t, duration / 3000);
                // Stop oscillators after fade completes
                if (this.drone) {
                    for (const osc of this.drone) {
                        osc.stop(t + duration / 1000 + 1);
                    }
                    // Keep this.drone reference so restartDrone() can stop them immediately
                }
            }

            // Re-create oscillators after fadeOut (stopped oscillators can't restart)
            restartDrone() {
                if (!this.audioCtx || !this.droneGain) return;
                // Stop any existing oscillators
                if (this.drone) {
                    for (const osc of this.drone) {
                        try { osc.stop(); } catch(e) {}
                    }
                }
                const t = this.audioCtx.currentTime;
                this.masterGain.gain.setValueAtTime(0.25, t);

                const osc1 = this.audioCtx.createOscillator();
                osc1.type = 'sine'; osc1.frequency.value = 110;
                const g1 = this.audioCtx.createGain(); g1.gain.value = 0.5;
                osc1.connect(g1); g1.connect(this.droneGain);

                const osc2 = this.audioCtx.createOscillator();
                osc2.type = 'sine'; osc2.frequency.value = 110; osc2.detune.value = 3;
                const g2 = this.audioCtx.createGain(); g2.gain.value = 0.4;
                osc2.connect(g2); g2.connect(this.droneGain);

                const osc3 = this.audioCtx.createOscillator();
                osc3.type = 'sine'; osc3.frequency.value = 220;
                const g3 = this.audioCtx.createGain(); g3.gain.value = 0.1;
                osc3.connect(g3); g3.connect(this.droneGain);

                osc1.start(t); osc2.start(t); osc3.start(t);
                this.drone = [osc1, osc2, osc3];
                this.droneGain.gain.setTargetAtTime(0.6, t, 0.3);
            }

            destroy() {
                if (this.drone) {
                    for (const osc of this.drone) {
                        try { osc.stop(); } catch(e) {}
                    }
                    this.drone = null;
                }
                if (this.audioCtx) {
                    this.audioCtx.close();
                    this.audioCtx = null;
                }
            }
        }

        // ========================================================================
        // WASM INTERFACE
        // ========================================================================
        class SimulatorInterface {
            constructor() {
                this.initFromTrianglesWasm = Module.cwrap('initFromTriangles', 'number', ['number', 'number']);
                this.performGlauberStepsWasm = Module.cwrap('performGlauberSteps', 'number', ['number']);
                this.exportDimersWasm = Module.cwrap('exportDimers', 'number', []);
                this.setQBiasWasm = Module.cwrap('setQBias', null, ['number']);
                this.setHoleBaseHeightWasm = Module.cwrap('setHoleBaseHeight', 'number', ['number', 'number']);
                this.getHoleCountWasm = Module.cwrap('getHoleCount', 'number', []);
                this.getAllHolesInfoWasm = Module.cwrap('getAllHolesInfo', 'number', []);
                this.adjustHoleWindingWasm = Module.cwrap('adjustHoleWindingExport', 'number', ['number', 'number']);
                this.freeStringWasm = Module.cwrap('freeString', null, ['number']);

                this.dimers = [];
                this.boundaries = [];
                this.isValid = false;
            }

            initFromTriangles(trianglesMap) {
                const arr = [];
                for (const [key, tri] of trianglesMap) {
                    arr.push(tri.n, tri.j, tri.type);
                }

                if (arr.length === 0) {
                    this.isValid = false;
                    return { status: 'empty' };
                }

                const dataPtr = Module._malloc(arr.length * 4);
                for (let i = 0; i < arr.length; i++) {
                    Module.setValue(dataPtr + i * 4, arr[i], 'i32');
                }

                const ptr = this.initFromTrianglesWasm(dataPtr, arr.length);
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                Module._free(dataPtr);

                const result = JSON.parse(jsonStr);
                this.isValid = result.status === 'valid';

                if (this.isValid) {
                    this.refreshDimers();
                }

                return result;
            }

            step(numSteps) {
                const ptr = this.performGlauberStepsWasm(numSteps);
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                const result = JSON.parse(jsonStr);
                this.refreshDimers();
                return result;
            }

            refreshDimers() {
                const ptr = this.exportDimersWasm();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                const result = JSON.parse(jsonStr);
                this.boundaries = result.boundaries || [];
                this.dimers = result.dimers;
            }

            setQBias(q) {
                this.setQBiasWasm(q);
            }

            setHoleBaseHeight(holeIdx, height) {
                this.setHoleBaseHeightWasm(holeIdx, height);
            }

            getHoleCount() {
                return this.getHoleCountWasm();
            }

            getAllHolesInfo() {
                const ptr = this.getAllHolesInfoWasm();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                return JSON.parse(jsonStr);
            }

            adjustHoleWinding(holeIdx, delta) {
                const ptr = this.adjustHoleWindingWasm(holeIdx, delta);
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                return JSON.parse(jsonStr);
            }
        }

        // ========================================================================
        // RENDERING
        // ========================================================================
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            displayWidth = rect.width;
            displayHeight = rect.height;
        }

        function getTransform() {
            const baseViewSize = 20;
            const baseScale = Math.min(displayWidth, displayHeight) / baseViewSize;
            const scale = baseScale * zoom;
            const centerX = displayWidth / 2 - panX * scale;
            const centerY = displayHeight / 2 + panY * scale;
            return { centerX, centerY, scale };
        }

        function toCanvas(x, y, centerX, centerY, scale) {
            return [centerX + x * scale, centerY - y * scale];
        }

        function fitToRegion() {
            if (activeTriangles.size === 0) return;

            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            for (const [key, tri] of activeTriangles) {
                let verts;
                if (tri.type === 1) {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n, tri.j - 1), getVertex(tri.n + 1, tri.j - 1)];
                } else {
                    verts = [getVertex(tri.n, tri.j), getVertex(tri.n + 1, tri.j), getVertex(tri.n + 1, tri.j - 1)];
                }
                for (const v of verts) {
                    minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                    minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
                }
            }

            const padding = 2;
            minX -= padding; maxX += padding;
            minY -= padding; maxY += padding;

            const centerWorldX = (minX + maxX) / 2;
            const centerWorldY = (minY + maxY) / 2;
            const rangeX = maxX - minX;
            const rangeY = maxY - minY;

            const baseViewSize = 20;
            const neededZoomX = displayWidth / rangeX / (Math.min(displayWidth, displayHeight) / baseViewSize);
            const neededZoomY = displayHeight / rangeY / (Math.min(displayWidth, displayHeight) / baseViewSize);
            zoom = Math.min(neededZoomX, neededZoomY);
            panX = centerWorldX;
            panY = centerWorldY;
        }

        function getLozengeVertices(dimer) {
            const { bn, bj, t } = dimer;
            if (t === 0) {
                return [getVertex(bn, bj), getVertex(bn + 1, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            } else if (t === 1) {
                return [getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn + 1, bj - 2), getVertex(bn, bj - 1)];
            } else {
                return [getVertex(bn - 1, bj), getVertex(bn, bj), getVertex(bn + 1, bj - 1), getVertex(bn, bj - 1)];
            }
        }

        // Parse hex color to RGB components
        function hexToRgb(hex) {
            const n = parseInt(hex.slice(1), 16);
            return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
        }

        // Pre-compute palette RGB values once
        const PALETTE_RGB = LOZENGE_PALETTE.map(p => {
            const light = hexToRgb(p.light);
            const dark = hexToRgb(p.dark);
            return {
                light, dark,
                mid: light.map((c, i) => Math.round((c + dark[i]) / 2))
            };
        });

        // Blend two RGB arrays by factor t (0=a, 1=b)
        function lerpColor(a, b, t) {
            return [
                Math.round(a[0] + (b[0] - a[0]) * t),
                Math.round(a[1] + (b[1] - a[1]) * t),
                Math.round(a[2] + (b[2] - a[2]) * t)
            ];
        }

        function rgbStr(c) { return `rgb(${c[0]},${c[1]},${c[2]})`; }

        // Warm accent color for chaos energy — amber glow
        const WARM_ACCENT = [200, 140, 60];

        function draw() {
            // Background: pure black in chaos, subtle dark warm tone as annealing progresses
            const bgR = Math.round(8 * animPhase.annealProgress);
            const bgG = Math.round(6 * animPhase.annealProgress);
            const bgB = Math.round(4 * animPhase.annealProgress);
            ctx.fillStyle = `rgb(${bgR},${bgG},${bgB})`;
            ctx.fillRect(0, 0, displayWidth, displayHeight);

            if (!sim || !sim.isValid || sim.dimers.length === 0) return;

            const { centerX, centerY, scale } = getTransform();

            // Chaos energy: warm color pulse that fades as order emerges
            const energy = animPhase.chaosEnergy;
            const warmPulse = energy * (0.5 + 0.5 * Math.sin(animPhase.time * 0.004));

            // Pre-compute per-type colors for this frame (avoids redundant per-lozenge computation)
            const useGradients = energy < 0.7; // skip gradients during peak chaos — visual noise masks them
            const frameColors = PALETTE_RGB.map(pal => {
                let lightC = pal.light;
                let darkC = pal.dark;
                let midC = pal.mid;
                if (warmPulse > 0.01) {
                    lightC = lerpColor(lightC, WARM_ACCENT, warmPulse * 0.15);
                    darkC = lerpColor(darkC, WARM_ACCENT, warmPulse * 0.10);
                    midC = lerpColor(lightC, darkC, 0.5);
                }
                return {
                    lightStr: rgbStr(lightC),
                    darkStr: rgbStr(darkC),
                    midStr: rgbStr(midC),
                    lightC, darkC
                };
            });

            // Draw lozenges — two passes for seam-free rendering
            // Pass 1: fill each lozenge + matching-color stroke to cover anti-aliasing gaps
            ctx.lineWidth = 0.6;
            ctx.lineJoin = 'round';

            const dimers = sim.dimers;
            const numDimers = dimers.length;
            // Pre-allocate canvas coord array (reused across lozenges)
            const cvBuf = [[0,0],[0,0],[0,0],[0,0]];

            // Build separation line path alongside fill pass (avoids recomputing vertices)
            const sepPath = new Path2D();

            for (let d = 0; d < numDimers; d++) {
                const dimer = dimers[d];
                const verts = getLozengeVertices(dimer);

                // Inline toCanvas for performance
                for (let vi = 0; vi < 4; vi++) {
                    cvBuf[vi][0] = centerX + verts[vi].x * scale;
                    cvBuf[vi][1] = centerY - verts[vi].y * scale;
                }

                const fc = frameColors[dimer.t];

                ctx.beginPath();
                ctx.moveTo(cvBuf[0][0], cvBuf[0][1]);
                ctx.lineTo(cvBuf[1][0], cvBuf[1][1]);
                ctx.lineTo(cvBuf[2][0], cvBuf[2][1]);
                ctx.lineTo(cvBuf[3][0], cvBuf[3][1]);
                ctx.closePath();

                if (useGradients) {
                    // Gradient for 3D depth — direction follows face orientation
                    let gx0, gy0, gx1, gy1;
                    if (dimer.t === 0) {
                        gx0 = (cvBuf[0][0] + cvBuf[1][0]) * 0.5; gy0 = (cvBuf[0][1] + cvBuf[1][1]) * 0.5;
                        gx1 = (cvBuf[2][0] + cvBuf[3][0]) * 0.5; gy1 = (cvBuf[2][1] + cvBuf[3][1]) * 0.5;
                    } else if (dimer.t === 1) {
                        gx0 = cvBuf[0][0]; gy0 = cvBuf[0][1];
                        gx1 = cvBuf[2][0]; gy1 = cvBuf[2][1];
                    } else {
                        gx0 = (cvBuf[0][0] + cvBuf[1][0]) * 0.5; gy0 = (cvBuf[0][1] + cvBuf[1][1]) * 0.5;
                        gx1 = (cvBuf[2][0] + cvBuf[3][0]) * 0.5; gy1 = (cvBuf[2][1] + cvBuf[3][1]) * 0.5;
                    }
                    const grad = ctx.createLinearGradient(gx0, gy0, gx1, gy1);
                    grad.addColorStop(0, fc.lightStr);
                    grad.addColorStop(1, fc.darkStr);
                    ctx.fillStyle = grad;
                } else {
                    // Flat fill during chaos — faster, visually indistinguishable
                    ctx.fillStyle = fc.midStr;
                }

                ctx.fill();
                ctx.strokeStyle = fc.midStr;
                ctx.stroke();

                // Accumulate separation line into batched path
                sepPath.moveTo(cvBuf[0][0], cvBuf[0][1]);
                sepPath.lineTo(cvBuf[1][0], cvBuf[1][1]);
                sepPath.lineTo(cvBuf[2][0], cvBuf[2][1]);
                sepPath.lineTo(cvBuf[3][0], cvBuf[3][1]);
                sepPath.lineTo(cvBuf[0][0], cvBuf[0][1]);
            }

            // Stroke batched separation lines for tile definition
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.12)';
            ctx.lineWidth = 0.3;
            ctx.lineJoin = 'miter';
            ctx.stroke(sepPath);

            // Draw boundary — soft warm glow instead of harsh white
            if (sim.boundaries && sim.boundaries.length > 0) {
                ctx.strokeStyle = 'rgba(255, 252, 245, 0.4)';
                ctx.lineWidth = 1.5;
                ctx.lineJoin = 'round';
                for (const boundary of sim.boundaries) {
                    if (boundary.length < 2) continue;
                    ctx.beginPath();
                    const first = toCanvas(boundary[0].x, boundary[0].y, centerX, centerY, scale);
                    ctx.moveTo(first[0], first[1]);
                    for (let i = 1; i < boundary.length; i++) {
                        const pt = toCanvas(boundary[i].x, boundary[i].y, centerX, centerY, scale);
                        ctx.lineTo(pt[0], pt[1]);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
            }

            // Vignette — radial darkening around edges to focus attention
            const vx = displayWidth / 2;
            const vy = displayHeight / 2;
            const vr = Math.max(displayWidth, displayHeight) * 0.75;
            const vignette = ctx.createRadialGradient(vx, vy, vr * 0.4, vx, vy, vr);
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.55)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, displayWidth, displayHeight);
        }

        // ========================================================================
        // STATE MACHINE
        // ========================================================================
        function enterHook() {
            currentState = STATES.HOOK;
            const hookEl = document.getElementById('hook-screen');
            hookEl.style.display = 'flex';
            canvas.style.display = 'none';

            // Reset hook text animations for re-entry
            const question = hookEl.querySelector('.question');
            const hint = hookEl.querySelector('.hint');
            question.style.animation = 'none';
            hint.style.animation = 'none';
            // Force reflow to restart animations
            void question.offsetWidth;
            question.style.animation = '';
            hint.style.animation = '';

            startHookBg();

            // Start on click or Enter/Space key
            function startFromHook(e) {
                if (e.type === 'keydown' && e.key !== 'Enter' && e.key !== ' ') return;
                if (e.type === 'keydown') e.preventDefault();
                hookEl.removeEventListener('click', startFromHook);
                document.removeEventListener('keydown', startFromHook);
                enterLoading();
            }
            hookEl.addEventListener('click', startFromHook);
            document.addEventListener('keydown', startFromHook);
        }

        async function enterLoading() {
            currentState = STATES.LOADING;
            stopHookBg();
            document.getElementById('hook-screen').style.display = 'none';
            document.getElementById('loading').textContent = 'Loading\u2026';
            document.getElementById('loading').style.display = 'block';

            // Initialize audio (requires user gesture) — non-fatal if unavailable
            try {
                sonifier = new FlipSonifier();
                sonifier.init();
            } catch (e) {
                console.warn('Audio unavailable:', e);
                try { sonifier.destroy(); } catch(ignored) {}
                sonifier = null;
            }

            // Initialize WASM first
            sim = new SimulatorInterface();

            // Generate scaled shape using WASM boundaries
            setTimeout(async () => {
                try {
                    activeTriangles = await generateScaledShape(sim);

                    // Final init with scaled shape
                    sim.initFromTriangles(activeTriangles);

                    // Adjust hole height for impossible illusion, but allow fluctuation
                    const holeCount = sim.getHoleCount();
                    if (holeCount > 0) {
                        const HOLE_HEIGHT_INCREASE = 8;
                        const initialInfo = sim.getAllHolesInfo();
                        for (let i = 0; i < holeCount; i++) {
                            const baseWinding = initialInfo.holes[i].currentWinding;

                            // Increase winding by 8 for the impossible illusion
                            for (let step = 0; step < HOLE_HEIGHT_INCREASE; step++) {
                                const result = sim.adjustHoleWinding(i, +1);
                                if (!result.success) break;
                            }

                            // Set base height to initial (before +8) to allow downward fluctuation
                            sim.setHoleBaseHeight(i, baseWinding);
                        }
                    }

                    if (sim.isValid) {
                        // RANDOMIZATION - Melt to chaos BEFORE first draw
                        sim.setQBias(Q_CHAOS);
                        sim.step(200000);

                        // Launch Visuals - first draw will be messy/chaotic
                        document.getElementById('loading').style.display = 'none';
                        canvas.style.opacity = '1';
                        canvas.style.display = 'block';
                        resizeCanvas();
                        fitToRegion();
                        draw(); // First draw is CHAOS

                        enterTransforming();
                    } else {
                        document.getElementById('loading').textContent = 'Error: Invalid shape';
                        setTimeout(() => {
                            document.getElementById('loading').style.display = 'none';
                            if (sonifier) { sonifier.destroy(); sonifier = null; }
                            sim = null;
                            enterHook();
                        }, 3000);
                    }
                } catch (err) {
                    console.error('Error:', err);
                    document.getElementById('loading').textContent = 'Error: ' + err.message;
                    // Auto-recover after 3s so kiosk mode doesn't get stuck
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                        if (sonifier) { sonifier.destroy(); sonifier = null; }
                        sim = null;
                        enterHook();
                    }, 3000);
                }
            }, 50);
        }

        function enterTransforming() {
            currentState = STATES.TRANSFORMING;
            const startTime = performance.now();

            let currentQ = Q_CHAOS;

            function animationLoop(timestamp) {
                if (currentState !== STATES.TRANSFORMING) return;

                const elapsed = timestamp - startTime;
                animPhase.time = elapsed;

                // --- TIMELINE LOGIC ---
                if (elapsed < CHAOS_DURATION) {
                    // Phase 1: Pure Chaos — full energy, no annealing
                    currentQ = Q_CHAOS;
                    animPhase.chaosEnergy = 1.0;
                    animPhase.annealProgress = 0;
                } else if (elapsed < CHAOS_DURATION + ANNEAL_DURATION) {
                    // Phase 2: The Emergence (Cubic Annealing)
                    const progress = (elapsed - CHAOS_DURATION) / ANNEAL_DURATION;
                    currentQ = Q_CHAOS + (Q_ORDER - Q_CHAOS) * Math.pow(progress, 3);
                    // Energy fades out as order emerges (quadratic decay for snappy cooling)
                    animPhase.chaosEnergy = Math.max(0, 1.0 - progress * progress);
                    animPhase.annealProgress = progress;
                } else {
                    // Phase 3: Truth Reached
                    animPhase.chaosEnergy = 0;
                    animPhase.annealProgress = 1;
                    enterFrozen();
                    return;
                }

                // Apply Physics
                sim.setQBias(currentQ);
                sim.step(STEPS_PER_FRAME);

                // Audio — drone pitch tracks chaos/order state
                if (sonifier) {
                    sonifier.setEntropy(animPhase.chaosEnergy);
                }

                draw();
                animationId = requestAnimationFrame(animationLoop);
            }

            animationId = requestAnimationFrame(animationLoop);
        }

        function enterFrozen() {
            currentState = STATES.FROZEN;

            // Lock visual state to fully annealed
            animPhase.chaosEnergy = 0;
            animPhase.annealProgress = 1;

            // Final polish - lock in the Truth
            sim.setQBias(Q_ORDER);
            sim.step(10000);
            sim.refreshDimers();
            draw();

            if (sonifier) sonifier.fadeOut(2000);

            // Start inactivity timer for auto-restart
            resetInactivityTimer();

            // UI Reveal (track handles so returnToHook can cancel them)
            frozenTimers = [];
            frozenTimers.push(setTimeout(() => {
                document.getElementById('caption').classList.add('visible');
            }, 500));

            frozenTimers.push(setTimeout(() => {
                document.getElementById('controls').classList.add('visible');
                document.getElementById('attribution').classList.add('visible');
                enterInteractive();
            }, 2000));
        }

        function enterInteractive() {
            currentState = STATES.INTERACTIVE;

            // Restart audio drone (oscillators were stopped by fadeOut in enterFrozen)
            if (sonifier) sonifier.restartDrone();

            const slider = document.getElementById('entropy');

            let lastSliderVal = -1; // track slider changes to avoid redundant redraws

            function interactiveLoop(timestamp) {
                if (currentState !== STATES.INTERACTIVE || !sim) return;

                // Get slider value (0 = Frozen, 100 = Chaos)
                const val = parseInt(slider.value);
                const e = val / 100;

                // Skip simulation + redraw when slider hasn't changed and is at 0 (fully ordered)
                if (val === 0 && lastSliderVal === 0) {
                    animationId = requestAnimationFrame(interactiveLoop);
                    return;
                }
                lastSliderVal = val;

                // Map slider to Q: 0 -> Q_ORDER, 100 -> Q_CHAOS
                const targetQ = Q_ORDER * Math.pow(Q_CHAOS / Q_ORDER, e);

                // Visual effects respond to entropy slider
                animPhase.chaosEnergy = e;
                animPhase.annealProgress = 1 - e;
                animPhase.time = timestamp || performance.now();

                sim.setQBias(targetQ);
                sim.step(STEPS_PER_FRAME);

                // Audio — drone pitch tracks slider entropy
                if (sonifier) {
                    sonifier.setEntropy(e);
                }

                draw();
                animationId = requestAnimationFrame(interactiveLoop);
            }

            animationId = requestAnimationFrame(interactiveLoop);
        }

        // ========================================================================
        // AUTO-RESTART — return to hook after inactivity (gallery/kiosk mode)
        // ========================================================================
        let inactivityTimer = null;
        let frozenTimers = []; // track setTimeout handles from enterFrozen
        const INACTIVITY_TIMEOUT = 120000; // 2 minutes

        function resetInactivityTimer() {
            if (inactivityTimer) clearTimeout(inactivityTimer);
            if (currentState === STATES.INTERACTIVE || currentState === STATES.FROZEN) {
                inactivityTimer = setTimeout(returnToHook, INACTIVITY_TIMEOUT);
            }
        }

        function returnToHook() {
            // Set state immediately to prevent re-entrance during fade-out
            currentState = STATES.HOOK;

            // Cancel any running animation
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
                inactivityTimer = null;
            }
            // Cancel pending frozen-state timers
            for (const t of frozenTimers) clearTimeout(t);
            frozenTimers = [];

            // Destroy audio context to prevent memory leaks
            if (sonifier) {
                sonifier.destroy();
                sonifier = null;
            }

            // Hide UI elements (CSS transition fades them out)
            document.getElementById('caption').classList.remove('visible');
            document.getElementById('controls').classList.remove('visible');
            document.getElementById('attribution').classList.remove('visible');

            // Reset slider
            document.getElementById('entropy').value = 0;

            // Reset animation phase
            animPhase.chaosEnergy = 0;
            animPhase.annealProgress = 0;
            animPhase.time = 0;

            // Clean up WASM sim
            sim = null;

            // Smooth fade-out: transition canvas opacity, then hide and show hook
            canvas.style.transition = 'opacity 1.5s ease-out';
            canvas.style.opacity = '0';
            setTimeout(() => {
                canvas.style.transition = '';
                canvas.style.display = 'none';
                enterHook();
            }, 1500);
        }

        // ========================================================================
        // EVENT LISTENERS
        // ========================================================================
        window.addEventListener('resize', () => {
            if (canvas.style.display !== 'none') {
                resizeCanvas();
                fitToRegion();
                draw();
            }
            // Also resize hook background if visible
            if (hookAnimId) {
                initHookBg();
                seedParticles();
            }
        });

        document.getElementById('entropy').addEventListener('input', () => {
            resetInactivityTimer();
        });

        // Reset inactivity on any pointer/keyboard activity
        ['pointermove', 'pointerdown', 'keydown'].forEach(evt => {
            document.addEventListener(evt, resetInactivityTimer, { passive: true });
        });

        // Pause inactivity timer when tab is hidden to prevent
        // auto-restart while user is simply on another tab
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (inactivityTimer) {
                    clearTimeout(inactivityTimer);
                    inactivityTimer = null;
                }
            } else {
                resetInactivityTimer();
            }
        });

        // ========================================================================
        // INITIALIZATION
        // ========================================================================
        // Wait for WASM to be ready
        if (typeof Module !== 'undefined' && Module.calledRun) {
            enterHook();
        } else if (typeof Module !== 'undefined') {
            Module.onRuntimeInitialized = function() {
                enterHook();
            };
        } else {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = 'Error: Failed to load simulation engine';
        }

    })();
    </script>
</body>
</html>
