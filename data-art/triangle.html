---
layout: null
permalink: triangle/
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Can Chaos Hide the Truth? — Leonid Petrov</title>
    <meta name="description" content="An interactive data art piece where impossible geometry emerges from probabilistic truth. MCMC-sampled lozenge tilings anneal from chaos into a Penrose triangle.">
    <meta property="og:title" content="Can Chaos Hide the Truth?">
    <meta property="og:description" content="Impossible geometry emerges from probabilistic truth. An interactive data art piece by Leonid Petrov.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://lpetrov.cc/triangle/">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Can Chaos Hide the Truth?">
    <meta name="twitter:description" content="Impossible geometry emerges from probabilistic truth. An interactive data art piece by Leonid Petrov.">
    <style>
        @font-face {
            font-family: 'JetBrains Mono';
            src: url('/fonts/JetBrainsMono-Light.woff2') format('woff2');
            font-weight: 300;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'JetBrains Mono';
            src: url('/fonts/JetBrainsMono-Regular.woff2') format('woff2');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Didot', 'Bodoni MT', 'Noto Serif Display', 'Georgia', serif;
        }

        #canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: none;
        }

        /* Hook screen */
        #hook-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10;
        }

        #hook-screen .question {
            color: rgba(255, 255, 255, 0.6);
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: clamp(1.1rem, 2.2vw, 1.8rem);
            font-weight: 300;
            letter-spacing: 0.02em;
            line-height: 2;
            text-align: left;
            white-space: pre;
            padding: 0 2rem;
            opacity: 0;
            animation: fadeIn 2.5s ease-out forwards;
        }

        #hook-bg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }

#hook-screen .hint {
            color: rgba(255, 255, 255, 0.45);
            font-size: clamp(0.65rem, 1.2vw, 0.8rem);
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-weight: 300;
            letter-spacing: 0.15em;
            margin-top: 4rem;
            opacity: 0;
            animation: fadeIn 1s ease-out 2s forwards, pulse 3s ease-in-out 3s infinite;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.7; }
        }

        /* Vignette overlay (replaces 2D canvas vignette) */
        #vignette {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.55) 100%);
            z-index: 2;
            display: none;
        }

        /* Caption */
        #caption {
            position: absolute;
            bottom: 10vh;
            left: 0; right: 0;
            text-align: center;
            color: rgba(255, 255, 255, 0.85);
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: clamp(0.85rem, 1.8vw, 1.15rem);
            font-weight: 300;
            letter-spacing: 0.18em;
            opacity: 0;
            transition: opacity 2.5s ease-in;
            pointer-events: none;
            z-index: 5;
        }

        #caption.visible {
            opacity: 1;
        }

        /* Text screen — code-styled */
        #text-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            background: #000;
            z-index: 10;
            opacity: 0;
            transition: opacity 2s ease-in;
        }

        #text-screen.visible {
            opacity: 1;
        }

        #text-screen .code-block {
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            font-size: clamp(0.7rem, 1.4vw, 1rem);
            font-weight: 300;
            line-height: 1.85;
            color: rgba(255, 255, 255, 0.6);
            white-space: pre;
            padding: 2vh 3vw;
        }

        #text-screen .line {
            display: block;
        }

        #text-screen .line-num {
            display: inline-block;
            width: 3ch;
            text-align: right;
            margin-right: 2ch;
            color: rgba(255, 255, 255, 0.15);
            user-select: none;
        }

        #text-screen .comment {
            color: rgba(255, 255, 255, 0.35);
        }

        #text-screen .keyword {
            color: rgba(200, 160, 255, 0.7);
        }

        #text-screen .string {
            color: rgba(160, 220, 160, 0.7);
        }

        #text-screen .number {
            color: rgba(200, 180, 140, 0.7);
        }

        #text-screen .fn {
            color: rgba(140, 190, 240, 0.7);
        }

        /* Gallery attribution */
        #attribution {
            position: absolute;
            bottom: 1.2vh;
            right: 2vw;
            color: rgba(255, 255, 255, 0.18);
            font-size: 0.5rem;
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            font-weight: 300;
            letter-spacing: 0.15em;
            opacity: 0;
            transition: opacity 2s ease-in;
            pointer-events: none;
            z-index: 5;
        }

        #attribution.visible {
            opacity: 1;
        }

        /* Loading indicator */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            display: none;
            z-index: 15;
        }
    </style>
</head>
<body>
    <div id="hook-screen">
        <canvas id="hook-bg"></canvas>
        <div class="question"><span style="color: rgba(255,255,255,0.15); margin-right: 2ch;">01</span><span style="color: rgba(255,255,255,0.5);">// </span><span style="color: rgba(255,255,255,0.85);">Can Chaos Hide the Truth?</span>
<span style="color: rgba(255,255,255,0.15); margin-right: 2ch;">02</span><span style="color: rgba(255,255,255,0.25);">//</span>
<span style="color: rgba(255,255,255,0.15); margin-right: 2ch;">03</span><span style="color: rgba(255,255,255,0.25);">//</span>
<span style="color: rgba(255,255,255,0.15); margin-right: 2ch;">04</span><span style="color: rgba(200,160,255,0.35);">const</span> <span style="color: rgba(140,190,240,0.35);">shape</span> = <span style="color: rgba(140,190,240,0.35);">penroseTriangle</span>();
<span style="color: rgba(255,255,255,0.15); margin-right: 2ch;">05</span><span style="color: rgba(200,160,255,0.35);">const</span> <span style="color: rgba(140,190,240,0.35);">tiling</span> = <span style="color: rgba(140,190,240,0.35);">CFTP</span>.<span style="color: rgba(140,190,240,0.35);">sample</span>(shape);
<span style="color: rgba(255,255,255,0.15); margin-right: 2ch;">06</span><span style="color: rgba(140,190,240,0.35);">anneal</span>(tiling, { <span style="color: rgba(140,190,240,0.35);">γ</span>: <span style="color: rgba(200,180,140,0.35);">0</span> → <span style="color: rgba(200,180,140,0.35);">∞</span> });</div>
        <p class="hint">Leonid Petrov · lpetrov.cc</p>
    </div>

    <canvas id="canvas"></canvas>
    <div id="vignette"></div>

    <div id="caption">Local Truth, Global Paradox</div>

    <div id="text-screen">
        <div class="code-block"></div>
    </div>

    <div id="attribution">Leonid Petrov &middot; Can Chaos Hide the Truth? &middot; 2026</div>

    <div id="loading">Loading...</div>

    <script src="/js/three.min.js"></script>
    <script src="/js/OrbitControls.js"></script>
    <script src="/js/2025-11-28-ultimate-lozenge.js"></script>
    <script>
    (function() {
        'use strict';

        // ========================================================================
        // HOOK BACKGROUND — faint drifting lozenges
        // ========================================================================
        const hookBg = document.getElementById('hook-bg');
        const hookCtx = hookBg.getContext('2d');
        let hookAnimId = null;

        function initHookBg() {
            const dpr = window.devicePixelRatio || 1;
            const w = window.innerWidth;
            const h = window.innerHeight;
            hookBg.width = w * dpr;
            hookBg.height = h * dpr;
            hookCtx.scale(dpr, dpr);
        }

        const NUM_PARTICLES = 60;
        const particles = [];
        function seedParticles() {
            particles.length = 0;
            const w = window.innerWidth;
            const h = window.innerHeight;
            for (let i = 0; i < NUM_PARTICLES; i++) {
                particles.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    size: 8 + Math.random() * 25,
                    rotation: Math.random() * Math.PI * 2,
                    drift: 0.06 + Math.random() * 0.14,
                    rotSpeed: (Math.random() - 0.5) * 0.003,
                    alpha: 0.04 + Math.random() * 0.08
                });
            }
        }

        function drawLozenge(cx, cy, size, rotation, alpha) {
            const aspect = 0.58;
            hookCtx.save();
            hookCtx.translate(cx, cy);
            hookCtx.rotate(rotation);
            hookCtx.beginPath();
            hookCtx.moveTo(0, -size);
            hookCtx.lineTo(size * aspect, 0);
            hookCtx.lineTo(0, size);
            hookCtx.lineTo(-size * aspect, 0);
            hookCtx.closePath();
            hookCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            hookCtx.fill();
            hookCtx.restore();
        }

        function animateHookBg() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            hookCtx.clearRect(0, 0, w, h);

            for (const p of particles) {
                p.y -= p.drift;
                p.rotation += p.rotSpeed;
                if (p.y < -p.size * 2) {
                    p.y = h + p.size * 2;
                    p.x = Math.random() * w;
                }
                drawLozenge(p.x, p.y, p.size, p.rotation, p.alpha);
            }
            hookAnimId = requestAnimationFrame(animateHookBg);
        }

        function startHookBg() {
            initHookBg();
            seedParticles();
            animateHookBg();
        }

        function stopHookBg() {
            if (hookAnimId) {
                cancelAnimationFrame(hookAnimId);
                hookAnimId = null;
            }
        }

        // ========================================================================
        // CONFIGURATION
        // ========================================================================
        const LOZENGE_COLORS_3D = ['#EDE8E0', '#A0ADB8', '#CCC0B0'];
        const SCALE_ITERATIONS = 4;
        const STEPS_PER_FRAME = 2000;
        const CUBE_SIZE = 1.35;

        // Timing
        const FLYING_DURATION = 5000;
        const ASSEMBLY_DURATION = 6000;
        const CHAOS_DURATION = 3000;
        const ANNEAL_DURATION = 22000;
        const CUBE_SURFACE_BLEND_DURATION = 1600;
        const Q_CHAOS = 1.0;
        const Q_ORDER = 50.0;

        // Base Penrose triangle shape (12 triangles) - creates hole with winding
        const BASE_SHAPE = [
            { n: -9, j: 5, type: 2 },
            { n: -9, j: 6, type: 1 },
            { n: -9, j: 6, type: 2 },
            { n: -9, j: 7, type: 1 },
            { n: -8, j: 6, type: 2 },
            { n: -8, j: 7, type: 1 },
            { n: -7, j: 6, type: 1 },
            { n: -7, j: 5, type: 2 },
            { n: -7, j: 5, type: 1 },
            { n: -8, j: 5, type: 2 },
            { n: -8, j: 5, type: 1 },
            { n: -9, j: 7, type: 2 }
        ];

        // ========================================================================
        // STATE
        // ========================================================================
        const STATES = {
            HOOK: 'hook',
            LOADING: 'loading',
            FLYING_CUBES: 'flying_cubes',
            ASSEMBLY: 'assembly',
            TRANSFORMING: 'transforming',
            FROZEN: 'frozen',
            TEXT_SCREEN: 'text_screen'
        };

        let currentState = STATES.HOOK;
        let sim = null;
        let activeTriangles = new Map();
        let animationId = null;
        let sonifier = null;

        let animPhase = {
            chaosEnergy: 0,
            annealProgress: 0,
            time: 0
        };

        // Three.js state
        let scene = null, renderer = null, camera = null, controls = null, meshGroup = null;
        let surfaceMesh = null, surfaceGeo = null, edgeLines = null;
        let surfaceMaterial = null, edgeMaterial = null;
        const frustumSize = 30;

        // Flying cubes state
        let cubesMesh = null;
        let cubePositions = null;  // Float32Array(n*3) — 3D world positions
        let cubePos2D = null;      // Float32Array(n*2) — 2D in camera view plane
        let cubeVel2D = null;      // Float32Array(n*2) — 2D velocities
        let cubeDepth = null;      // Float32Array(n) — slight depth offsets
        let cubeRotations = null;  // Float32Array(n*3) — Euler angles (x,y,z)
        let cubeAngVel = null;     // Float32Array(n*3) — angular velocities
        let cubeFlying = null;     // Uint8Array(n) — 1=flying (physics), 0=stationary (at target)
        let cubeTargets = null;    // Float32Array(n*3) — 3D target positions
        let cubeTargets2D = null;  // Float32Array(n*2) — target positions in view plane
        let cubeTargetDepth = null;// Float32Array(n) — target depth offsets
        // Camera basis vectors (set by initFlyingCubes)
        let camRight = null, camUp = null, camForward = null;
        let cubeHalfW = 0, cubeHalfH = 0;

        // Render loop state
        let lastTimestamp = 0;
        let stateStartTime = 0;
        let transformBlendComplete = false;
        let dumpedPreGlauber = false;
        let dumpedPostGlauber = false;

        const canvas = document.getElementById('canvas');

        // Triangular lattice constants
        const slope = 1 / Math.sqrt(3);
        const deltaC = 2 / Math.sqrt(3);

        // ========================================================================
        // GEOMETRY HELPERS
        // ========================================================================
        function getVertex(n, j) {
            return {
                x: n,
                y: slope * n + j * deltaC
            };
        }

        function getTriangleCentroid(n, j, type) {
            if (type === 1) {
                const v0 = getVertex(n, j);
                const v1 = getVertex(n, j - 1);
                const v2 = getVertex(n + 1, j - 1);
                return { x: (v0.x + v1.x + v2.x) / 3, y: (v0.y + v1.y + v2.y) / 3 };
            } else {
                const v0 = getVertex(n, j);
                const v1 = getVertex(n + 1, j);
                const v2 = getVertex(n + 1, j - 1);
                return { x: (v0.x + v1.x + v2.x) / 3, y: (v0.y + v1.y + v2.y) / 3 };
            }
        }

        function pointInPolygon(x, y, polygon) {
            if (!polygon || polygon.length < 3) return false;
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // ========================================================================
        // SHAPE SCALING (uses WASM boundaries like ultimate-lozenge)
        // ========================================================================
        function trianglesToMap(triangles) {
            const map = new Map();
            for (const t of triangles) {
                map.set(`${t.n},${t.j},${t.type}`, { n: t.n, j: t.j, type: t.type });
            }
            return map;
        }

        function worldToLattice(x, y) {
            const n = Math.round(x);
            const j = Math.round((y - slope * n) / deltaC);
            return { n, j };
        }

        function doubleMeshWithBoundaries(triangles, boundaries) {
            if (triangles.size === 0 || !boundaries || boundaries.length === 0) return triangles;

            let outerIdx = 0;
            let maxDiag = -1;
            const latticeBoundaries = boundaries.map(b => b.map(v => worldToLattice(v.x, v.y)));

            latticeBoundaries.forEach((b, i) => {
                let mn = Infinity, mxn = -Infinity, mj = Infinity, mxj = -Infinity;
                for (const v of b) {
                    mn = Math.min(mn, v.n); mxn = Math.max(mxn, v.n);
                    mj = Math.min(mj, v.j); mxj = Math.max(mxj, v.j);
                }
                const diag = (mxn - mn) ** 2 + (mxj - mj) ** 2;
                if (diag > maxDiag) { maxDiag = diag; outerIdx = i; }
            });

            const outerLattice = latticeBoundaries[outerIdx];
            let cenN = 0, cenJ = 0;
            for (const v of outerLattice) { cenN += v.n; cenJ += v.j; }
            const anchorN = Math.round(cenN / outerLattice.length);
            const anchorJ = Math.round(cenJ / outerLattice.length);

            const scaledBoundaries = latticeBoundaries.map(b => {
                return b.map(v => {
                    const newN = anchorN + (v.n - anchorN) * 2;
                    const newJ = anchorJ + (v.j - anchorJ) * 2;
                    return getVertex(newN, newJ);
                });
            });

            const scaledOuter = scaledBoundaries[outerIdx];
            const scaledHoles = scaledBoundaries.filter((_, i) => i !== outerIdx);

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const v of scaledOuter) {
                minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
            }

            const newTriangles = new Map();
            const searchMinN = Math.floor(minX) - 2;
            const searchMaxN = Math.ceil(maxX) + 2;
            const nRange = searchMaxN - searchMinN;
            const searchMinJ = Math.floor(minY / deltaC) - nRange - 5;
            const searchMaxJ = Math.ceil(maxY / deltaC) + nRange + 5;

            for (let n = searchMinN; n <= searchMaxN; n++) {
                for (let j = searchMinJ; j <= searchMaxJ; j++) {
                    const c1 = getTriangleCentroid(n, j, 1);
                    if (pointInPolygon(c1.x, c1.y, scaledOuter)) {
                        let inHole = false;
                        for (const hole of scaledHoles) {
                            if (pointInPolygon(c1.x, c1.y, hole)) { inHole = true; break; }
                        }
                        if (!inHole) newTriangles.set(`${n},${j},1`, { n, j, type: 1 });
                    }
                    const c2 = getTriangleCentroid(n, j, 2);
                    if (pointInPolygon(c2.x, c2.y, scaledOuter)) {
                        let inHole = false;
                        for (const hole of scaledHoles) {
                            if (pointInPolygon(c2.x, c2.y, hole)) { inHole = true; break; }
                        }
                        if (!inHole) newTriangles.set(`${n},${j},2`, { n, j, type: 2 });
                    }
                }
            }

            return newTriangles;
        }

        async function generateScaledShape(simInterface) {
            let triangles = trianglesToMap(BASE_SHAPE);

            for (let i = 0; i < SCALE_ITERATIONS; i++) {
                console.time(`scaleIter-${i}`);
                simInterface.initFromTriangles(triangles);
                if (!simInterface.isValid || !simInterface.boundaries || simInterface.boundaries.length === 0) {
                    console.error('Invalid shape at iteration', i);
                    break;
                }
                triangles = doubleMeshWithBoundaries(triangles, simInterface.boundaries);
                console.timeEnd(`scaleIter-${i}`);
                console.log(`  iter ${i}: ${triangles.size} triangles`);
            }

            return triangles;
        }

        // ========================================================================
        // AUDIO SONIFICATION — ambient drone that shifts with order/chaos
        // ========================================================================
        class FlipSonifier {
            constructor() {
                this.audioCtx = null;
                this.masterGain = null;
                this.drone = null;
                this.droneGain = null;
                this.droneFilter = null;
            }

            init() {
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume();
                }
                this.masterGain = this.audioCtx.createGain();
                this.masterGain.connect(this.audioCtx.destination);
                this.masterGain.gain.value = 0.25;

                const t = this.audioCtx.currentTime;

                this.droneGain = this.audioCtx.createGain();
                this.droneGain.gain.setValueAtTime(0, t);

                this.droneFilter = this.audioCtx.createBiquadFilter();
                this.droneFilter.type = 'lowpass';
                this.droneFilter.frequency.value = 800;
                this.droneFilter.Q.value = 1;

                const osc1 = this.audioCtx.createOscillator();
                osc1.type = 'sine';
                osc1.frequency.value = 110;
                const g1 = this.audioCtx.createGain();
                g1.gain.value = 0.5;
                osc1.connect(g1);
                g1.connect(this.droneGain);

                const osc2 = this.audioCtx.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.value = 110;
                osc2.detune.value = 3;
                const g2 = this.audioCtx.createGain();
                g2.gain.value = 0.4;
                osc2.connect(g2);
                g2.connect(this.droneGain);

                const osc3 = this.audioCtx.createOscillator();
                osc3.type = 'sine';
                osc3.frequency.value = 220;
                const g3 = this.audioCtx.createGain();
                g3.gain.value = 0.1;
                osc3.connect(g3);
                g3.connect(this.droneGain);

                this.droneGain.connect(this.droneFilter);
                this.droneFilter.connect(this.masterGain);

                osc1.start(t);
                osc2.start(t);
                osc3.start(t);

                this.drone = [osc1, osc2, osc3];
                this.droneGain.gain.setTargetAtTime(1, t, 0.3);
            }

            setEntropy(entropy) {
                if (!this.audioCtx || !this.drone) return;
                const t = this.audioCtx.currentTime;

                const baseFreq = 110;
                const chaosFreq = 147;
                const freq = baseFreq + (chaosFreq - baseFreq) * entropy;

                this.drone[0].frequency.setTargetAtTime(freq, t, 0.15);
                this.drone[1].frequency.setTargetAtTime(freq, t, 0.15);
                this.drone[2].frequency.setTargetAtTime(freq * 2, t, 0.15);

                this.drone[1].detune.setTargetAtTime(3 + entropy * 12, t, 0.15);

                const filterFreq = 400 + entropy * 1200;
                this.droneFilter.frequency.setTargetAtTime(filterFreq, t, 0.1);

                const vol = 0.6 + entropy * 0.4;
                this.droneGain.gain.setTargetAtTime(vol, t, 0.1);
            }

            fadeOut(duration = 2000) {
                if (!this.masterGain || !this.audioCtx) return;
                const t = this.audioCtx.currentTime;
                this.masterGain.gain.setTargetAtTime(0, t, duration / 3000);
                if (this.drone) {
                    for (const osc of this.drone) {
                        osc.stop(t + duration / 1000 + 1);
                    }
                }
            }

            restartDrone() {
                if (!this.audioCtx || !this.droneGain) return;
                if (this.drone) {
                    for (const osc of this.drone) {
                        try { osc.stop(); } catch(e) {}
                    }
                }
                const t = this.audioCtx.currentTime;
                this.masterGain.gain.setValueAtTime(0.25, t);

                const osc1 = this.audioCtx.createOscillator();
                osc1.type = 'sine'; osc1.frequency.value = 110;
                const g1 = this.audioCtx.createGain(); g1.gain.value = 0.5;
                osc1.connect(g1); g1.connect(this.droneGain);

                const osc2 = this.audioCtx.createOscillator();
                osc2.type = 'sine'; osc2.frequency.value = 110; osc2.detune.value = 3;
                const g2 = this.audioCtx.createGain(); g2.gain.value = 0.4;
                osc2.connect(g2); g2.connect(this.droneGain);

                const osc3 = this.audioCtx.createOscillator();
                osc3.type = 'sine'; osc3.frequency.value = 220;
                const g3 = this.audioCtx.createGain(); g3.gain.value = 0.1;
                osc3.connect(g3); g3.connect(this.droneGain);

                osc1.start(t); osc2.start(t); osc3.start(t);
                this.drone = [osc1, osc2, osc3];
                this.droneGain.gain.setTargetAtTime(0.6, t, 0.3);
            }

            destroy() {
                if (this.drone) {
                    for (const osc of this.drone) {
                        try { osc.stop(); } catch(e) {}
                    }
                    this.drone = null;
                }
                if (this.audioCtx) {
                    this.audioCtx.close();
                    this.audioCtx = null;
                }
            }
        }

        // ========================================================================
        // WASM INTERFACE
        // ========================================================================
        class SimulatorInterface {
            constructor() {
                this.initFromTrianglesWasm = Module.cwrap('initFromTriangles', 'number', ['number', 'number']);
                this.performGlauberStepsWasm = Module.cwrap('performGlauberSteps', 'number', ['number']);
                this.exportDimersWasm = Module.cwrap('exportDimers', 'number', []);
                this.setQBiasWasm = Module.cwrap('setQBias', null, ['number']);
                this.setHoleBaseHeightWasm = Module.cwrap('setHoleBaseHeight', 'number', ['number', 'number']);
                this.getHoleCountWasm = Module.cwrap('getHoleCount', 'number', []);
                this.getAllHolesInfoWasm = Module.cwrap('getAllHolesInfo', 'number', []);
                this.adjustHoleWindingWasm = Module.cwrap('adjustHoleWindingExport', 'number', ['number', 'number']);
                this.freeStringWasm = Module.cwrap('freeString', null, ['number']);
                this.initCFTPWasm = Module.cwrap('initCFTP', 'number', []);
                this.stepCFTPWasm = Module.cwrap('stepCFTP', 'number', []);
                this.finalizeCFTPWasm = Module.cwrap('finalizeCFTP', 'number', []);

                this.dimers = [];
                this.boundaries = [];
                this.isValid = false;
            }

            initFromTriangles(trianglesMap) {
                const arr = [];
                for (const [key, tri] of trianglesMap) {
                    arr.push(tri.n, tri.j, tri.type);
                }

                if (arr.length === 0) {
                    this.isValid = false;
                    return { status: 'empty' };
                }

                const dataPtr = Module._malloc(arr.length * 4);
                for (let i = 0; i < arr.length; i++) {
                    Module.setValue(dataPtr + i * 4, arr[i], 'i32');
                }

                const ptr = this.initFromTrianglesWasm(dataPtr, arr.length);
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                Module._free(dataPtr);

                const result = JSON.parse(jsonStr);
                this.isValid = result.status === 'valid';

                if (this.isValid) {
                    this.refreshDimers();
                }

                return result;
            }

            step(numSteps) {
                const ptr = this.performGlauberStepsWasm(numSteps);
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                const result = JSON.parse(jsonStr);
                this.refreshDimers();
                return result;
            }

            refreshDimers() {
                const ptr = this.exportDimersWasm();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                const result = JSON.parse(jsonStr);
                this.boundaries = result.boundaries || [];
                this.dimers = result.dimers;
            }

            setQBias(q) {
                this.setQBiasWasm(q);
            }

            setHoleBaseHeight(holeIdx, height) {
                this.setHoleBaseHeightWasm(holeIdx, height);
            }

            getHoleCount() {
                return this.getHoleCountWasm();
            }

            getAllHolesInfo() {
                const ptr = this.getAllHolesInfoWasm();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                return JSON.parse(jsonStr);
            }

            adjustHoleWinding(holeIdx, delta) {
                const ptr = this.adjustHoleWindingWasm(holeIdx, delta);
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                return JSON.parse(jsonStr);
            }

            initCFTP() {
                const ptr = this.initCFTPWasm();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                return JSON.parse(jsonStr);
            }

            stepCFTP() {
                const ptr = this.stepCFTPWasm();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                return JSON.parse(jsonStr);
            }

            finalizeCFTP() {
                const ptr = this.finalizeCFTPWasm();
                const jsonStr = Module.UTF8ToString(ptr);
                this.freeStringWasm(ptr);
                const result = JSON.parse(jsonStr);
                if (result.status === 'finalized') {
                    this.refreshDimers();
                }
                return result;
            }
        }

        // ========================================================================
        // THREE.JS SCENE SETUP
        // ========================================================================
        function initThreeScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);

            const aspect = canvas.clientWidth / canvas.clientHeight || 1;
            camera = new THREE.OrthographicCamera(
                -frustumSize * aspect / 2, frustumSize * aspect / 2,
                frustumSize / 2, -frustumSize / 2,
                -5000, 6000
            );
            camera.up.set(0, 0, 1);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.rotateSpeed = 0.8;
            controls.panSpeed = 0.8;
            controls.zoomSpeed = 1.2;
            controls.enableRotate = false;
            controls.enablePan = false;
            controls.enableZoom = false;

            // Metallic lighting for dark background
            scene.add(new THREE.AmbientLight(0xffffff, 0.35));
            const hemi = new THREE.HemisphereLight(0x6666aa, 0x222244, 0.25);
            hemi.position.set(0, 20, 0);
            scene.add(hemi);
            const dir = new THREE.DirectionalLight(0xffffff, 1.2);
            dir.position.set(15, 20, 5);
            scene.add(dir);
            const fill = new THREE.DirectionalLight(0xffffff, 0.3);
            fill.position.set(-10, 5, -5);
            scene.add(fill);

            meshGroup = new THREE.Group();
            scene.add(meshGroup);

            // Reusable materials
            surfaceMaterial = new THREE.MeshStandardMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: true,
                roughness: 0.3,
                metalness: 0.35,
                color: 0xddeeff
            });

            edgeMaterial = new THREE.LineBasicMaterial({
                color: 0x000000, linewidth: 1, opacity: 0.8, transparent: true
            });
        }

        function disposeThreeScene() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            if (cubesMesh) {
                meshGroup.remove(cubesMesh);
                cubesMesh.geometry.dispose();
                cubesMesh.material.dispose();
                cubesMesh = null;
            }
            if (edgeLines) {
                meshGroup.remove(edgeLines);
                edgeLines.geometry.dispose();
                edgeLines = null;
            }
            if (surfaceMesh) {
                meshGroup.remove(surfaceMesh);
                surfaceMesh = null;
            }
            if (surfaceGeo) { surfaceGeo.dispose(); surfaceGeo = null; }
            if (surfaceMaterial) { surfaceMaterial.dispose(); surfaceMaterial = null; }
            if (edgeMaterial) { edgeMaterial.dispose(); edgeMaterial = null; }
            if (controls) { controls.dispose(); controls = null; }
            if (renderer) { renderer.dispose(); renderer = null; }
            scene = null; camera = null; meshGroup = null;
            cubePositions = null; cubePos2D = null; cubeVel2D = null; cubeDepth = null;
            cubeRotations = null; cubeAngVel = null; cubeFlying = null;
            cubeTargets = null; cubeTargets2D = null; cubeTargetDepth = null;
            camRight = null; camUp = null; camForward = null;
        }

        function resizeThreeScene() {
            if (!renderer || !camera) return;
            const w = canvas.clientWidth, h = canvas.clientHeight;
            if (w === 0 || h === 0) return;
            renderer.setSize(w, h, false);
            const aspect = w / h;
            camera.left = -frustumSize * aspect / 2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;
            camera.updateProjectionMatrix();
        }

        // ========================================================================
        // 3D GEOMETRY HELPERS — ported from 2to3d-sim.js
        // ========================================================================
        function getVertexKeys(dimer) {
            const { bn, bj, t } = dimer;
            if (t === 0) return [[bn, bj], [bn+1, bj], [bn+1, bj-1], [bn, bj-1]];
            if (t === 1) return [[bn, bj], [bn+1, bj-1], [bn+1, bj-2], [bn, bj-1]];
            return [[bn-1, bj], [bn, bj], [bn+1, bj-1], [bn, bj-1]];
        }

        function getHeightPattern(t) {
            if (t === 0) return [0, 0, 0, 0];
            if (t === 1) return [1, 0, 0, 1];
            return [1, 1, 0, 0];
        }

        function to3D(n, j, h) {
            return { x: h, y: -n - h, z: j - h };
        }

        function computeHeights(dimers) {
            if (!dimers || dimers.length === 0) return new Map();

            const vertexToDimers = new Map();
            for (const dimer of dimers) {
                for (const [n, j] of getVertexKeys(dimer)) {
                    const key = `${n},${j}`;
                    if (!vertexToDimers.has(key)) vertexToDimers.set(key, []);
                    vertexToDimers.get(key).push(dimer);
                }
            }

            const heights = new Map();
            const firstVerts = getVertexKeys(dimers[0]);
            const startKey = `${firstVerts[0][0]},${firstVerts[0][1]}`;
            heights.set(startKey, 0);

            const queue = [startKey];
            const visited = new Set();

            while (queue.length > 0) {
                const currentKey = queue.shift();
                if (visited.has(currentKey)) continue;
                visited.add(currentKey);

                const currentH = heights.get(currentKey);
                const [cn, cj] = currentKey.split(',').map(Number);

                for (const dimer of vertexToDimers.get(currentKey) || []) {
                    const verts = getVertexKeys(dimer);
                    const pattern = getHeightPattern(dimer.t);
                    const myIdx = verts.findIndex(([vn, vj]) => vn === cn && vj === cj);
                    if (myIdx >= 0) {
                        for (let i = 0; i < 4; i++) {
                            const vkey = `${verts[i][0]},${verts[i][1]}`;
                            if (!heights.has(vkey)) {
                                heights.set(vkey, currentH + (pattern[i] - pattern[myIdx]));
                                queue.push(vkey);
                            }
                        }
                    }
                }
            }
            return heights;
        }

        function hashDimers(dimers) {
            // Small stable hash to quickly compare two dumped surfaces.
            let h = 2166136261 >>> 0;
            for (let i = 0; i < dimers.length; i++) {
                const d = dimers[i];
                h ^= (d.bn | 0); h = Math.imul(h, 16777619) >>> 0;
                h ^= (d.bj | 0); h = Math.imul(h, 16777619) >>> 0;
                h ^= (d.t  | 0); h = Math.imul(h, 16777619) >>> 0;
            }
            return h.toString(16).padStart(8, '0');
        }

        function dumpSurfaceSnapshot(label) {
            if (!sim || !Array.isArray(sim.dimers)) return null;

            const dump = {
                label,
                capturedAt: new Date().toISOString(),
                state: currentState,
                dimersCount: sim.dimers.length,
                boundariesCount: Array.isArray(sim.boundaries) ? sim.boundaries.length : 0,
                hash: hashDimers(sim.dimers),
                dimers: sim.dimers.map(d => ({ bn: d.bn, bj: d.bj, t: d.t })),
                boundaries: Array.isArray(sim.boundaries)
                    ? JSON.parse(JSON.stringify(sim.boundaries))
                    : []
            };

            if (!window.__triangleSurfaceDumps) window.__triangleSurfaceDumps = {};
            window.__triangleSurfaceDumps[label] = dump;

            console.log(`[SURFACE_DUMP] ${label}`, {
                capturedAt: dump.capturedAt,
                state: dump.state,
                dimersCount: dump.dimersCount,
                boundariesCount: dump.boundariesCount,
                hash: dump.hash
            });

            if (label === 'post_glauber' && window.__triangleSurfaceDumps.pre_glauber) {
                const pre = window.__triangleSurfaceDumps.pre_glauber;
                console.log('[SURFACE_DUMP] pre -> post', {
                    changed: pre.hash !== dump.hash,
                    preHash: pre.hash,
                    postHash: dump.hash
                });
            }

            return dump;
        }

        // Cached THREE.Color objects for lozenge types
        const colorObjs3D = LOZENGE_COLORS_3D.map(c => new THREE.Color(c));

        // Scene center and size (set by positionCamera, used by flying cubes)
        let sceneCenter = { x: 0, y: 0, z: 0 };
        let sceneSize = 10;

        function positionCamera(dimers) {
            const heights = computeHeights(dimers);
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            for (const [key, h] of heights) {
                const [n, j] = key.split(',').map(Number);
                const p = to3D(n, j, h);
                minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
                minZ = Math.min(minZ, p.z); maxZ = Math.max(maxZ, p.z);
            }

            sceneCenter.x = (minX + maxX) / 2;
            sceneCenter.y = (minY + maxY) / 2;
            sceneCenter.z = (minZ + maxZ) / 2;
            sceneSize = Math.max(maxX - minX, maxY - minY, maxZ - minZ) || 10;

            // Isometric direction: (1, -1, -1) — height changes invisible from here
            const d = 1 / Math.sqrt(3);
            camera.position.set(
                sceneCenter.x + d * sceneSize * 5,
                sceneCenter.y - d * sceneSize * 5,
                sceneCenter.z - d * sceneSize * 5
            );
            controls.target.set(sceneCenter.x, sceneCenter.y, sceneCenter.z);
            camera.updateProjectionMatrix();
            controls.update();

            // Project all vertices onto camera view plane to compute tight fit
            camera.updateMatrixWorld();
            const cRight = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 0);
            const cUp = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 1);
            let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;
            for (const [key, h] of heights) {
                const [n, j] = key.split(',').map(Number);
                const p = to3D(n, j, h);
                const dx = p.x - sceneCenter.x, dy = p.y - sceneCenter.y, dz = p.z - sceneCenter.z;
                const u = dx * cRight.x + dy * cRight.y + dz * cRight.z;
                const v = dx * cUp.x + dy * cUp.y + dz * cUp.z;
                minU = Math.min(minU, u); maxU = Math.max(maxU, u);
                minV = Math.min(minV, v); maxV = Math.max(maxV, v);
            }

            // Fit so the triangle fills full height or width (with small margin)
            const aspect = canvas.clientWidth / canvas.clientHeight || 1;
            const projW = maxU - minU;
            const projH = maxV - minV;
            const viewW = frustumSize * aspect;
            const viewH = frustumSize;
            const margin = 1.05; // 5% breathing room
            camera.zoom = Math.min(viewW / (projW * margin), viewH / (projH * margin));
            camera.updateProjectionMatrix();
            controls.update();
        }

        function computeTargets(dimers) {
            // Use ordered-state heights for 3D cube assembly targets
            const heights = computeHeights(dimers);
            const targets = new Float32Array(dimers.length * 3);
            for (let i = 0; i < dimers.length; i++) {
                const verts = getVertexKeys(dimers[i]);
                const h0 = heights.get(`${verts[0][0]},${verts[0][1]}`) || 0;
                const pattern = getHeightPattern(dimers[i].t);
                const baseH = h0 - pattern[0];
                let cx = 0, cy = 0, cz = 0;
                for (let vi = 0; vi < 4; vi++) {
                    const p = to3D(verts[vi][0], verts[vi][1], baseH + pattern[vi]);
                    cx += p.x; cy += p.y; cz += p.z;
                }
                targets[i * 3] = cx / 4;
                targets[i * 3 + 1] = cy / 4;
                targets[i * 3 + 2] = cz / 4;
            }
            return targets;
        }

        // ========================================================================
        // SURFACE MESH — build and update
        // ========================================================================
        function fillSurfaceBuffers(dimers, pos, norm, col) {
            const heights = computeHeights(dimers);
            const numDimers = dimers.length;

            for (let d = 0; d < numDimers; d++) {
                const dimer = dimers[d];
                const verts = getVertexKeys(dimer);
                // Locally-consistent heights per tile (avoids branch-cut ladder)
                const h0 = heights.get(`${verts[0][0]},${verts[0][1]}`) || 0;
                const pat = getHeightPattern(dimer.t);
                const baseH = h0 - pat[0];
                const v3d = verts.map(([n, j], idx) => to3D(n, j, baseH + pat[idx]));

                const base = d * 12; // 4 vertices * 3 components
                for (let vi = 0; vi < 4; vi++) {
                    pos[base + vi * 3]     = v3d[vi].x;
                    pos[base + vi * 3 + 1] = v3d[vi].y;
                    pos[base + vi * 3 + 2] = v3d[vi].z;
                }

                // Flat normal from cross product
                const e1x = v3d[1].x - v3d[0].x, e1y = v3d[1].y - v3d[0].y, e1z = v3d[1].z - v3d[0].z;
                const e2x = v3d[3].x - v3d[0].x, e2y = v3d[3].y - v3d[0].y, e2z = v3d[3].z - v3d[0].z;
                let nx = e1y * e2z - e1z * e2y;
                let ny = e1z * e2x - e1x * e2z;
                let nz = e1x * e2y - e1y * e2x;
                const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
                nx /= len; ny /= len; nz /= len;
                for (let vi = 0; vi < 4; vi++) {
                    norm[base + vi * 3]     = nx;
                    norm[base + vi * 3 + 1] = ny;
                    norm[base + vi * 3 + 2] = nz;
                }

                // Color by type
                const clr = colorObjs3D[dimer.t];
                for (let vi = 0; vi < 4; vi++) {
                    col[base + vi * 3]     = clr.r;
                    col[base + vi * 3 + 1] = clr.g;
                    col[base + vi * 3 + 2] = clr.b;
                }
            }
        }

        function buildSurfaceMesh(dimers, withEdges) {
            const numDimers = dimers.length;
            const positions = new Float32Array(numDimers * 4 * 3);
            const normals = new Float32Array(numDimers * 4 * 3);
            const colors = new Float32Array(numDimers * 4 * 3);

            fillSurfaceBuffers(dimers, positions, normals, colors);

            if (!surfaceGeo) {
                surfaceGeo = new THREE.BufferGeometry();
                surfaceGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                surfaceGeo.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
                surfaceGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const indices = new Uint32Array(numDimers * 6);
                for (let d = 0; d < numDimers; d++) {
                    const bi = d * 4;
                    indices[d * 6]     = bi;
                    indices[d * 6 + 1] = bi + 1;
                    indices[d * 6 + 2] = bi + 2;
                    indices[d * 6 + 3] = bi;
                    indices[d * 6 + 4] = bi + 2;
                    indices[d * 6 + 5] = bi + 3;
                }
                surfaceGeo.setIndex(new THREE.BufferAttribute(indices, 1));

                surfaceMesh = new THREE.Mesh(surfaceGeo, surfaceMaterial);
                meshGroup.add(surfaceMesh);
            } else {
                surfaceGeo.attributes.position.array.set(positions);
                surfaceGeo.attributes.position.needsUpdate = true;
                surfaceGeo.attributes.normal.array.set(normals);
                surfaceGeo.attributes.normal.needsUpdate = true;
                surfaceGeo.attributes.color.array.set(colors);
                surfaceGeo.attributes.color.needsUpdate = true;
            }

            // Edge lines
            if (withEdges) {
                if (edgeLines) {
                    meshGroup.remove(edgeLines);
                    edgeLines.geometry.dispose();
                }
                const edgesGeo = new THREE.EdgesGeometry(surfaceGeo, 10);
                edgeLines = new THREE.LineSegments(edgesGeo, edgeMaterial);
                meshGroup.add(edgeLines);
            } else if (edgeLines) {
                meshGroup.remove(edgeLines);
                edgeLines.geometry.dispose();
                edgeLines = null;
            }
        }

        function updateSurfaceInPlace(dimers) {
            if (!surfaceGeo) return;
            fillSurfaceBuffers(
                dimers,
                surfaceGeo.attributes.position.array,
                surfaceGeo.attributes.normal.array,
                surfaceGeo.attributes.color.array
            );
            surfaceGeo.attributes.position.needsUpdate = true;
            surfaceGeo.attributes.normal.needsUpdate = true;
            surfaceGeo.attributes.color.needsUpdate = true;
        }

        // ========================================================================
        // FLYING CUBES — InstancedMesh in camera view plane (thin 2D layer)
        // ========================================================================
        class SpatialHash2D {
            constructor(cellSize) {
                this.inv = 1 / cellSize;
                this.grid = new Map();
            }
            clear() { this.grid.clear(); }
            insert(idx, x, y) {
                const k = `${Math.floor(x * this.inv)},${Math.floor(y * this.inv)}`;
                let cell = this.grid.get(k);
                if (!cell) { cell = []; this.grid.set(k, cell); }
                cell.push(idx);
            }
            query(x, y) {
                const cx = Math.floor(x * this.inv);
                const cy = Math.floor(y * this.inv);
                const result = [];
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const cell = this.grid.get(`${cx + dx},${cy + dy}`);
                        if (cell) for (let i = 0; i < cell.length; i++) result.push(cell[i]);
                    }
                }
                return result;
            }
        }

        const spatialHash = new SpatialHash2D(CUBE_SIZE * 2);
        const _dummy = new THREE.Object3D();

        // Convert 2D view-plane coords + depth to 3D world positions
        function updateCubes2Dto3D() {
            if (!cubePos2D || !camRight || !camUp) return;
            const n = cubePos2D.length / 2;
            const tx = controls.target.x, ty = controls.target.y, tz = controls.target.z;
            for (let i = 0; i < n; i++) {
                const u = cubePos2D[i * 2];
                const v = cubePos2D[i * 2 + 1];
                const w = cubeDepth[i];
                cubePositions[i * 3]     = tx + u * camRight.x + v * camUp.x + w * camForward.x;
                cubePositions[i * 3 + 1] = ty + u * camRight.y + v * camUp.y + w * camForward.y;
                cubePositions[i * 3 + 2] = tz + u * camRight.z + v * camUp.z + w * camForward.z;
            }
        }

        function initFlyingCubes(dimers) {
            const numCubes = dimers.length;

            // Extract camera basis vectors
            camera.updateMatrixWorld();
            camRight = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 0);
            camUp = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 1);
            camForward = new THREE.Vector3();
            camera.getWorldDirection(camForward);

            // Visible area in world units
            const aspect = canvas.clientWidth / canvas.clientHeight || 1;
            const visW = frustumSize * aspect / camera.zoom;
            const visH = frustumSize / camera.zoom;
            cubeHalfW = visW * 1.2;
            cubeHalfH = visH * 1.2;
            const depthRange = visW * 0.08;

            // Allocate arrays
            cubePos2D = new Float32Array(numCubes * 2);
            cubeVel2D = new Float32Array(numCubes * 2);
            cubeDepth = new Float32Array(numCubes);
            cubePositions = new Float32Array(numCubes * 3);
            cubeRotations = new Float32Array(numCubes * 3);
            cubeAngVel = new Float32Array(numCubes * 3);
            cubeFlying = new Uint8Array(numCubes);

            // Compute 2D target positions from 3D targets
            computeTargets2D();

            // All cubes participate in the build-up.
            for (let i = 0; i < numCubes; i++) cubeFlying[i] = 1;

            // Initialize all cubes with scattered positions.
            for (let i = 0; i < numCubes; i++) {
                cubePos2D[i * 2]     = (Math.random() - 0.5) * visW * 0.9;
                cubePos2D[i * 2 + 1] = (Math.random() - 0.5) * visH * 0.9;
                cubeDepth[i] = (Math.random() - 0.5) * depthRange;
                const speed = 1.5 + Math.random() * 3;
                const angle = Math.random() * Math.PI * 2;
                cubeVel2D[i * 2]     = speed * Math.cos(angle);
                cubeVel2D[i * 2 + 1] = speed * Math.sin(angle);
                cubeRotations[i * 3]     = Math.random() * Math.PI * 2;
                cubeRotations[i * 3 + 1] = Math.random() * Math.PI * 2;
                cubeRotations[i * 3 + 2] = Math.random() * Math.PI * 2;
                cubeAngVel[i * 3]     = (Math.random() - 0.5) * 0.8;
                cubeAngVel[i * 3 + 1] = (Math.random() - 0.5) * 0.8;
                cubeAngVel[i * 3 + 2] = (Math.random() - 0.5) * 0.8;
            }

            updateCubes2Dto3D();

            // Create InstancedMesh for all cubes.
            const geo = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            const mat = new THREE.MeshStandardMaterial({
                roughness: 0.4, metalness: 0.2
            });
            cubesMesh = new THREE.InstancedMesh(geo, mat, numCubes);

            // Per-instance colors by dimer type
            for (let i = 0; i < numCubes; i++) {
                cubesMesh.setColorAt(i, colorObjs3D[dimers[i].t]);
            }
            cubesMesh.instanceColor.needsUpdate = true;

            updateCubeMatrices();
            meshGroup.add(cubesMesh);
        }

        function updateCubeMatrices() {
            if (!cubesMesh) return;
            const n = cubesMesh.count;
            for (let i = 0; i < n; i++) {
                if (cubeFlying && cubeFlying[i] === 0) {
                    // Hidden — not yet spawned
                    _dummy.scale.set(0, 0, 0);
                    _dummy.position.set(0, 0, 0);
                    _dummy.rotation.set(0, 0, 0);
                } else {
                    _dummy.scale.set(1, 1, 1);
                    _dummy.position.set(
                        cubePositions[i * 3],
                        cubePositions[i * 3 + 1],
                        cubePositions[i * 3 + 2]
                    );
                    if (cubeRotations) {
                        _dummy.rotation.set(
                            cubeRotations[i * 3],
                            cubeRotations[i * 3 + 1],
                            cubeRotations[i * 3 + 2]
                        );
                    } else {
                        _dummy.rotation.set(0, 0, 0);
                    }
                }
                _dummy.updateMatrix();
                cubesMesh.setMatrixAt(i, _dummy.matrix);
            }
            cubesMesh.instanceMatrix.needsUpdate = true;
        }

        function updateFlyingCubesPhysics(dt) {
            if (!cubePos2D || !cubesMesh) return;
            const n = cubesMesh.count;
            const pos = cubePos2D;
            const vel = cubeVel2D;

            // Integrate 2D positions and rotations (flying cubes only)
            for (let i = 0; i < n; i++) {
                if (!cubeFlying || !cubeFlying[i]) continue;
                pos[i * 2]     += vel[i * 2] * dt;
                pos[i * 2 + 1] += vel[i * 2 + 1] * dt;
                cubeRotations[i * 3]     += cubeAngVel[i * 3] * dt;
                cubeRotations[i * 3 + 1] += cubeAngVel[i * 3 + 1] * dt;
                cubeRotations[i * 3 + 2] += cubeAngVel[i * 3 + 2] * dt;
            }

            // Wall bounce (screen edges, flying cubes only)
            for (let i = 0; i < n; i++) {
                if (!cubeFlying || !cubeFlying[i]) continue;
                if (pos[i * 2] < -cubeHalfW) { pos[i * 2] = -cubeHalfW; vel[i * 2] = Math.abs(vel[i * 2]); }
                if (pos[i * 2] > cubeHalfW)  { pos[i * 2] = cubeHalfW;  vel[i * 2] = -Math.abs(vel[i * 2]); }
                if (pos[i * 2 + 1] < -cubeHalfH) { pos[i * 2 + 1] = -cubeHalfH; vel[i * 2 + 1] = Math.abs(vel[i * 2 + 1]); }
                if (pos[i * 2 + 1] > cubeHalfH)  { pos[i * 2 + 1] = cubeHalfH;  vel[i * 2 + 1] = -Math.abs(vel[i * 2 + 1]); }
            }

            // 2D collision detection via spatial hash (flying cubes only)
            spatialHash.clear();
            for (let i = 0; i < n; i++) {
                if (!cubeFlying || !cubeFlying[i]) continue;
                spatialHash.insert(i, pos[i * 2], pos[i * 2 + 1]);
            }

            for (let a = 0; a < n; a++) {
                if (!cubeFlying || !cubeFlying[a]) continue;
                const neighbors = spatialHash.query(pos[a * 2], pos[a * 2 + 1]);
                for (const b of neighbors) {
                    if (b <= a) continue;
                    if (!cubeFlying || !cubeFlying[b]) continue;
                    const dx = pos[b * 2] - pos[a * 2];
                    const dy = pos[b * 2 + 1] - pos[a * 2 + 1];
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < CUBE_SIZE && dist > 0.001) {
                        const nx = dx / dist, ny = dy / dist;
                        const dvx = vel[a * 2] - vel[b * 2];
                        const dvy = vel[a * 2 + 1] - vel[b * 2 + 1];
                        const vn = dvx * nx + dvy * ny;

                        if (vn > 0) {
                            vel[a * 2]     -= vn * nx;
                            vel[a * 2 + 1] -= vn * ny;
                            vel[b * 2]     += vn * nx;
                            vel[b * 2 + 1] += vn * ny;
                            const overlap = (CUBE_SIZE - dist) * 0.5;
                            pos[a * 2]     -= overlap * nx;
                            pos[a * 2 + 1] -= overlap * ny;
                            pos[b * 2]     += overlap * nx;
                            pos[b * 2 + 1] += overlap * ny;
                            // Collision gives a gentle spin
                            const kick = vn * 0.3;
                            cubeAngVel[a * 3]     += (Math.random() - 0.5) * kick;
                            cubeAngVel[a * 3 + 1] += (Math.random() - 0.5) * kick;
                            cubeAngVel[b * 3]     += (Math.random() - 0.5) * kick;
                            cubeAngVel[b * 3 + 1] += (Math.random() - 0.5) * kick;
                        }
                    }
                }
            }

            // Convert 2D to 3D world positions
            updateCubes2Dto3D();
            updateCubeMatrices();
        }

        // ========================================================================
        // ASSEMBLY — physics continues, spring attraction grows
        // ========================================================================

        // Project 3D targets into 2D view-plane coords
        function computeTargets2D() {
            if (!cubeTargets || !camRight || !camUp || !camForward) return;
            const n = cubeTargets.length / 3;
            cubeTargets2D = new Float32Array(n * 2);
            cubeTargetDepth = new Float32Array(n);
            const tx = controls.target.x, ty = controls.target.y, tz = controls.target.z;
            for (let i = 0; i < n; i++) {
                const dx = cubeTargets[i * 3] - tx;
                const dy = cubeTargets[i * 3 + 1] - ty;
                const dz = cubeTargets[i * 3 + 2] - tz;
                cubeTargets2D[i * 2]     = dx * camRight.x + dy * camRight.y + dz * camRight.z;
                cubeTargets2D[i * 2 + 1] = dx * camUp.x + dy * camUp.y + dz * camUp.z;
                cubeTargetDepth[i]       = dx * camForward.x + dy * camForward.y + dz * camForward.z;
            }
        }

        function updateAssemblyPhysics(dt, progress) {
            if (!cubePos2D || !cubesMesh) return;
            const n = cubesMesh.count;
            const pos = cubePos2D;
            const vel = cubeVel2D;

            // Spring strength ramps up cubically
            const p3 = progress * progress * progress;
            const springK = 3 + p3 * 30;
            const damping = 1 + p3 * 8;
            const angDamp = 3 + progress * 15;

            // Apply spring force toward targets.
            for (let i = 0; i < n; i++) {
                if (cubeFlying[i] !== 1) continue;
                const dxT = cubeTargets2D[i * 2] - pos[i * 2];
                const dyT = cubeTargets2D[i * 2 + 1] - pos[i * 2 + 1];
                vel[i * 2]     += dxT * springK * dt;
                vel[i * 2 + 1] += dyT * springK * dt;
                vel[i * 2]     *= Math.max(0, 1 - damping * dt);
                vel[i * 2 + 1] *= Math.max(0, 1 - damping * dt);
                cubeDepth[i] += (cubeTargetDepth[i] - cubeDepth[i]) * springK * dt;
            }

            // Integrate positions; damp rotations toward zero.
            for (let i = 0; i < n; i++) {
                if (cubeFlying[i] !== 1) continue;
                pos[i * 2]     += vel[i * 2] * dt;
                pos[i * 2 + 1] += vel[i * 2 + 1] * dt;
                const af = Math.max(0, 1 - angDamp * dt);
                cubeAngVel[i * 3]     *= af;
                cubeAngVel[i * 3 + 1] *= af;
                cubeAngVel[i * 3 + 2] *= af;
                cubeRotations[i * 3]     += cubeAngVel[i * 3] * dt;
                cubeRotations[i * 3 + 1] += cubeAngVel[i * 3 + 1] * dt;
                cubeRotations[i * 3 + 2] += cubeAngVel[i * 3 + 2] * dt;
                const rotPull = Math.min(1, angDamp * 0.5 * dt);
                cubeRotations[i * 3]     *= (1 - rotPull);
                cubeRotations[i * 3 + 1] *= (1 - rotPull);
                cubeRotations[i * 3 + 2] *= (1 - rotPull);
            }

            // Snap flying cube rotations to zero in final 10%
            if (progress > 0.9) {
                const snap = (progress - 0.9) / 0.1;
                for (let i = 0; i < n; i++) {
                    if (cubeFlying[i] !== 1) continue;
                    cubeRotations[i * 3]     *= (1 - snap);
                    cubeRotations[i * 3 + 1] *= (1 - snap);
                    cubeRotations[i * 3 + 2] *= (1 - snap);
                }
            }

            updateCubes2Dto3D();
            updateCubeMatrices();
        }

        // ========================================================================
        // STATE MACHINE
        // ========================================================================
        const HOOK_DURATION = 15000; // title card display time
        let hookTimerId = null;

        function onHookClick() {
            if (currentState === STATES.HOOK) enterLoading();
        }

        function enterHook() {
            console.log('[STATE] → HOOK');
            currentState = STATES.HOOK;
            const hookEl = document.getElementById('hook-screen');
            hookEl.style.display = 'flex';
            canvas.style.display = 'none';
            document.getElementById('vignette').style.display = 'none';

            // Reset hook text animations for re-entry
            const question = hookEl.querySelector('.question');
            const hint = hookEl.querySelector('.hint');
            question.style.animation = 'none';
            hint.style.animation = 'none';
            void question.offsetWidth;
            question.style.animation = '';
            hint.style.animation = '';

            startHookBg();

            // Auto-advance after title card duration (tracked so we can cancel)
            if (hookTimerId) clearTimeout(hookTimerId);
            hookTimerId = setTimeout(() => {
                hookTimerId = null;
                if (currentState === STATES.HOOK) enterLoading();
            }, HOOK_DURATION);

            // Click anywhere to skip (single named handler, safe to re-add)
            hookEl.removeEventListener('click', onHookClick);
            hookEl.addEventListener('click', onHookClick);
        }

        function runCFTPAsync() {
            return new Promise((resolve) => {
                sim.initCFTP();
                function step() {
                    const result = sim.stepCFTP();
                    console.log('CFTP:', result.status, 'T=' + result.T);
                    if (result.status === 'coalesced') {
                        sim.finalizeCFTP();
                        resolve(true);
                    } else if (result.status === 'in_progress' || result.status === 'not_coalesced') {
                        setTimeout(step, 0);
                    } else {
                        console.warn('CFTP failed:', result);
                        sim.setQBias(Q_CHAOS);
                        sim.step(50000);
                        sim.refreshDimers();
                        resolve(false);
                    }
                }
                step();
            });
        }

        async function enterLoading() {
            console.log('[STATE] → LOADING');
            currentState = STATES.LOADING;
            if (hookTimerId) { clearTimeout(hookTimerId); hookTimerId = null; }
            stopHookBg();
            document.getElementById('hook-screen').style.display = 'none';
            document.getElementById('loading').textContent = 'Loading\u2026';
            document.getElementById('loading').style.display = 'block';

            // Initialize audio (requires user gesture)
            try {
                sonifier = new FlipSonifier();
                sonifier.init();
            } catch (e) {
                console.warn('Audio unavailable:', e);
                try { sonifier.destroy(); } catch(ignored) {}
                sonifier = null;
            }

            sim = new SimulatorInterface();

            setTimeout(async () => {
                try {
                    // Generate scaled shape
                    console.time('generateScaledShape');
                    activeTriangles = await generateScaledShape(sim);
                    console.timeEnd('generateScaledShape');
                    console.log('Triangle count:', activeTriangles.size);

                    // Final init with scaled shape
                    console.time('finalInit');
                    sim.initFromTriangles(activeTriangles);
                    console.timeEnd('finalInit');

                    // Adjust hole height for impossible illusion
                    console.time('holeSetup');
                    const holeCount = sim.getHoleCount();
                    if (holeCount > 0) {
                        const HOLE_HEIGHT_INCREASE = 8;
                        const initialInfo = sim.getAllHolesInfo();
                        for (let i = 0; i < holeCount; i++) {
                            const baseWinding = initialInfo.holes[i].currentWinding;
                            for (let step = 0; step < HOLE_HEIGHT_INCREASE; step++) {
                                const result = sim.adjustHoleWinding(i, +1);
                                if (!result.success) break;
                            }
                            sim.setHoleBaseHeight(i, baseWinding);
                        }
                    }
                    console.timeEnd('holeSetup');

                    if (sim.isValid) {
                        // Run CFTP for exact uniform sample
                        console.time('CFTP');
                        await runCFTPAsync();
                        console.timeEnd('CFTP');
                        console.log('Dimer count:', sim.dimers.length);

                        // Init Three.js
                        canvas.style.display = 'block';
                        canvas.style.opacity = '1';
                        document.getElementById('vignette').style.display = 'block';
                        initThreeScene();

                        // Compute targets from CFTP state (the chaotic config Glauber starts from)
                        cubeTargets = computeTargets(sim.dimers);
                        positionCamera(sim.dimers);

                        // Setup flying cubes
                        initFlyingCubes(sim.dimers);

                        // Hide loading, start
                        document.getElementById('loading').style.display = 'none';
                        enterFlyingCubes();
                    } else {
                        document.getElementById('loading').textContent = 'Error: Invalid shape';
                        setTimeout(() => {
                            document.getElementById('loading').style.display = 'none';
                            if (sonifier) { sonifier.destroy(); sonifier = null; }
                            sim = null;
                            enterHook();
                        }, 3000);
                    }
                } catch (err) {
                    console.error('Error:', err);
                    document.getElementById('loading').textContent = 'Error: ' + err.message;
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                        if (sonifier) { sonifier.destroy(); sonifier = null; }
                        sim = null;
                        enterHook();
                    }, 3000);
                }
            }, 50);
        }

        function enterFlyingCubes() {
            console.log('[STATE] → FLYING_CUBES');
            currentState = STATES.FLYING_CUBES;
            stateStartTime = performance.now();
            lastTimestamp = performance.now();

            // Just cubes flying in empty space — no triangle yet
            if (sonifier) sonifier.setEntropy(1.0);
            animationId = requestAnimationFrame(renderFrame);
        }

        function enterAssembly() {
            console.log('[STATE] → ASSEMBLY');
            currentState = STATES.ASSEMBLY;
            stateStartTime = performance.now();
            // 2D targets already computed in initFlyingCubes
            // Spring physics pulls all cubes to the CFTP targets
        }

        function enterTransforming() {
            console.log('[STATE] → TRANSFORMING');
            currentState = STATES.TRANSFORMING;
            stateStartTime = performance.now();
            transformBlendComplete = !cubesMesh;
            dumpedPreGlauber = false;
            dumpedPostGlauber = false;

            // Build surface from current CFTP state; fade it in over cubes.
            buildSurfaceMesh(sim.dimers, false);
            if (surfaceMaterial) {
                surfaceMaterial.transparent = true;
                surfaceMaterial.opacity = transformBlendComplete ? 1 : 0;
            }
            if (cubesMesh && cubesMesh.material) {
                cubesMesh.material.transparent = true;
                cubesMesh.material.opacity = 1;
                cubesMesh.material.depthWrite = false;
            }

            // Sim is already at CFTP state (chaotic) — Glauber starts directly
            if (!dumpedPreGlauber) {
                dumpSurfaceSnapshot('pre_glauber');
                dumpedPreGlauber = true;
            }
            sim.setQBias(Q_CHAOS);
        }

        function updateTransforming(elapsed) {
            animPhase.time = elapsed;
            const dynamicElapsed = Math.max(0, elapsed - CUBE_SURFACE_BLEND_DURATION);

            if (!transformBlendComplete) {
                const blend = Math.min(1, elapsed / CUBE_SURFACE_BLEND_DURATION);
                if (surfaceMaterial) surfaceMaterial.opacity = blend;
                if (cubesMesh && cubesMesh.material) cubesMesh.material.opacity = 1 - blend;
                if (blend >= 1) {
                    if (cubesMesh) {
                        meshGroup.remove(cubesMesh);
                        cubesMesh.geometry.dispose();
                        cubesMesh.material.dispose();
                        cubesMesh = null;
                    }
                    if (surfaceMaterial) {
                        surfaceMaterial.opacity = 1;
                        surfaceMaterial.transparent = false;
                    }
                    transformBlendComplete = true;
                }
            }

            let currentQ;
            if (dynamicElapsed < CHAOS_DURATION) {
                // Phase 1: Pure Chaos
                currentQ = Q_CHAOS;
                animPhase.chaosEnergy = 1.0;
                animPhase.annealProgress = 0;
            } else if (dynamicElapsed < CHAOS_DURATION + ANNEAL_DURATION) {
                // Phase 2: Smooth quadratic annealing
                const progress = (dynamicElapsed - CHAOS_DURATION) / ANNEAL_DURATION;
                currentQ = Q_CHAOS + (Q_ORDER - Q_CHAOS) * progress * progress;
                animPhase.chaosEnergy = Math.max(0, 1.0 - progress);
                animPhase.annealProgress = progress;
            } else {
                // Phase 3: Done
                animPhase.chaosEnergy = 0;
                animPhase.annealProgress = 1;
                enterFrozen();
                return;
            }

            if (transformBlendComplete) {
                sim.setQBias(currentQ);
                // Fewer steps as q increases — slow down so ordering is visible
                // Power-1.5 scaling: drops much faster at moderate q
                const stepsThisFrame = Math.max(100, Math.round(STEPS_PER_FRAME / Math.pow(currentQ, 1.5)));
                sim.step(stepsThisFrame);
                console.log(`[ANNEAL] t=${(dynamicElapsed/1000).toFixed(1)}s q=${currentQ.toFixed(3)} steps=${stepsThisFrame} progress=${animPhase.annealProgress.toFixed(3)}`);
                if (!dumpedPostGlauber) {
                    dumpSurfaceSnapshot('post_glauber');
                    dumpedPostGlauber = true;
                }
            }

            if (sonifier) sonifier.setEntropy(animPhase.chaosEnergy);

            updateSurfaceInPlace(sim.dimers);
        }

        const ROTATION_DURATION = 12000; // ms per full 360° rotation
        const PAUSE_DURATION = 2000;     // ms pause between rotations
        const TEXT_SCREEN_DURATION = 12000;

        // Frozen phase: rotate → pause → rotate → text screen
        let frozenRotationAngle = 0;

        function enterFrozen() {
            console.log('[STATE] → FROZEN');
            currentState = STATES.FROZEN;
            stateStartTime = performance.now();
            frozenRotationAngle = 0;

            // Ensure cubes gone, surface fully opaque
            if (cubesMesh) {
                meshGroup.remove(cubesMesh);
                cubesMesh.geometry.dispose();
                cubesMesh.material.dispose();
                cubesMesh = null;
            }
            if (surfaceMaterial) {
                surfaceMaterial.opacity = 1;
                surfaceMaterial.transparent = false;
            }

            animPhase.chaosEnergy = 0;
            animPhase.annealProgress = 1;

            // Final polish
            sim.setQBias(Q_ORDER);
            sim.step(10000);
            sim.refreshDimers();

            // Rebuild surface with edge lines
            buildSurfaceMesh(sim.dimers, true);

            if (sonifier) sonifier.fadeOut(4000);

            // Disable OrbitControls auto-rotate — we drive rotation manually
            controls.autoRotate = false;

            frozenTimers = [];
            frozenTimers.push(setTimeout(() => {
                document.getElementById('caption').classList.add('visible');
                document.getElementById('attribution').classList.add('visible');
            }, 500));
        }

        function updateFrozen(elapsed) {
            const totalDuration = ROTATION_DURATION + PAUSE_DURATION + ROTATION_DURATION;

            if (elapsed < ROTATION_DURATION) {
                // First full rotation
                const t = elapsed / ROTATION_DURATION;
                const angle = t * Math.PI * 2;
                setFrozenRotation(angle);
            } else if (elapsed < ROTATION_DURATION + PAUSE_DURATION) {
                // Pause — hold at 360° (= 0°)
                setFrozenRotation(0);
            } else if (elapsed < totalDuration) {
                // Second full rotation
                const t = (elapsed - ROTATION_DURATION - PAUSE_DURATION) / ROTATION_DURATION;
                const angle = t * Math.PI * 2;
                setFrozenRotation(angle);
            } else {
                // Done — go to text screen
                setFrozenRotation(0);
                enterTextScreen();
            }
        }

        function setFrozenRotation(angle) {
            // Rotate camera around the target (orbit in the horizontal plane)
            if (!camera || !controls) return;
            const dist = camera.position.distanceTo(controls.target);
            const baseDir = new THREE.Vector3(1, -1, -1).normalize(); // isometric direction
            // Rotate baseDir around Z axis by angle
            const cosA = Math.cos(angle), sinA = Math.sin(angle);
            const rx = baseDir.x * cosA - baseDir.y * sinA;
            const ry = baseDir.x * sinA + baseDir.y * cosA;
            const rz = baseDir.z;
            camera.position.set(
                controls.target.x + rx * dist,
                controls.target.y + ry * dist,
                controls.target.z + rz * dist
            );
            camera.lookAt(controls.target);
        }

        function buildCodeLines() {
            return [
                { type: 'comment', text: '// Can Chaos Hide the Truth?' },
                { type: 'comment', text: '//' },
                { type: 'code', text: '<span class="keyword">const</span> shape = <span class="fn">penroseTriangle</span>();' },
                { type: 'code', text: '<span class="keyword">const</span> surface = <span class="fn">lozenges</span>(shape);' },
                { type: 'comment', text: '// every local patch is valid' },
                { type: 'comment', text: '// but the global surface cannot exist' },
                { type: 'comment', text: '//' },
                { type: 'code', text: 'surface.<span class="fn">monodromy</span>() <span class="comment">// => +8 around the hole</span>' },
                { type: 'comment', text: '//' },
                { type: 'code', text: '<span class="keyword">let</span> tiling = <span class="fn">CFTP</span>.<span class="fn">sample</span>(surface);' },
                { type: 'code', text: '<span class="keyword">for</span> (<span class="keyword">let</span> γ = <span class="number">0</span>; γ &lt; <span class="number">Infinity</span>; γ++) {' },
                { type: 'code', text: '  tiling = <span class="fn">glauber</span>(tiling, <span class="fn">exp</span>(-γ/N));' },
                { type: 'code', text: '  <span class="comment">// chaos → order</span>' },
                { type: 'code', text: '}' },
                { type: 'comment', text: '//' },
                { type: 'comment', text: '// <span class="string">Leonid Petrov · 2026</span>' },
                { type: 'comment', text: '// <span class="string">lpetrov.cc/triangle/</span>' },
            ];
        }

        function enterTextScreen() {
            console.log('[STATE] → TEXT_SCREEN');
            currentState = STATES.TEXT_SCREEN;
            stateStartTime = performance.now();

            // Fade out 3D canvas
            canvas.style.transition = 'opacity 1.5s ease-out';
            canvas.style.opacity = '0';
            document.getElementById('vignette').style.display = 'none';
            document.getElementById('caption').classList.remove('visible');
            document.getElementById('attribution').classList.remove('visible');

            // Build code block
            const lines = buildCodeLines();
            const codeBlock = document.querySelector('#text-screen .code-block');
            codeBlock.innerHTML = '';

            const textScreen = document.getElementById('text-screen');
            textScreen.style.display = 'flex';

            // Stagger each line in with a typing effect
            lines.forEach((line, idx) => {
                const lineEl = document.createElement('span');
                lineEl.className = 'line';
                lineEl.style.opacity = '0';
                lineEl.style.transition = `opacity 0.6s ease-in ${idx * 0.25}s`;

                const numSpan = document.createElement('span');
                numSpan.className = 'line-num';
                numSpan.textContent = String(idx + 1).padStart(2, '0');

                lineEl.appendChild(numSpan);

                const contentSpan = document.createElement('span');
                if (line.type === 'comment') {
                    contentSpan.className = 'comment';
                }
                contentSpan.innerHTML = line.text;
                lineEl.appendChild(contentSpan);

                codeBlock.appendChild(lineEl);
            });

            // Trigger fade-in after layout
            requestAnimationFrame(() => {
                textScreen.classList.add('visible');
                codeBlock.querySelectorAll('.line').forEach(el => {
                    el.style.opacity = '1';
                });
            });

            // After TEXT_SCREEN_DURATION, fade out then return to hook
            frozenTimers.push(setTimeout(() => {
                textScreen.classList.remove('visible');
                codeBlock.querySelectorAll('.line').forEach(el => {
                    el.style.opacity = '0';
                });
                // Track the nested fade-out timer too
                frozenTimers.push(setTimeout(() => {
                    textScreen.style.display = 'none';
                    returnToHook();
                }, 2000));
            }, TEXT_SCREEN_DURATION));
        }

        // ========================================================================
        // RENDER LOOP
        // ========================================================================
        function renderFrame(timestamp) {
            if (!renderer) return;
            if (currentState === STATES.HOOK || currentState === STATES.LOADING || currentState === STATES.TEXT_SCREEN) return;

            const dt = Math.min((timestamp - lastTimestamp) / 1000, 0.05);
            lastTimestamp = timestamp;
            const elapsed = timestamp - stateStartTime;

            switch (currentState) {
                case STATES.FLYING_CUBES:
                    updateFlyingCubesPhysics(dt);
                    if (elapsed >= FLYING_DURATION) enterAssembly();
                    break;

                case STATES.ASSEMBLY:
                    updateAssemblyPhysics(dt, Math.min(1, elapsed / ASSEMBLY_DURATION));
                    if (elapsed >= ASSEMBLY_DURATION) {
                        enterTransforming();
                    }
                    break;

                case STATES.TRANSFORMING:
                    updateTransforming(elapsed);
                    break;

                case STATES.FROZEN:
                    updateFrozen(elapsed);
                    break;
            }

            // Background color: black in chaos → subtle warm dark in order
            const bgR = 8 * animPhase.annealProgress / 255;
            const bgG = 6 * animPhase.annealProgress / 255;
            const bgB = 4 * animPhase.annealProgress / 255;
            scene.background.setRGB(bgR, bgG, bgB);

            controls.update();
            renderer.render(scene, camera);
            animationId = requestAnimationFrame(renderFrame);
        }

        // ========================================================================
        // LOOP RESTART — return to hook screen
        // ========================================================================
        let frozenTimers = [];

        function returnToHook() {
            console.log('[STATE] → RETURN_TO_HOOK');
            currentState = STATES.HOOK;

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            for (const t of frozenTimers) clearTimeout(t);
            frozenTimers = [];

            if (sonifier) {
                sonifier.destroy();
                sonifier = null;
            }

            // Hide UI
            document.getElementById('caption').classList.remove('visible');
            document.getElementById('attribution').classList.remove('visible');

            animPhase.chaosEnergy = 0;
            animPhase.annealProgress = 0;
            animPhase.time = 0;

            // Dispose Three.js
            disposeThreeScene();
            sim = null;

            canvas.style.transition = '';
            canvas.style.display = 'none';
            document.getElementById('vignette').style.display = 'none';
            enterHook();
        }

        // ========================================================================
        // EVENT LISTENERS
        // ========================================================================
        window.addEventListener('resize', () => {
            if (renderer) {
                resizeThreeScene();
            }
            if (hookAnimId) {
                initHookBg();
                seedParticles();
            }
        });

        // Click to advance to next stage (for testing)
        canvas.addEventListener('click', () => {
            switch (currentState) {
                case STATES.FLYING_CUBES: enterAssembly(); break;
                case STATES.ASSEMBLY: enterTransforming(); break;
                case STATES.TRANSFORMING: enterFrozen(); break;
                case STATES.FROZEN: enterTextScreen(); break;
            }
        });
        document.getElementById('text-screen').addEventListener('click', () => {
            if (currentState === STATES.TEXT_SCREEN) {
                for (const t of frozenTimers) clearTimeout(t);
                frozenTimers = [];
                document.getElementById('text-screen').style.display = 'none';
                document.getElementById('text-screen').classList.remove('visible');
                returnToHook();
            }
        });

        // Pause render loop when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && renderer && currentState !== STATES.HOOK && currentState !== STATES.LOADING && currentState !== STATES.TEXT_SCREEN) {
                lastTimestamp = performance.now();
            }
        });

        // ========================================================================
        // INITIALIZATION
        // ========================================================================
        if (typeof Module !== 'undefined' && Module.calledRun) {
            enterHook();
        } else if (typeof Module !== 'undefined') {
            Module.onRuntimeInitialized = function() {
                enterHook();
            };
        } else {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = 'Error: Failed to load simulation engine';
        }

    })();
    </script>
</body>
</html>
